[
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "References\n\n\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "docs/pkg/utils.html",
    "href": "docs/pkg/utils.html",
    "title": "rust 实用库",
    "section": "",
    "text": "cargo add csv\nuse anyhow::Result;\nuse std::fs::{self, File};\nfn main() -&gt; Result&lt;()&gt; {\n    // 如果你是在 工作空间根目录下 执行 cargo run,\n    // 则这个csv文件需要相对于 工作空间根目录\n    let file = File::open(\"a.csv\")?;\n    let mut csv = csv::Reader::from_reader(file);\n    // let headers = csv.headers()?.clone();\n    // println!(\"{:?}\", headers);\n    for result in csv.records() {\n        let record = result?;\n        //  let json_val = headers.iter().zip(record.iter()).collect::&lt;Value&gt;();\n        println!(\"{:?}\", record);\n        println!(\"{:?}\", record.get(0));\n    }\n    Ok(())\n}",
    "crumbs": [
      "库",
      "常用库"
    ]
  },
  {
    "objectID": "docs/pkg/utils.html#csv",
    "href": "docs/pkg/utils.html#csv",
    "title": "rust 实用库",
    "section": "",
    "text": "cargo add csv\nuse anyhow::Result;\nuse std::fs::{self, File};\nfn main() -&gt; Result&lt;()&gt; {\n    // 如果你是在 工作空间根目录下 执行 cargo run,\n    // 则这个csv文件需要相对于 工作空间根目录\n    let file = File::open(\"a.csv\")?;\n    let mut csv = csv::Reader::from_reader(file);\n    // let headers = csv.headers()?.clone();\n    // println!(\"{:?}\", headers);\n    for result in csv.records() {\n        let record = result?;\n        //  let json_val = headers.iter().zip(record.iter()).collect::&lt;Value&gt;();\n        println!(\"{:?}\", record);\n        println!(\"{:?}\", record.get(0));\n    }\n    Ok(())\n}",
    "crumbs": [
      "库",
      "常用库"
    ]
  },
  {
    "objectID": "docs/pkg/utils.html#serde1",
    "href": "docs/pkg/utils.html#serde1",
    "title": "rust 实用库",
    "section": "2 serde1",
    "text": "2 serde1\ncargo add serde --features derive\nuse std::error::Error;\n\n#[derive(Debug, serde::Deserialize)]\nstruct Record {\n    city: String,\n    region: u8,\n    country: String,\n}\n\n/* a.csv\ntokyo,3,japan\nbeijing,1,china\n*/\nfn read_csv() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {\n    let file = std::fs::File::open(\"a.csv\")?;\n    let mut rdr = csv::ReaderBuilder::new()\n        .has_headers(false) // 如果都是数据的情况, 设置没有 header\n        .from_reader(file);\n    for result in rdr.deserialize() {\n        // Notice that we need to provide a type hint for automatic\n        // deserialization.\n        let record: Record = result?;\n        println!(\"{}-{}\", record.city, record.country);\n    }\n    Ok(())\n}\n\n/*  a-with-header.csv\ncity,region,country\ntokyo,3,japan\nbeijing,1,china\n */\nfn read_csv_with_header() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {\n    let file = std::fs::File::open(\"a-with-header.csv\")?;\n    let mut rdr = csv::ReaderBuilder::new()\n        .has_headers(true) // 如果是有header的情况, 设置true\n        .from_reader(file);\n    for result in rdr.deserialize() {\n        let record: Record = result?;\n        println!(\"{}-{}\", record.city, record.country);\n    }\n    Ok(())\n}\n\nfn main() {\n    if let Err(err) = read_csv() {\n        println!(\"error running read_csv_with_header: {}\", err);\n    }\n    if let Err(err) = read_csv_with_header() {\n        println!(\"error running read_csv_with_header: {}\", err);\n    }\n}\n\ncargo add serde_json\nuse serde::{Deserialize, Serialize};\n\n// 使用 serde 的 derive 宏来为结构体自动实现序列化和反序列化\n#[derive(Serialize, Deserialize, Debug)]\nstruct Person {\n    // rename可以设置json 格式的时候, 显示的名字\n    #[serde(rename = \"user_name\")]\n    name: String,\n    age: u8,\n    phones: Vec&lt;String&gt;,\n}\n\nfn main() {\n    // 创建一个 Person 实例\n    let person = Person {\n        name: \"John Doe\".to_string(),\n        age: 30,\n        phones: vec![\"+44 1234567\".to_string(), \"+44 2345678\".to_string()],\n    };\n\n    // 将 Person 实例序列化为 JSON 字符串\n    let serialized = serde_json::to_string(&person).unwrap();\n    println!(\"Serialized:\\n{}\", serialized);\n\n    // 将 JSON 字符串反序列化为 Person 实例\n    let deserialized: Person = serde_json::from_str(&serialized).unwrap();\n    println!(\"Deserialized:\\n{:?}\", deserialized);\n}",
    "crumbs": [
      "库",
      "常用库"
    ]
  },
  {
    "objectID": "docs/pkg/utils.html#time",
    "href": "docs/pkg/utils.html#time",
    "title": "rust 实用库",
    "section": "3 time",
    "text": "3 time\n\n3.1 标准库里的time\nfn main() {\n    use std::time::{Duration, SystemTime, UNIX_EPOCH};\n    let now = SystemTime::now();\n\n    println!(\"{:?}\", now);\n    let now = SystemTime::now();\n    // UNIX_EPOCH: 1970/1/1\n    match now.duration_since(UNIX_EPOCH) {\n        Ok(elapsed) =&gt; {\n            println!(\"从 UNIX EPOCH 现在过去了 {} 秒\", elapsed.as_secs());\n        }\n        Err(e) =&gt; {\n            println!(\"SystemTime 在 UNIX EPOCH 之前: {:?}\", e);\n        }\n    }\n\n    use std::thread;\n\n    println!(\"程序开始\");\n    // 休眠2s\n    thread::sleep(Duration::from_secs(2));\n    println!(\"程序结束\");\n    let duration = now.elapsed();\n    println!(\"从获取now开始 到现在操作耗时: {:?}\", duration);\n    let now2 = now.checked_add(Duration::from_secs(3));\n    println!(\"{:?}\", now2);\n}",
    "crumbs": [
      "库",
      "常用库"
    ]
  },
  {
    "objectID": "docs/pkg/utils.html#footnotes",
    "href": "docs/pkg/utils.html#footnotes",
    "title": "rust 实用库",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nhttps://serde.rs/  serde github↩︎",
    "crumbs": [
      "库",
      "常用库"
    ]
  },
  {
    "objectID": "docs/basic/cargo.html",
    "href": "docs/basic/cargo.html",
    "title": "rust cargo",
    "section": "",
    "text": "打开本地离线cargo文档\n\nrustup doc --cargo\n\n\n\n发布的配置信息, 是预定义好的,可自定义\n\ncargo build\n    Finished dev [unoptimized + debuginfo] target(s) in 0.0s\ncargo build --release\n    Finished release [optimized] target(s) in 0.0s\n我们运行2个命令看看, 看到 dev 和 release, 实际就是使用了不同的默认配置 dev默认的一些配置\n[profile.dev]\nopt-level = 0\ndebug = true\nsplit-debuginfo = '...'  # Platform-specific.\nstrip = \"none\"\ndebug-assertions = true\noverflow-checks = true\nlto = false\npanic = 'unwind'\nincremental = true\ncodegen-units = 256\nrpath = false\n我们可以通过修改Cargo.toml来覆盖一些默认配置\n[package]\nname = \"world\"\nversion = \"0.1.0\"\nedition = \"2021\"\n[dependencies]\nrand = \"0.8.5\"\n[profile.dev] # dev 配置\nopt-level = 1\n[profile.release] # release 配置\nopt-level = 3\n修改完后, 我们再次编译可以看到 optimized\ncargo build\n    Finished dev [optimized + debuginfo] target(s) in 3.14s\ndependencies的三种方式\n[dependencies]\nclap = \"2.27.1\" # from crates.io\nrand = { git = \"https://github.com/rust-lang-nursery/rand\" } # from online repo\nbar = { path = \"../bar\" } # from a path in the local filesystem\n\n\n\n\n\n\n\n\n\nCaution\n\n\n\n待完善\n\n\n~/.cargo/config.toml影响该用户的所有 Rust 项目\n安装 sccache2 编译加速\ncargo install sccache\n\n\n~/.cargo/config.toml\n\n[source.crates-io]\nreplace-with = 'ustc'\n\n[source.ustc]\nregistry = \"sparse+https://mirrors.ustc.edu.cn/crates.io-index/\"\n\n[alias]     # command aliases\nb = \"build\"\nc = \"check\"\nt = \"test\"\nr = \"run\"\nrr = \"run --release\"\n[build]\n# 这样设置可以将所有的rust编译后的可执行文件放到一块去,哪天清理时比较方便\n1target-dir = \"/Users/xxxx/.rust-target\"\n# 使用 sccache 进行编译加速\nrustc-wrapper = \"/Users/xxxx/.cargo/bin/sccache\"\n\n\n1\n\n路径自行配置, 使用绝对路径",
    "crumbs": [
      "核心基础",
      "基础篇",
      "cargo"
    ]
  },
  {
    "objectID": "docs/basic/cargo.html#配置文件",
    "href": "docs/basic/cargo.html#配置文件",
    "title": "rust cargo",
    "section": "",
    "text": "打开本地离线cargo文档\n\nrustup doc --cargo\n\n\n\n发布的配置信息, 是预定义好的,可自定义\n\ncargo build\n    Finished dev [unoptimized + debuginfo] target(s) in 0.0s\ncargo build --release\n    Finished release [optimized] target(s) in 0.0s\n我们运行2个命令看看, 看到 dev 和 release, 实际就是使用了不同的默认配置 dev默认的一些配置\n[profile.dev]\nopt-level = 0\ndebug = true\nsplit-debuginfo = '...'  # Platform-specific.\nstrip = \"none\"\ndebug-assertions = true\noverflow-checks = true\nlto = false\npanic = 'unwind'\nincremental = true\ncodegen-units = 256\nrpath = false\n我们可以通过修改Cargo.toml来覆盖一些默认配置\n[package]\nname = \"world\"\nversion = \"0.1.0\"\nedition = \"2021\"\n[dependencies]\nrand = \"0.8.5\"\n[profile.dev] # dev 配置\nopt-level = 1\n[profile.release] # release 配置\nopt-level = 3\n修改完后, 我们再次编译可以看到 optimized\ncargo build\n    Finished dev [optimized + debuginfo] target(s) in 3.14s\ndependencies的三种方式\n[dependencies]\nclap = \"2.27.1\" # from crates.io\nrand = { git = \"https://github.com/rust-lang-nursery/rand\" } # from online repo\nbar = { path = \"../bar\" } # from a path in the local filesystem\n\n\n\n\n\n\n\n\n\nCaution\n\n\n\n待完善\n\n\n~/.cargo/config.toml影响该用户的所有 Rust 项目\n安装 sccache2 编译加速\ncargo install sccache\n\n\n~/.cargo/config.toml\n\n[source.crates-io]\nreplace-with = 'ustc'\n\n[source.ustc]\nregistry = \"sparse+https://mirrors.ustc.edu.cn/crates.io-index/\"\n\n[alias]     # command aliases\nb = \"build\"\nc = \"check\"\nt = \"test\"\nr = \"run\"\nrr = \"run --release\"\n[build]\n# 这样设置可以将所有的rust编译后的可执行文件放到一块去,哪天清理时比较方便\n1target-dir = \"/Users/xxxx/.rust-target\"\n# 使用 sccache 进行编译加速\nrustc-wrapper = \"/Users/xxxx/.cargo/bin/sccache\"\n\n\n1\n\n路径自行配置, 使用绝对路径",
    "crumbs": [
      "核心基础",
      "基础篇",
      "cargo"
    ]
  },
  {
    "objectID": "docs/basic/cargo.html#常用命令",
    "href": "docs/basic/cargo.html#常用命令",
    "title": "rust cargo",
    "section": "2 常用命令",
    "text": "2 常用命令\n# 查看所有cargo 命令\ncargo --list\n# 添加 一个依赖项 (外部crate)\n# 会在 Cargo.toml [dependencies] 下写入依赖的crate名以及它的版本\ncargo add csv\n# 工作空间下, 多package 的情况下,需要指定 package\ncargo add csv --package test_csv\n# --features derive 表示启用了serde 的derive 这个特性\n# 启用后你可以在你的代码中使用 serde 宏来为你的数据结构自动生成序列化和反序列化的实现\ncargo add serde --features derive",
    "crumbs": [
      "核心基础",
      "基础篇",
      "cargo"
    ]
  },
  {
    "objectID": "docs/basic/cargo.html#文档",
    "href": "docs/basic/cargo.html#文档",
    "title": "rust cargo",
    "section": "3 文档",
    "text": "3 文档\n\n3.1 注释\n生成HTML文档,显示如何使用API\n我们 在src/lib.rs中添加一些文档注释\n\n\nsrc/lib.rs\n\n1//! # My Crate\n//!\n//! `my_crate` is a collection of utilities to make performing certain\n//! calculations more convenient.\n\n/// Adds one to the number given.\n///\n2/// # Examples\n///\n/// ```\n3/// let arg = 5;\n/// let answer = my_crate::add_one(arg);\n///\n/// assert_eq!(6, answer);\n/// ```\npub fn add_one(x: i32) -&gt; i32 {\n    x + 1\n}\n\n\n1\n\n描述 我们要发布的 整个crate, 使用 //!\n\n2\n\n使用 ///,可以用markdown 语法  Example 是一个常见的我们要去写的区域,后面写上示例Panics: 描述可能发生panic的场景 Errors: 如何函数返回Result,描述可能的错误种类,以及导致错误的条件Safty: 如果函数处于unsafe调用, 那么就描述使用unsafe的原因和使用的前提\n\n3\n\n使用cargo test 会测试这里的代码, 注意 需要将 示例代码里使用的 my_crate改成 Cargo.toml中 [package] 的 name\n\n\n# --open 会直接打开 生成的 html\ncargo doc --open\n# 会测试 文档注释中的代码\ncargo test\n   Doc-tests ....\n\n\n3.2 pub use\n\nsrc/lib.rssrc/main.rs\n\n\n//! # Art\n//!\n//! A library for modeling artistic concepts.\n\n// --加上这些--\n1pub use self::kinds::PrimaryColor;\npub use self::kinds::SecondaryColor;\npub use self::utils::mix;\n//  -----\n\npub mod kinds {\n    /// The primary colors according to the RYB color model.\n    pub enum PrimaryColor {\n        Red,\n        Yellow,\n        Blue,\n    }\n\n    /// The secondary colors according to the RYB color model.\n    pub enum SecondaryColor {\n        Orange,\n        Green,\n        Purple,\n    }\n}\n\npub mod utils {\n    use crate::kinds::*;\n\n    /// Combines two primary colors in equal amounts to create\n    /// a secondary color.\n    pub fn mix(c1: PrimaryColor, c2: PrimaryColor) -&gt; SecondaryColor {\n        SecondaryColor::Orange\n    }\n}\n\n1\n\n这样生成的文档方便用户查看,不需要点击多次才能看到\n\n\n\n\n// use art::kinds::PrimaryColor;\n// use art::utils::mix;\n\n// 在lib.rs 添加 pub use 后, 这里可以这样了,生成的文档也方便用户使用\nuse art::mix;\nuse art::PrimaryColor;\n\nfn main() {\n    let red = PrimaryColor::Red;\n    let yellow = PrimaryColor::Yellow;\n    mix(red, yellow);\n}\n\n\n\ncargo doc --open # 查看一下",
    "crumbs": [
      "核心基础",
      "基础篇",
      "cargo"
    ]
  },
  {
    "objectID": "docs/basic/cargo.html#发布crate到crate.io",
    "href": "docs/basic/cargo.html#发布crate到crate.io",
    "title": "rust cargo",
    "section": "4 发布crate到crate.io",
    "text": "4 发布crate到crate.io\n\n4.1 登录crate.io获取token\n登录crate.io后,进入settings页面, 生成一个token\n# 该命令会将token 存储在 ~/.cargo/credentials\ncargo login abcdefghijklmnopqrstuvwxyz012345\n\n\n4.2 修改Cargo.toml\n[package]\n1name = \"guessing_game\"\nversion = \"0.1.0\"\nedition = \"2021\"\n2description = \"该描述会显示在crate.io的搜索结果里\"\n3license = \"MIT OR Apache-2.0\"\n[dependencies]\n\n1\n\n名字在crate.io中必须是独一无二的\n\n2\n\n必填项\n\n3\n\n必填项,许可标识值可在spdx上查找\n\n\n\n\n4.3 发布\ncargo publish\n发布已存在crate的新版本, 需要修改 toml文件中的 version3, 再执行cargo publish 即可\n\n\n4.4 cargo yank 撤回\n\n首先 crate.io 是不能让你删除已经发布的版本的,因为如果已经有人用了怎么办\n但是可以让你撤回,它的意思是, 防止新的用户使用这个可能不太好的版本,cargo add xxxx 后不会使用到这个撤回的版本, 如果是已经使用了这个版本的人(Cargo.lock里指定了版本了), 还是可以下载使用的\n\ncargo yank --vers 1.0.1\n    Updating crates.io index\n        Yank guessing_game@1.0.1\n# 取消 yank\ncargo yank --vers 1.0.1 --undo\n    Updating crates.io index\n      Unyank guessing_game@1.0.1",
    "crumbs": [
      "核心基础",
      "基础篇",
      "cargo"
    ]
  },
  {
    "objectID": "docs/basic/cargo.html#工作空间-workspace",
    "href": "docs/basic/cargo.html#工作空间-workspace",
    "title": "rust cargo",
    "section": "5 工作空间 workspace",
    "text": "5 工作空间 workspace\n\n5.1 创建\nmkdir add\ncd add\ntouch Cargo.toml\n\n\nCargo.toml\n\n[workspace]\n\nmembers = [\n1    \"adder\",\n]\n2resolver = \"2\"\n\n\n1\n\n这样一个member就是一个package, 我们可以这样在一个工作空间中创建多个package, 之前比如测试代码时我们可能会cargo new xxx 一个新的项目来进行测试,现在可以这样处理.  实际操作时,这里空着或者members=整个都不写就行,后面使用cargo new xxx 会自动在这里添加\n\n2\n\nresolver4\n\n\n\n\n添加 一个binary package\n\ncargo new adder\ncargo build\ntree -L 2\n    .\n    ├── Cargo.lock\n    ├── Cargo.toml\n    ├── adder\n    │   ├── Cargo.toml\n    │   └── src\n    └── target # 存放所有members 编译后的东西\n        ├── CACHEDIR.TAG\n        └── debug\ncd adder\n# 我们没有看到在这个adder目录下生成target目录\n# 还是会在 外层的 target 目录下生成\ncargo build\n\n\n\n添加一个 lib package\n\n# 该命令会在 Cargo.toml的 members 里自动添加\ncargo new add_one --lib\ntree -L 2\n    ├── Cargo.lock\n    ├── Cargo.toml\n    ├── add_one\n    │   ├── Cargo.toml\n    │   └── src\n    │       └── lib.rs\n    ├── adder\n    │   ├── Cargo.toml\n    │   └── src\n    │       └── main.rs\n    └── target\n\n\n\n在add_one/src/lib.rs添加一个方法\n\npub fn add_one(x: i32) -&gt; i32 {\n    x + 1\n}\n\n现在我们要在adder 中依赖add_one这个package,需要在adder/Cargo.toml中添加\n\n\nadder/Cargo.toml\n\n[package]\nname = \"adder\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[dependencies]\nadd_one = { path = \"../add_one\" }\n\n\n\nadder/src/main.rs\n\nuse add_one;\n\nfn main() {\n    let num = 10;\n    println!(\"Hello, world! {num} plus one is {}!\", add_one::add_one(num));\n}\n\n\n\n运行指定 binary crate\n\ncargo run  -p adder\n\n\n\n5.2 使用外部crate\nadder/Cargo.toml[dependencies]中添加rand = \"0.8.1\",然后在add_one/Cargo.toml[dependencies]中添加rand = \"0.8.5\"后, cargo build 只会在外层Cargo.lock中生成一个rand版本.这样工作空间中的crate 都会使用同一个版本的rand\n\n\n5.3 测试\n# 在add目录下\n# 会test 工作空间中所有的package\ncargo test\n# 指定\ncargo test -p adder",
    "crumbs": [
      "核心基础",
      "基础篇",
      "cargo"
    ]
  },
  {
    "objectID": "docs/basic/cargo.html#一个package多个binary",
    "href": "docs/basic/cargo.html#一个package多个binary",
    "title": "rust cargo",
    "section": "6 一个package多个binary",
    "text": "6 一个package多个binary\n├── Cargo.lock\n├── Cargo.toml\n├── src\n│   ├── main.rs  # 含有main()\n│   ├── bin # 必须用这个目录名\n│   │   └── hello.rs # 同样含有main()\n\n\n运行另外一个可执行 binary hello.rs\n\ncargo run --bin=hello # = 指定文件名(去掉 .后缀)\n# 可以不用=\ncargo run --bin hello",
    "crumbs": [
      "核心基础",
      "基础篇",
      "cargo"
    ]
  },
  {
    "objectID": "docs/basic/cargo.html#安装二进制包",
    "href": "docs/basic/cargo.html#安装二进制包",
    "title": "rust cargo",
    "section": "7 安装二进制包",
    "text": "7 安装二进制包\n只能安装具有 binary target的 package (有binary crate)\n# 会安装到 $HOME/.cargo/bin 目录\ncargo install ripgrep",
    "crumbs": [
      "核心基础",
      "基础篇",
      "cargo"
    ]
  },
  {
    "objectID": "docs/basic/cargo.html#自定义命令扩展",
    "href": "docs/basic/cargo.html#自定义命令扩展",
    "title": "rust cargo",
    "section": "8 自定义命令扩展",
    "text": "8 自定义命令扩展\n在系统中你可以直接运行的一个命令 名字是cargo-xxxx,那么你就可以运行cargo xxxx 这样来替代运行它, cargo --list 可以查看到.\n我们在安装rust后, 可以在~/.cargo/bin 看到一些可执行文件, cargo-fmt 就是其中的一个, 我们可以发现有cargo fmt这个命令,就像cargo 的内置命令一样",
    "crumbs": [
      "核心基础",
      "基础篇",
      "cargo"
    ]
  },
  {
    "objectID": "docs/basic/cargo.html#footnotes",
    "href": "docs/basic/cargo.html#footnotes",
    "title": "rust cargo",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nconfig.toml↩︎\nsccache↩︎\nhttp://semver.org/↩︎\nresolver-versions↩︎",
    "crumbs": [
      "核心基础",
      "基础篇",
      "cargo"
    ]
  },
  {
    "objectID": "docs/basic/pattern-match.html",
    "href": "docs/basic/pattern-match.html",
    "title": "rust 模式匹配 pattern match",
    "section": "",
    "text": "Important\n\n\n\n\n模式匹配是一种编程语言特性, 允许你将值(简单的值或者复杂的数据结构)与预定义的模式进行比较,并在匹配成功时执行相应的代码(变量绑定或其他操作)\n结合下图, 然后后面的实际例子, 体会一下\n就我个人印象, 了解下模式匹配的定义(没错,就是定义) 是很有好处的, 之前就直接开干,概念没有特别去思考, 有些东西会有些模糊",
    "crumbs": [
      "核心基础",
      "基础篇",
      "模式匹配"
    ]
  },
  {
    "objectID": "docs/basic/pattern-match.html#概念逻辑",
    "href": "docs/basic/pattern-match.html#概念逻辑",
    "title": "rust 模式匹配 pattern match",
    "section": "",
    "text": "Important\n\n\n\n\n模式匹配是一种编程语言特性, 允许你将值(简单的值或者复杂的数据结构)与预定义的模式进行比较,并在匹配成功时执行相应的代码(变量绑定或其他操作)\n结合下图, 然后后面的实际例子, 体会一下\n就我个人印象, 了解下模式匹配的定义(没错,就是定义) 是很有好处的, 之前就直接开干,概念没有特别去思考, 有些东西会有些模糊",
    "crumbs": [
      "核心基础",
      "基础篇",
      "模式匹配"
    ]
  },
  {
    "objectID": "docs/basic/pattern-match.html#let",
    "href": "docs/basic/pattern-match.html#let",
    "title": "rust 模式匹配 pattern match",
    "section": "2 let",
    "text": "2 let\nlet PATTERN = EXPRESSION;\nfn main() {\n    // 这种变量申明初始化, 其实就是模式匹配\n    // x 就是pattern , 然后1 就是 x 要与之匹配的值\n    // 这个就属于 irrefutable 类型的模式, 因为x 能匹配上任何东西, 必定匹配上的.\n    let x = 1;\n\n    // (b,c) 是模式, 右边的(1,2) 是值, 结构上能够匹配上\n    // 所以 将 1 绑定到变量b, 将 2 绑定到变量c\n    let (b, c) = (1, 2);\n    println!(\"{}-{}\", b, c);\n    // 忽略第一个元素 , 这里 _ 就是图一里提到的占位符模式\n    let (_, y) = (1, 2);\n    println!(\"y: {}\", y);\n\n    struct Person {\n        name: String,\n        age: i32,\n    }\n    let p1 = Person {\n        name: \"zhang fei\".to_string(),\n        age: 22,\n    };\n    // 同理\n    let Person { name: n, age: m } = p1;\n    println!(\"{} : {}\", n, m);\n\n    let p2 = Person {\n        name: \"liu bei\".to_string(),\n        age: 32,\n    };\n    // 名字与字段名一样的情况,可以省略\n    let Person { name, age } = p2;\n    println!(\"{} : {}\", name, age);\n    let p3 = Person {\n        name: \"guan yu\".to_string(),\n        age: 13,\n    };\n    // 可以使用.. 省略\n    let Person { name,.. } = p3;\n    println!(\"{}\",name);\n}\n\n\n支持& 这种匹配\n\nfn print_coordinates(&(x, y): &(i32, i32)) {\n    println!(\"Current location: ({}, {})\", x, y);\n}\n\nfn main() {\n    let point = (3, 5);\n    // 函数传递参数 相当于 let 形参=传递的实参\n    // let &(x, y)= &(3,5)\n    print_coordinates(&point);\n\n    // 理解了 这也是模式匹配, 下面这个就不觉得奇怪了\n    let &a = &11;\n    println!(\"{}\", a);\n}",
    "crumbs": [
      "核心基础",
      "基础篇",
      "模式匹配"
    ]
  },
  {
    "objectID": "docs/basic/pattern-match.html#match",
    "href": "docs/basic/pattern-match.html#match",
    "title": "rust 模式匹配 pattern match",
    "section": "3 match",
    "text": "3 match\nmatch VALUE {\n    PATTERN =&gt; EXPRESSION,\n    PATTERN =&gt; EXPRESSION,\n    PATTERN =&gt; EXPRESSION,\n}\n\n3.1 枚举\n模式是枚举\nfn main() {\n    let x = Some(5);\n    // 这里的 x 是值\n    match x {\n        // Some(value) 是模式\n        Some(value) =&gt; {\n            // 匹配成功后,执行相应代码\n            // Some(value)=Some(5) 这里也绑定了 变量, value=5\n            println!(\"Got a value: {}\", value)\n        }\n        // None 是模式\n        None =&gt; println!(\"No value\"),\n    }\n}\nenum Coin {\n    Penny,\n    Nickel,\n    Dime(String),\n    Quarter,\n}\n\nfn main() {\n    let c = Coin::Penny;\n    let d = Coin::Dime(\"hello\".to_string());\n    // 这里 let r=  就是前面我们提到 irrefutable 类型的模式\n    // 然后右边本身也含着一个 模式匹配\n    let r = match d {\n        Coin::Penny =&gt; {\n            println!(\"Lucky penny!\");\n            1\n        }\n        Coin::Nickel =&gt; 5,\n        Coin::Dime(s) =&gt; {\n            println!(\"{}\", s); // 可以在这边获取枚举成员携带的数据\n            10 //返回值\n        }\n        // 必须把所有成员匹配都写上,否则报错, 去看 Pattern Syntax\n        Coin::Quarter =&gt; 25,\n    };\n    println!(\"{}\", r);\n}\n\n\n3.2 字面量\nfn main(){\n    let x = 1;\n\n    match x {\n        // 这里的数字1  就是模式, 是字面量的模式\n        1 =&gt; println!(\"一\"),\n        2 =&gt; println!(\"二\"),\n        // 虽然这个也匹配, 但是只会执行前面第一个匹配的分支\n        1 =&gt; println!(\"1\"),\n        3 =&gt; println!(\"三\"),\n        4 =&gt; println!(\"四\"),\n        5 =&gt; println!(\"五\"),\n        // _ 是占位符模式\n        _ =&gt; println!(\"其他数字\"),\n    }\n    match x{\n        2=&gt;println!(\"二\"),\n        // 可以随便一个变量名来表示其他数据\n        other=&gt;println!(\"其他数字: {}\",other),\n    }\n}\n\n\n3.3 结构体\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nfn main() {\n    let p = Point { x: 10, y: 0 };\n\n    match p {\n        Point { x, y: 0 } =&gt; println!(\"y=0 才能匹配上 {}\", x),\n        Point { x, y: 0..=2 } =&gt; println!(\"y&gt;=0 &lt;=2 是才匹配上 {}\", x),\n        Point { x: 0, y } =&gt; println!(\"x=0 才能匹配上 {}\", y),\n        Point { x, y } =&gt; println!(\"都能匹配上 ({}, {})\", x, y),\n    }\n}",
    "crumbs": [
      "核心基础",
      "基础篇",
      "模式匹配"
    ]
  },
  {
    "objectID": "docs/basic/pattern-match.html#if-let",
    "href": "docs/basic/pattern-match.html#if-let",
    "title": "rust 模式匹配 pattern match",
    "section": "4 if let",
    "text": "4 if let\n相当于 使用 match ,然后只匹配一个成员,然后执行代码块, 更加简洁\n\n使用if .. else注意\n\n\nfn main() {\n    // Some 这个是Option&lt;t&gt; 枚举里的成员, 因为 默认 use了,所以可以直接拿来用\n    let config_max = Some(3u8);\n    match config_max {\n        Some(max) =&gt; println!(\"The maximum is configured to be {}\", max),\n        _ =&gt; (),\n    }\n    let config_max = Some(3u8);\n    // 相当于上面的 match, 但是我们这里不用写 另外 _ 的分支\n    // 模式匹配上,绑定值到变量max, 然后执行 {} 里的代码, 匹配不上 就继续后面的代码\n    // 和if 判断 很像\n    if let Some(max) = config_max {\n        println!(\"The maximum is configured to be {}\", max);\n    }\n}\n\n\nfn main() {\n    let n = 1;\n    // 1=n , 1 是字面量 模式(pattern)\n    // n 是值, 这里匹配上了\n    if let 1 = n {\n        println!(\"{}\", 1);\n    } else {  // 也能 else if {} else{}\n        println!(\"{}\", 2);\n    }\n    // 类似我们之前if 条件语句那边\n    let r = if let 1 = n { 11 } else { 22 };\n    println!(\"{}\", r);\n}\n\n\nfn main() {\n    // 之前 这种 let x =1  很显然也可以 使用 if\n    // 只是这样写, 会提示你 这个肯定会匹配上, 不需要写 if 这种\n    if let x = 1 {\n        println!(\"hello\")\n    }\n    //错误, 提示在这个作用域中找不到x\n    // println!(\"{}\", x);\n}",
    "crumbs": [
      "核心基础",
      "基础篇",
      "模式匹配"
    ]
  },
  {
    "objectID": "docs/basic/pattern-match.html#while-let",
    "href": "docs/basic/pattern-match.html#while-let",
    "title": "rust 模式匹配 pattern match",
    "section": "5 while let",
    "text": "5 while let\nfn main() {\n    let mut optional = Some(0);\n\n    // let Some(i)=optional 匹配上, 就进入{}\n    // 1. 第一次 匹配上 i=0\n    while let Some(i) = optional {\n        if i &gt; 9 {\n            println!(\"Greater than 9, quit!\");\n            optional = None;\n        } else {\n            // 2. 到这里, ... 到 i=9 最后一次在这里,然后 i&gt;9,走上面的分支\n            println!(\"`i` is `{:?}`. Try again.\", i);\n            optional = Some(i + 1);\n        }\n    }\n}",
    "crumbs": [
      "核心基础",
      "基础篇",
      "模式匹配"
    ]
  },
  {
    "objectID": "docs/basic/pattern-match.html#let-ref",
    "href": "docs/basic/pattern-match.html#let-ref",
    "title": "rust 模式匹配 pattern match",
    "section": "6 let ref",
    "text": "6 let ref\nref 是模式的一部分, 而 & 是借用运算符,是表达式的一部分\n\n简单变量中使用结构体使用枚举中使用ref mut 可变借用\n\n\nfn main() {\n    let ref_c2 = &1;\n    // 等价上面,  如果是ref mut 就是可变借用了\n    let ref ref_c1 = 1;\n    println!(\"{}-{}\", *ref_c1, *ref_c2);\n}\n\n\n\n\n看一下这个例子, 报错了\n\nstruct Person {\n    name: String,\n    age: i32,\n}\nfn main() {\n    let p1 = Person {\n        name: \"zhang fei\".to_string(),\n        age: 22,\n    };\n    let Person { name, age } = p1;\n    println!(\"{} : {}\", name, age);\n    // 我们发现这里会报错,提示 p1.name 已经被move给前面的 name了\n    // 因为相当于变量赋值,name 是 move 类别\n    println!(\"{}-{}\", p1.age, p1.name);\n}\n\n\n\n我们使用ref 借用name就行\n\nstruct Person {\n    name: String,\n    age: i32,\n}\nfn main() {\n    let p1 = Person {\n        name: \"zhang fei\".to_string(),\n        age: 22,\n    };\n    let Person { ref name, age } = p1;\n    println!(\"{} : {}\", name, age);\n    let Person {\n        // 这里的name 是字段, n 才是我们要的值, 所以别弄错, ref是修饰n\n        name: ref n,\n        age: m,\n    } = p1;\n    println!(\"{} : {}\", n, m);\n}\n\n\n\n\n\n报错: 枚举中发生move\n\nfn main() {\n    let x: Option&lt;String&gt; = Some(\"hello\".to_string());\n    match x {\n        // 注意是在这里 发生了 move\n        // Some(e)=x, e 获取了x 里部分数据的所有权.\n        Some(e) =&gt; println!(\"{}\", e),\n        _ =&gt; println!(\"other\"),\n    }\n    // x中的数据被转移所有权了,所以这里报错了\n    println!(\"{:?}\", x);\n}\n\n\n\n添加ref\n\nfn main() {\n    let x: Option&lt;String&gt; = Some(\"hello\".to_string());\n    match x {\n        // 加上ref ,表示这里e 是 借用了 x里面的数据\n        // x 数据是完整的, 后面就不会报错了.\n        Some(ref e) =&gt; println!(\"hello{}\", e),\n        _ =&gt; println!(\"other\"),\n    }\n\n    println!(\"{:?}\", x);\n}\n\n\n\n使用match &x\n\nfn main() {\n    let x: Option&lt;String&gt; = Some(\"hello\".to_string());\n    // match &x\n    match &x {\n        // 编译器自动将e弄成 &String ,对 x 内 字符串的借用了\n        // 如果是 match &mut x 同理\n        Some(e) =&gt; println!(\"hello{}\", *e),\n        _ =&gt; println!(\"other\"),\n    }\n\n    println!(\"{:?}\", x);\n}\n\n\n\nstruct Person {\n    name: String,\n    age: i32,\n}\nfn main() {\n    let mut p1 = Person {\n        name: \"zhang fei\".to_string(),\n        age: 22,\n    };\n    let Person { ref mut name, age } = p1;\n    println!(\"{} : {}\", name, age);\n    name.push_str(\" hello\");\n    println!(\"{}\", p1.name);\n}",
    "crumbs": [
      "核心基础",
      "基础篇",
      "模式匹配"
    ]
  },
  {
    "objectID": "docs/basic/pattern-match.html#let-mut",
    "href": "docs/basic/pattern-match.html#let-mut",
    "title": "rust 模式匹配 pattern match",
    "section": "7 let mut",
    "text": "7 let mut\n\n\n\n\n\n\nCaution\n\n\n\n没错, 我们平常使用的let mut x=1 类似这种语句, mut 是模式匹配中模式的一部分\n\n\nstruct Person {\n    name: String,\n    age: i32,\n}\nfn main() {\n    let mut x=2;\n    let (mut a, mut b) = (1, 2);\n    a = 33;\n    println!(\"{}\", a);\n    struct Person {\n        name: String,\n        age: i32,\n    }\n    let p1 = Person {\n        name: \"zhang fei\".to_string(),\n        age: 22,\n    };\n    let Person { name, age } = p1;\n    println!(\"{} : {}\", name, age);\n    // name.push_str(\"string\"); 报错,因为name 不可变\n    let p1 = Person {\n        name: \"zhang fei\".to_string(),\n        age: 22,\n    };\n    let Person { mut name, age } = p1;\n    name.push_str(\"string\"); // ok\n}",
    "crumbs": [
      "核心基础",
      "基础篇",
      "模式匹配"
    ]
  },
  {
    "objectID": "docs/basic/pattern-match.html#pattern-syntax",
    "href": "docs/basic/pattern-match.html#pattern-syntax",
    "title": "rust 模式匹配 pattern match",
    "section": "8 Pattern Syntax",
    "text": "8 Pattern Syntax\n\n8.1 .. 剩余\nstruct Point {\n    x: i32,\n    y: i32,\n    z: i32,\n}\nfn main() {\n    let (a, ..) = (1, 2, 3, 4, 5);\n    println!(\"{}\", a); // 1\n    let (b, .., c) = (1, 2, 3, 4, 5);\n    println!(\"{}-{}\", b, c); // 1-5\n\n    // 结构体 不能 将.. 放中间\n    let Point { x: x1, .. } = Point {\n        x: 11,\n        y: 22,\n        z: 33,\n    };\n    println!(\"{}\", x1); // 1\n}\n\n\n8.2 _ 忽略绑定\nfn main() {\n    let (_, x, _) = (1, 2, 3);\n    println!(\"{}\", x);\n\n    let y = Some(String::from(\"hello\"));\n    // - 没有绑定, 所以没有move,后面的y打印不会报错\n    if let Some(_) = y {\n        println!(\"ss\");\n    };\n    println!(\"{:?}\", y);\n}\n\n\n8.3 _ 剩余部分\n成员不用全部写上的方式\nenum Coin {\n    Penny,\n    Nickel,\n    Dime(String),\n    Quarter,\n}\n\nfn main() {\n    let d = Coin::Dime(\"hello\".to_string());\n    let r = match d {\n        Coin::Penny =&gt; {\n            println!(\"Lucky penny!\");\n            1\n        }\n        // 用other 表示其他情况\n        other =&gt; 666,\n    };\n    println!(\"{}\", r);\n}\n使用_来表示不匹配的情况,这里的和枚举显然不一样,在枚举里如果要写,是肯定能匹配上的,这里是完全可能匹配不上,所以用 _ 来区分 前面用的other.\n其实都用 _ 就行\nfn main() {\n    let d = 3;\n    let r = match d {\n        1 =&gt; 11,\n        2 =&gt; 22,\n        _ =&gt; 888,\n    };\n    println!(\"{}\", r);\n}\n\n\n8.4 | 和 if\nfn main() {\n    let x = 4;\n    let y = true;\n\n    match x {\n        // 或者等4或5,或6 并且 y为真才行, y是外部定义的那个y\n        4 | 5 | 6 if y =&gt; println!(\"yes\"),\n        7 | 8 =&gt; println!(\"7-8\"),\n        _ =&gt; println!(\"no\"),\n    }\n}\nfn main() {\n    let x = Some(5);\n    let y = 5;\n\n    match x {\n        Some(50) =&gt; println!(\"50\"),\n        // ==y 的y 是外部 定义的 y =5\n        // Some(y) 的y 与外部无关\n        Some(y) if y == y =&gt; {\n            println!(\"Matched, n = {}\", y)\n        }\n        _ =&gt; println!(\"Default case, x = {:?}\", x),\n    }\n}\n\n\n8.5 ..= 范围\n&gt;=xx &lt;=yy\nfn main() {\n    let x = 5i32;\n\n    match x {\n        1..=5 =&gt; println!(\"&gt;=1 &lt;=5\"),\n        _ =&gt; println!(\"something else\"),\n    }\n    println!(\"i32最小值{}\", i32::MIN);\n    match x {\n        i32::MIN..=2_i32 =&gt; println!(\"&lt;=2\"),\n        3 =&gt; println!(\"=3\"),\n        4 =&gt; println!(\"=4\"),\n        5_i32..=i32::MAX =&gt; println!(\"&gt;=5\"),\n    };\n}\n\n\n8.6 @ 绑定\nenum Student {\n    primary { age: i32 },\n    junior { age: i32 },\n}\nfn main() {\n    let s = Student::primary { age: 3 };\n\n    match s {\n        Student::primary { age: primary_age } if primary_age &gt;= 7 && primary_age &lt;= 11 =&gt; {\n            println!(\"Hello\")\n        }\n        // 相当于上面 primary_age &gt;= 3 && primary_age &lt;= 6\n        // @前面是绑定的变量 \n        Student::primary {\n            // 这里就表示当你符合 &gt;=3 &lt;=6 ,绑定匹配到的age到primary_age 这个变量\n            age: primary_age @ 3..=6,\n        } =&gt; println!(\"是 &gt;=3 &lt;=6 岁的小学生: {}\", primary_age),\n        Student::junior { age: 10..=12 } =&gt; {\n            println!(\"10-12 岁的初中生\")\n        }\n        Student::junior { age } =&gt; println!(\"Found: {}\", age),\n        _ =&gt; (),\n    }\n\n    let a=Some(42);\n    match a {\n        // 得到 `Some` 可变类型，如果它的值（绑定到 `n` 上）等于 42，则匹配。\n        Some(n @ 42) =&gt; println!(\"The Answer: {}!\", n),\n        // 匹配任意其他数字。\n        Some(n)      =&gt; println!(\"Not interesting... {}\", n),\n        // 匹配任意其他值（`None` 可变类型）。\n        _            =&gt; (),\n    }\n}\nfn main() {\n    let x = 11;\n    match x {\n        // | 多个情况 绑定\n        e @ 11 | e @ 1..=3 =&gt; println!(\"{}\", e),\n        _ =&gt; println!(\"other\"),\n    }\n}",
    "crumbs": [
      "核心基础",
      "基础篇",
      "模式匹配"
    ]
  },
  {
    "objectID": "docs/basic/pattern-match.html#non_exhaustive",
    "href": "docs/basic/pattern-match.html#non_exhaustive",
    "title": "rust 模式匹配 pattern match",
    "section": "9 non_exhaustive",
    "text": "9 non_exhaustive\n\n\n\n\n\n\nCaution\n\n\n\n\n当你使用上游开发人员创建的一个enum, 然后你写了全部分支, OK.\n突然有一天, 上游人员给这个enum 添加了一个变体成员, 这个时候因为你的模式匹配enum中没有写_ 这种,导致现在没有写完全部分支,错误发生了\nnon_exhaustive就是为了防止这种情况的发生而设计的\n\n\n\n\n.\n├── Cargo.toml # package : world\n└── src\n    ├── lib.rs \n    ├── main.rs\n\nlib.rsmain.rs\n\n\npub mod enum_ex {\n    // 这个属性, 表示 其他人 match时 必须使用 _ 来整完剩余分支\n    #[non_exhaustive]\n    pub enum Coin {\n        Penny,\n        Nickel,\n        Dime(String),\n        Quarter,\n    }\n}\n\n\nuse world::enum_ex::Coin;\n\nfn main() {\n    let c = Coin::Penny;\n    let d = Coin::Dime(\"hello\".to_string());\n    let r = match d {\n        Coin::Penny =&gt; {\n            println!(\"Lucky penny!\");\n            1\n        }\n        Coin::Nickel =&gt; 5,\n        Coin::Dime(s) =&gt; {\n            println!(\"{}\", s);\n            10\n        }\n        Coin::Quarter =&gt; 25,\n        // 必须 使用 _, 否则报错,编译不过的\n        _ ==&gt; 0,\n    };\n    println!(\"{}\", r);\n}",
    "crumbs": [
      "核心基础",
      "基础篇",
      "模式匹配"
    ]
  },
  {
    "objectID": "docs/basic/crate-mod.html#crate1",
    "href": "docs/basic/crate-mod.html#crate1",
    "title": "rust 模块",
    "section": "1 crate1",
    "text": "1 crate1\nRust 程序由 crate组成. 每个 crate 都是既完整又内聚的单元,包括单个库(library)或可执行程序的所有源代码,以及任何相关的测试、示例、工具、配置和其他杂项\ncrate root 是源代码文件,编译器会从这里开始组成你的crate的根module\ncargo new hello\ncd hello\ntree\n.\n├── Cargo.toml\n└── src\n    ├   # 这个是 binary crate 的crate root\n    ├   # 这个 binary crate 的名字与package相同, hello\n    └── main.rs\n# 我们手动创建一个library crate\n# 这个 library crate 的名字也是与package相同,hello\ntouch src/lib.rs # 这个文件默认就是 library crate 的crate root\nCargo.toml 没有指定上面2个文件名是 crate root ,因为这个是一种默认约定, 就像go里的main.go, cargo 会把crate root 文件给 rustc来构建",
    "crumbs": [
      "核心基础",
      "基础篇",
      "crate与模块"
    ]
  },
  {
    "objectID": "docs/basic/crate-mod.html#module",
    "href": "docs/basic/crate-mod.html#module",
    "title": "rust 模块",
    "section": "2 module",
    "text": "2 module\n模块是组织代码的一种方式,它允许你将代码分割到不同的文件中,并让每个文件只包含相关的代码. 模块可以嵌套,并且可以被任意数量的模块使用\nmod front_of_house {\n    mod hosting {\n        fn add_to_waitlist() {}\n        fn seat_at_table() {}\n    }\n    mod serving {\n        fn take_order() {}\n        fn serve_order() {}\n        fn take_payment() {}\n    }\n}\n前面我们说到 src/main.rs and src/lib.rs 之所以被称为 crate root, 这是因为 main.rs或lib.rs 文件的内容形成了一个名字叫做 crate的模块,位于module tree的root位置\n上面代码的 module tree\ncrate #(根部,名字为crate的模块)\n └── front_of_house # (名字为front_of_house的模块)\n     ├── hosting #(名字为hosting的模块)\n     │   ├── add_to_waitlist\n     │   └── seat_at_table\n     └── serving #(名字为serving的模块)\n         ├── take_order\n         ├── serve_order\n         └── take_payment\n就像目录一样, 这样我们是不是就可以像目录一样的访问方式去找到我们的模块",
    "crumbs": [
      "核心基础",
      "基础篇",
      "crate与模块"
    ]
  },
  {
    "objectID": "docs/basic/crate-mod.html#pathpub",
    "href": "docs/basic/crate-mod.html#pathpub",
    "title": "rust 模块",
    "section": "3 path,pub",
    "text": "3 path,pub\n\n\n\n\n\n\n关于pub的总结\n\n\n\n\n没有设置pub 相当于 设置pub(self)\npub(xxxx) 表示被约束的东西只能被xxxx及其子模块访问\n单独的pub 表示能被外部访问\n\n\n\n.\n├── Cargo.toml\n└── src\n    ├── lib.rs\n    └── main.rs\n\n\nsrc/lib.rs\n\n// 没有pub 的模块, 表示只能被当前模块及其后代模块访问\n// 对front_of_house 来说 ,当前模块是 crate\nmod front_of_house {\n    // 如果没有pub, 表示 hosting模块是私有的, 只能被当前模块及其后代模块访问\n    // 对hosting 来说 ,当前模块是front_of_house \n    // 该mod 如果要让外部访问, 需要 + pub\n    pub mod hosting {\n        // 方法同理\n        pub fn add_to_waitlist() {}\n    }\n}\n\npub fn eat_at_restaurant() {\n    // 绝对路径调用, 这个lib.rs 文件隐含着 形成的 名为 crate的模块\n    // 同理如果你在 main.rs 中 使用crate:: 表示main.rs 文件里找模块\n    // 因为 front_of_house 和 eat_at_restaurant 在同一个crate中,\n    // 注意 eat_at_restaurant 是方法,不是模块, 所以它是在 根模块 crate 中\n    // 好比 linux的目录 / 中, 而 front_of_house 是模块, 就好比 /front_of_house 目录\n    // 所以可以直接使用 crate:: 来,不需要 pub front_of_house\n    crate::front_of_house::hosting::add_to_waitlist();\n\n    // 相对路径\n    // 好比在目录 / 中访问 front_of_house/hosting/add_to_waitlist\n    front_of_house::hosting::add_to_waitlist();\n\n    let mut meal = back_of_house::Breakfast::summer(\"Rye\");\n    meal.toast = String::from(\"Wheat\");\n    println!(\"I'd like {} toast please\", meal.toast);\n\n    //  seasonal_fruit 是私有的, 无法访问\n    // meal.seasonal_fruit = String::from(\"blueberries\");\n}\n\nfn deliver_order() {}\n\nmod back_of_house {\n    fn fix_incorrect_order() {\n        cook_order();\n        // super 父模块 ,得到根模块 crate\n        // 子模块访问父模块的方法, 方法不需要pub\n        super::deliver_order();\n        // 绝对路径\n        crate::deliver_order();\n    }\n\n    fn cook_order() {\n        // 父模块访问子模块 fridge里的方法, 方法需要pub\n        fridge::get_item();\n    }\n    // 没有pub 的模块, 只对被当前模块及其后代模块访问\n    // 对fridge 来说 ,当前模块是 back_of_house\n    mod fridge {\n        pub fn get_item() {}\n        // 没有pub的, 表示只能被当前模块, 这里就是 fridge 访问\n        fn get_item2(){}\n        fn get_item3(){\n            self::get_item2();\n        }\n    }\n\n    // 结构体的 权限\n    pub struct Breakfast {\n        pub toast: String, // pub\n        seasonal_fruit: String, //私有\n    }\n\n    impl Breakfast {\n        pub fn summer(toast: &str) -&gt; Breakfast {\n            Breakfast {\n                toast: String::from(toast),\n                seasonal_fruit: String::from(\"peaches\"),\n            }\n        }\n    }\n    // 枚举的权限, 只要 pub enum ,成员变体就全是pub了\n    pub enum Appetizer {\n        Soup,\n        Salad,\n    }\n}\n\npub(crate) pub(self) pub(super)\n\n.\n├── Cargo.toml\n└── src\n    ├── lib.rs\n    └── main.rs\n\nCargo.tomllib.rsmain.rs\n\n\n[package]\nname = \"world\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n\npub mod back {\n    pub fn hello() {\n        println!(\"hello\");\n    }\n}\npub mod back2 {\n    // 表示给只能被crate 模块及其子模块访问\n    pub(crate) fn world2() {\n        println!(\"world2\");\n    }\n    pub fn world22() {\n        println!(\"world22\");\n    }\n    // pub(self) 表示只能被当前模块以及子模块访问\n    // 这和不带 pub(self) 是一样的.\n    // 等同于 fn world222()\n    pub(self) fn world222() {\n        println!(\"world222\");\n    }\n    pub mod back2_son {\n        // pub(super) 表示该back2_son_1方法只能被父模块\n        // 也就是back2及其子模块访问\n        pub(super) fn back2_son_1() {\n            println!(\"back2_son_1\");\n        }\n        pub fn back2_son_2() {\n            println!(\"back2_son_2\");\n        }\n        // in 只能设置父模块或祖先模块\n        pub(in crate::back2) fn back2_son_3() {\n            println!(\"back2_son_3\");\n        }\n    }\n    mod back2_son2 {\n\n        fn say() {\n            super::back2_son::back2_son_1();\n            super::back2_son::back2_son_2();\n        }\n    }\n}\n// 表示给crate 模块及其子模块使用\n// 在main.rs 里是无法使用的.\npub(crate) mod back3 {\n    pub fn world3() {\n        println!(\"world3\");\n        crate::back2::back2_son::back2_son_2();\n        // crate::back2::back2_son::back2_son_1(); 不可访问\n    }\n}\n\n\nuse world::back;\nuse world::back2;\n// use world::back3; 不可访问\nfn main() {\n    back::hello();\n    // back2::world2(); 不可访问\n    back2::world22();\n    // back2::world222(); 不可访问\n}",
    "crumbs": [
      "核心基础",
      "基础篇",
      "crate与模块"
    ]
  },
  {
    "objectID": "docs/basic/crate-mod.html#use",
    "href": "docs/basic/crate-mod.html#use",
    "title": "rust 模块",
    "section": "4 use",
    "text": "4 use\n\n\n\n\n\n\nTip\n\n\n\nuse 语句将路径引入到当前作用域,从而允许你使用路径中指定的名称\n\n\n\n4.1 mod\nmod front_of_house {\n    pub mod hosting {\n        pub fn add_to_waitlist() {}\n        pub struct Dog {}\n    }\n}\n// 将hosting 引入当前作用域, 这样 就能直接使用 这个hosting模块\n// 相当于在 crate 根模块中 定义了 hosting 模块\n1use crate::front_of_house::hosting;\n// 使用相对路径, as 别名\nuse front_of_house::hosting as hosting2;\n// 引入函数一般是引入到父级模块\n// 可以use 引入具体的函数,但是一般我们不这样弄,\n// 因为 最后是让你自己知道使用的函数是引入的模块里的还是你自己这里定义的\nuse front_of_house::hosting::add_to_waitlist as waitlist;\n// 如果是引入 struct enum 等其他不是函数的东西 ,一般就use 到 具体的struct,enum.\nuse front_of_house::hosting::Dog;\n\n// 外部代码 默认是不能访问, use 还需要 加上pub\n// pub use 表示导出, 这样外部代码就能 导入到它的作用域\npub use front_of_house::hosting as pub_hosting;\n\npub fn eat_at_restaurant() {\n    hosting::add_to_waitlist();\n    hosting2::add_to_waitlist();\n    waitlist();\n    let a = Dog {};\n}\n\nmod back_of_house {\n    use crate::front_of_house::hosting;\n\n    fn take() {\n        // 当前这个 back_of_house 模块下想直接使用, 还是得 use 引入\n        // add_to_waitlist 还是必须pub\n        hosting::add_to_waitlist();\n        // 使用super 来\n        super::hosting::add_to_waitlist();\n    }\n}\n\n1\n\n将hosting 引入当前作用域, 这样 就能直接使用 这个hosting模块 相当于在 crate 根模块中 定义了 hosting 模块\n\n\n\n\n4.2 外部package\n\n\n\n\n\n\n使用外部package\n\n\n\n\nCargo.toml 添加要依赖的包\n代码中使用 use 将包引入到自己的作用域\n虽然std标准库也是外部包,但是已经被内置,所以不需要Cargo.toml 中添加\n\n\n\n添加包\ncargo add rand\n查看一下Cargo.toml\n[package]\nname = \"hello\"\nversion = \"0.1.0\"\nedition = \"2021\"\n[dependencies]\nrand = \"0.8.5\"\nuse rand::Rng;  // 引入添加的外部包\nuse std::collections::HashMap; // 引入标准库\nfn main() {}\n\n\n4.3 本地package\n\n\n\n\n\n\nTip\n\n\n\nmain.rs 变为本地 package的使用者. The module tree should be defined in src/lib.rs. Then, any public items can be used in the binary crate by starting paths with the name of the package. The binary crate becomes a user of the library crate just like a completely external crate would use the library crate\n\n\n\n.\n├── Cargo.toml\n└── src\n    ├── lib.rs\n    └── main.rs\n\nCargo.tomllib.rsmain.rs\n\n\n[package]\nname = \"world\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n\npub mod back {\n    pub fn hello() {\n        println!(\"hello\");\n    }\n}\n\n\nuse world::back;\nfn main() {\n    back::hello();\n}\n\n\n\n\n\n\n4.4 use 其他语法\nuse std::cmp::Ordering;\nuse std::io;\n使用{} 来简写\nuse std::{cmp::Ordering, io};\nuse std::io;\nuse std::io::Write;\n// 使用 self, 等价于上面2个\nuse std::io::{self, Write};\n使用*\nuse std::collections::*;\n\n\n4.5 prelude\n\n\n\n\n\n\nTip\n\n\n\n标准库中有一些非常常用的东西,我们可能每一个rs文件都要去use相关的, 所以rust编译期自动的为每一个crate插入一句use std::prelude::*;",
    "crumbs": [
      "核心基础",
      "基础篇",
      "crate与模块"
    ]
  },
  {
    "objectID": "docs/basic/crate-mod.html#module-拆分",
    "href": "docs/basic/crate-mod.html#module-拆分",
    "title": "rust 模块",
    "section": "5 module 拆分",
    "text": "5 module 拆分\n\n\nsrc/main.rs\n\n// mod 后 就可以直接在 main() 里使用 front_of_house::hosting::add_to_waitlist()\n// 这样 显式mod 后, 才会将 该mod 的代码进行编译\n1mod front_of_house;\n\n// 上面mod 后, 我们才能用 use 的方式\nuse crate::front_of_house::hosting;\n\npub fn eat_at_restaurant() {\n    hosting::add_to_waitlist();\n}\n\nfn main() {\n    front_of_house::hosting::add_to_waitlist();\n    hosting::add_to_waitlist();\n}\n\n\n1\n\n如果我们在定义mod 时, 模块名后面跟着 ; 号, 那么rust 必须能从src目录下找到(否则报错) 1. 与模块同名的文件,里面的内容就是这个模块的定义  2. 或者与模块同名的文件夹(文件夹里需要一个mod.rs文件,它的内容就是模块的定义)\n\n\n\n模块同名的文件模块同名的文件夹\n\n\n\n\nsrc/front_of_house.rs\n\npub mod hosting {\n    pub fn add_to_waitlist() {\n        println!(\"hello\");\n    }\n}\n\n\n\n\n\nsrc/front_of_house/mod.rs\n\npub mod hosting {\n    pub fn add_to_waitlist() {\n        println!(\"hello\");\n    }\n}\n\n\n\n\n理解为将该文件包含到main.rs中,相当于如下代码\n\n\nsrc/main.rs\n\nmod front_of_house {\n    pub mod hosting {\n        pub fn add_to_waitlist() {\n            println!(\"hello\");\n        }\n    }\n}\n\nuse crate::front_of_house::hosting;\n\npub fn eat_at_restaurant() {\n    hosting::add_to_waitlist();\n}\nfn main() {\n    front_of_house::hosting::add_to_waitlist();\n    hosting::add_to_waitlist();\n}\n\n我们继续将front_of_house模块里的hosting模块进行拆分\n\n模块同名的文件的情况模块同名的文件夹的情况\n\n\n\n\nsrc/front_of_house.rs\n\npub mod hosting;\n\ncd src\nmkdir -p front_of_house\n我们需要在 front_of_house 目录下创建hosting.rs 文件\n\n\nsrc/front_of_house/hosting.rs\n\npub fn add_to_waitlist() {\n    println!(\"hello\");\n}\n\n\n\n\n\nsrc/front_of_house/mod.rs\n\npub mod hosting;\n\ncd src\nmkdir -p front_of_house/hosting\n\n\nsrc/front_of_house/hosting/mod.rs\n\npub fn add_to_waitlist() {\n    println!(\"hello\");\n}",
    "crumbs": [
      "核心基础",
      "基础篇",
      "crate与模块"
    ]
  },
  {
    "objectID": "docs/basic/crate-mod.html#footnotes",
    "href": "docs/basic/crate-mod.html#footnotes",
    "title": "rust 模块",
    "section": "Footnotes",
    "text": "Footnotes\n\n\ncrates github crates.io↩︎",
    "crumbs": [
      "核心基础",
      "基础篇",
      "crate与模块"
    ]
  },
  {
    "objectID": "docs/basic/error.html",
    "href": "docs/basic/error.html",
    "title": "rust 错误",
    "section": "",
    "text": "越界\nfn main() {\n    let v = vec![1, 2, 3];\n\n    v[99];\n}\n\n\n\n\npanic!()\n\nfn main() {\n    panic!(\"crash and burn\"); // 后面的不会执行\n    println!(\"1\");\n}\n\nfn not_yet_implemented() {\n    // 标记尚未实现的功能。\n    // 当执行到这个宏时，程序会 panic,并显示一条消息\n    unimplemented!();\n}\nfn feature_not_ready_yet() {\n    // 用于标记代码中的“待办事项”\n    // 即开发者知道这部分代码需要在未来完成\n    todo!(\"Implement this feature\");\n}\nfn unreachable() {\n    // 表明某个代码路径实际上不应该被执行到\n    // 如果执行到这个宏，程序会触发一个 panic\n    unreachable!();\n}\n\nfn main() {\n    let x = 5;\n    assert!(x &lt; 10); // 如果 x &gt;= 10，则会 panic\n    let a = 5;\n    let b = 6;\n    assert_eq!(a, b); // 如果 a != b，则会 panic\n    assert_ne!(a, b); // 如果 a == b，则会 panic\n}",
    "crumbs": [
      "核心基础",
      "基础篇",
      "错误处理"
    ]
  },
  {
    "objectID": "docs/basic/error.html#unrecoverable-errors",
    "href": "docs/basic/error.html#unrecoverable-errors",
    "title": "rust 错误",
    "section": "",
    "text": "越界\nfn main() {\n    let v = vec![1, 2, 3];\n\n    v[99];\n}\n\n\n\n\npanic!()\n\nfn main() {\n    panic!(\"crash and burn\"); // 后面的不会执行\n    println!(\"1\");\n}\n\nfn not_yet_implemented() {\n    // 标记尚未实现的功能。\n    // 当执行到这个宏时，程序会 panic,并显示一条消息\n    unimplemented!();\n}\nfn feature_not_ready_yet() {\n    // 用于标记代码中的“待办事项”\n    // 即开发者知道这部分代码需要在未来完成\n    todo!(\"Implement this feature\");\n}\nfn unreachable() {\n    // 表明某个代码路径实际上不应该被执行到\n    // 如果执行到这个宏，程序会触发一个 panic\n    unreachable!();\n}\n\nfn main() {\n    let x = 5;\n    assert!(x &lt; 10); // 如果 x &gt;= 10，则会 panic\n    let a = 5;\n    let b = 6;\n    assert_eq!(a, b); // 如果 a != b，则会 panic\n    assert_ne!(a, b); // 如果 a == b，则会 panic\n}",
    "crumbs": [
      "核心基础",
      "基础篇",
      "错误处理"
    ]
  },
  {
    "objectID": "docs/basic/error.html#recoverable-errors",
    "href": "docs/basic/error.html#recoverable-errors",
    "title": "rust 错误",
    "section": "2 Recoverable Errors",
    "text": "2 Recoverable Errors\nenum Result&lt;T, E&gt; {\n    Ok(T),\n    Err(E),\n}\n\n2.1 match\nuse std::fs::File;\n\nfn main() {\n    let greeting_file_result = File::open(\"hello.txt\");\n\n    let greeting_file = match greeting_file_result {\n        Ok(file) =&gt; file, // 返回给 greeting_file\n        Err(error) =&gt; {\n            // 直接panic\n            panic!(\"Problem opening the file: {:?}\", error);\n        }\n    };\n}\nuse std::fs::File;\nuse std::io::ErrorKind;\n\nfn main() {\n    let greeting_file_result = File::open(\"hello.txt\");\n\n    let greeting_file = match greeting_file_result {\n        Ok(file) =&gt; file,\n        Err(error) =&gt; match error.kind() {\n            // 匹配不同的错误\n            ErrorKind::NotFound =&gt; match File::create(\"hello.txt\") {\n                Ok(fc) =&gt; fc,\n                Err(e) =&gt; panic!(\"Problem creating the file: {:?}\", e),\n            },\n            other_error =&gt; {\n                panic!(\"Problem opening the file: {:?}\", other_error);\n            }\n        },\n    };\n}\n\n\n2.2 unwrap_or_else\n使用 Result&lt;T, E&gt; 的方法 unwrap_or_else\nuse std::fs::File;\nuse std::io::ErrorKind;\n\nfn main() {\n    let greeting_file = File::open(\"hello.txt\").unwrap_or_else(|error| {\n        if error.kind() == ErrorKind::NotFound {\n            File::create(\"hello.txt\").unwrap_or_else(|error| {\n                panic!(\"Problem creating the file: {:?}\", error);\n            })\n        } else {\n            panic!(\"Problem opening the file: {:?}\", error);\n        }\n    });\n}\n\n\n2.3 unwrap\nuse std::fs::File;\n\nfn main() {\n    // unwrap 方法会返回一个 Result 枚举，\n    // 如果 Result 枚举是 Ok 类型，则 unwrap 会返回 Ok 中的值，\n    // 如果 Result 枚举是 Err 类型，则 unwrap 会panic Err 中的错误信息, 程序退出\n    let greeting_file = File::open(\"hello.txt\").unwrap();\n}\n\n\n2.4 expect\n相比unwrap 就是能定义输出的错误信息\nuse std::fs::File;\n\nfn main() {\n    let greeting_file = File::open(\"hello.txt\")\n        .expect(\"hello.txt 文件不存在 \");\n}\n\n\n2.5 ?\nuse std::fs::File;\nuse std::io::{self, Read};\nfn main() {\n    read_username_from_file().unwrap();\n}\nfn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {\n    let username_file_result = File::open(\"hello.txt\");\n    // 错误的情况, 返回 result&lt;String,Error&gt;\n    let mut username_file = match username_file_result {\n        Ok(file) =&gt; file,\n        // return 会退出函数, 返回Err(e) 给read_username_from_file\n        Err(e) =&gt; return Err(e),\n    };\n\n    let mut username = String::new();\n    // 不管结果如何, 都返回 ,让给调用者处理\n    match username_file.read_to_string(&mut username) {\n        Ok(_) =&gt; Ok(username),\n        Err(e) =&gt; Err(e),\n    }   // 注意这里是没有 ; 的, 因为要返回 result&lt;T,E&gt;\n}\n上面的写法, 你会发现, 有同样类似的逻辑, 就是将结果result 给调用者自己处理, 使用? 简化代码\nuse std::fs::File;\nuse std::io::{self, Read};\nfn main() {\n    read_username_from_file().unwrap();\n}\nfn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {\n    // \\? 放在 Result 类型的返回值上\n    // 如果返回值是 Ok,那么Ok包含的value 会被返回, 程序继续执行\n    // 如果返回值是 Err, 则 当前函数执行完毕, return Err ,Err作为函数的返回值\n    let mut username_file = File::open(\"hello.txt\")?;\n    let mut username = String::new();\n    let s = username_file.read_to_string(&mut username)?;\n    println!(\"s:=={}\", s); // 读取的字节书\n    Ok(username)\n}\n更简洁\nuse std::fs::File;\nuse std::io::{self, Read};\n\nfn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {\n    let mut username = String::new();\n\n    File::open(\"hello.txt\")?.read_to_string(&mut username)?;\n\n    Ok(username)\n}\n当然 标准库 提供了 上面的需求的更好的方法, 知道就行, 这不是我们讨论的点.\nuse std::fs;\nuse std::io;\n\nfn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {\n    fs::read_to_string(\"hello.txt\")\n}\n\n\n\n\n\n\nCaution\n\n\n\n\n? 只能被用在 函数里\n只能用在 Result, Option, 或者其他 实现了 FromResidual的 类型上\n\n\n\n下面代码报错了\nuse std::fs::File;\n\nfn main() {\n    let greeting_file = File::open(\"hello.txt\")?;\n}",
    "crumbs": [
      "核心基础",
      "基础篇",
      "错误处理"
    ]
  },
  {
    "objectID": "docs/basic/error.html#开源错误处理库",
    "href": "docs/basic/error.html#开源错误处理库",
    "title": "rust 错误",
    "section": "3 开源错误处理库",
    "text": "3 开源错误处理库\n\n3.1 anyhow1\n\n3.1.1 源码分析\n\n\n3.1.2 使用\nuse std::fs;\n\nuse anyhow::Result as anyRes;\nfn main() {\n}\n\n// 使用anyhow 我们可以不关心具体的错误\nfn get_file_info()(file_path: &str) -&gt; anyRes&lt;String&gt; {\n    // ? 表示 正确返回Ok() 里的值, 如有错误,则直接return Err(e),函数 退出\n    let info = fs::read_to_string(file_path)?;\n    // 正常的情况, 需要用Ok包起来 变成 Result 返回\n    Ok(info)\n}\n\n\n\n3.2 thiserror2",
    "crumbs": [
      "核心基础",
      "基础篇",
      "错误处理"
    ]
  },
  {
    "objectID": "docs/basic/error.html#footnotes",
    "href": "docs/basic/error.html#footnotes",
    "title": "rust 错误",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nanyhow, doc↩︎\nthiserror↩︎",
    "crumbs": [
      "核心基础",
      "基础篇",
      "错误处理"
    ]
  },
  {
    "objectID": "docs/basic/iterator.html",
    "href": "docs/basic/iterator.html",
    "title": "rust 迭代器iterator",
    "section": "",
    "text": "什么是迭代器?\n\n\n\n\n迭代器是一个可以帮助你逐个访问集合（比如数组、列表或者其他数据结构）中元素的“指针”或者“工具”.\n获取一个集合的迭代器后,你就拥有了可以逐个访问它的元素的能力\n\n\n\n\n\n\n\n\n\n怎么设计?\n\n\n\n\n只要给一个类型实现了能够逐个获取元素的能力, 它可以说就实现了迭代器\ntrait 作为有可以共享代码的机制非常合适\n设计这样一个trait\n\n里面有一个需要实现的方法next(),功能就是上面提到的逐个获取元素的能力\n再设置一些默认的方法, 他们调用了next方法,做对应的功能处理,功能就共享给了所有实现该trait的类型\n\n只要类型实现了该next方法就可以了\n\n\n\n所有迭代器都实现了 iterator trait\n\n\nIterator trait 在标准库中的定义\n\npub trait Iterator {\n    type Item;\n\n    fn next(&mut self) -&gt; Option&lt;Self::Item&gt;;\n\n    // 其他方法都有默认实现\n}",
    "crumbs": [
      "核心基础",
      "基础篇",
      "迭代器"
    ]
  },
  {
    "objectID": "docs/basic/iterator.html#原理",
    "href": "docs/basic/iterator.html#原理",
    "title": "rust 迭代器iterator",
    "section": "",
    "text": "什么是迭代器?\n\n\n\n\n迭代器是一个可以帮助你逐个访问集合（比如数组、列表或者其他数据结构）中元素的“指针”或者“工具”.\n获取一个集合的迭代器后,你就拥有了可以逐个访问它的元素的能力\n\n\n\n\n\n\n\n\n\n怎么设计?\n\n\n\n\n只要给一个类型实现了能够逐个获取元素的能力, 它可以说就实现了迭代器\ntrait 作为有可以共享代码的机制非常合适\n设计这样一个trait\n\n里面有一个需要实现的方法next(),功能就是上面提到的逐个获取元素的能力\n再设置一些默认的方法, 他们调用了next方法,做对应的功能处理,功能就共享给了所有实现该trait的类型\n\n只要类型实现了该next方法就可以了\n\n\n\n所有迭代器都实现了 iterator trait\n\n\nIterator trait 在标准库中的定义\n\npub trait Iterator {\n    type Item;\n\n    fn next(&mut self) -&gt; Option&lt;Self::Item&gt;;\n\n    // 其他方法都有默认实现\n}",
    "crumbs": [
      "核心基础",
      "基础篇",
      "迭代器"
    ]
  },
  {
    "objectID": "docs/basic/iterator.html#获取迭代器",
    "href": "docs/basic/iterator.html#获取迭代器",
    "title": "rust 迭代器iterator",
    "section": "2 获取迭代器",
    "text": "2 获取迭代器\nlet v1 = vec![1, 2, 3];\n// 仅仅定义而没有使用它, 这样不会有任何的消耗\n// 看ide的提示信息\nv1.iter();\nlet v1_iter = v1.iter();\n\n对原数据的不可变借用对原数据的可变借用对原数据获取了所有权\n\n\nfn main() {\n    let v1 = vec![1, 2, 3];\n\n    // v1_iter 本身取得的是 v1元素的不可变借用\n    let v1_iter = v1.iter();\n\n    // 这个mut 表示 该迭代器是可变的.\n    let mut v1_iter = v1.iter();\n    if let Some(b) = v1_iter.next() {\n        println!(\"{}\", b); // 1\n    }\n    // 结果是: Iter([2, 3]), 这下能理解为啥上面需要 mut v1_iter\n    // 因为 next 方法会消耗 迭代器, 迭代器改变了\n    println!(\"{:?}\", v1_iter);\n    // 继续调用next ,继续消耗迭代器\n    v1_iter.next();\n    v1_iter.next();\n    if let None = v1_iter.next() {\n        println!(\"没有元素后再调用next 返回None\");\n    }\n    //结果是 Iter([])\n    println!(\"{:?}\", v1_iter);\n    v1_iter.next(); // 不会报错\n    println!(\"{:?}\", v1_iter);\n\n    let v1 = vec![1, 2, 3];\n    let v1_iter = v1.iter();\n    // for循环 会取得v1_iter的所有权\n    // 底层是调用了 next() 方法\n    for val in v1_iter {\n        println!(\"{}\", val);\n        //  v1_iter 已经被move了, 报错\n        println!(\"{:?}\", v1_iter);\n    }\n}\n\n\nfn main() {\n    let mut v1 = vec![1, 2, 3];\n    // 取得v1的可变借用的迭代器\n    let v1_iter = v1.iter_mut();\n    println!(\"{:?}\", v1_iter);\n    let v11 = v1_iter.map(|x| {\n        *x = *x + 1; // 修改v1元素的值,每个元素+1\n        *x + 1\n    });\n    println!(\"{:?}\", v11.collect::&lt;Vec&lt;_&gt;&gt;()); //  [3, 4, 5]\n    println!(\"{:?}\", v1); //[2, 3, 4]\n\n}\n\n\nfn main() {\n    let v1 = vec![1, 2, 3];\n    // v1.into_iter 看into_iter源码 impl&lt;T, A: Allocator&gt; IntoIterator for Vec&lt;T, A&gt;\n    // 我们平常都写Vec&lt;i32&gt; 这种, 第二个参数一般省略,A表示使用默认的用于存储向量元素的分配器\n    // 所以实际是调用 Vec::&lt;i32&gt;::into_iter(v1)\n    // 而 v1 是 move 型的类型\n    let v1_iter = v1.into_iter();\n    // println!(\"{:?}\", v1);  // 报错了, 提示已经被move\n    println!(\"{:?}\", v1_iter2); // IntoIter([1, 2, 3])\n}",
    "crumbs": [
      "核心基础",
      "基础篇",
      "迭代器"
    ]
  },
  {
    "objectID": "docs/basic/iterator.html#使用适配器",
    "href": "docs/basic/iterator.html#使用适配器",
    "title": "rust 迭代器iterator",
    "section": "3 使用适配器",
    "text": "3 使用适配器\n\n\n\n\n\n\n什么是适配器?\n\n\n\n\n通过将原有数据进行转换调整以达到符合我们需求的一种”设备”\nrust上来讲就是迭代器iterator trait上定义的一些方法,用于对迭代器中可处理的数据进行操作\n\n\n\n\n3.1 适配器的类别\n\n\n\n\n\n\nTip\n\n\n\n\n消耗型适配器: 前面章节中我们使用的 next() 就是消耗型\n迭代器适配器: 它不会消耗迭代器,相反它是产生一个新的迭代器\n\n\n\n\n\n迭代器适配器\n\nfn main() {\n    let v1 = vec![1, 2, 3];\n    let v1_iter = v1.iter();\n    // Iterator::map(self, f), 源码第一个参数是Self\n    // 所以实际是 Iterator::map(v1_iter,|x|*x+1)\n    // 迭代器是结构体, 是move类型\n    let v1_new_iter = v1_iter.map(|x| *x + 1);\n    //报错了. v1_iter 已经被move了,被 获取了所有权\n    println!(\"{:?}\", v1_iter);\n}\n\n\n\n消耗型适配器collect\n\nfn main() {\n    let  v1 = vec![1, 2, 3];\n    let v1_iter = v1.iter();\n    let v1_new_iter = v1_iter.map(|x| *x + 1);\n    // let data = v1_new_iter.collect::&lt;Vec&lt;_&gt;&gt;();\n    let data: Vec&lt;_&gt; = v1_new_iter.collect();\n    // 报错, collect 会消耗迭代器然后创建一个 vector 来保存数据\n    // 提示被move了\n    println!(\"{:?}\", v1_new_iter);\n    println!(\"{:?}\", data);\n\n\n\n3.2 常用适配器\n\n3.2.1 sum\nfn main() {\n    let v1 = vec![1, 2, 3];\n\n    let v1_iter = v1.iter();\n    let total: i32 = v1_iter.sum();\n    println!(\"{total}\");\n    // 调用sum 会获取v1_iter的所有权,所以报错了,提示move掉了\n    // println!(\"{:?}\", v1_iter);\n}\n\n\n3.2.2 zip\nfn main() {\n    let a = [1, 2, 3];\n    let b = ['a', 'b', 'c'];\n    // [(1, 'a'), (2, 'b'), (3, 'c')]\n    let r=a.iter().zip(b.iter()).collect::&lt;Vec&lt;_&gt;&gt;();\n    println!(\"{:?}\", r);\n}\n\n\n3.2.3 map\n\n源码定义.iter()下map里使用的闭包参数类型.into_iter()下.iter_mut()下\n\n\nfn map&lt;B, F&gt;(self, f: F) -&gt; Map&lt;Self, F&gt;\n    where\n        Self: Sized,\n        F: FnMut(Self::Item) -&gt; B,\n    {\n        Map::new(self, f)\n    }\n\n\nuse std::any::type_name;\n\nfn print_type_of&lt;T&gt;(_: &T) {\n    println!(\"{}\", type_name::&lt;T&gt;());\n}\nfn main() {\n    let v1 = vec![1, 2, 3];\n    for i in &v1 {\n        print_type_of(&i); // i 的类型是 &i32\n        println!(\"{}\", *i);\n    }\n    let mut v1_iter = v1.iter();\n    if let Some(b) = v1_iter.next() {\n        print_type_of(&b); // &i32\n    }\n    println!(\"{:?}\", v1);\n    let v1_iter = v1.iter();\n    // map 里闭包捕获的 v1的元素 是 &i32 类型\n    // 然后我们再看map的源码\n    // Iterator::map(self, FnMut(Self::Item) -&gt; B),\n    // 所以首先 v1_iter被move 了,失效了\n    // v1_iter.next() 得到的每个 元素 是 &i32,\n    // FnMut(Self::Item) -&gt; B 闭包参数是 Self.Item 就是迭代器逐个解析出的每个元素 &i32\n    // 所以传递给闭包 |x| *x + 1 的参数x\n    // 知道了x 是&i32, 所以我们才写 *x+1\n    // Vec&lt;_&gt; _ 表示Vec 元素类型不清楚\n    let f: Vec&lt;_&gt; = v1_iter.map(|x| *x + 1).collect();\n    println!(\"{:?}\", f); // [2, 3, 4]\n\n    let a = vec![(1, 11), (2, 22), (3, 33)];\n    let b: Vec&lt;_&gt; = a.iter().map(|&(x, y)| x + 1).collect();\n    println!(\"{:?}\", b);\n}\n\n\nfn main() {\n    let v1 = vec![1, 2, 3];\n    for i in v1 {\n        print_type_of(&i); // i的类型是 i32\n    }\n    let v1 = vec![1, 2, 3];\n    let mut v1_iter = v1.into_iter();\n    if let Some(b) = v1_iter.next() {\n        print_type_of(&b); // i32\n    }\n    let v1 = vec![1, 2, 3];\n    let v1_iter = v1.into_iter();\n    let f: Vec&lt;_&gt; = v1_iter.map(|x| x + 1).collect();\n    println!(\"{:?}\", f);\n}\n\n\nuse std::any::type_name;\n\nfn print_type_of&lt;T&gt;(_: &T) {\n    println!(\"{}\", type_name::&lt;T&gt;());\n}\nfn main() {\n    let mut v1 = vec![1, 2, 3];\n    for i in &mut v1 {\n        print_type_of(&i); // i 的类型是 &mut i32\n        println!(\"{}\", *i);\n    }\n    let mut v1_iter = v1.iter_mut();\n    if let Some(b) = v1_iter.next() {\n        print_type_of(&b); // &mut i32\n    }\n    println!(\"{:?}\", v1);\n    let v1_iter = v1.iter_mut();\n    let f: Vec&lt;_&gt; = v1_iter\n        .map(|x| {\n            *x = *x + 1; // 可变借用 ,所以可以修改\n            *x + 1\n        })\n        .collect();\n    println!(\"{:?}\", f);\n    println!(\"{:?}\", v1);\n}\n\n\n\n\n\n3.2.4 filter\n\n源码定义.iter()下filter里使用的闭包参数类型.into_iter()下\n\n\n#[inline]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_do_not_const_check]\nfn filter&lt;P&gt;(self, predicate: P) -&gt; Filter&lt;Self, P&gt;\nwhere\n    Self: Sized,\n    P: FnMut(&Self::Item) -&gt; bool,\n{\n    Filter::new(self, predicate)\n}\n\n\nfn main() {\n    let v1: Vec&lt;i32&gt; = vec![1, 2, 3, 4, 5];\n    let v1_iter = v1.iter();\n    let two = 2;\n    // filter 将符合条件的返回 (true的情况)\n    // v1_iter 元素是 &i32,\n    // filter源码 定义的闭包类型是 FnMut(&Self::Item) -&gt; bool\n    // 取的 &Self::Item -&gt; & &i32, 所以 闭包里的x 的类型是 &&i32\n    let v_filtered: Vec&lt;_&gt; = v1_iter.filter(|x| **x &gt;= two).collect();\n    println!(\"{:?}\", v_filtered);\n}\n\n\nfn main() {\n    let v1: Vec&lt;i32&gt; = vec![1, 2, 3, 4, 5];\n    let v1_iter = v1.into_iter();\n    let two = 2;\n    let v_filtered: Vec&lt;_&gt; = v1_iter.filter(|x| *x &gt;= two).collect();\n    println!(\"{:?}\", v_filtered);\n}\n\n\n\n\n\n3.2.5 any\nfn main() {\n    let v1 = vec![1, 2, 3];\n    // any 如果有一个满足条件就返回true\n    println!(\"2 in v1: {}\", v1.iter().any(|x| *x == 2));\n}\n\n\n3.2.6 find\n\n源码定义使用\n\n\nfn find&lt;P&gt;(&mut self, mut predicate: P) -&gt; Option&lt;Self::Item&gt;\nwhere\n    Self: Sized,\n    P: FnMut(&Self::Item) -&gt; bool,\n{\n    while let Some(x) = self.next() {\n        if predicate(&x) {\n            return Some(x);\n        }\n    }\n    None\n}\n\n\nfn main() {\n    let v1 = vec![1, 2, 3];\n    let mut iter = v1.iter();\n    println!(\"Find 2 in v1: {:?}\", iter.find(|&&x| x == 2));\n}\nfn main() {\n    let v1 = vec![1, 2, 3];\n    let mut iter = v1.into_iter();\n    println!(\"Find 2 in v1: {:?}\", iter.find(|&x| x == 2));\n}\n\n\n\n\n\n3.2.7 position\nfn main() {\n    let v1 = vec![1, 2, 6];\n    // 符合条件的 索引 返回, 第一个元素 符合 *2=2\n    let index = v1.iter().position(|&x| x * 2 == 2);\n    println!(\"{:?}\", index)  // Some(0) 第一个元素\n}\n\n\n3.2.8 enumerate\nfn main(){\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    // 产生一个新的迭代器, 每个元素是一个元组 (元素索引,元素)\n    for (index, value) in vowels.iter().enumerate() {\n        println!(\"{}: {}\", index, value);\n    }\n}",
    "crumbs": [
      "核心基础",
      "基础篇",
      "迭代器"
    ]
  },
  {
    "objectID": "docs/basic/iterator.html#为自定义类型实现迭代器",
    "href": "docs/basic/iterator.html#为自定义类型实现迭代器",
    "title": "rust 迭代器iterator",
    "section": "4 为自定义类型实现迭代器",
    "text": "4 为自定义类型实现迭代器\n随便写一个非常简单的例子\nuse std::iter::Iterator;\nuse std::result;\n\n// 定义一个自定义类型 `Counter`\nstruct Counter {\n    start: u32,\n    end: u32,\n}\n\n// 不可变借用迭代器\nstruct CounterIter&lt;'a&gt; {\n    counter: &'a Counter,\n    curr: u32,\n}\n\n// 可变借用迭代器\nstruct CounterIterMut&lt;'a&gt; {\n    counter: &'a mut Counter,\n    curr: u32,\n}\n\n// 实现不可变借用迭代器\nimpl&lt;'a&gt; Iterator for CounterIter&lt;'a&gt; {\n    type Item = u32;\n\n    fn next(&mut self) -&gt; Option&lt;Self::Item&gt; {\n        self.curr += 1;\n\n        if self.curr - 1 + self.counter.start &lt;= self.counter.end {\n            Some(self.curr - 1 + self.counter.start)\n        } else {\n            None\n        }\n    }\n}\n\n// 实现可变借用迭代器\nimpl&lt;'a&gt; Iterator for CounterIterMut&lt;'a&gt; {\n    type Item = u32;\n\n    fn next(&mut self) -&gt; Option&lt;Self::Item&gt; {\n        self.curr += 1;\n        if self.curr - 1 + self.counter.start &lt;= self.counter.end {\n            Some(self.curr - 1 + self.counter.start)\n        } else {\n            None\n        }\n    }\n}\n\n// 为 `Counter` 类型增加方法以获取不同类型的迭代器\nimpl Counter {\n    // 获取不可变借用迭代器\n    fn iter(&self) -&gt; CounterIter {\n        CounterIter {\n            counter: self,\n            curr: 0,\n        }\n    }\n\n    // 获取可变借用迭代器\n    fn iter_mut(&mut self) -&gt; CounterIterMut {\n        CounterIterMut {\n            counter: self,\n            curr: 0,\n        }\n    }\n\n    // 获取所有权\n    fn into_iter(self) -&gt; Self {\n        self\n    }\n    fn new(start: u32, end: u32) -&gt; Self {\n        Counter { start, end }\n    }\n}\n// 为 `Counter` 实现 `Iterator` trait\nimpl Iterator for Counter {\n    // 定义迭代器返回的类型\n    type Item = u32;\n\n    // 实现 `next` 方法\n    fn next(&mut self) -&gt; Option&lt;Self::Item&gt; {\n        // 检查计数器是否超过某个阈值\n        if self.start &lt;= self.end {\n            self.start += 1;\n            Some(self.start - 1)\n        } else {\n            None\n        }\n    }\n}\nfn main() {\n    let counter = Counter::new(1, 4);\n\n    // 使用不可变借用迭代器\n    let mut iter = counter.iter();\n    println!(\"Immutable borrow iterator:\");\n    while let Some(number) = iter.next() {\n        println!(\"{}\", number);\n    }\n\n    let mut counter = Counter::new(2, 6);\n\n    // 使用可变借用迭代器\n    let mut iter_mut = counter.iter_mut();\n    println!(\"\\nMutable borrow iterator:\");\n    while let Some(number) = iter_mut.next() {\n        println!(\"{}\", number);\n    }\n\n    // 使用获取所有权的迭代器\n    println!(\"\\nOwned iterator:\");\n    for number in counter.into_iter() {\n        println!(\"{}\", number);\n    }\n}",
    "crumbs": [
      "核心基础",
      "基础篇",
      "迭代器"
    ]
  },
  {
    "objectID": "docs/basic/collection.html",
    "href": "docs/basic/collection.html",
    "title": "rust 集合",
    "section": "",
    "text": "Tip\n\n\n\n\n只能存储相同类型的数据\n在内存中连续存放\n容量可以在执行过程中动态扩大和缩放\n\n既然是动态的,那么它必定是要在堆上分配的.\n\n\n\n\n\n\nfn main() {\n    // 第一种方式,存放的类型是i32,\n    // 也可以不指定是什么类型的(去掉Vec&lt;i32&gt;),push 后 就推断出什么类型了\n    let mut v: Vec&lt;i32&gt; = Vec::new();\n    // 添加\n    v.push(5);\n    v.push(6);\n    // 第二种定义方式\n    // 宏等价于调用 Vec::new 创建一个新的空 vector，然后向其中添加元素\n    let mut y=vec![1,2,3,4,5];\n    // 第三种 通过迭代器创建\n    let v: Vec&lt;i32&gt; = (0..5).collect();\n    println!(\"{:?}\", v);\n    // 第四中 设置 capacity\n    let mut v = Vec::with_capacity(5);\n    v.push(1);\n    println!(\"{}-{}\", v.capacity(), v.len());\n\n    // 插入和删除\n    let mut v = vec![10, 20, 30, 40, 50];\n    // 在索引为 3的地方插入 35\n    v.insert(3, 35);\n    assert_eq!(v, [10, 20, 30, 35, 40, 50]);\n    // 移除索引为 1的元素\n    v.remove(1);\n    assert_eq!(v, [10, 30, 35, 40, 50])\n}\n\n\n\n#[test]\nfn test() {\n    let v = vec![1, 2, 3, 4, 5];\n\n    let third: &i32 = &v[2];\n    println!(\"The third element is {third}\");\n\n    // get的返回类型是  Option\n    let third: Option&lt;&i32&gt; = v.get(2);\n    match third {\n        Some(third) =&gt; println!(\"The third element is {third}\"),\n        None =&gt; println!(\"There is no third element.\"),\n    }\n}\n越界,报错\n#[test]\nfn test() {\n    let v = vec![1, 2, 3, 4, 5];\n    // 会直接panic: index out of bounds\n    let does_not_exist = &v[100];\n    // 这个不会报错\n    let does_not_exist = v.get(100);\n}\n\n\n\nenum SpreadsheetCell {\n    Int(i32),\n    Float(f64),\n    Text(String),\n}\nfn main() {\n    let row = vec![\n        SpreadsheetCell::Int(3),\n        SpreadsheetCell::Text(String::from(\"blue\")),\n        SpreadsheetCell::Float(10.12),\n    ];\n}\n\n\n\n#[test]\nfn test() {\n    let v = vec![100, 32, 57];\n    // 不可变借用 遍历\n    for i in &v {\n        println!(\"{i}\");\n    }\n\n    let mut v2 = vec![100, 32, 57];\n    // 可变借用,然后修改元素\n    for i in &mut v2 {\n        *i += 50;\n    }\n    println!(\"{:?}\", v2)\n}",
    "crumbs": [
      "核心基础",
      "基础篇",
      "集合"
    ]
  },
  {
    "objectID": "docs/basic/collection.html#vector",
    "href": "docs/basic/collection.html#vector",
    "title": "rust 集合",
    "section": "",
    "text": "Tip\n\n\n\n\n只能存储相同类型的数据\n在内存中连续存放\n容量可以在执行过程中动态扩大和缩放\n\n既然是动态的,那么它必定是要在堆上分配的.\n\n\n\n\n\n\nfn main() {\n    // 第一种方式,存放的类型是i32,\n    // 也可以不指定是什么类型的(去掉Vec&lt;i32&gt;),push 后 就推断出什么类型了\n    let mut v: Vec&lt;i32&gt; = Vec::new();\n    // 添加\n    v.push(5);\n    v.push(6);\n    // 第二种定义方式\n    // 宏等价于调用 Vec::new 创建一个新的空 vector，然后向其中添加元素\n    let mut y=vec![1,2,3,4,5];\n    // 第三种 通过迭代器创建\n    let v: Vec&lt;i32&gt; = (0..5).collect();\n    println!(\"{:?}\", v);\n    // 第四中 设置 capacity\n    let mut v = Vec::with_capacity(5);\n    v.push(1);\n    println!(\"{}-{}\", v.capacity(), v.len());\n\n    // 插入和删除\n    let mut v = vec![10, 20, 30, 40, 50];\n    // 在索引为 3的地方插入 35\n    v.insert(3, 35);\n    assert_eq!(v, [10, 20, 30, 35, 40, 50]);\n    // 移除索引为 1的元素\n    v.remove(1);\n    assert_eq!(v, [10, 30, 35, 40, 50])\n}\n\n\n\n#[test]\nfn test() {\n    let v = vec![1, 2, 3, 4, 5];\n\n    let third: &i32 = &v[2];\n    println!(\"The third element is {third}\");\n\n    // get的返回类型是  Option\n    let third: Option&lt;&i32&gt; = v.get(2);\n    match third {\n        Some(third) =&gt; println!(\"The third element is {third}\"),\n        None =&gt; println!(\"There is no third element.\"),\n    }\n}\n越界,报错\n#[test]\nfn test() {\n    let v = vec![1, 2, 3, 4, 5];\n    // 会直接panic: index out of bounds\n    let does_not_exist = &v[100];\n    // 这个不会报错\n    let does_not_exist = v.get(100);\n}\n\n\n\nenum SpreadsheetCell {\n    Int(i32),\n    Float(f64),\n    Text(String),\n}\nfn main() {\n    let row = vec![\n        SpreadsheetCell::Int(3),\n        SpreadsheetCell::Text(String::from(\"blue\")),\n        SpreadsheetCell::Float(10.12),\n    ];\n}\n\n\n\n#[test]\nfn test() {\n    let v = vec![100, 32, 57];\n    // 不可变借用 遍历\n    for i in &v {\n        println!(\"{i}\");\n    }\n\n    let mut v2 = vec![100, 32, 57];\n    // 可变借用,然后修改元素\n    for i in &mut v2 {\n        *i += 50;\n    }\n    println!(\"{:?}\", v2)\n}",
    "crumbs": [
      "核心基础",
      "基础篇",
      "集合"
    ]
  },
  {
    "objectID": "docs/basic/collection.html#hashmap",
    "href": "docs/basic/collection.html#hashmap",
    "title": "rust 集合",
    "section": "2 hashmap",
    "text": "2 hashmap\nuse std::collections::HashMap;\nfn main() {\n    // 如果仅仅只有这个语句, 则会报错,因为编译器无法知道数据类型,就无法分配内存了\n    // let mut s = HashMap::new();\n    // 这样就不会了\n    let mut scores: HashMap&lt;String, i32&gt; = HashMap::new();\n    // 插入元素\n    scores.insert(String::from(\"Blue\"), 10);\n    scores.insert(String::from(\"Yellow\"), 50);\n\n    // 读取\n    let team_name = String::from(\"Blue2\");\n    // get() 返回 类型是Option&lt;&V&gt;,没有的话就是 返回 None\n    // copied() 将 返回的Option&lt;&i32&gt; 变成 Option&lt;i32&gt;\n    // unwrap_or(0)  表示如果该key ,则返回一个 0\n    let score = scores.get(&team_name).copied().unwrap_or(2);\n    println!(\"{}\", score);\n\n    // 遍历\n    for (key, value) in &scores {\n        println!(\"{key}: {value}\");\n    }\n\n    // 更新元素, 还是用insert 会覆盖\n    scores.insert(String::from(\"Blue\"), 12);\n\n    // key Yellow 不存在,才添加\n    // 返回一个value的可变借用\n    scores.entry(String::from(\"Yellow\")).or_insert(50);\n\n    let text = \"hello world wonderful world\";\n    let mut map = HashMap::new();\n    for word in text.split_whitespace() {\n        // 第一次 word  key 不存在的时候, 插入 0, 返回value的可变借用\n        // 下面的操作才会是  *count +=1\n        // 第二次来, 存在, 返回旧 value 的可变借用 ,后面 还是 *count +=1\n        let count = map.entry(word).or_insert(0);\n        *count += 1;\n    }\n\n    println!(\"{:?}\", map);\n    println!(\"{:#?}\",map); // 格式化打印\n}\n所有权\nuse std::collections::HashMap;\nfn main() {\n    let field_name = String::from(\"Favorite color\");\n    let field_value = String::from(\"Blue\");\n\n    let mut map = HashMap::new();\n    map.insert(field_name, field_value);\n    //  field_name, field_value  已经被move 了. 报错了. 看值的类型\n    // println!(\"{}-{}\", field_name, field_value);\n}",
    "crumbs": [
      "核心基础",
      "基础篇",
      "集合"
    ]
  },
  {
    "objectID": "docs/basic/collection.html#字符串",
    "href": "docs/basic/collection.html#字符串",
    "title": "rust 集合",
    "section": "3 字符串",
    "text": "3 字符串\n\n\n\n\n\n\n\n\nImportant\n\n\n\nrust中字符串默认编码是utf-8,是变长的, 字母ab这些是一个字节, 中文3个字节\n\n\n字符串相关的几种定义\n\n\n3.1 str\nfn main(){\n    let a = \"abc\";\n    let b = \"hello\";\n}\n\n我们可以得到这个a和b的类型是 &str,在没有学习切片前,仅从这个类型名称看,我们可以推断 &str 是一个指向字符串字面量的指针.\n既然是 &这个操作, 那么*a 指向的类型似乎就是str了,a和b指向的str类型占用的空间不同,这样说来str类型的长度是可变的.\n所以我们无法在代码中直接使用str类型, 因为编译期间需要确定变量的大小.\n那么不难推断出&str这种引用可变长度类型的类型, 除了有指针指向str外, 还必须有一个信息来存储你引用的长度.\n\n\n\n3.2 &str\n字符串切片: 只是对一块内存空间的借用,无所有权\nuse std::mem;\nfn main() {\n    // 字符切片 &str , abc 这个是 字符串字面量\n    let x = \"abc\";\n    println!(\n        \"x指向的字符串实际地址:{:p}--长度:{}--占用字节数: {}\",\n        x.as_ptr(),\n        x.len(),\n        mem::size_of_val(&x)\n    );\n    let y: &'static str = \"abc\";\n    println!(\n        \"y指向的字符串实际地址:{:p}--长度:{}--占用字节数: {}\",\n        y.as_ptr(),\n        y.len(),\n        mem::size_of_val(&y)\n    );\n    // 字符串 String\n    let z = String::from(x);\n    println!(\"z指向的字符串的地址:{:p}\", z.as_ptr());\n    let s = String::from(\"hello world\");\n    // 字符串切片\n    let s2 = &s[0..4]; // s2 内容是 \"hell\"\n    println!(\"String s:{:p}\", s.as_ptr());\n    println!(\"&str s2:{:p}\", s2.as_ptr());\n    println!(\"{s}-{s2}\");\n}\n看看是否能修改\nfn main() {\n    // 会直接提示不需要mut\n    let mut a = \"abc\";\n    // let mut a = \"abc\".to_string();\n    let b = a.as_ptr() as *mut i8;\n    unsafe {\n        println!(\"11\");\n        *b = 98; // 修改字符串内容\n        println!(\"22\"); // 上一步无法成功执行,但是没报错, 这里不会执行打印\n    }\n    println!(\"x{}\", a);\n}\nfn main() {\n    // 不会转义, 原样输出\n    let a = r\"\\a\\b\";\n    println!(\"{}\", a);\n    println!(\n        r#\"hello\nworld \\n ('\"')\n\"#\n    )\n}\n\n\n3.3 String\n字符串:有这块内存空间的所有权\n是一种集合类型,所以前面集合类型的操作也适用\n\n\n\n\n\n\nImportant\n\n\n\n函数参数用 &str, 结构体成员图方便的话,可以直接用 String\n\n\n\n3.3.1 基础操作\nuse std::mem;\nfn main() {\n    let s1 = \"hello\".to_string();\n    // 空字符串\n    let s2 = String::new();\n    let s3 = \" world\".to_string();\n    // + 法 , 第二个变量 要是 字符串的借用\n    let c = s1 + &s3; //s1 被move 了\n    println!(\"{}\", c);\n\n    // format! 宏 来拼接字符串, 类似 println! ,只不过返回结果,不打印\n    let s1 = String::from(\"tic\");\n    let s2 = String::from(\"tac\");\n    let s3 = String::from(\"toe\");\n    // let s = s1 + \"-\" + &s2 + \"-\" + &s3;\n    let s = format!(\"{s1}-{s2}-{s3}\");\n    println!(\"{}-{}-{}\", s1, s2, s3); // 都可用\n\n    let mut x = String::from(\"abc\");\n    println!(\"{:p}\", &x);\n    println!(\"{}\", mem::size_of_val(&x));\n    x.push_str(\"我们\");\n    println!(\"{}\", x);\n    println!(\"{}\", mem::size_of_val(&x));\n    println!(\"{:?}-{}-{}\", x.as_ptr(), x.len(), x.capacity());\n    x.pop();\n    println!(\"{:?}-{}-{}\", x.as_ptr(), x.len(), x.capacity());\n    x.push('x');\n    println!(\"{:?}-{}-{}\", x.as_ptr(), x.len(), x.capacity());\n    // cap 这个显示的值和 内部实际预留空间,应该是不同, 参考go的设计\n    x.push_str(\"hello world python golang rust c++ c# java php\");\n    println!(\"{:?}-{}-{}\", x.as_ptr(), x.len(), x.capacity());\n}\n\n\n3.3.2 切片\nfn main() {\n    let s = String::from(\"hello\");\n    // [start_index..end_index]\n    let slice1 = &s[0..2];\n    let slice2 = &s[..2]; // 同上\n    println!(\"{}-{}\", slice1, slice2);\n\n    let len = s.len();\n\n    let slice3 = &s[3..len];\n    let slice4 = &s[3..]; //同上\n    println!(\"{}-{}\", slice3, slice4);\n\n    let slice5 = &s[0..len];\n    let slice6 = &s[..]; // 同上\n    println!(\"{}-{}\", slice5, slice6);\n}\n\n\n通过可变借用的切片,对原String进行修改\n\nfn main() {\n    let mut a = \"abc\".to_string();\n    let b = &mut a[..];\n    // 我们无法通过b对原a String进行添加字符的操作\n    // 因为我们只是可变借用了原String的一部分\n    b.make_ascii_uppercase(); // 将 a 的内容转换为大写\n    println!(\"{}\", a);\n}\n\n\n\n3.3.3 索引操作?\nString 类型无法进行 索引操作\nfn main() {\n    let s1 = String::from(\"hello\");\n    let h = s1[0]; // 报错\n}\n\n\n使用这种方式来\n\nfn main() {\n    let s1 = String::from(\"he我ll们o\");\n    // 这种查找 复杂度 O(n) , 每个\"字\" 占用空间不同, 需要先解析出一个个\"字\"\n    let h = s1.chars().nth(0);\n    let i = s1.chars().nth(2);\n    println!(\"{:?}\", h); // Some('h')\n    println!(\"{:?}\", i); // Some('我')\n}\n\n\n\n3.3.4 三种方式读取\nString 类型是对 Vec[u8]的一种包装\nfn main() {\n    let s1 = String::from(\"नमस्ते\");\n    println!(\"{}\", s1.len());\n    // 1. 以字节(byte) 的形式\n    for b in s1.bytes() {\n        println!(\"{b}\");\n    }\n    // 2. 以unicode 标量值(scalar values)的形式\n\n    // 打印了 每一个字(或字母)\n    for c in \"hello我们\".chars() {\n        println!(\"{}\", c);\n    }\n    // 但是 这个好像不对了,\n    // .chars()  用unicode 编码的方式来读取,按理说应该能读取到想要的字才对\n    // 毕竟 unicode 编码了全世界的字符(每个字符都有对应的unicode编码)\n    // 原因是 梵文中的某些字符可能由多个Unicode标量值组成，这些标量值在视觉上被视为一个整体\n    // 所以 这里只打印了 \"真正字符\"的一部分\n    for c in s1.chars() {\n        println!(\"{}\", c);\n    }\n    println!(\"=============\");\n    // 3. 获取真正更接近 字母的 字形簇 (grapheme clusters)\n    // 需要添加 第三方crate: cargo add unicode_segmentation\n    use unicode_segmentation::UnicodeSegmentation;\n    for grapheme in s1.graphemes(true) {\n        println!(\"{}\", grapheme);\n    }\n}\n\n\n\n3.4 单字节字符字面量\n\n\n\n\n\n\nTip\n\n\n\n\n这个实际是单字节数组\nchar 是 字符字面量, 一个字符是4个字节\n\n\n\nuse std::any::type_name;\n\nfn print_type_of&lt;T&gt;(_: &T) {\n    println!(\"{}\", type_name::&lt;T&gt;());\n}\nfn main() {\n    let a = b\"hello\";\n    // &[u8; 5]  结果发现是 [u8;5] 这种数组的引用\n    print_type_of(&a);\n    let b = a as &[u8]; // 转切片\n}\n\n\n3.5 通过切片计算实际指向的字符串占用的字节大小\nfn main() {\n    let s1 = String::from(\"hello我们\");\n    // 方法1：使用 std::mem::size_of_val()\n    println!(\n        \"s1 实际指向的字符串内容占用的内存大小: {} 字节\",\n        // s1.as_str()  &String 转为 &str 字符串切片\n        std::mem::size_of_val(s1.as_str()) //11  hello=5个字节, 我们=6个字节\n    );\n    // s1 字符串变量 占用空间大小 24\n    println!(\"字符串变量s1占用内存大小: {}\", std::mem::size_of_val(&s1));\n    let a = [1, 2, 3];\n    let b = &a; // b 数组 的指针, 就是 8个字节\n    println!(\"数组指针的大小(b的大小): {}\", std::mem::size_of_val(&b));\n    let c = b as &[i32]; // 数组指针转换为 切片\n    println!(\"数组切片占用空间(c的大小): {}\", std::mem::size_of_val(&c)); // 16 胖指针 ,没毛病\n    println!(\n        \"切片指向的内容(这里刚好是整个数组内容)实际占用的空间: {}\",\n        std::mem::size_of_val(c)\n    ); // 12 ,3个i32 =12\n    let d = &a[1..2];\n    // size_of_val(指针) =&gt; 计算指针指向的 内容占用内存大小\n    // &[T]或 &str 这种 切片, 指向的是 不定长的类型 [T] 或 str,所以是计算他们占用的空间\n    println!(\"切片指向的内容占用的空间: {}\", std::mem::size_of_val(d)); // 8 ,2个i32\n}",
    "crumbs": [
      "核心基础",
      "基础篇",
      "集合"
    ]
  },
  {
    "objectID": "docs/basic/struct.html",
    "href": "docs/basic/struct.html",
    "title": "rust 结构体",
    "section": "",
    "text": "C struct\n\n#[derive(Debug)]\nstruct User {\n    active: bool,\n    username: String,\n    email: String,\n    sign_in_count: u64,\n}\n\nfn main() {\n    let mut u = build_user(\"username123\".to_string(), \"someone@example.com\".to_string());\n\n    println!(\"{}\", u.email);\n    u.active = false;\n    println!(\"{}\", u);\n\n    let u1 = build_user(\"u1@hotmail\".to_string(), \"u1\".to_string());\n    let u2 = User {\n        email: String::from(\"u2@hotmail\"),\n        // 作为 base struct 必须放在最后, 否则是报错的\n        // base struct 会使用剩余没设置值的字段\n        // 所以注意这里u1 的 name被move 进来了.\n        ..u1\n    };\n    println!(\"{:?}\", u2);\n    println!(\"{:#?}\", u2); // 更加直观的打印\n\n    // 因为u1.name 被move 了,所以会报错\n    // println!(\"{:?}\", u1); \n    println!(\"{:?}\", u1.email); // email 还是可以打印的.\n\n}\nfn build_user(email: String, username: String) -&gt; User {\n    User { // 每个字段都必须设置值, 否则报错\n        active: true,\n        username, //  如果和结构体的字段同名, 可以直接这样简化写法\n        email,    //  \n        sign_in_count: 1,\n    }\n}\n\n\n\n\n\n\n\n\n\nTip\n\n\n\n\ntuple struct\n只有字段的类型,没有name\n\n\n\n// 虽然元素类型一样, 但是2个结构体是不同的类型\nstruct Color(i32, i32, i32);\nstruct Point(i32, i32, i32);\n\nfn main() {\n    let black = Color(0, 0, 0);\n    let origin = Point(0, 0, 0);\n    // 同元祖访问\n    println!(\"{}\", black.0);\n}\n\n\n\nunit struct, 没有字段的结构体\n\nstruct AlwaysEqual;\n\nfn main() {\n    // 实例化了\n    let subject = AlwaysEqual;\n}",
    "crumbs": [
      "核心基础",
      "基础篇",
      "结构体"
    ]
  },
  {
    "objectID": "docs/basic/struct.html#三种形式",
    "href": "docs/basic/struct.html#三种形式",
    "title": "rust 结构体",
    "section": "",
    "text": "C struct\n\n#[derive(Debug)]\nstruct User {\n    active: bool,\n    username: String,\n    email: String,\n    sign_in_count: u64,\n}\n\nfn main() {\n    let mut u = build_user(\"username123\".to_string(), \"someone@example.com\".to_string());\n\n    println!(\"{}\", u.email);\n    u.active = false;\n    println!(\"{}\", u);\n\n    let u1 = build_user(\"u1@hotmail\".to_string(), \"u1\".to_string());\n    let u2 = User {\n        email: String::from(\"u2@hotmail\"),\n        // 作为 base struct 必须放在最后, 否则是报错的\n        // base struct 会使用剩余没设置值的字段\n        // 所以注意这里u1 的 name被move 进来了.\n        ..u1\n    };\n    println!(\"{:?}\", u2);\n    println!(\"{:#?}\", u2); // 更加直观的打印\n\n    // 因为u1.name 被move 了,所以会报错\n    // println!(\"{:?}\", u1); \n    println!(\"{:?}\", u1.email); // email 还是可以打印的.\n\n}\nfn build_user(email: String, username: String) -&gt; User {\n    User { // 每个字段都必须设置值, 否则报错\n        active: true,\n        username, //  如果和结构体的字段同名, 可以直接这样简化写法\n        email,    //  \n        sign_in_count: 1,\n    }\n}\n\n\n\n\n\n\n\n\n\nTip\n\n\n\n\ntuple struct\n只有字段的类型,没有name\n\n\n\n// 虽然元素类型一样, 但是2个结构体是不同的类型\nstruct Color(i32, i32, i32);\nstruct Point(i32, i32, i32);\n\nfn main() {\n    let black = Color(0, 0, 0);\n    let origin = Point(0, 0, 0);\n    // 同元祖访问\n    println!(\"{}\", black.0);\n}\n\n\n\nunit struct, 没有字段的结构体\n\nstruct AlwaysEqual;\n\nfn main() {\n    // 实例化了\n    let subject = AlwaysEqual;\n}",
    "crumbs": [
      "核心基础",
      "基础篇",
      "结构体"
    ]
  },
  {
    "objectID": "docs/basic/struct.html#方法和关联函数",
    "href": "docs/basic/struct.html#方法和关联函数",
    "title": "rust 结构体",
    "section": "2 方法和关联函数",
    "text": "2 方法和关联函数\n#[derive(Debug)]\nstruct Rectangle {\n    width: u32,\n    height: u32,\n}\n// impl 块里的所有东西都和 Rectangle 类型产生关联\nimpl Rectangle {\n    // 第一个参数是 &self 是 self: &Self的简写, 是不可变借用\n    // 如果想用 所有权的, 就 用 self 是 self: Self的简写\n    // 如果想用可变借用 就用&mut self 是self: &mut Self 的简写\n    // 调用方法实际上是将调用者作为第一个参数传递给方法\n    fn area_borrows_immutably(&self) -&gt; u32 {\n        println!(\" width... {}\", (*self).width);\n        self.width * self.height\n    }\n\n    fn area_move(self) -&gt; u32 {\n        println!(\" width... {}\", self.width);\n        self.width * self.height\n    }\n    fn area_borrows_mutably(&mut self) -&gt; u32 {\n        println!(\" width... {}\", (*self).width);\n        self.width * self.height\n    }\n\n    fn change_width(&mut self, width: u32) {\n        self.width = width;\n    }\n\n    // 关联函数\n    // 例子: 正方形 ,这里没有用到 &self 作为第一个参数\n    fn square(size: u32) -&gt; Self {\n        Self {\n            width: size,\n            height: size,\n        }\n    }\n    // rust没有专门的构造函数,需要自己定义,我们一般用new 这个方法名,\n    pub fn new(width: u32, height: u32) -&gt; Self {\n        Rectangle {\n            width,\n            height,\n        }\n    }\n}\n\nfn main() {\n    let rect1 = Rectangle {\n        width: 30,\n        height: 50,\n    };\n    println!(\"{}\", rect1.area_borrows_immutably());  // &lt;1&gt;\n    println!(\"{:?}\", rect1);\n    println!(\"{}\", rect1.area_move());\n    // 报错, move掉了, 说明 我们的结构体是move 属性的,\n    // println!(\"{:?}\", rect1);\n    let mut rect1 = Rectangle {\n        width: 30,\n        height: 50,\n    };\n    println!(\"{}\", rect1.area_borrows_mutably());\n\n    let mut rect2 = Rectangle {\n        width: 30,\n        height: 50,\n    };\n    // 调用的时候根据方法的第一个参数类型,会自动转为 比如 可变借用\n    rect2.change_width(35);\n    println!(\"{}\", rect2.area_borrows_immutably());\n\n    // 这样的方式调用\n    let r = &mut rect2;\n    Rectangle::change_width(r, 40);\n    println!(\"{}\", r.height);\n    println!(\"{}\", rect2.area_borrows_immutably());\n\n    // 使用 :: 来调用\n    let sq = Rectangle::square(3);\n    println!(\"{}\", sq.area_borrows_immutably());\n}\n\nrect1.area_borrows_immutably()这个其实只是语法糖, 实际上是Rectangle::area_borrows_immutably(&rect1)",
    "crumbs": [
      "核心基础",
      "基础篇",
      "结构体"
    ]
  },
  {
    "objectID": "docs/basic/expression.html",
    "href": "docs/basic/expression.html",
    "title": "rust 语句和表达式",
    "section": "",
    "text": "知识点回顾\n\n\n\n() 既是一种类型:单元类型, 也是一个值",
    "crumbs": [
      "核心基础",
      "基础篇",
      "语句和表达式"
    ]
  },
  {
    "objectID": "docs/basic/expression.html#概念",
    "href": "docs/basic/expression.html#概念",
    "title": "rust 语句和表达式",
    "section": "",
    "text": "知识点回顾\n\n\n\n() 既是一种类型:单元类型, 也是一个值",
    "crumbs": [
      "核心基础",
      "基础篇",
      "语句和表达式"
    ]
  },
  {
    "objectID": "docs/basic/expression.html#代码块表达式",
    "href": "docs/basic/expression.html#代码块表达式",
    "title": "rust 语句和表达式",
    "section": "2 {} 代码块表达式",
    "text": "2 {} 代码块表达式\n\n\n{}代码块表达式的值\n\nfn main() {\n    // {} 代码块 是有值的, 如果最后一个表达式后面有分号，那么整个代码块的值是 ()\n    // 所以我们可以将它赋值给变量, 注意最后 }后的分号 是表明这一整个是一个语句\n    let a = {\n        let tmp = 2;\n    };\n    println!(\"a的值: {:?}\", a); // ()\n    let a = {\n        let tmp = 2;\n        5\n    };\n    println!(\"a的值: {:?}\", a); // 5\n}\n\nfn test() -&gt; i32 {\n    {\n        let a = 1;\n        // 如果写了什么作为返回值, 就只能写 ()\n        // 当然我们不可能写类似这样的代码\n        // 因为这个{} 没有接收者\n        ()\n    }  //注意这里没有 ; \n    let b = 2;\n    b\n}\nfn test() -&gt; i32 {\n    {\n        let a = 1;\n        \"aa\"  // 可以返回任何类型的值\n    };  // 当你加了 ; 后, 这{}; 是一个语句,\n        // 你可以理解为 将{} 表达式的值赋值给一个临时变量,\n        // 所以{} 里面可以返回任何值\n\n    let b = 2;\n    b\n}\nfn main(){}",
    "crumbs": [
      "核心基础",
      "基础篇",
      "语句和表达式"
    ]
  },
  {
    "objectID": "docs/basic/expression.html#赋值表达式",
    "href": "docs/basic/expression.html#赋值表达式",
    "title": "rust 语句和表达式",
    "section": "3 赋值表达式",
    "text": "3 赋值表达式\n\n\n赋值表达式的值\n\nfn main(){\n    let y;\n    // 赋值表达式 y=2, 我们知道表达式是有值的, 它的返回值是()\n    // let b = (y = 2); (y=2) 的括号可以省略,所以如下写法\n    let b = y = 2;\n    println!(\"y的值: {}\", y); // 2\n    println!(\"b的值: {:?}\", b); // ()\n    // 直接报错, 右边是个语句,没有返回值\n    // let a=(let z=2;);\n}\n\n\n\nif中使用赋值表达式\n\nfn main(){\n    let z;\n    // z=3 的返回值是() , 而 我们需要是的 bool类型\n    // 所以报错了.\n    if z = 3 {\n        println!(\"hello\");\n    }\n}",
    "crumbs": [
      "核心基础",
      "基础篇",
      "语句和表达式"
    ]
  },
  {
    "objectID": "docs/basic/expression.html#if-else-表达式",
    "href": "docs/basic/expression.html#if-else-表达式",
    "title": "rust 语句和表达式",
    "section": "4 if else 表达式",
    "text": "4 if else 表达式\n\n\n\n\n\n\nNote\n\n\n\n\n当成三元运算, 实际上这种方式更加的易于理解,可读性好\n三元运算,本身需要重新学习,时间一长,可能忘记了逻辑, 而if else天生就不会忘记\n\n\n\nfn main() {\n    let x = 1;\n    let is_one = if x == 1 { true } else { false };\n    println!(\"{}\", is_one);\n}",
    "crumbs": [
      "核心基础",
      "基础篇",
      "语句和表达式"
    ]
  },
  {
    "objectID": "docs/basic/ptr.html",
    "href": "docs/basic/ptr.html",
    "title": "rust 智能指针",
    "section": "",
    "text": "指针: 指向一块内存地址的变量,变量的值是内存地址\n智能指针\n\nRust 的智能指针是一类数据结构，它们对传统指针的功能进行了扩展\n它们通常包含元数据（例如，引用计数）以管理内存和对象的生命周期\nRust 标准库中定义了几种智能指针，如 Box&lt;T&gt;, Rc&lt;T&gt;, Arc&lt;T&gt;, Ref, RefMut, Cell, RefCell 等\n智能指针的主要目的是提供对内存安全、并发安全以及数据共享和所有权转移的更精细的控制\n\n\n\n智能指针通常使用struct来实现,实现了Deref和Drop trait\n\nDeref trait 允许智能指针像引用一样使用, 例如解引用\nDrop trait 智能指针在离开作用域时执行的代码",
    "crumbs": [
      "核心基础",
      "基础篇",
      "智能指针"
    ]
  },
  {
    "objectID": "docs/basic/ptr.html#相关概念",
    "href": "docs/basic/ptr.html#相关概念",
    "title": "rust 智能指针",
    "section": "",
    "text": "指针: 指向一块内存地址的变量,变量的值是内存地址\n智能指针\n\nRust 的智能指针是一类数据结构，它们对传统指针的功能进行了扩展\n它们通常包含元数据（例如，引用计数）以管理内存和对象的生命周期\nRust 标准库中定义了几种智能指针，如 Box&lt;T&gt;, Rc&lt;T&gt;, Arc&lt;T&gt;, Ref, RefMut, Cell, RefCell 等\n智能指针的主要目的是提供对内存安全、并发安全以及数据共享和所有权转移的更精细的控制\n\n\n\n智能指针通常使用struct来实现,实现了Deref和Drop trait\n\nDeref trait 允许智能指针像引用一样使用, 例如解引用\nDrop trait 智能指针在离开作用域时执行的代码",
    "crumbs": [
      "核心基础",
      "基础篇",
      "智能指针"
    ]
  },
  {
    "objectID": "docs/basic/ptr.html#box",
    "href": "docs/basic/ptr.html#box",
    "title": "rust 智能指针",
    "section": "2 Box",
    "text": "2 Box\nBox&lt;T&gt; 是一个智能指针,它允许在堆上存储数据,在栈上存放指向它的指针,并确保在离开作用域时正确清理堆上的数据\n\n2.1 基本使用\nfn main() {\n    // 5 是在 堆上分配的, 栈上的变量b 指向了 它\n    let b = Box::new(5);\n    println!(\"b = {}\", b);\n}\n我们运行一下这个,看看报错的信息\n// 这里的定义本身就报错了, 因为这个 枚举类型的大小无法确定\nenum List {\n    Cons(i32, List),\n    Nil,\n}\n\nuse crate::List::{Cons, Nil};\n\nfn main() {\n    let list = Cons(1, Cons(2, Cons(3, Nil)));\n}\n提示使用Box ,这样 cons(i32, Box&lt;List&gt;) 大小就确定了.\nhelp: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to break the cycle\n  |\n2 |     Cons(i32, Box&lt;List&gt;),\n修改后\nenum List {\n    Cons(i32, Box&lt;List&gt;),\n    Nil,\n}\n\nuse crate::List::{Cons, Nil};\n\nfn main() {\n    let list = Cons(1, Box::new(Cons(2, Box::new(Cons(3, Box::new(Nil))))));\n}\n\n\n\n\n\n\nCaution\n\n\n\n\n执行下面代码我们可以推测出, Box::new([1i32; 16])会先在栈上创建数组[1i32; 16],然后再将它复制到堆上.\n原因是数组 [1;16] 是个表达式,是需要先计算它的大小的,需要在栈上计算和存储\n\n\n\nfn main() {\n    let a = 11;\n    let b = Box::new([1i32; 16]);\n    let c = 5;\n    println!(\"{:p}\", &a);\n    println!(\"{:p}\", &b);\n    println!(\"{:p}\", &c);\n}\n\n\n2.2 获取裸指针\n\n\n获取Box的裸指针\n\nfn main() {\n    let f;\n    {\n        let b = Box::new(5);\n        println!(\"{:p}\", b); // 堆上的5的地址\n        println!(\"{:p}\", &b); // 栈上b变量的地址\n        // 将 b 转换为 *mut T 可变裸指针\n        // c 的类型是 这里是 *mut i32\n        // b 被move 掉了,但是这个c指向了 b指向的内存,且c没有这块内存的所有权\n        let c = Box::into_raw(b);\n        println!(\"{:p}\", c); // 堆上5的地址\n        unsafe {\n            println!(\"{}\", *c);\n            *c = 23;\n            f = &*c;\n            // Box::from_raw 重新获取所有权,这样离开作用域后, 堆上的数据5被回收了\n            let s = Box::from_raw(c);\n        }\n    }\n    println!(\"f=={}\", *f);  // 指向的数据已经不确定了,是不对的\n}\n\nfn main() {\n    let d;\n    {\n        let mut b = Box::new(5);\n        println!(\"{:p}\", b); // 堆上的5的地址\n        // 第二种方式来获取 裸指针\n        // unsafe 那里对 *d 做修改, 就是需要对d 所指向的数据修改\n        // 那么就是 对 *b 做修改, 则需要 对 *b 做 &mut 处理\n        d = &mut *b as *const i32 as *mut i32;\n        unsafe {\n            println!(\"{}\", *d);\n        }\n    } // b drop 了, 指向的堆内存 释放了\n\n    println!(\"{:p}\", d);\n    // println!(\"{}\", b);\n    unsafe {\n        // 数据不对了\n        println!(\"{}\", *d);\n    }\n}",
    "crumbs": [
      "核心基础",
      "基础篇",
      "智能指针"
    ]
  },
  {
    "objectID": "docs/basic/ptr.html#deref-trait",
    "href": "docs/basic/ptr.html#deref-trait",
    "title": "rust 智能指针",
    "section": "3 deref trait",
    "text": "3 deref trait\n\n3.1 Box\nfn main() {\n    let x = 5;\n    let y = &x;\n\n    assert_eq!(5, x);\n    assert_eq!(5, *y);// *y 解引用 得到 x\n}\n因为Box 实现了Deref trait,所以可以对Box&lt;T&gt;进行解引用操作是可以的\nfn main() {\n    let x = 5;  // 栈上的5\n    let y = Box::new(x); // 将5复制到堆上\n\n    assert_eq!(5, x);\n    assert_eq!(5, *y);\n}\n\n\n3.2 隐式解引用转化(Deref coercion)\n\n\n\n\n\n\nTip\n\n\n\n当把某个类型T(实现了Deref trait)的引用传递给一个函数或方法时,与函数或方法定义的参数类型不一样时,会自动进行式解引用转化,转化为经过 deref 操作后返回的那个引用\n可变引用的情况需要实现 DerefMut trait\n\n下面三种情况会发生自动转化\n\nFrom &T to &U when T: Deref&lt;Target=U&gt;\nFrom &mut T to &mut U when T: DerefMut&lt;Target=U&gt;\nFrom &mut T to &U when T: Deref&lt;Target=U&gt;\n\n\n\n\nstruct MyBox&lt;T&gt;(T);\n\nimpl&lt;T&gt; MyBox&lt;T&gt; {\n    fn new(x: T) -&gt; MyBox&lt;T&gt; {\n        MyBox(x)\n    }\n}\nuse std::ops::Deref;\n\nimpl&lt;T&gt; Deref for MyBox&lt;T&gt; {\n    type Target = T;\n    // 实现 Deref trait 的这个deref 方法的返回值,就是我们 * 操作的真正目标\n    // 因为返回的是引用, 所以 * 操作 ok的\n    fn deref(&self) -&gt; &Self::Target {\n        &self.0\n    }\n}\nfn hello(name: &str) {\n    println!(\"Hello, {name}!\");\n}\n\nfn main() {\n    let m = MyBox::new(String::from(\"Rust\"));\n    // &m: MyBox&lt;String&gt; deref 转化为 &String\n    // String 也实现了 Deref trait ,&String deref返回的是 &str\n    // 这些过程在编译时就完成了, 所以不会有额外的开销\n    hello(&m);\n    // 等价于\n    hello(&(*m)[..])\n}\n\n\n3.3 自定义智能指针\nstruct MyBox&lt;T&gt;(T, T);\n\nimpl&lt;T&gt; MyBox&lt;T&gt; {\n    fn new(x: T, y: T) -&gt; MyBox&lt;T&gt; {\n        MyBox(x, y)\n    }\n}\nuse std::ops::Deref;\n\nimpl&lt;T&gt; Deref for MyBox&lt;T&gt; {\n    type Target = T;\n    // 实现 Deref trait 的这个deref 方法的返回值,就是我们 * 操作的真正目标\n    // 因为返回的是引用, 所以 * 操作 ok的\n    fn deref(&self) -&gt; &Self::Target {\n        &self.1\n    }\n}\n\nfn main() {\n    let x = 5;\n    let y = MyBox::new(x, 12);\n    // 如果没有实现 Deref trait, 那么 * 操作就会报错\n    println!(\"{}\", *y); // 12\n    // 显然 上面实现的 deref(&self)方法是 类型MyBox的方法,\n    // 所以可以 y.deref() 获取\n    println!(\"{}\", *(y.deref())); // 12\n}",
    "crumbs": [
      "核心基础",
      "基础篇",
      "智能指针"
    ]
  },
  {
    "objectID": "docs/basic/ptr.html#drop-trait",
    "href": "docs/basic/ptr.html#drop-trait",
    "title": "rust 智能指针",
    "section": "4 drop trait",
    "text": "4 drop trait\n\n相当于析构函数\n通过实现 Drop trait, 可以自定义值离开作用域时发生的事情(比如文件资源的释放).\n任何类型都可以实现这个 Drop trait\n\ndrop 一个 实现了copy的类型, 不会执行任何操作\n\n\nstruct CustomSmartPointer {\n    data: String,\n}\n// Drop 在预导入模块里, 所以不需要use\nimpl Drop for CustomSmartPointer {\n    // 参数是可变借用 &mut self\n    fn drop(&mut self) {\n        println!(\"Dropping CustomSmartPointer with data `{}`!\", self.data);\n    }\n}\n\nfn main() {\n    let a = CustomSmartPointer {\n        data: String::from(\"hello stuff\"),\n    };\n    // 无法显示的调用 drop 方法\n    // a.drop()\n    // 可以使用  std::mem::drop(a); 来提前调用\n    // drop(a);  这样就行了, 因为drop 是预导入模块里的\n    {\n        let c = CustomSmartPointer {\n            data: String::from(\"my stuff\"),\n        };\n    }// c 最先执行drop, 所以先打印 my stuff\n    let d = CustomSmartPointer {\n        data: String::from(\"other stuff\"),\n    };\n    println!(\"CustomSmartPointers created.\");\n}",
    "crumbs": [
      "核心基础",
      "基础篇",
      "智能指针"
    ]
  },
  {
    "objectID": "docs/basic/ptr.html#rct-引用计数智能指针",
    "href": "docs/basic/ptr.html#rct-引用计数智能指针",
    "title": "rust 智能指针",
    "section": "5 Rc<T> 引用计数智能指针",
    "text": "5 Rc&lt;T&gt; 引用计数智能指针\n\nRc = reference counting\nRc&lt;T&gt; 允许同一个数据有多个所有者\n当最后是0个引用,那么该值就会被清理\n员工下班了,谁离开了是不能随便就熄灯关门,是等只有最后一个人走了,才能熄灯关门,这种需求的时候我们就可以用这个 Rc&lt;T&gt; 类型\n通过不可变引用来共享数据,只读\n\nenum List {\n    Cons(i32, Box&lt;List&gt;),\n    Nil,\n}\n\nuse crate::List::{Cons, Nil};\n\nfn main() {\n    let a = Cons(5, Box::new(Cons(10, Box::new(Nil))));\n    let b = Cons(3, Box::new(a));\n    let c = Cons(4, Box::new(a)); // 报错了, a 被move了\n}\n使用 Rc&lt;T&gt; 就可以解决这个问题\nenum List {\n    Cons(i32, Rc&lt;List&gt;),\n    Nil,\n}\n\nuse crate::List::{Cons, Nil};\nuse std::rc::Rc;\n\nfn main() {\n    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));\n    println!(\"count after creating a = {}\", Rc::strong_count(&a)); //1\n    // Rc::clone() 只会使 引用计数+1, 不会进行深度 copy\n    // a.clone()  会进行深度copy\n    let b = Cons(3, Rc::clone(&a)); // a 的引用计数+1\n    println!(\"count after creating b = {}\", Rc::strong_count(&a)); //2\n     {\n        let d = Cons(4, Rc::clone(&a));\n        println!(\"count after creating d = {}\", Rc::strong_count(&a)); // 3\n    } // 这里d离开作用域,drop操作, 所以a的引用计数-1, 变为2\n    let c = Cons(4, Rc::clone(&a)); // a 的引用计数+1\n    println!(\"count after creating c = {}\", Rc::strong_count(&a)); // 3\n}",
    "crumbs": [
      "核心基础",
      "基础篇",
      "智能指针"
    ]
  },
  {
    "objectID": "docs/basic/ptr.html#refcellt",
    "href": "docs/basic/ptr.html#refcellt",
    "title": "rust 智能指针",
    "section": "6 RefCell<T>",
    "text": "6 RefCell&lt;T&gt;\n\n单线程内部使用\n数据所有者只有一个\n运行时检查\n\n报错了,因为你不能可变借用一个不可变的值\nfn main() {\n    let x = 5;\n    let y = &mut x;\n}\n有这样的需求, 我们希望该值对外部是不可变的, 对于它内部可以有方法来修改它的值.\nRefCell 就是能够可变借用一个原本不可变的值\nuse std::cell::RefCell;\n\nfn main() {\n    let shared_map = RefCell::new(vec![1, 2, 3]);\n    // 创建1个可变引用\n    let mut first_ref = shared_map.borrow_mut();\n    // 不允许多个可变借用同时存在\n    // let mut second_ref = shared_map.borrow_mut();\n\n    // 修改通过不可变引用获取的数据\n    first_ref.push(4);\n    println!(\"{:?}\", shared_map);\n}\nuse std::cell::RefCell;\n\nfn main() {\n    let c = RefCell::new(5);\n    // 多个不可变借用\n    let borrowed_five = c.borrow();\n    let borrowed_five2 = c.borrow();\n}\n\n每次 调用 .borrow() 方法, 不可变借用计数+1, 其返回值离开作用域,不可变计数-1\n每次调用 .borrow_mut() 方法, 可变借用计数+1,其返回值离开作用域,可变计数-1\n根据上面2点来检查借用规则, 只允许一个可变借用,或多个不可变借用",
    "crumbs": [
      "核心基础",
      "基础篇",
      "智能指针"
    ]
  },
  {
    "objectID": "docs/basic/ptr.html#rc-refcell-结合使用",
    "href": "docs/basic/ptr.html#rc-refcell-结合使用",
    "title": "rust 智能指针",
    "section": "7 Rc RefCell 结合使用",
    "text": "7 Rc RefCell 结合使用\n#[derive(Debug)]\nenum List {\n    Cons(Rc&lt;RefCell&lt;i32&gt;&gt;, Rc&lt;List&gt;),\n    Nil,\n}\n\nuse crate::List::{Cons, Nil};\nuse std::cell::RefCell;\nuse std::rc::Rc;\n\nfn main() {\n    let value = Rc::new(RefCell::new(5));\n\n    let a = Rc::new(Cons(Rc::clone(&value), Rc::new(Nil)));\n\n    let b = Cons(Rc::new(RefCell::new(3)), Rc::clone(&a));\n    let c = Cons(Rc::new(RefCell::new(4)), Rc::clone(&a));\n\n    *value.borrow_mut() += 10;\n\n    println!(\"a after = {:?}\", a);\n    println!(\"b after = {:?}\", b);\n    println!(\"c after = {:?}\", c);\n}",
    "crumbs": [
      "核心基础",
      "基础篇",
      "智能指针"
    ]
  },
  {
    "objectID": "docs/basic/ptr.html#引用循环",
    "href": "docs/basic/ptr.html#引用循环",
    "title": "rust 智能指针",
    "section": "8 引用循环",
    "text": "8 引用循环\n\n8.1 Rc\nuse crate::List::{Cons, Nil};\nuse std::cell::RefCell;\nuse std::rc::Rc;\n\n#[derive(Debug)]\nenum List {\n    Cons(i32, RefCell&lt;Rc&lt;List&gt;&gt;),\n    Nil,\n}\n\nimpl List {\n    fn tail(&self) -&gt; Option&lt;&RefCell&lt;Rc&lt;List&gt;&gt;&gt; {\n        // self: &Self\n        match self {\n            Cons(_, item) =&gt; Some(item),\n            Nil =&gt; None,\n        }\n    }\n}\n\nfn main() {\n    let a = Rc::new(Cons(5, RefCell::new(Rc::new(Nil))));\n\n    println!(\"a initial rc count = {}\", Rc::strong_count(&a)); // 1\n    println!(\"a next item = {:?}\", a.tail());\n    // b的下一个元素是a\n    let b = Rc::new(Cons(10, RefCell::new(Rc::clone(&a))));\n\n    println!(\"a rc count after b creation = {}\", Rc::strong_count(&a)); //2\n    println!(\"b initial rc count = {}\", Rc::strong_count(&b)); //1\n    println!(\"b next item = {:?}\", b.tail());\n\n    if let Some(link) = a.tail() {\n        // a的下一个元素是b, a和b 之间循环引用了.\n        *link.borrow_mut() = Rc::clone(&b); // b +1\n    }\n\n    println!(\"b rc count after changing a = {}\", Rc::strong_count(&b)); //2\n    println!(\"a rc count after changing a = {}\", Rc::strong_count(&a)); //2\n\n    // 栈溢出了, 因为打印 a.tail() ,就是要打印b, 而要完全打印b,就需要打印a的值,因为b的\"下一个元素\"是a\n    // println!(\"a next item = {:?}\", a.tail());\n} // 离开作用域, b 做引用计数-1操作,那么还有1个, 接着a离开作用域 引用计数-1,也是还剩1个. 这样2个都没被释放\n\n\n8.2 Weak\n\n强引用\n\nRc.clone 后rc的引用计数(strong_count)会+1, 实例只有在 strong_count=0,才会被释放\n\n弱引用\n\nRc::downgrade 会创建值的弱引用(weak_count+1),返回类型是 Weak\nweak_count不为0,不会影响值的释放\nstrong_ount为0, 弱引用会自动断开\n使用Weak前,需要确保它指向的值依然存在\n\n\nuse std::cell::RefCell;\nuse std::rc::{Rc, Weak};\n\n#[derive(Debug)]\nstruct Node {\n    value: i32,\n    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,\n    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,\n}\nfn main() {\n    let leaf = Rc::new(Node {\n        value: 3,\n        parent: RefCell::new(Weak::new()),\n        children: RefCell::new(vec![]),\n    });\n    println!(\n        \"leaf strong = {}, weak = {}\",\n        Rc::strong_count(&leaf),\n        Rc::weak_count(&leaf),\n    );\n    // upgrade: 从 Weak&lt;T&gt; 获取一个 Rc&lt;T&gt;\n    println!(\"leaf parent = {:?}\", leaf.parent.borrow().upgrade());\n\n    let branch = Rc::new(Node {\n        value: 5,\n        parent: RefCell::new(Weak::new()),\n        children: RefCell::new(vec![Rc::clone(&leaf)]),\n    });\n    *leaf.parent.borrow_mut() = Rc::downgrade(&branch);\n    println!(\n        \"branch strong = {}, weak = {}\",\n        Rc::strong_count(&branch),\n        Rc::weak_count(&branch),\n    );\n\n    println!(\n        \"leaf strong = {}, weak = {}\",\n        Rc::strong_count(&leaf), //2\n        Rc::weak_count(&leaf),\n    );\n\n    println!(\"leaf parent = {:?}\", leaf.parent.borrow().upgrade());\n    println!(\n        \"leaf strong = {}, weak = {}\",\n        Rc::strong_count(&leaf),\n        Rc::weak_count(&leaf),\n    );\n}",
    "crumbs": [
      "核心基础",
      "基础篇",
      "智能指针"
    ]
  },
  {
    "objectID": "docs/basic/enum.html",
    "href": "docs/basic/enum.html",
    "title": "rust 枚举 enum",
    "section": "",
    "text": "Important\n\n\n\n\n看枚举之前,先看看union\nunion是一种允许在相同的内存位置存储多种类型的数据结构\n因此该类型大小等于内存占用最大的那个成员的内存大小\nunion类型的主要功能是和c语言进行交互\n\n\n\nunion MyUnion {\n    j: i32,\n    i: i8,\n}\n\nfn main() {\n    // 00000001 00000100  &lt;== 整个union 是这样的数据 4个字节\n    let mut my_union = MyUnion { j: 260 };\n    // 把它当作i32整型来使用, 需要 unsafe 块，因为这可能涉及内存重新解释\n    println!(\"j value: {}\", unsafe { my_union.j });\n    // 我们直接打印 i 看看,发现 是260 低位的一个字节的值\n    println!(\"i value: {}\", unsafe { my_union.i });\n    // 注意：在访问了union的一个字段后，访问其他字段之前,最好先进行“重置”或明确知道内存布局\n    // 否则可能会读取到无效的、未初始化的或者非预期的数据\n    my_union.i = 3;\n    println!(\"j value: {}\", unsafe { my_union.j }); // 259\n}",
    "crumbs": [
      "核心基础",
      "基础篇",
      "枚举"
    ]
  },
  {
    "objectID": "docs/basic/enum.html#union",
    "href": "docs/basic/enum.html#union",
    "title": "rust 枚举 enum",
    "section": "",
    "text": "Important\n\n\n\n\n看枚举之前,先看看union\nunion是一种允许在相同的内存位置存储多种类型的数据结构\n因此该类型大小等于内存占用最大的那个成员的内存大小\nunion类型的主要功能是和c语言进行交互\n\n\n\nunion MyUnion {\n    j: i32,\n    i: i8,\n}\n\nfn main() {\n    // 00000001 00000100  &lt;== 整个union 是这样的数据 4个字节\n    let mut my_union = MyUnion { j: 260 };\n    // 把它当作i32整型来使用, 需要 unsafe 块，因为这可能涉及内存重新解释\n    println!(\"j value: {}\", unsafe { my_union.j });\n    // 我们直接打印 i 看看,发现 是260 低位的一个字节的值\n    println!(\"i value: {}\", unsafe { my_union.i });\n    // 注意：在访问了union的一个字段后，访问其他字段之前,最好先进行“重置”或明确知道内存布局\n    // 否则可能会读取到无效的、未初始化的或者非预期的数据\n    my_union.i = 3;\n    println!(\"j value: {}\", unsafe { my_union.j }); // 259\n}",
    "crumbs": [
      "核心基础",
      "基础篇",
      "枚举"
    ]
  },
  {
    "objectID": "docs/basic/enum.html#enum",
    "href": "docs/basic/enum.html#enum",
    "title": "rust 枚举 enum",
    "section": "2 enum",
    "text": "2 enum\n枚举是这样一种类型,允许你通过列举可能的成员(variants:变体)来定义一个类型\n\n2.1 内存布局\n\n\n\n\n\n\n\n例子1,运行看看, 然后取消注释b257再运行\n\n\n\n\n\nenum Cat {\n    b1,\n    b2,\n    b3,\n    b4,\n    b5,\n    b6,\n    b7,\n    b8,\n    b9,\n    b10,\n    b11,\n    b12,\n    b13,\n    b14,\n    b15,\n    b16,\n    b17,\n    b18,\n    b19,\n    b20,\n    b21,\n    b22,\n    b23,\n    b24,\n    b25,\n    b26,\n    b27,\n    b28,\n    b29,\n    b30,\n    b31,\n    b32,\n    b33,\n    b34,\n    b35,\n    b36,\n    b37,\n    b38,\n    b39,\n    b40,\n    b41,\n    b42,\n    b43,\n    b44,\n    b45,\n    b46,\n    b47,\n    b48,\n    b49,\n    b50,\n    b51,\n    b52,\n    b53,\n    b54,\n    b55,\n    b56,\n    b57,\n    b58,\n    b59,\n    b60,\n    b61,\n    b62,\n    b63,\n    b64,\n    b65,\n    b66,\n    b67,\n    b68,\n    b69,\n    b70,\n    b71,\n    b72,\n    b73,\n    b74,\n    b75,\n    b76,\n    b77,\n    b78,\n    b79,\n    b80,\n    b81,\n    b82,\n    b83,\n    b84,\n    b85,\n    b86,\n    b87,\n    b88,\n    b89,\n    b90,\n    b91,\n    b92,\n    b93,\n    b94,\n    b95,\n    b96,\n    b97,\n    b98,\n    b99,\n    b100,\n    b101,\n    b102,\n    b103,\n    b104,\n    b105,\n    b106,\n    b107,\n    b108,\n    b109,\n    b110,\n    b111,\n    b112,\n    b113,\n    b114,\n    b115,\n    b116,\n    b117,\n    b118,\n    b119,\n    b120,\n    b121,\n    b122,\n    b123,\n    b124,\n    b125,\n    b126,\n    b127,\n    b128,\n    b129,\n    b130,\n    b131,\n    b132,\n    b133,\n    b134,\n    b135,\n    b136,\n    b137,\n    b138,\n    b139,\n    b140,\n    b141,\n    b142,\n    b143,\n    b144,\n    b145,\n    b146,\n    b147,\n    b148,\n    b149,\n    b150,\n    b151,\n    b152,\n    b153,\n    b154,\n    b155,\n    b156,\n    b157,\n    b158,\n    b159,\n    b160,\n    b161,\n    b162,\n    b163,\n    b164,\n    b165,\n    b166,\n    b167,\n    b168,\n    b169,\n    b170,\n    b171,\n    b172,\n    b173,\n    b174,\n    b175,\n    b176,\n    b177,\n    b178,\n    b179,\n    b180,\n    b181,\n    b182,\n    b183,\n    b184,\n    b185,\n    b186,\n    b187,\n    b188,\n    b189,\n    b190,\n    b191,\n    b192,\n    b193,\n    b194,\n    b195,\n    b196,\n    b197,\n    b198,\n    b199,\n    b200,\n    b201,\n    b202,\n    b203,\n    b204,\n    b205,\n    b206,\n    b207,\n    b208,\n    b209,\n    b210,\n    b211,\n    b212,\n    b213,\n    b214,\n    b215,\n    b216,\n    b217,\n    b218,\n    b219,\n    b220,\n    b221,\n    b222,\n    b223,\n    b224,\n    b225,\n    b226,\n    b227,\n    b228,\n    b229,\n    b230,\n    b231,\n    b232,\n    b233,\n    b234,\n    b235,\n    b236,\n    b237,\n    b238,\n    b239,\n    b240,\n    b241,\n    b242,\n    b243,\n    b244,\n    b245,\n    b246,\n    b247,\n    b248,\n    b249,\n    b250,\n    b251,\n    b252,\n    b253,\n    b254,\n    b255,\n    b256,\n    // b257,\n}\nfn main() {\n    let x = Cat::b1;\n    // 一个字节一共可以有256种可能,刚好可以保存上面任何一个变体,值就能区分\n    println!(\"{}\", std::mem::size_of::&lt;Cat&gt;());\n}\n\n\n\n\n\n\n\n\n\n例子2\n\n\n\n\n\n\ncode内存结构图\n\n\nenum Cat {\n    Tiger(i32), //tag =0\n    Lion(i8),  // tag =1\n    Dog(i16), // tag =2\n}\n\nuse std::mem;\nfn main() {\n    let lion = Cat::Lion(66);\n    println!(\"lion : {}\", mem::size_of_val(&lion)); // 8\n    unsafe {\n        let d = &lion as *const Cat as *const u64;\n        //0x4201 --&gt; 0x42=66 这个是data 0x01=1 这个是tag\n        //实际: 第一个字节存tag, 第二个字节存携带的数据 (因为这里Lion携带的数据是i8用一个字节就行了)\n        println!(\"0x{:x}\", *d);\n    }\n    let dog = Cat::Dog(66);\n    println!(\"Dog : {}\", mem::size_of_val(&dog));  // 8\n    unsafe {\n        let d = &dog as *const Cat as *const u64;\n        //0x420002 --&gt; 0x42=66 这个是data 0x0002 这个是tag\n        //Dog 携带的数据是i16  是2个字节, 所以这里tag和携带的数据各占用两个字节\n        println!(\"0x{:x}\", *d);\n    }\n\n    let tiger = Cat::Tiger(66);\n    println!(\"Tiger : {}\", mem::size_of_val(&tiger)); // 8\n    unsafe {\n        let d = &tiger as *const Cat as *const u64;\n        //0x4200000000 --&gt; 0x42=66 , 0x00 这个是tag\n        println!(\"0x{:x}\", *d);\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n例子3: 我们来看看枚举中变体携带String的情况\n\n\n\n\n\n\ncode内存结构图\n\n\nenum Message {\n    Quit,                    // 不需要占用内存空间, 0\n    Move { x: i32, y: i32 }, // 8bytes\n    Write(String),           // 24\n    ChangeColor(i32, i32, i32), // 12\n    // Read(String),\n}\nstruct enumStringStruct {\n    a: u64,\n    b: u64,\n    c: u64,\n    // d: u64,\n}\n\nfn main() {\n    let mut s = \"hello\".to_string();\n    println!(\"{}-{}\", s.len(), s.capacity());\n    s.push_str(\"x\");\n    println!(\"{}-{}\", s.len(), s.capacity());\n    println!(\"{:p}\", s.as_ptr()); //0x7f8144705f90\n    let m = Message::Write(s);\n    println!(\"{}\", mem::size_of_val(&m)); // 24\n    let b = &m as *const Message as *const enumStringStruct;\n    unsafe {\n        // 发现没有 这个 携带String的没有tag信息, 无tag信息来表示这个是携带String的变体\n        // 0xa-0x7f8144705f90-0x6\n        println!(\"Write: 0x{:x}-0x{:x}-0x{:x}\", (*b).a, (*b).b, (*b).c);\n    }\n    // 取消注释掉下面的代码, 和上面定义的枚举Message中的Read(String) 变体 ,再看看,会发现有各自的tag信息, 总体的内存占用变为32个字节了\n    //---\n    // let mut s = \"hello\".to_string();\n    // s.push_str(\"x\");\n    // println!(\"{:p}\", s.as_ptr()); \n    // let m = Message::Read(s);\n    // println!(\"{}\", mem::size_of_val(&m)); // 24\n    // let b = &m as *const Message as *const enumStringStruct;\n    // unsafe {\n    //     println!(\n    //         \"Read: 0x{:x}-0x{:x}-0x{:x}\",\n    //         (*b).a,\n    //         (*b).b,\n    //         (*b).c,\n    //         (*b).d\n    //     );\n    // }\n    //---\n    let m = Message::Move { x: 11, y: 22 };\n    println!(\"{}\", mem::size_of_val(&m)); // 24\n    let b = &m as *const Message as *const enumStringStruct;\n    unsafe {\n        //                tag    y       x\n        // 0x8000000000000001-0x160000000b-0x0\n        println!(\"Move: 0x{:x}-0x{:x}-0x{:x}\", (*b).a, (*b).b, (*b).c);\n    }\n\n    let m = Message::ChangeColor(6, 7, 8);\n    println!(\"{}\", mem::size_of_val(&m)); // 24\n    let b = &m as *const Message as *const enumStringStruct;\n    unsafe {\n        //                tag   7       6   8\n        // 0x8000000000000003-0x700000006-0x8\n        println!(\"ChangeColor: 0x{:x}-0x{:x}-0x{:x}\", (*b).a, (*b).b, (*b).c);\n    }\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n例子4: 只有一个成员且不携带数据的枚举\n\n\n\n\n\n\n\n不需要tag来区分哪个变体,所以不需要空间来存储tag\n\nfn main() {\n    enum MyEnum {\n        Cat,\n    }\n    let a = MyEnum::Cat;\n    println!(\"{}\", mem::size_of_val(&a));//0\n}\n\n\n\n\n\n\n\n\n\n\nImportant\n\n\n\n\n根据实际情况, 我们看到, 在上面的例子中 携带String的 枚举变体实际上没有存储tag信息,其他变体存了tag,且在高位估计是为了区分Write变体存的cap而增加了一个0x80 (注意: 这只是这个例子的推测)\n如果将上面的例子中的 Read(String) 取消注释, 这样就有2个携带String的变体了,这个时候怎么区分了,可以试试看, 结果是该枚举的大小变成了32字节了,需要新的内存空间来区分它们\n实际源码根据不同情况是如何优化的,我没去看, 但是通过上面的例子,我们大概了解了一些情况,我觉得ok\n\n\n\n\n\n2.2 简单例子\nenum IpAddrKind {\n    V4,\n    V6,\n}\n\nstruct IpAddr {\n    kind: IpAddrKind,\n    address: String,\n}\n\nfn main() {\n    // 下面2个的类型都是 IpAddrKind\n    // 他们的值,只能是枚举定义里的成员的其中一个\n    let four = IpAddrKind::V4;\n    let six = IpAddrKind::V6;\n    // 任何一个传给函数的参数类型是 IpAddrKind ,是ok的\n    route(IpAddrKind::V4);\n    route(IpAddrKind::V6);\n\n    let home = IpAddr {\n        kind: IpAddrKind::V4,\n        address: String::from(\"127.0.0.1\"),\n    };\n\n    let loopback = IpAddr {\n        kind: IpAddrKind::V6,\n        address: String::from(\"::1\"),\n    };\n}\n\nfn route(ip_kind: IpAddrKind) {}\n\n\n2.3 携带数据\n上面的例子中, 我们可能会问, 枚举的成员本身要是能携带数据岂不是更好?\nenum IpAddr {\n    // 可以设置携带不同类型的数据\n    // 就好像一个构造方法一样了\n    V4(u8, u8, u8, u8),\n    V6(String),\n}\nenum Message {\n    Quit,\n    // 像一个结构体一样\n    Move { x: i32, y: i32 },\n    Write(String),\n    ChangeColor(i32, i32, i32),\n}\n\nfn main() {\n    // 就好像调用了构造方法,返回类型 IpAddr的一个实例\n    let home = IpAddr::V4(127, 0, 0, 1);\n\n    let loopback = IpAddr::V6(String::from(\"::1\"));\n\n    let m = Message::Move { x: 22, y: 11 };\n}\n上面的message 的成员就好像 不同的 struct\nstruct QuitMessage; // unit struct\nstruct MoveMessage {\n    x: i32,\n    y: i32,\n}\nstruct WriteMessage(String); // tuple struct\nstruct ChangeColorMessage(i32, i32, i32); // tuple struct\n\n\n2.4 实现方法\n可以像 struct 一样 设置方法\nenum Message {\n    Quit,\n    // 像一个结构体一样\n    Move { x: i32, y: i32 },\n    Write(String),\n    ChangeColor(i32, i32, i32),\n    // hello(),\n}\nimpl Message {\n    // 接收一个 `&self` 参数，表示它是一个实例方法\n    fn call(&self) {\n        // method body would be defined here\n    }\n    // 如果 Message的成员里有个成员名字和这个一样\n    // 那么 Message::hello()  会被认为是 成员,类型是Message\n    fn hello() {\n        println!(\"hello\");\n    }\n}\n\nfn main() {\n    let m = Message::Write(String::from(\"hello\"));\n    m.call();\n    Message::hello();\n}\n\n\n2.5 变体成员是函数?\n\n\n\n\n\n\nCaution\n\n\n\n\n通过下面的测试我们发现: 带() 这种变体可以当成函数类型\n\n\n\n\n\nMessage::Write 实现了 Fn trait\n\n#[derive(Debug)]\nenum Message {\n    Write(i32),\n}\nfn apply&lt;F, T&gt;(f: F, v: T)\nwhere\n    F: Fn(T) -&gt; Message,\n{\n    f(v);\n}\nfn main() {\n    let a = Message::Write;\n    let f = a(2); // 本身这样看,就挺像函数的\n    println!(\"{:?}\", f);\n    apply(a, 3); // 没报错, 说明a 实现了Fn trait\n}\n\nfn main() {\n    let wr = Message::Write(11);\n    print_type_of(&wr); // 类型是 Message\n    let a = [1, 2, 3];\n    // 我们知道map 接收一个闭包\n    let mut f = a.iter().map(Some);\n    // Some 当成函数, 而Some 的参数算 (T) 捕获的是&x\n    // Some(&x) 返回值Option::Some(&x)\n    if let Some(Option::Some(&y)) = f.next() {\n        println!(\"{}\", y);\n    }\n\n    #[derive(Debug)]\n    enum Message {\n        Write(i32),\n    }\n    let a = [1, 2, 3];\n    let mut f = a.into_iter().map(Message::Write);\n    if let Some(Message::Write(x)) = f.next() {\n        println!(\"{}\", x);\n    }\n    let a = [1, 2, 3];\n    // Message::Write 相当于函数, 参数是i32, 看Message定义里的 Write(i32)\n    // into_iter().map 里面传递参数是 Self, 所以 这里闭包使用的参数 也是i32, 返回值是Message::Write(i32)\n    // collect() 的返回值是 Vec&lt;Message&gt;\n    let f: Vec&lt;Message&gt; = a.into_iter().map(Message::Write).collect();\n    println!(\"{:?}\", f);\n}\n\n\n2.6 类C枚举\n// An attribute to hide warnings for unused code.\n#![allow(dead_code)]\n\n// 从0开始自增\nenum Number {\n    Zero,\n    One,\n    Two,\n}\n// 从3 开始自增\nenum Number2 {\n    Zero = 3,\n    One,\n    Two,\n}\n\n// 明确指定值\nenum Color {\n    Red = 0xff0000,\n    Green = 0x00ff00,\n    Blue = 0x0000ff,\n}\n\nfn main() {\n    // `enums` 使用 as 进行转换, 获取数据.\n    println!(\"zero is {}\", Number::Zero as i32);\n    println!(\"one is {}\", Number::One as i32);\n    println!(\"number2 one is {}\", Number2::One as i32); //4\n    println!(\"number2 two is {}\", Number2::Two as i32); //5\n\n    println!(\"roses are #{:06x}\", Color::Red as i32);\n    println!(\"violets are #{:06x}\", Color::Blue as i32);\n}\n\n\n2.7 use\n#![allow(dead_code)]\nenum Status {\n    Rich,\n    Poor,\n}\n\nfn main() {\n    // 使用use ,这样使用的时候,不用 写前面的 Status\n    // 可以这样, use crate::Status::*;\n    use crate::Status::{Poor, Rich};\n    // 等价于 `Status::Poor`.\n    let status = Poor;\n}\n\n\n2.8 Option 枚举\n// 在rust 中用 Option&lt;T&gt; 枚举来表示要么是一个T类型的值, 要么就是None (表示没有任何值)\nenum Option&lt;T&gt; {\n    None,\n    // T 泛型, 这里说明Some这个成员可以携带任何数据\n    Some(T),\n}\n\nand_thenmap\n\n\n\n\n\n\n\n\nTip\n\n\n\n\nOption 枚举类型的方法, 如果调用者(Option类型) 值为None, 则返回 None; 否则使用包装的值调用 f,并返回结果\n\n\n\n\n\n源码\n\npub fn and_then&lt;U, F&gt;(self, f: F) -&gt; Option&lt;U&gt;\n    where\n        F: FnOnce(T) -&gt; Option&lt;U&gt;,\n    {\n        match self {\n\n            Some(x) =&gt; f(x),\n            None =&gt; None,\n        }\n    }\n\n\n\n测试例子\n\nfn main() {\n    // and_then 接收的f , 必须是返回 Option的闭包\n    let a = \"abc\".parse::&lt;i32&gt;().ok().and_then(|x| Some(x));\n    println!(\"{:?}\", a);\n}\n\n\n\n\n\n源码\n\npub fn map&lt;U, F&gt;(self, f: F) -&gt; Option&lt;U&gt;\nwhere\n    F: FnOnce(T) -&gt; U,\n{\n    match self {\n        // 相比较and_then, f 不用返回Option\n        // 这里就用Some 包起来.\n        Some(x) =&gt; Some(f(x)),\n        None =&gt; None,\n    }\n}\n\n\n\n例子\n\nfn main() {\n    let s1 = Some(String::from(\"Hello, World!\"));\n    let len = s1.map(|s| s.len());\n    println!(\"{:?}\", len)\n}\n\n\n\n\n\n\n2.9 Result 枚举\npub enum Result&lt;T, E&gt; {\n    Ok(T),\n    Err(E),\n}\n\nand_then\n\n\n\n\n源码\n\npub fn and_then&lt;U, F: FnOnce(T) -&gt; Result&lt;U, E&gt;&gt;(self, op: F) -&gt; Result&lt;U, E&gt; {\n    match self {\n        Ok(t) =&gt; op(t),\n        Err(e) =&gt; Err(e),\n    }\n}\n\n\n\n测试例子\n\nuse std::fs::File;\nuse std::io::{self, Read};\n\nfn open_file(path: &str) -&gt; Result&lt;File, io::Error&gt; {\n    File::open(path)\n}\nfn main() {\n    let file_path = \"example.txt\";\n    let file = open_file(file_path).and_then(|mut f| {\n        let mut buffer = String::new();\n        f.read_to_string(&mut buffer)?;\n        Ok(buffer)\n    });\n\n    match file {\n        Ok(content) =&gt; println!(\"File content: {}\", content),\n        Err(e) =&gt; println!(\"Failed to read file: {}\", e),\n    }\n}",
    "crumbs": [
      "核心基础",
      "基础篇",
      "枚举"
    ]
  },
  {
    "objectID": "docs/basic/concurrency.html",
    "href": "docs/basic/concurrency.html",
    "title": "rust 并发",
    "section": "",
    "text": "rust 标准库就提供1:1 模型的实现, 第三方crate 有m:n模型的实现",
    "crumbs": [
      "核心基础",
      "基础篇",
      "并发"
    ]
  },
  {
    "objectID": "docs/basic/concurrency.html#实现模型",
    "href": "docs/basic/concurrency.html#实现模型",
    "title": "rust 并发",
    "section": "",
    "text": "rust 标准库就提供1:1 模型的实现, 第三方crate 有m:n模型的实现",
    "crumbs": [
      "核心基础",
      "基础篇",
      "并发"
    ]
  },
  {
    "objectID": "docs/basic/concurrency.html#使用线程",
    "href": "docs/basic/concurrency.html#使用线程",
    "title": "rust 并发",
    "section": "2 使用线程",
    "text": "2 使用线程\nuse std::thread;\nuse std::time::Duration;\n\nfn main() {\n\n    thread::spawn(|| {\n        for i in 1..10 {\n            println!(\"hi number {} from the spawned thread!\", i);\n            thread::sleep(Duration::from_millis(1));\n        }\n    });\n\n    for i in 1..5 {\n        println!(\"hi number {} from the main thread!\", i);\n        thread::sleep(Duration::from_millis(1));\n    }\n}\n线程没有完全执行完,就退出了\n等待线程完成\nuse std::thread;\nuse std::time::Duration;\n\nfn main() {\n    //thread::spawn 的返回类型是 JoinHandle,它有值的所有权\n    let handle = thread::spawn(|| {\n        for i in 1..10 {\n            println!(\"hi number {} from the spawned thread!\", i);\n            thread::sleep(Duration::from_millis(1));\n        }\n    });\n\n    for i in 1..5 {\n        println!(\"hi number {} from the main thread!\", i);\n        thread::sleep(Duration::from_millis(1));\n    }\n    // 等待其他线程执行完成\n    handle.join().unwrap();\n}",
    "crumbs": [
      "核心基础",
      "基础篇",
      "并发"
    ]
  },
  {
    "objectID": "docs/basic/concurrency.html#move-闭包",
    "href": "docs/basic/concurrency.html#move-闭包",
    "title": "rust 并发",
    "section": "3 move 闭包",
    "text": "3 move 闭包\n报错\nuse std::thread;\n\nfn main() {\n    let v = vec![1, 2, 3];\n    // 闭包使用外部数据,是一种借用\n    // rust无法确定 子线程什么时候结束, 而线程使用的借用数据可能被其他线程修改(比如主线程),这样就有问题了\n    let handle = thread::spawn(|| {\n        println!(\"Here's a vector: {:?}\", v);\n    });\n\n    handle.join().unwrap();\n}\n使用move\nuse std::thread;\n\nfn main() {\n    let v = vec![1, 2, 3];\n    // v的所有权被move到闭包中\n    let handle = thread::spawn(move || {\n        println!(\"Here's a vector: {:?}\", v);\n    });\n    // println!(\"{:?}\", v);  // 提示v 已经被move了, 无法借用\n    handle.join().unwrap();\n}",
    "crumbs": [
      "核心基础",
      "基础篇",
      "并发"
    ]
  },
  {
    "objectID": "docs/basic/concurrency.html#channel-使用消息传递",
    "href": "docs/basic/concurrency.html#channel-使用消息传递",
    "title": "rust 并发",
    "section": "4 channel 使用消息传递",
    "text": "4 channel 使用消息传递\n类似go的channel, 线程之间通过发送消息来通信\nmpsc : multiple producer, single consumer\nuse std::sync::mpsc;\nuse std::thread;\n\nfn main() {\n    //tx 发送端, rx 接收端\n    let (tx, rx) = mpsc::channel();\n\n    thread::spawn(move || {\n        let val = String::from(\"hi\");\n        // send() 返回    Result&lt;T, E&gt;\n        tx.send(val).unwrap();\n    });\n    // recv 会堵塞, 直到channel 有数据发送过来\n    // 成功返回 Result&lt;T,E&gt; 发送端关闭,会返回错误\n    let received = rx.recv().unwrap();\n    println!(\"Got: {}\", received);\n}\n使用for in来接收数据\nuse std::sync::mpsc;\nuse std::thread;\nuse std::time::Duration;\n\nfn main() {\n    let (tx, rx) = mpsc::channel();\n\n    thread::spawn(move || {\n        let vals = vec![\n            String::from(\"hi\"),\n            String::from(\"from\"),\n            String::from(\"the\"),\n            String::from(\"thread\"),\n        ];\n\n        for val in vals {\n            tx.send(val).unwrap();\n            thread::sleep(Duration::from_secs(1));\n        }\n    });\n\n    for received in rx {\n        println!(\"Got: {}\", received);\n    }\n}\n多个生产者\nuse std::sync::mpsc;\nuse std::thread;\nuse std::time::Duration;\n\nfn main() {\n    // --snip--\n\n    let (tx, rx) = mpsc::channel();\n\n    let tx1 = tx.clone();\n    thread::spawn(move || {\n        let vals = vec![\n            String::from(\"hi\"),\n            String::from(\"from\"),\n            String::from(\"the\"),\n            String::from(\"thread\"),\n        ];\n\n        for val in vals {\n            tx1.send(val).unwrap();\n            thread::sleep(Duration::from_secs(1));\n        }\n    });\n\n    thread::spawn(move || {\n        let vals = vec![\n            String::from(\"more\"),\n            String::from(\"messages\"),\n            String::from(\"for\"),\n            String::from(\"you\"),\n        ];\n\n        for val in vals {\n            tx.send(val).unwrap();\n            thread::sleep(Duration::from_secs(1));\n        }\n    });\n\n    for received in rx {\n        println!(\"Got: {}\", received);\n    }\n}",
    "crumbs": [
      "核心基础",
      "基础篇",
      "并发"
    ]
  },
  {
    "objectID": "docs/basic/concurrency.html#共享状态的并发",
    "href": "docs/basic/concurrency.html#共享状态的并发",
    "title": "rust 并发",
    "section": "5 共享状态的并发",
    "text": "5 共享状态的并发\nShared-State Concurrency\n多所有权, 多个线程同时访问一块内存\n\n5.1 Mutex\nuse std::sync::Mutex;\n\nfn main() {\n    // 返回Mutex&lt;T&gt;  也是智能指针\n    let m = Mutex::new(5);\n\n    {\n        // 通过.lock() 获取锁, 如果获取不到,就会阻塞当前线程\n        // 返回值是 MutexGuard 类型,它实现了 Deref trait 和Drop trait\n        let mut num = m.lock().unwrap();\n        *num = 6;\n        // 报错, 锁还没释放, 下面的代码不能执行\n        // let mut num2 = m.lock().unwrap();\n    }\n    // 这里 m 已经释放锁(drop 操作), 下面的代码可以执行\n    let mut num2 = m.lock().unwrap();\n\n    println!(\"m = {:?}\", m);\n}\n\n\n5.2 Rc? 多个线程send\n报错了, rc 是不能在线程间安全发送,因为没有实现 Send trait\nuse std::rc::Rc;\nuse std::sync::Mutex;\nuse std::thread;\n\nfn main() {\n    let counter = Rc::new(Mutex::new(0));\n    let mut handles = vec![];\n\n    for _ in 0..10 {\n        let counter = Rc::clone(&counter);\n        let handle = thread::spawn(move || {\n            let mut num = counter.lock().unwrap();\n\n            *num += 1;\n        });\n        handles.push(handle);\n    }\n\n    for handle in handles {\n        handle.join().unwrap();\n    }\n\n    println!(\"Result: {}\", *counter.lock().unwrap());\n}\n\n\n5.3 Arc\nArc= atomic rc\nuse std::sync::{Arc, Mutex};\nuse std::thread;\n\nfn main() {\n    let counter = Arc::new(Mutex::new(0));\n    let mut handles = vec![];\n\n    for _ in 0..10 {\n        let counter = Arc::clone(&counter);\n        let handle = thread::spawn(move || {\n            let mut num = counter.lock().unwrap();\n\n            *num += 1;\n        });\n        handles.push(handle);\n    }\n\n    for handle in handles {\n        handle.join().unwrap();\n    }\n\n    println!(\"Result: {}\", *counter.lock().unwrap());\n}",
    "crumbs": [
      "核心基础",
      "基础篇",
      "并发"
    ]
  },
  {
    "objectID": "docs/basic/concurrency.html#send-sync-trait",
    "href": "docs/basic/concurrency.html#send-sync-trait",
    "title": "rust 并发",
    "section": "6 Send Sync trait",
    "text": "6 Send Sync trait\n\nSend\n\n实现Send trait的类型, 就可以线程间转移所有权\n几乎所有类型都实现了Send, 但是Rc 没有实现,它只能用于单线程\n由Send 成员组成的类型 也是Send\n\nSync\n\n实现Sync trait的类型,可以安全的被多线程引用\nT 是 Sync, 那么 &T 就是 Send\n基础类型都实现了 Sync, 完全由Sync组成的类型 也是Sync\nRc,RefCell, Cell不是 Sync, Mutex是Sync\n\n\n手动实现Send和Sync 是很难做到安全的",
    "crumbs": [
      "核心基础",
      "基础篇",
      "并发"
    ]
  },
  {
    "objectID": "docs/web/net.html",
    "href": "docs/web/net.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "hello.html\n\n&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n  &lt;head&gt;\n    &lt;meta charset=\"utf-8\"&gt;\n    &lt;title&gt;Hello!&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;h1&gt;Hello!&lt;/h1&gt;\n    &lt;p&gt;Hi from Rust&lt;/p&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n\n\n\nsrc/main.rs\n\nuse std::{\n    fs,\n    io::{prelude::*, BufReader},\n    net::{TcpListener, TcpStream},\n};\nfn main() {\n    let listener = TcpListener::bind(\"127.0.0.1:7878\").unwrap();\n\n    for stream in listener.incoming() {\n        // 每一个stream 表示 客户端和服务端之间的链接\n        // 包含客户端发送来的数据\n        let stream = stream.unwrap();\n\n        handle_connection(stream);\n    }\n}\n\nfn handle_connection(mut stream: TcpStream) {\n    let buf_reader = BufReader::new(&mut stream);\n    let http_request: Vec&lt;_&gt; = buf_reader\n        .lines()\n        .map(|result| result.unwrap())\n        .take_while(|line| !line.is_empty())\n        .collect();\n\n    println!(\"Request: {:#?}\", http_request);\n\n    // response\n    let status_line = \"HTTP/1.1 200 OK\";\n    let contents = fs::read_to_string(\"hello.html\").unwrap();\n    let length = contents.len();\n\n    let response = format!(\"{status_line}\\r\\nContent-Length: {length}\\r\\n\\r\\n{contents}\");\n\n    stream.write_all(response.as_bytes()).unwrap();\n}\n\nfn handle_connection2(mut stream: TcpStream) {\n    let buf_reader = BufReader::new(&mut stream);\n    let request_line = buf_reader.lines().next().unwrap().unwrap();\n\n    if request_line == \"GET / HTTP/1.1\" {\n        let status_line = \"HTTP/1.1 200 OK\";\n        let contents = fs::read_to_string(\"hello.html\").unwrap();\n        let length = contents.len();\n\n        let response = format!(\n            \"{status_line}\\r\\nContent-Length: {length}\\r\\n\\r\\n{contents}\"\n        );\n\n        stream.write_all(response.as_bytes()).unwrap();\n    } else {\n        let status_line = \"HTTP/1.1 404 NOT FOUND\";\n        // 再弄个 404.html \n        let contents = fs::read_to_string(\"404.html\").unwrap();\n        let length = contents.len();\n\n        let response = format!(\n            \"{status_line}\\r\\nContent-Length: {length}\\r\\n\\r\\n{contents}\"\n        );\n\n        stream.write_all(response.as_bytes()).unwrap();\n    }\n}\n\n运行后,"
  },
  {
    "objectID": "docs/web/net.html#单线程",
    "href": "docs/web/net.html#单线程",
    "title": "斯巴拉稀",
    "section": "",
    "text": "hello.html\n\n&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n  &lt;head&gt;\n    &lt;meta charset=\"utf-8\"&gt;\n    &lt;title&gt;Hello!&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;h1&gt;Hello!&lt;/h1&gt;\n    &lt;p&gt;Hi from Rust&lt;/p&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n\n\n\nsrc/main.rs\n\nuse std::{\n    fs,\n    io::{prelude::*, BufReader},\n    net::{TcpListener, TcpStream},\n};\nfn main() {\n    let listener = TcpListener::bind(\"127.0.0.1:7878\").unwrap();\n\n    for stream in listener.incoming() {\n        // 每一个stream 表示 客户端和服务端之间的链接\n        // 包含客户端发送来的数据\n        let stream = stream.unwrap();\n\n        handle_connection(stream);\n    }\n}\n\nfn handle_connection(mut stream: TcpStream) {\n    let buf_reader = BufReader::new(&mut stream);\n    let http_request: Vec&lt;_&gt; = buf_reader\n        .lines()\n        .map(|result| result.unwrap())\n        .take_while(|line| !line.is_empty())\n        .collect();\n\n    println!(\"Request: {:#?}\", http_request);\n\n    // response\n    let status_line = \"HTTP/1.1 200 OK\";\n    let contents = fs::read_to_string(\"hello.html\").unwrap();\n    let length = contents.len();\n\n    let response = format!(\"{status_line}\\r\\nContent-Length: {length}\\r\\n\\r\\n{contents}\");\n\n    stream.write_all(response.as_bytes()).unwrap();\n}\n\nfn handle_connection2(mut stream: TcpStream) {\n    let buf_reader = BufReader::new(&mut stream);\n    let request_line = buf_reader.lines().next().unwrap().unwrap();\n\n    if request_line == \"GET / HTTP/1.1\" {\n        let status_line = \"HTTP/1.1 200 OK\";\n        let contents = fs::read_to_string(\"hello.html\").unwrap();\n        let length = contents.len();\n\n        let response = format!(\n            \"{status_line}\\r\\nContent-Length: {length}\\r\\n\\r\\n{contents}\"\n        );\n\n        stream.write_all(response.as_bytes()).unwrap();\n    } else {\n        let status_line = \"HTTP/1.1 404 NOT FOUND\";\n        // 再弄个 404.html \n        let contents = fs::read_to_string(\"404.html\").unwrap();\n        let length = contents.len();\n\n        let response = format!(\n            \"{status_line}\\r\\nContent-Length: {length}\\r\\n\\r\\n{contents}\"\n        );\n\n        stream.write_all(response.as_bytes()).unwrap();\n    }\n}\n\n运行后,"
  },
  {
    "objectID": "docs/web/net.html#多线程版本",
    "href": "docs/web/net.html#多线程版本",
    "title": "斯巴拉稀",
    "section": "2 多线程版本",
    "text": "2 多线程版本\n这个版本, 每一个请求, 都会开启一个线程,没有限制了, 不断访问,可就产生很多的线程,服务器要完\nuse std::net::{TcpListener, TcpStream};\nuse std::thread;\nfn main() {\n    let listener = TcpListener::bind(\"127.0.0.1:7878\").unwrap();\n\n    for stream in listener.incoming() {\n        let stream = stream.unwrap();\n\n        thread::spawn(|| {\n            handle_connection(stream);\n        });\n    }\n}\n\nfn handle_connection(mut stream: TcpStream) {}\n使用线程池,设计了一个线程池\n\n\nsrc/main.rs\n\nuse hello::ThreadPool;\nuse std::fs;\nuse std::io::prelude::*;\nuse std::net::TcpListener;\nuse std::net::TcpStream;\nuse std::thread;\nuse std::time::Duration;\n\nfn main() {\n    let listener = TcpListener::bind(\"127.0.0.1:7878\").unwrap();\n    let pool = ThreadPool::new(4);\n\n    for stream in listener.incoming().take(2) {\n        let stream = stream.unwrap();\n\n        pool.execute(|| {\n            handle_connection(stream);\n        });\n    }\n\n    println!(\"Shutting down.\");\n}\n\nfn handle_connection(mut stream: TcpStream) {\n    let mut buffer = [0; 1024];\n    stream.read(&mut buffer).unwrap();\n\n    let get = b\"GET / HTTP/1.1\\r\\n\";\n    let sleep = b\"GET /sleep HTTP/1.1\\r\\n\";\n\n    let (status_line, filename) = if buffer.starts_with(get) {\n        (\"HTTP/1.1 200 OK\", \"hello.html\")\n    } else if buffer.starts_with(sleep) {\n        thread::sleep(Duration::from_secs(5));\n        (\"HTTP/1.1 200 OK\", \"hello.html\")\n    } else {\n        (\"HTTP/1.1 404 NOT FOUND\", \"404.html\")\n    };\n\n    let contents = fs::read_to_string(filename).unwrap();\n\n    let response = format!(\n        \"{}\\r\\nContent-Length: {}\\r\\n\\r\\n{}\",\n        status_line,\n        contents.len(),\n        contents\n    );\n\n    stream.write_all(response.as_bytes()).unwrap();\n    stream.flush().unwrap();\n}\n\n\n\nsrc/lib.rs\n\nuse std::{\n    sync::{mpsc, Arc, Mutex},\n    thread,\n};\n\npub struct ThreadPool {\n    workers: Vec&lt;Worker&gt;,\n    sender: Option&lt;mpsc::Sender&lt;Job&gt;&gt;,\n}\n\ntype Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;\n\nimpl ThreadPool {\n    /// Create a new ThreadPool.\n    ///\n    /// The size is the number of threads in the pool.\n    ///\n    /// # Panics\n    ///\n    /// The `new` function will panic if the size is zero.\n    pub fn new(size: usize) -&gt; ThreadPool {\n        assert!(size &gt; 0);\n\n        let (sender, receiver) = mpsc::channel();\n\n        let receiver = Arc::new(Mutex::new(receiver));\n\n        let mut workers = Vec::with_capacity(size);\n\n        for id in 0..size {\n            workers.push(Worker::new(id, Arc::clone(&receiver)));\n        }\n\n        ThreadPool {\n            workers,\n            sender: Some(sender),\n        }\n    }\n    // 模拟 thread spawn\n    pub fn execute&lt;F&gt;(&self, f: F)\n    where\n        F: FnOnce() + Send + 'static,\n    {\n        let job = Box::new(f);\n\n        self.sender.as_ref().unwrap().send(job).unwrap();\n    }\n}\n// 优雅退出\nimpl Drop for ThreadPool {\n    fn drop(&mut self) {\n        drop(self.sender.take());\n\n        for worker in &mut self.workers {\n            println!(\"Shutting down worker {}\", worker.id);\n\n            if let Some(thread) = worker.thread.take() {\n                thread.join().unwrap();\n            }\n        }\n    }\n}\n\nstruct Worker {\n    id: usize,\n    thread: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,\n}\n\nimpl Worker {\n    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {\n        let thread = thread::spawn(move || loop {\n            let message = receiver.lock().unwrap().recv();\n\n            match message {\n                Ok(job) =&gt; {\n                    println!(\"Worker {id} got a job; executing.\");\n\n                    job();\n                }\n                Err(_) =&gt; {\n                    println!(\"Worker {id} disconnected; shutting down.\");\n                    break;\n                }\n            }\n        });\n\n        Worker {\n            id,\n            thread: Some(thread),\n        }\n    }\n}"
  },
  {
    "objectID": "docs/web/axum/index.html",
    "href": "docs/web/axum/index.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "TODO"
  },
  {
    "objectID": "docs/web/axum/index.html#环境准备",
    "href": "docs/web/axum/index.html#环境准备",
    "title": "斯巴拉稀",
    "section": "1 环境准备",
    "text": "1 环境准备\ncargo add axum\n# cargo add tokio --features macros,rt-multi-thread\ncargo add tokio  --features full\ncargo add serde_json"
  },
  {
    "objectID": "docs/web/axum/index.html#样例",
    "href": "docs/web/axum/index.html#样例",
    "title": "斯巴拉稀",
    "section": "2 样例",
    "text": "2 样例\nuse axum::{response::Html, routing::get, Json, Router};\nuse serde_json::{json, Value};\n#[tokio::main]\nasync fn main() {\n    // build our application with a single route\n    // get 请求\n    let app = Router::new().route(\"/\", get(index_handler)).route(\n        \"/foo\",\n        // get post 2个请求都设置\n        get(|| async { \"Hello, Foo!\" }).post(json_handler),\n    );\n\n    // run our app with hyper, listening globally on port 3000\n    let listener = tokio::net::TcpListener::bind(\"0.0.0.0:3000\").await.unwrap();\n    axum::serve(listener, app).await.unwrap();\n}\nasync fn index_handler() -&gt; Html&lt;&'static str&gt; {\n    Html(\"&lt;h1&gt;Hello, World!&lt;/h1&gt;\")\n}\n\n// `&'static str` becomes a `200 OK` with `content-type: text/plain;charset=utf-8`\nasync fn plain_text() -&gt; &'static str {\n    \"foo\"\n}\n// `Json` gives a content-type of `application/json` and works with any type\n// that implements `serde::Serialize`\nasync fn json_handler() -&gt; Json&lt;Value&gt; {\n    Json(json!({ \"data\": 42 }))\n}\ngithub1 github2"
  },
  {
    "objectID": "docs/web/axum/index.html#footnotes",
    "href": "docs/web/axum/index.html#footnotes",
    "title": "斯巴拉稀",
    "section": "Footnotes",
    "text": "Footnotes\n\n\naxum: https://github.com/tokio-rs/axum↩︎\naxum生态: https://github.com/tokio-rs/axum/blob/main/ECOSYSTEM.md#tutorials↩︎"
  },
  {
    "objectID": "docs/advanced/02.type.html#dst",
    "href": "docs/advanced/02.type.html#dst",
    "title": "斯巴拉稀",
    "section": "1 DST",
    "text": "1 DST\nuse std::mem;\ntrait Summary {\n    fn summarize(&self) -&gt; String;\n    fn hello(&self) {\n        println!(\"hello\");\n    }\n}\nfn main() {\n    // 报错, 无法获取大小\n    println!(\"{}\", mem::size_of::&lt;Summary&gt;());\n}",
    "crumbs": [
      "进阶",
      "奇异的类型"
    ]
  },
  {
    "objectID": "docs/advanced/02.type.html#zst",
    "href": "docs/advanced/02.type.html#zst",
    "title": "斯巴拉稀",
    "section": "2 ZST",
    "text": "2 ZST\nuse std::mem;\nstruct Nothing; // No fields = no size\n                // All fields have no size = no size\nstruct LotsOfNothing {\n    foo: Nothing,\n    qux: (),      // empty tuple has no size\n    baz: [u8; 0], // empty array has no size\n}\n\nfn main() {\n    println!(\"{}\", mem::size_of::&lt;Nothing&gt;());\n    println!(\"{}\", mem::size_of::&lt;LotsOfNothing&gt;());\n    let a = Nothing {};\n    let b = &a;\n    println!(\"{}\", mem::size_of_val(&a)); // 0\n    println!(\"{:p}\", &a); // 0x7ff7b1bacf4f\n    println!(\"{:p}\", &b); // 0x7ff7b1bacf50\n    println!(\"{}\", mem::size_of_val(&b)); // 8\n}",
    "crumbs": [
      "进阶",
      "奇异的类型"
    ]
  },
  {
    "objectID": "docs/advanced/02.type.html#空类型",
    "href": "docs/advanced/02.type.html#空类型",
    "title": "斯巴拉稀",
    "section": "3 空类型",
    "text": "3 空类型\nuse std::mem;\nenum NoVariants {} // No variants = no size\nfn main() {\n    // 无法实例化\n    // let a = NoVariants;\n    println!(\"{}\", mem::size_of::&lt;NoVariants&gt;());\n}",
    "crumbs": [
      "进阶",
      "奇异的类型"
    ]
  },
  {
    "objectID": "docs/advanced/02.type.html#repr",
    "href": "docs/advanced/02.type.html#repr",
    "title": "斯巴拉稀",
    "section": "4 repr",
    "text": "4 repr\n\n4.1 repr(C)\n它的目的很简单, 就是和 C 保持一致. 数据的顺序,大小,对齐方式都和你在C 或C++中见到的一摸一样.\n我们前面在内存对齐看对Struct A的对齐方式和它的大小,这里我们使用repr(C)来定义Struct A\n#[repr(C)]\nstruct A {\n    a: u8,\n    b: u32,\n    c: u16,\n}\n\nuse std::mem;\nfn main() {\n    let x = A { a: 1, b: 2, c: 3 };\n    // 12\n    println!(\"{}\", mem::size_of_val(&x));\n    println!(\"0x{:p}-0x{:p}-0x{:p}\", &x.a, &x.b, &x.c);\n}\nTODO 特殊情况\n\nZSTs are still zero-sized …\n…\n\n\n\n4.2 repr(transparent)\n\n\n4.3 repr(u) repr(i)\n\n\n4.4 repr(packed)",
    "crumbs": [
      "进阶",
      "奇异的类型"
    ]
  },
  {
    "objectID": "add-table.html",
    "href": "add-table.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "Sample grid table.\n\n\n\n\n\n\n\nFruit\nPrice\nAdvantages\n\n\n\n\nBananas\n$1.34\n\nbuilt-in wrapper\nbright color\n\n\n\nOranges\n$2.10\n\ncures scurvy\ntasty\n\n\n\n\n在vscode中 右键 点击 Edit in visual mode ,然后插入table , 直接编辑它就行, 最后复制"
  },
  {
    "objectID": "add-table.html#添加这种格式的table-的方式",
    "href": "add-table.html#添加这种格式的table-的方式",
    "title": "斯巴拉稀",
    "section": "",
    "text": "Sample grid table.\n\n\n\n\n\n\n\nFruit\nPrice\nAdvantages\n\n\n\n\nBananas\n$1.34\n\nbuilt-in wrapper\nbright color\n\n\n\nOranges\n$2.10\n\ncures scurvy\ntasty\n\n\n\n\n在vscode中 右键 点击 Edit in visual mode ,然后插入table , 直接编辑它就行, 最后复制"
  },
  {
    "objectID": "docs/advanced/01.mem.html",
    "href": "docs/advanced/01.mem.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "Important\n\n\n\n会合并到基础篇",
    "crumbs": [
      "进阶",
      "内存"
    ]
  },
  {
    "objectID": "docs/advanced/01.mem.html#类型",
    "href": "docs/advanced/01.mem.html#类型",
    "title": "斯巴拉稀",
    "section": "1 类型",
    "text": "1 类型\n\n\n\n\n\n\n\n以1个字节1个字节的方式来读写原本4个字节类型的内存空间\n\n\n\n\n\nfn main() {\n    // 10 00000100 00000011 00000001\n    let mut a = 33817345i32;\n    struct FourI8 {\n        first: i8,\n        second: i8,\n        third: i8,\n        fourth: i8,\n    }\n    // 将变量a的地址 转换为一个指针 ,指针类型是i32,这个就是a原来的内存读取方式\n    // 然后再将这个指针 进行类型转换, 转换为 结构体的方式来读取 a 所在的那块内存\n    let b = &mut a as *mut i32 as *mut FourI8;\n    unsafe {\n        println!(\n            \"{} {} {} {}\",\n            (*b).first,\n            (*b).second,\n            (*b).third,\n            (*b).fourth\n        );\n        (*b).first = 2;\n        // 10 00000100 00000011 00000010\n        println!(\"{:b}\", a);\n    }\n}",
    "crumbs": [
      "进阶",
      "内存"
    ]
  },
  {
    "objectID": "docs/advanced/01.mem.html#内存对齐",
    "href": "docs/advanced/01.mem.html#内存对齐",
    "title": "斯巴拉稀",
    "section": "2 内存对齐",
    "text": "2 内存对齐\n\n代码可能的对齐方式一可能的对齐方式二实际测试结果\n\n\nstruct A {\n    a: u8,\n    b: u32,\n    c: u16,\n}\n\n\n// 这种对齐 12个字节\nstruct A {\n    a: u8,\n    _pad1: [u8; 3], // to align `b`\n    b: u32,\n    c: u16,\n    _pad2: [u8; 2], // to make overall size multiple of 4\n}\n\n\n// 这种对齐 8个字节\nstruct A {\n    b: u32,\n    c: u16,\n    a: u8,\n    _pad: u8,\n}\n\n\nuse std::mem;\n\nstruct A {\n    a: u8,\n    b: u32,\n    c: u16,\n}\n\nfn main() {\n    let x = A { a: 1, b: 2, c: 3 };\n    println!(\"{}\", mem::size_of_val(&x)); // 8\n    // 0x0x7ff7bf6930be-0x0x7ff7bf6930b8-0x0x7ff7bf6930bc\n    // 也就是说实际优化成\n    struct A {\n        b: u32,\n        c: u16,\n        a: u8,\n    }\n    println!(\"0x{:p}-0x{:p}-0x{:p}\", &x.a, &x.b, &x.c);\n}",
    "crumbs": [
      "进阶",
      "内存"
    ]
  },
  {
    "objectID": "docs/advanced/01.mem.html#box",
    "href": "docs/advanced/01.mem.html#box",
    "title": "斯巴拉稀",
    "section": "3 Box",
    "text": "3 Box\nfn main() {\n    // 5 是在 堆上分配的, 栈上的变量b 指向了它\n    let b = Box::new(5);\n    let a = 11i64;\n    let c = Box::new(&a);\n    println!(\"b的值 = {:p}\", b);\n    println!(\"c的地址 : {:p}\", &c);\n    println!(\"a的地址 : {:p}\", &a);\n    println!(\"c的值: {:p}\", c);\n    let d = &c as *const Box&lt;&i64&gt; as *const u64;\n    unsafe {\n        // c的值是个地址,指向堆上的内存\n        println!(\"c的值: 0x{:x}\", *d);\n        let dd = *d as *const u64;\n        // c的值是地址,该地址所在内存 存的是 a的地址\n        println!(\"0x{:x}\", *dd);\n    }\n}",
    "crumbs": [
      "进阶",
      "内存"
    ]
  },
  {
    "objectID": "docs/advanced/01.mem.html#vectnt",
    "href": "docs/advanced/01.mem.html#vectnt",
    "title": "斯巴拉稀",
    "section": "4 Vec,[T;N],&[T]",
    "text": "4 Vec,[T;N],&[T]\nfn main() {\n    let mut vec: Vec&lt;i32&gt; = vec![1, 2, 3, 4];\n    let arr = [1, 2, 3, 4];\n    vec.push(5);\n    let (ptr, len, cap) = (vec.as_ptr(), vec.len(), vec.capacity());\n    println!(\"Vec 的指针: {:?}\", ptr);\n    println!(\"Vec 的长度: {}\", len);\n    println!(\"Vec 的容量: {}\", cap);\n    // 等价于 let slice_vec:&[i32]=&v;\n    // let slice_vec = &v[..];\n    // [T] 本身表示动态大小, &[T] 切片后,确定了长度\n    let slice_vec = &vec as &[i32];\n\n    // 等价于 let slice_arr:&[i32]=&arr;\n    // let slice_arr = &arr[..];\n    let slice_arr = &arr as &[i32];\n    println!(\n        \"vec的ptr:{:p}-slice_vec的ptr:{:p}-{}\",\n        vec.as_ptr(),\n        slice_vec.as_ptr(),\n        slice_vec.len()\n    );\n    println!(\n        \"arr地址:{:p}-slice_arr的ptr:{:p}-{}\",\n        &arr,\n        slice_arr.as_ptr(),\n        slice_arr.len()\n    );\n\n    struct SliceStruct {\n        a: usize,\n        b: usize,\n    }\n\n    unsafe {\n        let b = &slice_vec as *const &[i32] as *const SliceStruct;\n        // a: cap, b:ptr,c:len\n        println!(\"0x{:x}-0x{:x}\", (*b).a, (*b).b);\n    }\n    struct VecStruct {\n        a: usize,\n        b: usize,\n        c: usize,\n    }\n\n    unsafe {\n        let b = &vec as *const Vec&lt;i32&gt; as *const VecStruct;\n        // a: cap, b:ptr,c:len\n        println!(\"0x{:x}-0x{:x}-0x{:x}\", (*b).a, (*b).b, (*b).c);\n    }\n}",
    "crumbs": [
      "进阶",
      "内存"
    ]
  },
  {
    "objectID": "docs/advanced/01.mem.html#stringstr",
    "href": "docs/advanced/01.mem.html#stringstr",
    "title": "斯巴拉稀",
    "section": "5 String,&str",
    "text": "5 String,&str\nfn main() {\n    let a = \"hello\";\n    let b = \"world\".to_string();\n    println!(\"{:p}-{:p}\", &a, a.as_ptr());\n    println!(\"{:p}-{:p}-{}-{}\", &b, b.as_ptr(), b.capacity(), b.len());\n    unsafe {\n        let c = a.as_ptr() as *const u8;\n        println!(\"{:p}\", c);\n        let mut d;\n        for i in 0..10 {\n            // 一个字节一个字节的打印\n            d = c.add(i);\n            // h-e-l-l-o-w-o-r-l-d-\n            print!(\"{}-\", *d as char);\n        }\n        println!(\"\")\n    }\n\n    let e = &b[1..];\n    println!(\"{:p}-{:p}\", &e, e.as_ptr());\n\n    struct StringStruct {\n        a: usize, // cap\n        b: usize, // ptr\n        c: usize, // len\n    }\n    let mut s = \"hello\".to_string();\n    s.push_str(\"x\");\n    // 6-10\n    println!(\"{}-{}\", s.len(), s.capacity());\n    let b = &s as *const String as *const StringStruct;\n    unsafe {\n        // 0xa-0x7f8fbb705f90-0x6\n        println!(\"0x{:x}-0x{:x}-0x{:x}\", (*b).a, (*b).b, (*b).c);\n    }\n}",
    "crumbs": [
      "进阶",
      "内存"
    ]
  },
  {
    "objectID": "docs/advanced/01.mem.html#static",
    "href": "docs/advanced/01.mem.html#static",
    "title": "斯巴拉稀",
    "section": "6 &’static",
    "text": "6 &’static\n1fn foo() -&gt; &'static [u8] {\n    &[1, 2, 3]\n}\nfn main(){\n    let b = 1;\n    println!(\"b: {:p}\", &b);\n\n    let a = foo();\n    // a: 0x10fa97aa0\n    println!(\"a: {:p}\", a); // 只读内存区\n    let c = Box::new(2i64);\n    println!(\"c: {:p}\", c.as_ref());\n    let d = &c as *const Box&lt;i64&gt; as *const u64;\n    unsafe {\n        // c的值是个地址,指向堆上的内存\n        println!(\"c指向堆上的地址: 0x{:x}\", *d);\n    }\n    let s = \"abc\";\n    //  s: 0x10fa97aa3 ,  a的 [1,2,3] 占用了3个字节 刚好\n    println!(\" s: {:p}\", s.as_ptr()); // 只读内存区\n}\n\n1\n\na.当看到这个可以编译通过时,我就猜测是在编译期直接在只读内存区写入数据,这和字符串字面量实际是一样的  b.当 foo()改成返回 &[b'a', b'b', b'c'], 你会发现 变量s 关联的只读区和 foo()关联的只读区 一样,直接复用了",
    "crumbs": [
      "进阶",
      "内存"
    ]
  },
  {
    "objectID": "docs/advanced/01.mem.html#todo",
    "href": "docs/advanced/01.mem.html#todo",
    "title": "斯巴拉稀",
    "section": "7 TODO",
    "text": "7 TODO",
    "crumbs": [
      "进阶",
      "内存"
    ]
  },
  {
    "objectID": "docs/web/test2.html",
    "href": "docs/web/test2.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "web test2 ## tt ff"
  },
  {
    "objectID": "docs/web/test2.html#tttt",
    "href": "docs/web/test2.html#tttt",
    "title": "斯巴拉稀",
    "section": "",
    "text": "web test2 ## tt ff"
  },
  {
    "objectID": "docs/web/actix-web/index.html#footnotes",
    "href": "docs/web/actix-web/index.html#footnotes",
    "title": "斯巴拉稀",
    "section": "Footnotes",
    "text": "Footnotes\n\n\ngithubhttps://actix.rs/docs/↩︎"
  },
  {
    "objectID": "docs/async/01.future.html",
    "href": "docs/async/01.future.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "async-std tokio https://tokio.rs/tokio/tutorial\n\n\n\n Back to top"
  },
  {
    "objectID": "docs/basic/env.html",
    "href": "docs/basic/env.html",
    "title": "rust 环境准备",
    "section": "",
    "text": "Caution\n\n\n\ntodo…",
    "crumbs": [
      "核心基础",
      "基础篇",
      "环境准备"
    ]
  },
  {
    "objectID": "docs/basic/env.html#rustup8",
    "href": "docs/basic/env.html#rustup8",
    "title": "rust 环境准备",
    "section": "1 rustup1",
    "text": "1 rustup1\n\n\n\n\n\n\nCaution\n\n\n\n对于这个rustup工具没有必要整这么细, 但是为了博客更加严谨, 我就把rustup稍微搞地更清楚一些\n\n\n\n1.1 设计思路\n\n\n\n\n\n1.2 安装(rustup这章可只看这个)\n\n配置国内源2\n\n\nzshbash\n\n\necho 'export RUSTUP_UPDATE_ROOT=https://mirrors.tuna.tsinghua.edu.cn/rustup/rustup' &gt;&gt; ~/.zshrc\necho 'export RUSTUP_DIST_SERVER=https://mirrors.tuna.tsinghua.edu.cn/rustup' &gt;&gt; ~/.zshrc\n. ~/.zshrc\n\n\necho 'export RUSTUP_UPDATE_ROOT=https://mirrors.tuna.tsinghua.edu.cn/rustup/rustup' &gt;&gt; ~/.bash_profile\necho 'export RUSTUP_DIST_SERVER=https://mirrors.tuna.tsinghua.edu.cn/rustup' &gt;&gt; ~/.bash_profile\n. ~/.bash_profile\n\n\n\n\n然后查看官方安装教程3\n\n\n\n\n安装\n\ncurl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n\n\n\n会提示出下列信息\n\n2   default host triple: x86_64-apple-darwin\n1     default toolchain: stable (default)\n3               profile: default\n  modify PATH variable: yes\n\n\n1\n\n指定toolchain 从 stable channel 中下载最新的工具链\n\n2\n\n很显然工具链是有系统区分的,所以系统会默认给你添加上这个信息(rustup target list命令查看),和指定的stable channel名一起真正构成 toolchain的名字\n\n3\n\n配置下载哪些 components\n\n\n\n安装过程我们可以看到 info: installing component 'rust-docs' 这类信息,说明安装了不少组件\n所有组件的代理程序都安装到 ~/.cargo/bin 这个目录 (看设计思路中图2说明)\ntree ~/.cargo/bin\n~/.cargo/bin\n├── cargo # Rust 的编译工具,包管理器,可以帮助你编译代码,运行,测试...\n├── cargo-clippy\n├── cargo-fmt\n├── cargo-miri\n├── clippy-driver\n1├── rls\n├── rust-analyzer\n├── rust-gdb\n├── rust-gdbgui\n├── rust-lldb\n├── rustc # rust 编译器\n├── rustdoc\n├── rustfmt\n└── rustup\n\n1\n\n由于我们用的profile是default配置, 根据前面的设计思路, 这里的2个是代理程序,实际对应的可执行程序还没有安装, 需要我们额外去安装\n\n\n\n\n\n\n\n\nImportant\n\n\n\n\nrls (需要rust-analysis 配合使用) 已经被 rust-analyzer 取代了 ,所以我们安装 rust-analyzer 即可\nrust-analyzer4, vscode中去安装\n\n\n\n\n\n安装额外需要的组件\n\n# RLS的全称是:'Rust Language Server',是一个守护进程\n# 用于和开发时使用的IDE进行IPC通信,完成代码提示、跳转到定义、显示变量类型等功能\n# rustup component add rls           --toolchain stable    # RLS\n# rustup component add rust-analysis --toolchain stable    # 分析工具\nrustup component add rust-analyzer --toolchain stable\n\n#std是Rust的标准库. 默认情况下,Rust安装的是标准库的二进制码,而添加源码后容易方便我们查询部分标准库的实现\nrustup component add rust-src      --toolchain stable    # std源码\n\n\n环境变量配置\n\n\nzsh\n\n\necho 'source \"$HOME/.cargo/env\"' &gt;&gt; ~/.zshrc\n\n\n\n\n命令自动补全\n\n\n\n用这个命令看如何配置\n\nrustup help completions\n\n\nzsh\n\n\n\n\n\n\n\n\nWarning\n\n\n\n不知道啥情况, 设置后 有一点自动补全,但是 效果很烂\n\n\nmkdir ~/.zfunc\nrustup completions zsh &gt; ~/.zfunc/_rustup\nrustup completions zsh cargo &gt; ~/.zfunc/_cargo\necho 'fpath+=~/.zfunc' &gt;&gt; ~/.zshrc\necho 'autoload -U compinit && compinit' &gt;&gt; ~/.zshrc\n. ~/.zshrc\n\n\n\n\n\n1.3 常用命令\n\n1.3.1 全局信息\nrustup show\n    # Default host: x86_64-apple-darwin\n    # rustup home:  ~/.rustup\n\n    # stable-x86_64-apple-darwin (default)\n    # rustc 1.80.1 (3f5fd8dd4 2024-08-06)\n\n\n查看支持的平台(上面的host)\n\nrustup target list\n\n\n\n1.3.2 toolchain\n\n安装查看执行指定工具链里的命令切换查看命令的真实路径更新卸载\n\n\n\n\n\n\n\n\nImportant\n\n\n\nrustup install 命令等同于 rustup toolchain install, 所以可以省略toolchain\n\n\nnightly版本发布情况 stable版本发布情况\n\n直接通过channel 方式安装\n\n1rustup toolchain install beta --profile minimal\n\n1\n\n--profile minimal 前面说过, 配置下载哪些components, 这里表示下载最少的组件\n\n\n\n使用[channel]-[data]的方式安装\n\nrustup toolchain install nightly-2024-07-25 --profile minimal\n国内源资源情况\n\n使用 版本号 &lt;major.minor&gt;或&lt;major.minor.patch&gt;的方式安装\n\n# 临时取消国内源(有些国内源可能没有保留的), 使用官方源下载\nRUSTUP_DIST_SERVER=  rustup toolchain install 1.77 --profile minimal\n\n\n\n\n\n查看安装的toolchain\n\nrustup toolchain list\n\n\n\n结果\n\n1stable-x86_64-apple-darwin (default)\nbeta-x86_64-apple-darwin\nnightly-2024-07-25-x86_64-apple-darwin\nnightly-2024-07-26-x86_64-apple-darwin\nnightly-x86_64-apple-darwin\n1.64-x86_64-apple-darwin\n1.77-x86_64-apple-darwin\n\n\n1\n\ndefault 表示当前我们默认使用的toolchain  我们可以看到现实的toolchain名字都带有 -x86_64-apple-darwin,系统会自动检测,你也可以自己install时加上\n\n\n\n\n\n\n# 指定 toolchain工具链 来执行它里面的 工具\nrustup run stable rustc --version\n# 同上\nrustup run stable-x86_64-apple-darwin rustc --version\n# 因为默认 使用 stable , 所以这里是调用 stable 里的, 同上\nrustc --version\n\n\n\n\n\n\n点击查看执行结果\n\n\n\n\n\nrustc 1.80.1 (3f5fd8dd4 2024-08-06)\n\n\n\n\n\n\n\n\n全局切换\n\n# 看看有哪些 toolchain\nrustup toolchain list\n#   stable/nightly/beta\nrustup default stable\n\n\n\n工作目录切换版本\n\ncd rust项目代码目录\nrustup override set 1.77.2\n# 取消当前工作目录的版本, 重新设置为默认的全局版本\nrustup override unset\n\n\n\n\nrustup which rustc\n\n\n查看结果\n\n~/.rustup/toolchains/stable-x86_64-apple-darwin/bin/rustc\n\n\n\n\n指定toolchain\n\n#  看看指定命令 实际的可执行的位置\nrustup which rustc  --toolchain=nightly-2024-07-25-x86_64-apple-darwin\n\n\n\n\n\n更新rustup 自身\n\nrustup self update\n\n\n\n更新所有toolchain\n\nrustup update\n\n\n\n更新指定toolchain\n\nrustup update nightly\n\n\n\n# 会删除所有的工具链\n# 注意, 卸载后, rustup 本身也没了,需要重新安装\nrustup self uninstall\n\n\n卸载指定toolchain\n\nrustup toolchain uninstall nightly\n\n\n\n\n\n\n1.3.3 components\n\n查看添加\n\n\n# 查看默认toolchain下已经安装的组件\nrustup component list --installed\n# 查看指定toolchain下已经安装的组件\nrustup component list --installed --toolchain nightly\n\n\nrustup component add rust-analyzer\n# 指定toolchain\nrustup component add rust-analyzer --toolchain stable",
    "crumbs": [
      "核心基础",
      "基础篇",
      "环境准备"
    ]
  },
  {
    "objectID": "docs/basic/env.html#其他准备",
    "href": "docs/basic/env.html#其他准备",
    "title": "rust 环境准备",
    "section": "2 其他准备",
    "text": "2 其他准备\n\n2.1 cargo generate5\n\n\n安装\n\n# 用于根据模板生成代码\n# 安装后,会在~/.cargo/bin下看到 cargo-generate可执行文件(这个不是代理程序)\n# 现在可以这样 cargo generate xxx/yyy (github 模板仓库 url)  创建项目\ncargo install cargo-generate\n\n或者 直接下载可执行文件 https://github.com/cargo-generate/cargo-generate/releases 放到 ~/.cargo/bin/\n\n\n使用\n\n# templates on github\ncargo generate --git https://github.com/username-on-github/mytemplate.git\n# 同上\ncargo generate username-on-github/mytemplate\n# 同上\ncargo generate gh:username-on-github/mytemplate\n\n# 其他平台的 templates\n# translates to https://gitlab.com/username-on-gitlab/mytemplate.git\ncargo generate gl:username-on-gitlab/mytemplate\n# translates to https://bitbucket.org/username-on-bitbucket/\ncargo generate bb:username-on-bitbucket/mytemplate mytemplate.git\n# translates to https://git.sr.ht/~username-on-sourcehut/mytemplate (主意有波浪号)\ncargo generate sr:username-on-sourcehut/mytemplate\n\ncargo help generate\n\n\n\n2.2 cargo deny6\n# 安装 Cargo deny 用于检查依赖的安全性\n# 替代 cargo-audit 这个同类型工具\ncargo install --locked cargo-deny\n# 在项目目录下 初始化, 会生成一个deny.toml 文件\ncargo deny init\n\n\ndeny.toml\n\n\n\n\n\n2.3 typos7\n# 英文单词拼写检查工具\ncargo install typos-cli\n\n\n_typos.toml 配置文件放到项目下\n\n[default]\nextend-ignore-identifiers-re = [\n    # *sigh* this just isn't worth the cost of fixing\n    \"AttributeID.*Supress.*\",\n]\n\n[default.extend-identifiers]\n# *sigh* this just isn't worth the cost of fixing\nAttributeIDSupressMenu = \"AttributeIDSupressMenu\"\n\n[default.extend-words]\n# Don't correct the surname \"Teh\"\nteh = \"teh\"\n\n[files]\n# 排除该目录下的所有的*.po文件,不用检查\nextend-exclude = [\"localized/*.po\"]\n\n\n\n2.4 cargo-nextest8\n# 安装 rust test 增强工具\ncargo install cargo-nextest --locked\n\n\n2.5 pre-commit 配置\n\n\n代码仓库中添加 .pre-commit-config.yaml\n\nfail_fast: false\nrepos:\n1  - repo: https://github.com/pre-commit/pre-commit-hooks\n    rev: v4.3.0\n    hooks:\n      - id: check-byte-order-marker\n      - id: check-case-conflict\n      - id: check-merge-conflict\n      - id: check-symlinks\n      - id: check-yaml\n      - id: end-of-file-fixer\n      - id: mixed-line-ending\n      - id: trailing-whitespace\n  - repo: https://github.com/psf/black\n    rev: 22.10.0\n    hooks:\n      - id: black\n  - repo: https://github.com/crate-ci/typos  \n    rev: v1.8.1\n    hooks:\n      - id: typos\n2  - repo: local\n    hooks:\n      - id: cargo-fmt\n        name: cargo fmt\n        description: Format files with rustfmt.\n        entry: bash -c 'cargo fmt -- --check'\n        language: rust\n        files: \\.rs$\n        args: []\n      - id: cargo-deny\n        name: cargo deny check\n        description: Check cargo dependencies 检查依赖的安全性\n        entry: bash -c 'cargo deny check -d'\n        language: rust\n        files: \\.rs$\n        args: []\n      - id: cargo-check\n        name: cargo check\n        description: Check the package for errors.\n        entry: bash -c 'cargo check --all'\n        language: rust\n        files: \\.rs$\n        pass_filenames: false\n      - id: cargo-clippy\n        name: cargo clippy\n        description: Lint rust sources\n        entry: bash -c 'cargo clippy --all-targets --all-features --tests --benches -- -D warnings'\n        language: rust\n        files: \\.rs$\n        pass_filenames: false\n      - id: cargo-test\n        name: cargo test\n        description: unit test for the project\n        entry: bash -c 'cargo nextest run --all-features'\n        language: rust\n        files: \\.rs$\n        pass_filenames: false\n\n\n1\n\n使用网络上别人提供的hook 脚本\n\n2\n\n自己本地自定义, 可以在下面看到自己写的脚本\n\n\n\n\n\n更新上面配置里设置的repos的版本\n\n# 在项目目录下执行\npre-commit autoupdate\n\n\n\n\n\n\n\n点击查看执行结果\n\n\n\n\n\n[https://github.com/pre-commit/pre-commit-hooks] updating v4.3.0 -&gt; v4.6.0\n[https://github.com/psf/black] updating 22.10.0 -&gt; 24.8.0\n[https://github.com/crate-ci/typos] updating v1.8.1 -&gt; v1.24.6",
    "crumbs": [
      "核心基础",
      "基础篇",
      "环境准备"
    ]
  },
  {
    "objectID": "docs/basic/env.html#查看文档",
    "href": "docs/basic/env.html#查看文档",
    "title": "rust 环境准备",
    "section": "3 查看文档",
    "text": "3 查看文档\n查看本地离线的rust文档,浏览器会自动打开文档, 可以看到好多教程可以点击查看\nrustup doc\n这个会打开 The Rust Programming Language 这本教程\nrustup docs --book\n# 查看帮助,可以看到其他book的 命令\nrustup docs --help\n# 直接打开 rust-by-example 这本书\nrustup docs --rust-by-example",
    "crumbs": [
      "核心基础",
      "基础篇",
      "环境准备"
    ]
  },
  {
    "objectID": "docs/basic/env.html#cargo简单介绍",
    "href": "docs/basic/env.html#cargo简单介绍",
    "title": "rust 环境准备",
    "section": "4 cargo简单介绍",
    "text": "4 cargo简单介绍\ncargo new hello \ncd hello\ntree -a\n# 会创建目录world, 并且 直接有 .git 纳入git管理\n.\n├── .git\n├── .gitignore\n1├── Cargo.toml\n└── src\n    └── main.rs\n\n1\n\ncargo.toml package的一些基本信息 toml参考\n\n\n\n\nCargo.toml\n\n[package]\nname = \"hello\"\n# 注意开发时第一个 version 一般是用0.1.0 不是0.0.1\nversion = \"0.1.0\"\nedition = \"2021\"\n\n\n\nsrc/main.rs\n\nfn main() {\n    println!(\"Hello, world!\");\n}\n\n\n\n执行命令\n\ncargo run\n\n\n\n运行打印的信息\n\n1       Fresh hello v0.1.0 (~/rust2024/hello)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.00s\n2     Running `target/debug/hello`\n3Hello, world!\n\n\n1\n\ncargo 调用 rust编译器 rustc来编译代码,生成可执行文件,会放到 target/debug 目录下\n\n2\n\n运行 可执行文件\n\n3\n\n输出结果\n\n\n配置crates国内源9, 下载依赖包就快了\n\n\n\n\n\n\nWarning\n\n\n\ncargo 1.68 及以上版本 使用 config.toml 文件名,而不是config\n\n\n\n\n这个好像更快...\n\nmkdir -vp ${CARGO_HOME:-$HOME/.cargo}\n\ncat &lt;&lt; EOF | tee -a ${CARGO_HOME:-$HOME/.cargo}/config.toml\n[source.crates-io]\nreplace-with = 'ustc'\n\n[source.ustc]\nregistry = \"sparse+https://mirrors.ustc.edu.cn/crates.io-index/\"\nEOF\n\n或者\nmkdir -vp ${CARGO_HOME:-$HOME/.cargo}\n\ncat &lt;&lt; EOF | tee -a ${CARGO_HOME:-$HOME/.cargo}/config.toml\n[source.crates-io]\nreplace-with = 'mirror'\n\n[source.mirror]\nregistry = \"sparse+https://mirrors.tuna.tsinghua.edu.cn/crates.io-index/\"\nEOF",
    "crumbs": [
      "核心基础",
      "基础篇",
      "环境准备"
    ]
  },
  {
    "objectID": "docs/basic/env.html#其他说明",
    "href": "docs/basic/env.html#其他说明",
    "title": "rust 环境准备",
    "section": "5 其他说明",
    "text": "5 其他说明\n源码和rust语言需求讨论10\n\nnightly版本使用实验性功能的方法, 需要讲rust版本切换到nightly, 然后在代码中添加feature语句\n等到这个功能稳定了,就是用了新版本的编译器,它就会提示你不需要这个feature语句了\n\n#![feature(unboxed_closures)]\n#![feature(fn_traits)]\n//.....",
    "crumbs": [
      "核心基础",
      "基础篇",
      "环境准备"
    ]
  },
  {
    "objectID": "docs/basic/env.html#footnotes",
    "href": "docs/basic/env.html#footnotes",
    "title": "rust 环境准备",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nrustup教程↩︎\nrustup国内源↩︎\n官方安装教程↩︎\nrust-analyzer↩︎\ncargo-generate  点击搜索别人开源的一些template  文档↩︎\ncargo deny\n\ngithub\nbook\nrust-ecosystem\n\n↩︎\ntypos↩︎\ncargo nextest  https://nexte.st/↩︎\n中科大开源镜像站 清华大学开源软件镜像站↩︎\nrust源码 RFC(需求讨论)↩︎",
    "crumbs": [
      "核心基础",
      "基础篇",
      "环境准备"
    ]
  },
  {
    "objectID": "docs/basic/quick-start.html",
    "href": "docs/basic/quick-start.html",
    "title": "rust 快速入门",
    "section": "",
    "text": "hello.rs\n\n// fn : function\nfn main() {\n    // rust的缩进是4个空格\n    // println! 是一个 rust macro 宏, 不是函数, 如果结尾没有! 则是函数\n    println!(\"hello\"); // 结尾 要有 ;\n    /* let 定义变量及初始化 */\n    // : i32 这种表示 变量x的类型\n    let x: i32 =6;\n    println!(\"{:?}\", x);\n    let y: i32;\n    println!(\"{:?}\", y); // 报错, 没有初始化会报错\n\n    // 定义了变量,但是没有使用它,rust会警告你,_开头的 rust不会警告\n    let _z = 5;\n\n    let a: i32;\n    // println!(\"{a}\");  使用之前必须初始化,否则报错\n    // 但是如果不使用的话,  是不会报错的\n\n    // _ 表示忽略这个变量绑定\n    let _ = 4;\n    // println!(\"{}\", _); 报错, _ 不是变量名\n}\n\nrustc 这个只适合编译简单的程序,大型程序 用cargo\n# -o 输出的名字, 没有则默认文件名\nrustc hello.rs -o main\n\n\n\n\n\n\nCaution\n\n\n\n将类型放到变量的后面的设计, 是考虑了rust想要类型自动推导.",
    "crumbs": [
      "核心基础",
      "基础篇",
      "快速入门"
    ]
  },
  {
    "objectID": "docs/basic/quick-start.html#入门例子",
    "href": "docs/basic/quick-start.html#入门例子",
    "title": "rust 快速入门",
    "section": "",
    "text": "hello.rs\n\n// fn : function\nfn main() {\n    // rust的缩进是4个空格\n    // println! 是一个 rust macro 宏, 不是函数, 如果结尾没有! 则是函数\n    println!(\"hello\"); // 结尾 要有 ;\n    /* let 定义变量及初始化 */\n    // : i32 这种表示 变量x的类型\n    let x: i32 =6;\n    println!(\"{:?}\", x);\n    let y: i32;\n    println!(\"{:?}\", y); // 报错, 没有初始化会报错\n\n    // 定义了变量,但是没有使用它,rust会警告你,_开头的 rust不会警告\n    let _z = 5;\n\n    let a: i32;\n    // println!(\"{a}\");  使用之前必须初始化,否则报错\n    // 但是如果不使用的话,  是不会报错的\n\n    // _ 表示忽略这个变量绑定\n    let _ = 4;\n    // println!(\"{}\", _); 报错, _ 不是变量名\n}\n\nrustc 这个只适合编译简单的程序,大型程序 用cargo\n# -o 输出的名字, 没有则默认文件名\nrustc hello.rs -o main\n\n\n\n\n\n\nCaution\n\n\n\n将类型放到变量的后面的设计, 是考虑了rust想要类型自动推导.",
    "crumbs": [
      "核心基础",
      "基础篇",
      "快速入门"
    ]
  },
  {
    "objectID": "docs/basic/quick-start.html#immutable",
    "href": "docs/basic/quick-start.html#immutable",
    "title": "rust 快速入门",
    "section": "2 immutable",
    "text": "2 immutable\nfn main() {\n    // 变量默认不可变\n    let a: i32 = 5;\n    // a=2;  会直接报错,提示不能修改 不可变的变量\n    println!(\"{:p}\", &a);\n\n    // 申明可变变量\n    let mut c: i32 = 5;\n    c = 7;\n    println!(\"{c}\");\n}",
    "crumbs": [
      "核心基础",
      "基础篇",
      "快速入门"
    ]
  },
  {
    "objectID": "docs/basic/quick-start.html#shadowing",
    "href": "docs/basic/quick-start.html#shadowing",
    "title": "rust 快速入门",
    "section": "3 shadowing",
    "text": "3 shadowing\nfn main() {\n    let a: i32 = 5;\n    // a=2;  会直接报错,提示不能修改 不可变的变量\n    println!(\"{:p}\", &a);\n    // shadowing  隐藏了上面的变量a\n    let a: i32 = 5;\n    // 与上面的地址不同, 已经是一个不同的变量了,只是用了相同的变量名\n    // 一开始申明的a 被隐藏了\n    println!(\"重新申明的a变量地址: {:p}\", &a);\n\n    let b = 5i32;\n    {\n        // 在这个作用域中, b 也确实shadowing 了外面的b\n        let b = 8i32;\n        println!(\"b 在作用域中的值: {b}\"); // 是8\n    }\n    // 但是在退出块作用域后, b还是5\n    println!(\"作用域外,b的值:{b}\");\n\n    // shadowing 可以使用完全不同的类型, 因为实际就是2个完全不同的变量\n    let b = \"abc\";\n    println!(\"{b}\");\n}\n一个变量转换类型后,想要用原来的变量名, 就用shadowing方式使用同名变量即可\n\n\n希望变量一开始可读写,之后想要弄成只读\n\nfn main() {\n    let mut a = vec![1, 2, 3];\n    a.push(4);\n    // 这以后就是只读的了. 可以称为冻结\n    let a = a;\n}\n\nfn main() {\n    // 不可变\n    let a = vec![1, 2, 3];\n    // 通过获取所有权, 这里又可以变成可变\n    let mut a = a;\n    a.push(4);\n}",
    "crumbs": [
      "核心基础",
      "基础篇",
      "快速入门"
    ]
  },
  {
    "objectID": "docs/basic/quick-start.html#原生类型",
    "href": "docs/basic/quick-start.html#原生类型",
    "title": "rust 快速入门",
    "section": "4 原生类型",
    "text": "4 原生类型\n\nprimitive type\n\n\n4.1 标量类型\n\nscalar type\n\n\n\n\n\n\n\nTip\n\n\n\n标量类型是指那些不可再分的、基本的、单个值的数据类型。 标量类型通常用于存储单一的数据项，如一个数字、一个字符或一个布尔值。 与标量类型相对的是复合数据类型，如数组、列表、对象和结构体，这些类型可以包含多个值\n\n\n\n4.1.1 整型\n\n介绍一些方法\n\n\nuse std::mem;\nfn main() {\n    // 有符号 i8 i16 i32 i64 i128 isize(根据系统架构决定)\n    // 无符号 u8 u16 u32 u64 u128 usize(根据系统架构决定)\n    let a=6;  // 不写类型,默认就是i32\n    // 打印i32类型的大小\n    println!(\"{}\",mem::size_of::&lt;i32&gt;());\n    // 打印变量占用的内存大小\n    println!(\"{}\",mem::size_of_val(&a));\n    let mut inferred_type = 12; // 根据下一行的赋值推断为 i64 类型\n    inferred_type = 4294967296i64;\n    // 十进制 2_100  下划线只是为了增加可读性, 这里相当于美国的千位加,的意思\n    let b:i32=2_100;\n    println!(\"{}\",b);\n    // hex 16进制 0x 开头\n    let c:i32=0xff;\n    println!(\"{}\",c);\n    // 八进制 0o 开头\n    let d:i32=0o12;\n    println!(\"{}\",d);\n    // 二进制\n    let e:i32=0b1111_0000;\n    println!(\"{}\",e);\n    // byte \n    let f:u8=b'A';\n    println!(\"{}\",f);  \n    // 可以使用类型后缀, 在值后边写上\n    let g=5i16;\n    println!(\"{}\",g);\n}\n\n\nfn main() {\n    println!(\"{}\", i32::MAX); // i32最大值\n    println!(\"{}\", 2_u16.pow(4)); // 求指数幂\n    println!(\"{}\", (-4_i32).abs()); // 求绝对值\n    println!(\"{}\", 0b0011_1101_u8.count_ones()); // 位计数(多少个1)\n    // 可以使用这种方式来调用方法\n    println!(\"{}\", i32::abs(-4));\n    println!(\"{}\", i8::count_zeros(0b0011_1101));\n\n    // Checked_ 操作返回一个结果的 Option 值：如果运算结果可以被结果类型正确表示就返\n    // 回 Some(v)，否则返回 None\n    assert_eq!((10_u8).checked_add(20), Some(30));\n    assert_eq!((100_u8).checked_add(200), None);\n\n    // wrapping_ 的结果是对 2的8次方 256的取模得到的余数\n    assert_eq!(16_u8.wrapping_mul(15), 240);\n    assert_eq!(18_u8.wrapping_mul(15), 14);\n\n    // 有符号数的操作可能会回环成负数。\n    // 0111 1111 + 1  =&gt;1000 0000 补码的 -128\n    assert_eq!(127_i8.wrapping_add(1), -128);\n    // 0111 1111 + 1+1  =&gt; 补码 1000 0001 =&gt; 反码:1000 0000 ==&gt; 1111 1111 原码\n    assert_eq!(127_i8.wrapping_add(2), -127);\n\n    // 在移位操作中，移动的位数会回环到该类型的位数之内\n    // 因此对 8位的数字移动 9位等于移动 1位\n    // 0000 0101 相当于左移 1位=&gt; 0000 1010\n    assert_eq!(5_i8.wrapping_shl(9), 10);\n\n    // Saturating_ 操作会返回最接近正确结果的表示,结果被“截断”到这个类型能表示的最大或最小值\n    assert_eq!(127_i8.saturating_add(1), 127);\n\n    // Overflowing_ 操作返回一个 tuple (result, overflowed)，其中result 是回环版本的方法\n    // 返回的结果，而 overflowed 是一个指示是否发生溢出的 bool 值：\n    assert_eq!(255_u8.overflowing_sub(2), (253, false));\n    assert_eq!(255_u8.overflowing_add(2), (1, true));\n    // 只有当位移距离大于等 于类型的位宽度时 overflowed 才为 true\n    // 实际的移位距离等于要求的距离对位宽度取余后的结果\n    // 0000 0101 相当于左移1位 (9%8)=&gt; 0000 1010\n    assert_eq!(5_u8.overflowing_shl(9), (10, true));\n    // 0000 0101 左移6位=&gt; 1 0100 0000: 64\n    assert_eq!(5_u8.overflowing_shl(6), (64, false));\n    // is_numeric 数字,字符0-9 , 还有这以外,也有是数字的\n    println!(\"{}\", '①'.is_numeric());  //true\n}\n\n\n\n\n\n4.1.2 浮点数\n\n介绍一些方法提供的一些常量\n\n\nfn main() {\n    let x = 2.0; // 不写类型,默认就是f64\n    let y: f32 = 3.0; // f32\n    // 科学计数法\n    let a = 1e6; // f64类型\n    let b = 7.6e-4; // f64类型\n    println!(\"a is {}\", a);\n    println!(\"a is {}\", b);\n}\n\n\nfn main() {\n    // 平方根\n    println!(\"{}\", 8f32.sqrt());\n    println!(\"{}\", 8.2f32.floor()); // 8\n    println!(\"{}\", 8.9f32.floor()); // 8\n    println!(\"{}\", (-8.9f32).floor()); // -9\n    // 方法调用的优先级高于前缀运算符，因此对负数调用方法时确保要用括号括起来\n    println!(\"{}\", -8.9f32.floor()); // -8\n    println!(\"{}\", 8.2f32.round()); // 8\n    println!(\"{}\", 8.5f32.round()); // 9\n}\n\n\nuse std::f32::consts;\nfn main() {\n    // rust 提供了一些常量, 比如 PI\n    println!(\"{}\", consts::PI);\n}\n\n\n\n\n\n4.1.3 bool\nfn main() {\n    let t = true;\n    println!(\"{t}\");\n    // 同样必须初始化,否则报错\n    let f: bool = false;\n    println!(\"{f}\"); // false\n    // bool 可以转 整型\n    let d = false as i8;\n    println!(\"{d}\"); // 0\n    // 整型不能转 bool\n    //    let c = 1i8 as bool;\n}\n\n\n4.1.4 char\n\n\n\n\n\n\nTip\n\n\n\nchar 设计的目的是用来存储任何一个unicode 字符, 所以它的大小是4个字节\n\n\nuse std::mem;\n\nfn main() {\n    let c = 'z'; // 这个是字符, 和前面 b'z' 是整型不同哦\n    println!(\"{}\", mem::size_of_val(&c)); // 4\n    let z: char = 'ℤ';\n    println!(\"{c}-{z}\");\n    // rust 中的char 是 4个字节,Unicode, 可以表示表情\n    let heart_eyed_cat = '😻';\n    println!(\"{heart_eyed_cat}\");\n\n    let a = 'a';\n    println!(\"{}\", a as u8); // 97\n    // 标准库提供了函数 std::char::from_u32 接受\n    // 任何 u32 值，并返回 Option&lt;char&gt;：\n        // 如果 u32 的值不是合法的 Unicode 码点，from_u32 会返回 None；\n        // 否则，它会返回 Some(c)，c 就是作为转换结果的 char\n    let hex_char = char::from_u32(97);\n    println!(\"{:?}\", hex_char);\n\n    let tr = '\\n';  // 换行\n    let good = '\\u{597D}'; // 好 unicode\n    println!(\"world {} {}\", tr, good);\n\n    let a = 'c';\n    println!(\"{}\", a.is_alphabetic()); // 是否为字母\n    let b = 'ß'; // 这个是非 ASCII 字符, 很多也被认为是字母\n    println!(\"{}\", b.is_alphabetic()); // true\n}\n\n\n\n4.2 复合类型\n\ncompound type\n\n\n4.2.1 tuple\nfn main() {\n    // 元素可以是多个,且可以是不同的类型, 确定后, \n    // 该元组tup 的类型是(i32, f64, u8),它的大小就固定了\n    let tup: (i32, f64, u8) = (100, 3.14, 2);\n    println!(\"{},{},{}\", tup.0, tup.1, tup.2);\n    let (x, y, z) = tup;\n    println!(\"{},{},{}\", x, y, z);\n}\nuse std::any::type_name;\n\nfn print_type_of&lt;T&gt;(_: &T) {\n    println!(\"{}\", type_name::&lt;T&gt;());\n}\nfn main() {\n    let a = (1,);\n    println!(\"{}\", a.0);\n    let b = (1);\n    print_type_of(&b);\n    // 单元类型,虽然是个元组, 一般会认为它不是复合类型\n    // 函数那里会讲到\n    let c = ();\n}\n\n\n4.2.2 数组\n\n\n\n\n\n\nTip\n\n\n\n\n元素类型必须一致\n长度是固定的,运行时不能修改, 长度是类型的一部分\n表示方法: [T;n] T表示泛型,后面会说, 这里就理解为数组元素的类型, n 表示元素个数\n数组是在栈上分配的单个块的内存\n常用于开辟一个固定大小的Buffer作为缓冲区,比如接收IO输入输出等\n等学了所有权之后,我们知道把数组作为参数传递给函数,是直接复制一份给函数参数,而不是我们某些其他语言里传递指针\n\n\n\nfn main() {\n    let x = [1, 2, 3, 4];  // 默认类型是[i32; 4]\n    println!(\"{}\", x[1]);\n    // [i32;5] 表示每个元素是i32,一共有5个元素\n    let x: [i32; 5] = [1, 2, 3, 4, 5];\n    println!(\"{}\", x.len());\n    // 相当于 let x=[3,3,3,3,3];\n    let x = [3; 5];\n    // 下标读取\n    println!(\"{}\", x[2]);\n\n    // 空数组\n    let x: [i8; 0] = [];\n    println!(\"{}\", std::mem::size_of_val(&x)); // 0\n    // is_empty() 源码就是 判断 self.len() == 0\n    println!(\"{}\", x.is_empty()); // true\n\n    // 数组长度是类型的一部分, 只有元素类型和元素个数一样的才是同一种数组类型\n    let mut a=[1,2,3,4];\n    let b=[2,3,4,5];\n    a=b; // ok\n\n    unsafe {\n        // 可以去看unsafe 章节\n        // 数组的裸指针,类型是数组元素类型 这里是i32\n        let ptr = a.as_ptr();\n        println!(\"{:p}-{:p}\", a.as_ptr(), &a);\n        println!(\"{}-{}\", *ptr, *ptr.wrapping_add(1))\n    }\n}\n\n\n\n\n\n\nCaution\n\n\n\n\n数组不鼓励用索引进行操作, 因为我们知道每次索引操作都会进行边界检查,看不是是溢出了,效率略有影响\n推荐后面说到的迭代器\n\n\n\n\n\n多维数组\n\nfn main() {\n    let x: [[i32; 2]; 5] = [[1, 11], [2, 22], [3, 33], [4, 44], [5, 55]];\n    for i in &x {\n        println!(\"x {:?}\", i);\n    }\n}\n\n\n\n4.2.3 切片\n\n\n\n\n\n\nNote\n\n\n\n\n医学上切片的意思是将组织样本切成薄片以便于在显微镜下观察,可以说切片是原物品的一部分\n编程上切片的意思: 原数据一段连续部分的引用,不难推断出它的数据结构是一个原数据的地址和引用的长度\n\n\n\nuse std::mem;\nfn main() {\n    let mut x = [1, 2, 3];\n    println!(\"{}\", mem::size_of_val(&x));  // 12\n    println!(\"{:p}\", x.as_ptr());\n    // 切片是对一块连续内存数据的引用\n    // 由2个部分组成, 一个是data指向数据,一个len 表示长度\n    // 这种比一般指针要多出一些信息的叫 胖指针\n    let y = &mut x[1..3];\n    println!(\"{:p}\", y.as_ptr());\n    println!(\"{}\", y.len());\n    println!(\"{}\", mem::size_of_val(&y));  // 16\n\n    let x = [1, 2, 3, 4, 5];\n    let (a, b) = x.split_at(2);\n    println!(\"{:?}\", a); // [1,2]\n    println!(\"{:?}\", b); // [3,4,5]\n}\n// &[T] 切片的表示方式\nfn analyze_slice(slice: &[i32]) {\n    println!(\"First element of the slice: {}\", slice[0]);\n    println!(\"The slice has {} elements\", slice.len());\n}\nfn main() {\n    let x: [i32; 5] = [2, 1, 4, 3, 5];\n    let y = &x[1..3];\n    analyze_slice(&y);\n\n    let mut chaos = [3, 5, 4, 1, 2];\n    //这里会隐式的把数组的引用转换为切片\n    chaos.sort();\n    println!(\"{:?}\", chaos);\n    chaos.reverse();\n    println!(\"{:?}\", chaos);\n\n    let x: [i32; 5] = [2, 1, 4, 3, 5];\n    // 也是隐式地转换为切片类型,才会可以for 循环\n    for i in &x {\n        println!(\"x {}\", i);\n    }\n}",
    "crumbs": [
      "核心基础",
      "基础篇",
      "快速入门"
    ]
  },
  {
    "objectID": "docs/basic/quick-start.html#类型转换",
    "href": "docs/basic/quick-start.html#类型转换",
    "title": "rust 快速入门",
    "section": "5 类型转换",
    "text": "5 类型转换\n\n\n\n\n\n\nImportant\n\n\n\n\nRust 不提供原生类型 之间的隐式类型转换(coercion),但可以使用 as 关键字进行显式类型转换(casting)\nrust 是静态强类型, 需要显示表明你要转换的类型\n\n\n\n\n5.1 as\nfn main() {\n    let a: i8 = 9;\n    // 需要加上 as, 否则报错\n    let b: i32 = a as i32;\n    println!(\"{}\",b);\n}\n\n\n5.2 transmute\n\n\n\n\n\n\nCaution\n\n\n\n不安全的转换, 需要 unsafe\n\n\n\nuse std::mem;\nuse std::any::type_name;\n\nfn print_type_of&lt;T&gt;(_: &T) {\n    println!(\"{}\", type_name::&lt;T&gt;());\n}\nfn main() {\n    // 这个元素的类型会根据你后面的transmute 里的src-type 来推断\n    // 之前在数组那里我们了解到  let x = [1, 2, 3, 4]; =&gt; 默认类型是[i32; 4]\n    let raw_bytes = [1, 2, 3, 4];\n    print_type_of(&raw_bytes);\n    // transmute::&lt;src-type, dst-type&gt;(src:src-type)\n    let num = unsafe { std::mem::transmute::&lt;[u8; 4], u32&gt;(raw_bytes) };\n    // 100 00000011 00000010 00000001\n    println!(\"{:b}\", num);\n    println!(\"{}\", num); // 67305985\n    let num = 67305985u32;\n    let r = unsafe { std::mem::transmute::&lt;u32, [u8; 4]&gt;(num) };\n    println!(\"{:?}\", r);  // [1, 2, 3, 4]\n}\n指针类型转换\nfn main() {\n    let a = 67109377;\n    // 将变量a的地址 转换为一个指针 ,指针类型是i32,这个就是a原来的内存读取方式\n    // 然后再将这个指针 进行类型转换, 转换为 数组的方式来读取 a 所在的那块内存\n    let r1 = &a as *const i32 as *mut [i8; 4];\n    unsafe {\n        println!(\"{:?}\", (*r1));\n        (*r1)[0] = 5;\n        println!(\"{:?}\", (*r1));\n        println!(\"{}\", a);\n    }\n}\n\n\n\n\n\n\nWarning\n\n\n\n下面这个操作, 没有得到你想要的结果, 元组可能因为内存对齐的原因, a的前2个字节组成元组的第二个元素, 看看就好.\n\n\nfn main() {\n    let a = 67244033i32;\n    //用 元组的形式区读取原本 a的那块内存\n    let d = unsafe { std::mem::transmute::&lt;&i32, &(i8, i16, i8)&gt;(&a) };\n    println!(\"{:?}\", d);\n}\n\n\n可变转换,然后可如此这般修改原来的数据\n\nfn main() {\n    let mut a = 67244033i32;\n    //用 元组的形式区读取原本 a的那块内存\n    let d = unsafe { std::mem::transmute::&lt;&mut i32, &mut [i8; 4]&gt;(&mut a) };\n    println!(\"{:?}\", d); // [1, 16, 2, 4]\n    d[0] = 3;\n    println!(\"{:?}\", d); // [3, 16, 2, 4]\n    println!(\"{}\", a); //67244035\n}\n\n\n\n5.3 使用trait\n直接看 类型转换相关trait",
    "crumbs": [
      "核心基础",
      "基础篇",
      "快速入门"
    ]
  },
  {
    "objectID": "docs/basic/quick-start.html#类型别名",
    "href": "docs/basic/quick-start.html#类型别名",
    "title": "rust 快速入门",
    "section": "6 类型别名",
    "text": "6 类型别名\n// 定义一个类型别名\n// 这使得代码更加简洁,更具可读性, 因为 Coordinates 比 (f64, f64) 更能表达其用途\ntype Coordinates = (f64, f64);\n\n// 使用类型别名\nfn calculate_distance(point1: Coordinates, point2: Coordinates) -&gt; f64 {\n    let (x1, y1) = point1;\n    let (x2, y2) = point2;\n    ((x2 - x1).powi(2) + (y2 - y1).powi(2)).sqrt()\n}\n\nfn main() {\n    let point_a: Coordinates = (0.0, 0.0);\n    let point_b: Coordinates = (3.0, 4.0);\n    let distance = calculate_distance(point_a, point_b);\n    println!(\"距离: {}\", distance);\n}\nfn main() {\n    // 类型别名\n    // 让类型含义更加的有意义\n    type Kilometers = i32;\n\n    let x: i32 = 5;\n    let y: Kilometers = 5;\n    // 实际还是是i32 所以可以 +\n    println!(\"x + y = {}\", x + y);\n}\n\n\n\n\n\n\nCaution\n\n\n\n下面几个例子,有些知识点在后续介绍\n\n\n减少重复代码, 让代码更简洁\n    type Thunk = Box&lt;dyn Fn() + Send + 'static&gt;;\n\n    let f: Thunk = Box::new(|| println!(\"hi\"));\n\n    fn takes_long_type(f: Thunk) {\n        // --snip--\n    }\n\n    fn returns_long_type() -&gt; Thunk {\n        // --snip--\n    }\n我们可以看到 Result&lt;usize, Error&gt; 类似这样的很多, 都要写Error\nuse std::fmt;\nuse std::io::Error;\n\npub trait Write {\n    fn write(&mut self, buf: &[u8]) -&gt; Result&lt;usize, Error&gt;;\n    fn flush(&mut self) -&gt; Result&lt;(), Error&gt;;\n\n    fn write_all(&mut self, buf: &[u8]) -&gt; Result&lt;(), Error&gt;;\n    fn write_fmt(&mut self, fmt: fmt::Arguments) -&gt; Result&lt;(), Error&gt;;\n}\nfn main() {}\n使用别名后的情况\nuse std::fmt;\n// std::io 中有这样一个别名\n// 标准库中类似这样的别名设计有还多\n// type Result&lt;T&gt; = std::result::Result&lt;T, std::io::Error&gt;;\n\n// 我们本地这样设计一个别名, 就不用每次 都写上Error\ntype Result&lt;T&gt; = std::io::Result&lt;T&gt;;\npub trait Write {\n    fn write(&mut self, buf: &[u8]) -&gt; Result&lt;usize&gt;;\n    fn flush(&mut self) -&gt; Result&lt;()&gt;;\n\n    fn write_all(&mut self, buf: &[u8]) -&gt; Result&lt;()&gt;;\n    fn write_fmt(&mut self, fmt: fmt::Arguments) -&gt; Result&lt;()&gt;;\n}\nfn main() {}",
    "crumbs": [
      "核心基础",
      "基础篇",
      "快速入门"
    ]
  },
  {
    "objectID": "docs/basic/quick-start.html#静态变量",
    "href": "docs/basic/quick-start.html#静态变量",
    "title": "rust 快速入门",
    "section": "7 静态变量",
    "text": "7 静态变量\n\n\n\n\n\n\nImportant\n\n\n\n\n使用 static ,一般在所有其他作用域之外声明, 作为全局变量\n\n\n\n\n\n不可变静态变量\n\nstruct Animal {\n    age: i32,\n}\nimpl Drop for Animal {\n    fn drop(&mut self) {\n        println!(\"animal 离开作用域了...{}\", self.age);\n    }\n}\nfn main() {\n    let a = 22;\n    {\n        // 申明时必须初始化,必须指定类型\n        static b: Animal = Animal { age: 11 };\n    }  // 不会调用 drop , 虽然无法访问b, 但是它不会被释放内存\n    let c = 11;\n    println!(\"{}\", a);\n    {\n        let d = Animal { age: 100 };\n    } // 这个会调用drop\n    println!(\"{}\", c);\n}\n\n\n\n可变的静态变量,修改需要unsafe\n\nstatic mut COUNTER: u32 = 0;\nfn add_to_count(inc: u32) {\n    unsafe {\n        COUNTER += inc;\n    }\n}\n\nfn main() {\n    add_to_count(3);\n\n    println!(\"COUNTER: {}\", unsafe { COUNTER });\n}\n\nstatic mut COUNTER: u32 = 22;\nconst COUNTER2: i32 = 11;\nstatic mut S1: &str = \"hello\";\nconst S2: &str = \"world\";\n\nfn main() {\n    println!(\"{:p}\", &COUNTER2);\n    unsafe {\n        println!(\"{:p}\", &COUNTER);\n    }\n    unsafe {\n        let s11 = S1.as_ptr(); // *const u8\n        println!(\"S1 指向的字符所在内存地址: {:p}\", s11);\n        println!(\"{}\", *s11); // 第一个h 字符\n        S1 = \"world\";\n        let s11 = S1.as_ptr();\n        // let s11 = S1.as_ptr() as *mut u8;\n        println!(\"S1 新指向的字符所在内存地址: {:p}\", s11);\n        println!(\"{}\", *s11);\n        let s22 = S2.as_ptr();\n        println!(\"S2 指向的字符所在内存地址:{:p}\", s22);\n    }\n}\n如果需要第一次使用才去初始化的静态变量 ,可以使用库once_cell,lazy_static",
    "crumbs": [
      "核心基础",
      "基础篇",
      "快速入门"
    ]
  },
  {
    "objectID": "docs/basic/quick-start.html#常量",
    "href": "docs/basic/quick-start.html#常量",
    "title": "rust 快速入门",
    "section": "8 常量",
    "text": "8 常量\n\n\n\n\n\n\nImportant\n\n\n\n\n常量是在编译期就进行求值的. 所以常量 = 的右边是可以使用表达式的\n常量在编译过程中会被内联优化,这个表示每个使用常量的地方都会直接替换为常量的值(如果没记错的话, 可类比汇编中的立即数..),不会占用内存\n因此修改常量的值本身就没有意思\n\n\n\nconst A: u32 = 60 * 60 * 3;\n\nfn main() {\n    // 一般用大写并且下划线来申明常量\n    // 不可修改, 不可shadowing\n    // 不可以使用mut,永远不可变\n    // 可以在任何作用域申明\n    const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;\n    println!(\"{}\", THREE_HOURS_IN_SECONDS);\n}\n\n\nconst fn\n\n// 编译期执行\nconst fn g() -&gt; i32 {\n    // 返回值视为常量\n    10 * 20\n}\nconst A: i32 = g();\nfn main() {\n    println!(\"{}\", A);\n}",
    "crumbs": [
      "核心基础",
      "基础篇",
      "快速入门"
    ]
  },
  {
    "objectID": "docs/basic/quick-start.html#函数",
    "href": "docs/basic/quick-start.html#函数",
    "title": "rust 快速入门",
    "section": "9 函数",
    "text": "9 函数\n\n\n\n\n\n\nTip\n\n\n\n\n语句: 执行动作, 没有返回值\n表达式: 是有一个值的\n函数体是由一系列语句和一个结尾(可以是语句或者表达式)组成\nunit type 单元类型 () 表示一种类型. 表示没有什么特殊的价值, 它的值就是它本身 也是()\n\n\n\n\n9.1 返回值\nfn five() -&gt; i32 {\n    // 表达式 ,值为5\n    5\n}\n\nfn main() {\n    let x = five();\n\n    println!(\"The value of x is: {x}\");\n}\n添加;号试试, 会直接报错提示 期望i32, 而实际发现是the unit type ()\n// -&gt; i32 , 表示返回值类型\nfn five() -&gt; i32 {\n    5;\n}\n我们将上面的返回值类型改成 () , 这样就不会报错了\nfn five() -&gt; () {\n    5;\n}\n实际上就是不用写返回值 的类型\n// 没有指明返回值的, 那么返回值类型就是 unit type :()\nfn five(){\n    5;\n}\nfn main() {\n    // 单元值判断\n    if five() == () {\n        // ok的\n        println!(\"ok\");\n    }\n}\nfn t() {\n    // 这里返回了5, 要求的是(),所以会提示错误\n    5\n}\n\n\n9.2 函数作为参数\nfn calc(m: fn(u32, u32) -&gt; u32, a: u32, b: u32) {\n    println!(\"add result: {}\", m(a, b));\n}\nfn add(a: u32, b: u32) -&gt; u32 {\n    a + b\n}\nfn main() {\n    calc(add, 1, 2);\n}\n\n\n9.3 函数作为返回值\n\n// 传入字符串:函数名,获取函数\nfn calc(m: &str) -&gt; fn(u32, u32) -&gt; u32 {\n    match m {\n        \"add\" =&gt; add,\n        _ =&gt; unimplemented!(),\n    }\n}\nfn add(a: u32, b: u32) -&gt; u32 {\n    a + b\n}\n\nfn main() {\n    let f = calc(\"add\");\n    let r = f(1, 2);\n    println!(\"{}\", r);\n}\n\n\n9.4 函数内部创建函数\nfn main() {\n    // 函数内部可以定义函数\n    fn add(t1: i32, t2: i32) -&gt; i32 {\n        t1 + t2\n    }\n    let r = add(1, 2);\n    print!(\"{}\", r);\n}\n\n\n9.5 函数的类型\nfn add1(t: (i32, i32)) -&gt; i32 {\n    t.0 + t.1\n}\n// 实际看来 与add1 参数一样\nfn add2((t1, t2): (i32, i32)) -&gt; i32 {\n    t1 + t2\n}\nfn main() {\n    let a = 1;\n    let b = 2;\n    let c = (1, 2);\n    println!(\"{}\", add1(c));\n    println!(\"{}\", add2((a, b)));\n\n    // f1的类型是 fn (t: (i32, i32)) -&gt; i32\n    let f1 = add1;\n    // 报错了 expected fn item, found a different fn item\n    // 不同的类型, 所以报错了.\n    // f1 = add2;\n\n    // 正确的方式是 定义变量时将 他的类型转换为 fn item 通用的fn 类型\n    let f1 = add1 as fn((i32, i32)) -&gt; i32;\n    println!(\"{}\", f1((1, 2)));\n\n    // 这样定义也可以\n    let mut f1: fn((i32, i32)) -&gt; i32 = add1;\n    f1 = add2; // 不会报错了\n    println!(\"{}\", f1((a, b)));\n}\n\n\n9.6 发散函数\n\ndiverging functions\n\n返回值是 ! ,被称为 The Never Type\n我们知道前面提到的函数其实都是有返回值, 即使是没有返回值的函数, 也会返回一个 () 单元类型的值:()\n那么一个 永远不会返回的函数它有返回值吗? 还有 panic 这种函数呢?\nfn main() {\n    let a = bar();\n    a=2;// 虽然不会执行到这里, 但是编译器不会报错\n    println!(\"{}\", a);\n}\n// 返回 ! never type\nfn bar() -&gt; ! {\n    // 永远不会返回,但是有rust 设计它有返回值, 类型是!\n    loop {\n        print!(\"and ever \");\n    }\n}\n\nfn foo() -&gt;!{\n    panic!(\"error\");\n}\n\n9.6.1 为什么需要发散类型\n下面我们都知道会报错\nfn main() {\n    let guess = \"42\";\n    let guess = match guess.trim().parse() {\n        Ok(_) =&gt; 5,\n        Err(_) =&gt; \"hello\", // 报错了\n    };\n}\n下面这个没有报错\nfn main() {\n    let r = bar();\n}\nfn bar() -&gt; ! {\n    let guess = \"42\";\n    loop {\n        let guess = match guess.trim().parse::&lt;i32&gt;() {\n            Ok(_) =&gt; 5,\n            // ! 发散类型可以被转换为任何类型\n            Err(_) =&gt; continue, \n        };\n    }\n}\nfn main() {\n    let r = bar(0);\n    println!(\"{:?}\", r);\n}\nfn bar(x: i32) -&gt; i32 {\n    if x == 0 {\n        // 这里panic 了, 但是函数没有报错\n        panic!(\"no 0\");\n    } else {\n        x * 2\n    }\n}",
    "crumbs": [
      "核心基础",
      "基础篇",
      "快速入门"
    ]
  },
  {
    "objectID": "docs/basic/quick-start.html#控制流程",
    "href": "docs/basic/quick-start.html#控制流程",
    "title": "rust 快速入门",
    "section": "10 控制流程",
    "text": "10 控制流程\n\n10.1 if\nfn main() {\n    let number = 3;\n    // 报错的, 需要bool类型\n    if number {\n        println!(\"number was three\");\n    }\n\n    let condition = true;\n    // 当成 三元 运算, 实际上这里的表达更加清晰,一看就明白\n    // 而三元运算你是需要稍微学习或者说记一下\n    // 这也是有些语言它不去支持三元运算的原因\n    let number = if condition { 5 } else { 6 };\n\n    println!(\"The value of number is: {number}\");\n    let number2 = if condition {\n        5;\n        7  // 还是看的返回值\n    } else {\n        6\n    };\n\n    println!(\"The value of number is: {number2}\");\n\n    // 报错\n    let number3 = if condition { 5 } else { \"six\" };\n}\n\n\n10.2 loop\nfn main() {\n    let mut i = 0;\n    let ret = loop {\n        i += 1;\n        if i &gt; 10 {\n            break i; // 返回值, 就是loop的返回值\n        }\n    };\n    println!(\"{}\", ret)\n\n    let y: i32;\n    // 编译器是能够判断出 后面的打印时, y肯定已经赋值了.\n    let x = loop {\n        y = 1;\n        break;\n    };\n    println!(\"{:?}\", x);\n    println!(\"{:?}\", y);\n}\n跳出多层 loop\n#![allow(unreachable_code, unused_labels)]\nfn main() {\n    'outer: loop {\n        println!(\"Entered the outer loop\");\n\n        'inner: loop {\n            println!(\"Entered the inner loop\");\n            // This would break only the inner loop\n            //break;\n            // This breaks the outer loop\n            break 'outer;\n        }\n        println!(\"This point will never be reached\");\n    }\n    println!(\"Exited the outer loop\");\n}\n\n\n10.3 for\n\n\n\n\n\n\nCaution\n\n\n\n\nfor 循环是利用迭代器对数据进行遍历的,参考后面迭代器章节\n标签 label的使用方式与loop一样\n\n\n\nfn main() {\n    // label 前面有个 ' 单引号\n    'outer: for i in 0..5 {\n        println!(\"Outer loop value: {}\", i);\n\n        for j in 0..5 {\n            println!(\"Inner loop value: {}\", j);\n\n            if i == 2 && j == 3 {\n                break 'outer;\n            }\n        }\n    }\n\n    let a = [10, 20, 30, 40, 50];\n\n    for element in a {\n        println!(\"the value is: {element}\");\n    }\n\n    // (1..4)  1 2 3\n    // 会提示不需要 用 () 将1..4 阔气来\n    for number in (1..4) {\n        println!(\"{number}!\");\n    }\n    // 不包含4\n    for number in 1..4 {\n        println!(\"{number}!\");\n    }\n    // =4 包含4\n    for number in 1..=4 {\n        println!(\"{number}\");\n    }\n\n    for number in 1.. {\n        if number == 10 {\n            break;\n        }\n        println!(\"{}\", number);\n    }\n\n    use std::ops::Range;\n    let a = Range { start: 1, end: 10 };\n    for j in a {\n        println!(\"{}\", j);\n    }\n    // x 实际上是一个RangeFrom&lt;i32&gt; 类型\n    // 0..5 这种实际就是一个语法糖\n    let x = (0..);\n    // x 实际为Range类型\n    let x = (0..5);\n}\n数组来测试 range\n\n#[cfg(test)] //配置测试模块\nmod abc {\n    #[test] //单元测试用例\n    fn it_works() {\n        let result = 2 + 2;\n        assert_eq!(result, 4);\n    }\n    #[test]\n    fn arr_range() {\n        let arr = [0, 1, 2, 3, 4];\n        assert_eq!(arr[..], [0, 1, 2, 3, 4]);\n        assert_eq!(arr[..3], [0, 1, 2]);\n        assert_eq!(arr[..=3], [0, 1, 2, 3]);\n        assert_eq!(arr[1..], [1, 2, 3, 4]);\n        assert_eq!(arr[1..3], [1, 2]); // This is a `Range`\n        assert_eq!(arr[1..=3], [1, 2, 3]);\n        assert_eq!((3..5), std::ops::Range { start: 3, end: 5 });\n    }\n}\n\n\n10.4 while\nfn main() {\n    let z: i32;\n    while true {\n        z = 1;\n        break;\n    }\n    // 打印这个的时候, 编译器无法直到 z到底是不是赋值了,\n    // 因为他认为while 能否进去是要判断的,\n    // 当然我们一看就知道是true 能进去,但是编译器不行\n    // 相比while loop 肯定是能进去的.\n    println!(\"{}\", z); //报错了\n}",
    "crumbs": [
      "核心基础",
      "基础篇",
      "快速入门"
    ]
  },
  {
    "objectID": "docs/basic/quick-start.html#测试",
    "href": "docs/basic/quick-start.html#测试",
    "title": "rust 快速入门",
    "section": "11 测试",
    "text": "11 测试\n#[cfg(test)]  //配置测试模块\nmod tests {\n    #[test]  //单元测试用例\n    fn it_works() {\n        let result = 2 + 2;\n        assert_eq!(result, 4);\n    }\n    // 再来一个测试用例\n    #[test]\n    fn it_works2() {\n        let result = 2 + 2;\n        assert_eq!(result, 4);\n    }\n}\ncargo test",
    "crumbs": [
      "核心基础",
      "基础篇",
      "快速入门"
    ]
  },
  {
    "objectID": "docs/basic/quick-start.html#查看汇编",
    "href": "docs/basic/quick-start.html#查看汇编",
    "title": "rust 快速入门",
    "section": "12 查看汇编",
    "text": "12 查看汇编\nrustc --emit=asm main.rs\nrustc -C debuginfo=1 -o output.s --emit asm -Cllvm-args=--x86-asm-syntax=intel --crate-type rlib  --edition 2021 src/main.rs\nrust-lang playground里可以选择asm 查看  godbolt",
    "crumbs": [
      "核心基础",
      "基础篇",
      "快速入门"
    ]
  },
  {
    "objectID": "docs/basic/quick-start.html#打印信息",
    "href": "docs/basic/quick-start.html#打印信息",
    "title": "rust 快速入门",
    "section": "13 打印信息",
    "text": "13 打印信息\n\n13.1 打印变量大小\nfn main() {\n    let a = 6;\n    println!(\"{}\", std::mem::size_of::&lt;i32&gt;());\n    // 打印变量占用的内存大小\n    println!(\"{}\", std::mem::size_of_val(&a));\n}\n\n\n13.2 打印变量类型名\nuse std::any::type_name;\n\nfn print_type_of&lt;T&gt;(_: &T) {\n    println!(\"{}\", type_name::&lt;T&gt;());\n}\n\nfn main() {\n    let x = 42;\n    print_type_of(&x); // 输出: i32\n\n    let y = 3.14;\n    print_type_of(&y); // 输出: f64\n\n    let z = \"hello\";\n    print_type_of(&z); // 输出: &str\n}\n\n\n13.3 常用打印\n\nformat!: 格式化文本到 String\nprint!: 同format! 只不过输出到 (io::stdout).\nprintln!: 同print! 但是换行\neprint!: 同 print! 只不过输出到 (io::stderr).\neprintln!: 同eprint! 但是换行\n\nfn main() {\n    println!(\"{} days\", 31);\n    // 多个可以使用 0 1 指定\n    println!(\"{0}, this is {1}. {1}, this is {0}\", \"Alice\", \"Bob\");\n    let x = \"Alice\";\n    let y = \"Bob\";\n    println!(\"{x}, this is {y}. {y}, this is {x}\");\n    println!(\"{a}, this is {b}. {b}, this is {a}\", a = \"Alice\", b = \"Bob\");\n    println!(\"Base 10:               {}\", 69420); // 69420\n    println!(\"Base 2 (binary):       {:b}\", 69420); // 10000111100101100\n    println!(\"Base 8 (octal):        {:o}\", 69420); //八进制: 207454\n    println!(\"Base 16 (hexadecimal): 0x{:x}\", 69420); //16进制: 10f2c\n    println!(\"Base 16 (hexadecimal): 0x{:X}\", 69420); //大写16进制: 10F2C\n    println!(\"科学计数法: {:e}\", 10000i32); // 1e4\n    println!(\"科学计数法 大写: {:E}\", 10000i32); // 1E4\n    println!(\"带换行和缩进的debug打印: {:#?}\", [1, 2, 3]);\n    println!(\"debug打印: {:?}\", [1, 2, 3]);\n    // &gt; 表示往右对齐,那么就是左边填充\n    println!(\"|{number:&gt;5}|\", number = 1); // 没写表示用空格填充, 4个空格 和一个1\n    println!(\"{number:0&gt;5}\", number = 1); // 用0填充 :   00001\n    println!(\"{number:0&lt;5}\", number = 1); // 用0填充 :   10000\n    // 注意 需要 $\n    println!(\"{number:0&gt;width$}\", number = 1, width = 5);\n\n\n    let number: f64 = 1.0;\n    let width: usize = 5;\n    println!(\"{number:&gt;width$}\");\n\n    // 浮点数 四舍五入\n    println!(\"Dog: {:.3} \", 1.12385); // 1.124\n}\n\n\n13.4 Debug\n\n\n\n\n\n\nTip\n\n\n\n\n所有实现了fmt::Debug这个trait(暂时不用管这个概念)的类型,才能使用println!(\"{:?}\")中{:?}或{:#?}这种打印方式\n可自动推导,使用 #[derive(Debug)]\n\n\n\nstruct Cat(i32);\n\n#[derive(Debug)] // 添加这个就自动实现了Debug trait\nstruct Dog(i32);\nfn main() {\n    println!(\"Cat: {:?} \", Cat(5)); // 报错了\n    println!(\"Dog: {:?} \", Dog(5)); // ok\n    // 使用这种 {0:?}  {dog:?}\n    println!(\"Dog: {0:?} {dog:?}\", Dog(5), dog = Dog(8));\n}\n\n\n13.5 Display\n\n\n\n\n\n\nTip\n\n\n\n\n所有实现了fmt::Display这个trait(暂时不用管这个概念)的类型,才能使用println!(\"{}\")中{}这种打印方式\n必须手动实现\n\n\n\nuse std::fmt;\nstruct Point2D {\n    x: f64,\n    y: f64,\n}\n\n// implement `Display` for `Point2D`.\nimpl fmt::Display for Point2D {\n    fn fmt(&self, f: &mut fmt::Formatter) -&gt; fmt::Result {\n        // 这里的写法类似 println! ,根据需要自定义输出信息\n        write!(f, \"x: {}, y: {}\", self.x, self.y)\n    }\n}\nfn main() {\n    let p = Point2D { x: 3.3, y: 7.2 };\n    println!(\"p: {}\", p);\n    // 实现了Display, 就能.to_string() 获取字符串 String\n    println!(\"{}\", p.to_string());\n}",
    "crumbs": [
      "核心基础",
      "基础篇",
      "快速入门"
    ]
  },
  {
    "objectID": "docs/basic/quick-start.html#main",
    "href": "docs/basic/quick-start.html#main",
    "title": "rust 快速入门",
    "section": "14 main()",
    "text": "14 main()\n\n14.1 返回值\n\n\n\n\n\n\nImportant\n\n\n\nrust main 入口函数返回值必须实现了Termination trait, trait后面章节讲, 先理解为接口.\n\n\n\n\nstd::process::Termination\n\npub trait Termination {\n    // Required method\n    fn report(self) -&gt; ExitCode;\n}\n\n// 返回值是 (), () 是实现了Termination trait\nfn main(){\n    // 编译运行后, echo $? 结果是0\n}\nfn main() -&gt; ! {\n    // 编译运行后, echo $? 结果是1\n    std::process::exit(1);\n}\nfn main() -&gt; impl std::process::Termination {\n    std::process::ExitCode::SUCCESS\n}\n// 或者返回类型是 Result&lt;T, E&gt; where T: Termination, E: Debug \n其他实现了Termination的 : Infallible.\n\n\n从外部导入作为main方法\n\nmod foo {\n    pub fn bar() {\n        println!(\"Hello, world! rust\");\n    }\n}\n// 从外部crate 或者本地 import 为 main 方法\nuse foo::bar as main;\n// 报错, 这里会提示已经定义了main函数\n// fn main() {}\n\n\n\n14.2 命令行参数\nfn main() {\n    // ./main ac -ver 1.2\n    let args_struct = std::env::args();\n    println!(\"{:?}\", args_struct);\n    let args: Vec&lt;_&gt; = args_struct.collect();\n    println!(\"程序名: {}\", &args[0]);\n    println!(\"命令行参数: {:?}\", &args[1..]); // [\"ac\", \"-ver\", \"1.2\"]\n\n    let first_arg = match args.get(1) {\n        Some(arg) =&gt; arg,\n        None =&gt; {\n            println!(\"没有提供足够的参数\");\n            return;\n        }\n    };\n\n    let number = match first_arg.parse::&lt;i32&gt;() {\n        Ok(num) =&gt; num,\n        Err(_) =&gt; {\n            println!(\"无法将第一个参数解析为整数\");\n            return;\n        }\n    };\n\n    println!(\"第一个参数作为整数是: {}\", number);\n}\n\n\n14.3 环境变量\nfn main() {\n    // 尝试获取环境变量，如果不存在则返回错误\n    match std::env::var(\"HOME\") {\n        Ok(value) =&gt; println!(\"环境变量 HOME 的值是: {}\", value),\n        Err(e) =&gt; println!(\"无法获取环境变量 HOME: {}\", e),\n    }\n\n    // 获取所有环境变量\n    for (key, value) in std::env::vars() {\n        println!(\"{}: {}\", key, value);\n    }\n}",
    "crumbs": [
      "核心基础",
      "基础篇",
      "快速入门"
    ]
  },
  {
    "objectID": "docs/basic/quick-start.html#属性",
    "href": "docs/basic/quick-start.html#属性",
    "title": "rust 快速入门",
    "section": "15 属性",
    "text": "15 属性\n\n15.1 dead_code\n\n\n\n\n\n\nTip\n\n\n\n\n编译器 默认会对 dead_code(死代码, 无效代码) 进行检查, 这会对未使用的函数产生警告. 可以用一个属性来禁用这个检查项\n\n\n\n// 代码头部使用\n// #! 开头的 作用于整个crate\n#![allow(dead_code)]\nfn used_function() {}\n\n// # 开头的 用于模块或项, 这里是只作用于该函数\n// `#[allow(dead_code)]` 属性可以禁用 `dead_code` 检查\n#[allow(dead_code)]\nfn unused_function() {}\n\nfn noisy_unused_function() {}\n\nfn main() {\n    used_function();\n}",
    "crumbs": [
      "核心基础",
      "基础篇",
      "快速入门"
    ]
  },
  {
    "objectID": "docs/basic/trait_advanced.html",
    "href": "docs/basic/trait_advanced.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "use std::ops::Add;\n\n#[derive(Debug, Copy, Clone, PartialEq)]\nstruct Point {\n    x: i32,\n    y: i32,\n}\n// 给Point 实现Add trait, Add trait 定义了+加法 会如何操作\nimpl Add for Point {\n    type Output = Point;\n\n    fn add(self, other: Point) -&gt; Point {\n        Point {\n            x: self.x + other.x,\n            y: self.y + other.y,\n        }\n    }\n}\n\nfn main() {\n    assert_eq!(\n        Point { x: 1, y: 0 } + Point { x: 2, y: 3 },\n        Point { x: 3, y: 3 }\n    );\n}\n我们看下Add trait的定义,发现实际带有类型参数,默认值是Self\npub trait Add&lt;Rhs = Self&gt; {\n    // ...\n}\n不同类型的+ 加法重载\nuse std::ops::Add;\n\nstruct Millimeters(u32);\nstruct Meters(u32);\n\nimpl Add&lt;Meters&gt; for Millimeters {\n    type Output = Millimeters;\n\n    fn add(self, other: Meters) -&gt; Millimeters {\n        Millimeters(self.0 + (other.0 * 1000))\n    }\n}\n\nfn main() {\n    let mm = Millimeters(10);\n    let m = Meters(1);\n\n    let sum = mm + m;\n    // sum is of type Millimeters\n    println!(\"sum is {}\", sum.0); // 1010\n    // 注意这样是不行的, 顺序是有关系的\n    // let sum2 = m + mm;\n}"
  },
  {
    "objectID": "docs/basic/trait_advanced.html#运算符重载",
    "href": "docs/basic/trait_advanced.html#运算符重载",
    "title": "斯巴拉稀",
    "section": "",
    "text": "use std::ops::Add;\n\n#[derive(Debug, Copy, Clone, PartialEq)]\nstruct Point {\n    x: i32,\n    y: i32,\n}\n// 给Point 实现Add trait, Add trait 定义了+加法 会如何操作\nimpl Add for Point {\n    type Output = Point;\n\n    fn add(self, other: Point) -&gt; Point {\n        Point {\n            x: self.x + other.x,\n            y: self.y + other.y,\n        }\n    }\n}\n\nfn main() {\n    assert_eq!(\n        Point { x: 1, y: 0 } + Point { x: 2, y: 3 },\n        Point { x: 3, y: 3 }\n    );\n}\n我们看下Add trait的定义,发现实际带有类型参数,默认值是Self\npub trait Add&lt;Rhs = Self&gt; {\n    // ...\n}\n不同类型的+ 加法重载\nuse std::ops::Add;\n\nstruct Millimeters(u32);\nstruct Meters(u32);\n\nimpl Add&lt;Meters&gt; for Millimeters {\n    type Output = Millimeters;\n\n    fn add(self, other: Meters) -&gt; Millimeters {\n        Millimeters(self.0 + (other.0 * 1000))\n    }\n}\n\nfn main() {\n    let mm = Millimeters(10);\n    let m = Meters(1);\n\n    let sum = mm + m;\n    // sum is of type Millimeters\n    println!(\"sum is {}\", sum.0); // 1010\n    // 注意这样是不行的, 顺序是有关系的\n    // let sum2 = m + mm;\n}"
  },
  {
    "objectID": "docs/basic/trait_advanced.html#trait-object",
    "href": "docs/basic/trait_advanced.html#trait-object",
    "title": "斯巴拉稀",
    "section": "2 trait object",
    "text": "2 trait object\n\n2.1 使用\n我们有这样一个需求, 创建一个GUI 工具, 会遍历一个列表, 调用每个元素的draw方法\n我们很快就能想到使用泛型,试试看\npub trait Draw {\n    fn draw(&self);\n}\npub struct ScreenWithGeneric&lt;T: Draw&gt; {\n    pub components: Vec&lt;T&gt;,\n}\n\nimpl&lt;T&gt; ScreenWithGeneric&lt;T&gt;\nwhere\n    T: Draw,\n{\n    pub fn run(&self) {\n        for component in self.components.iter() {\n            component.draw();\n        }\n    }\n}\n\npub struct Button {}\n\nimpl Draw for Button {\n    fn draw(&self) {\n        println!(\"Button\");\n    }\n}\nstruct SelectBox {}\nimpl Draw for SelectBox {\n    fn draw(&self) {\n        println!(\"SelectBox\");\n    }\n}\n\nfn main() {\n    let botton = Button {};\n    let botton2 = Button {};\n    let select_box = SelectBox {};\n    let s = ScreenWithGeneric {\n        // 报错了, 类型不一致了\n        components: vec![botton, select_box],\n    };\n    s.run();\n}\n结果发现行不通, 问题的关键是我们只要列表里的元素能够执行 draw 方法就行, 不管它是什么类型. 有什么办法呢? trait object 可以解决这个问题\n\npub trait Draw {\n    fn draw(&self);\n}\npub struct Screen {\n    // Box&lt;dyn Draw&gt; : 定义了一个 trait object\n    // 表示 Box里的元素必须都实现了 Draw 这个trait 就行, 不管它是什么类型\n1    pub components: Vec&lt;Box&lt;dyn Draw&gt;&gt;,\n}\nimpl Screen {\n    pub fn run(&self) {\n        for component in self.components.iter() {\n            component.draw();\n        }\n    }\n}\npub struct Button {}\n\nimpl Draw for Button {\n    fn draw(&self) {\n        println!(\"Button\");\n    }\n}\nstruct SelectBox {}\nimpl Draw for SelectBox {\n    fn draw(&self) {\n        println!(\"SelectBox\");\n    }\n}\nfn main() {\n    let button = Button {};\n\n    let select_box = SelectBox {};\n    let s = Screen {\n        // 这里ok了\n        components: vec![Box::new(button), Box::new(select_box)],\n    };\n    s.run();\n}\n\n1\n\n使用Box 包起来很好理解, 因为实现了Draw 这个trait的类型的大小不知道,直接用指针指向,所以用Box装箱\n\n\n\n\n2.2 动态派发\n\n\n\n\n\n\nTip\n\n\n\n\n当你使用泛型函数或方法时，编译器会为每个具体使用的数据类型生成专门的代码。这种机制称为单态化（Monomorphization）,单态化后的代码 会执行静态派发\n\n\n\n// 使用trait约束泛型T，这里T必须实现了Summary trait\nfn notify&lt;T: Summary&gt;(item: T) {\n    println!(\"Breaking news! {}\", item.summarize());\n}\n\n// 编译器会为每个具体使用的数据类型生成专门的代码,这样，当调用notify(tweet)和notify(article)时，直接调用的就是针对Tweet和NewsArticle预先生成好的、类型特定的函数，这就是静态派发的过程\n\n// 为Tweet类型特化生成的notify函数\nfn notify_Tweet(item: Tweet) {\n    println!(\"Breaking news! {}\", item.summarize());\n}\n\n// 为NewsArticle类型特化生成的notify函数\nfn notify_NewsArticle(item: NewsArticle) {\n    println!(\"Breaking news! {}\", item.summarize());\n}\n动态派发 ,使用dyn trait会用动态派发, 无法在编译期确定你调用的是哪个方法,会在运行时确定\n\n\n\n2.3 对象安全\n只能把满足对象安全的trait 转为 trait object\n\n安全的标准\n\n方法返回类型不是Self\n方法中没有泛型类型参数"
  },
  {
    "objectID": "docs/basic/trait_advanced.html#sized-trait",
    "href": "docs/basic/trait_advanced.html#sized-trait",
    "title": "斯巴拉稀",
    "section": "3 Sized Trait",
    "text": "3 Sized Trait\n\n动态大小的类型 DST (Dynamically Sized Types)\n\n\n\n\n\n\n\nNote\n\n\n\n\n类型可以说是规定了你如何去使用一块内存: 占用多少空间, 怎么读写,比如给你弄了写方法, 方便读写\n在数组里, [1i32,2] 占用了8字节 [1i32,2,3] 12个字节, 这2个是不同的类型, 虽然我们都说他们是数组\n\n\n\n\nlet s1: str = \"Hello there!\";\nlet s2: str = \"How's it going?\";\n\n// 这个就ok了, 因为这个 &str 类型的 占用空间是确定的,\n// 可以说动态类型的数据的一种通用使用方式, 就是一个指针去指向它的实际数据,其他比如长度等信息\nlet s3: &str = \"Hello there!\";\n\n\n\n\n\n\n上面报错了, 我们分析一下\n\n\n\n\n前面2行报错了, 你可能会疑惑? s1和s2的占用多少空间是很确定的样子,好像没问题?\ns1 s2 两个变量是同一个str类型,但是看起来他们占用的空间却不一样, 这就有问题了\nrust 需要在栈上为变量分配固定大小的内存空间, 这需要在编译期就知道类型的大小, 而该str类型大小不确定\n\n\n\n\n为了处理这种动态大小的类型,rust提供了Sized trait 来去确定一个类型的大小在编译器是否是已知的.\n在编译期知道大小的类型, rust会为其自动的实现一个trait (Sized)\nfn generic&lt;T&gt;(t: T) {\n    // --snip--\n}\n上面的代码实际上 等同与, rust 会为 每个泛型函数隐式添加 Sized trait约束\nfn generic&lt;T: Sized&gt;(t: T) {\n    // --snip--\n}\n默认情况下, 泛型函数只能在编译期知道其类型大小的情况下工作。但是, 你可以使用以下特殊语法来放宽这一限制:\n// ?Sized 表示 T的大小可能是不确定的\nfn generic&lt;T: ?Sized&gt;(t: &T) {\n    // --snip--\n}"
  },
  {
    "objectID": "docs/basic/trait_advanced.html#一些trait",
    "href": "docs/basic/trait_advanced.html#一些trait",
    "title": "斯巴拉稀",
    "section": "4 一些trait",
    "text": "4 一些trait\n\n4.1 类型转换相关\n\nFrom & IntoTryFrom & TryIntoToString & FromStr\n\n\nFrom trait 让你可以从另外一个B类型的数据,创建一个A类型的数据\nlet my_str = \"hello\";\n// 我们常用到的 String::from  就是String 类型 实现了 From trait\nlet my_string = String::from(my_str);\n\n\n自定义实现From\n\nuse std::convert::From;\n\n#[derive(Debug)]\nstruct Number {\n    value: i32,\n}\n\nimpl From&lt;i32&gt; for Number {\n    fn from(item: i32) -&gt; Self {\n        Number { value: item  }\n    }\n}\n\nfn main() {\n    let num = Number::from(30);\n    println!(\"My number is {:?}\", num);\n\n    // 如果你实现了from , 那么对方也自动实现了into\n    let int = 5;\n    // 试试删除类型说明\n    let num: Number = int.into();\n    println!(\"My number is {:?}\", num);\n}\n\n\n\n自定义实现into\n\nuse std::convert::Into;\n\n#[derive(Debug)]\nstruct Number {\n    value: i32,\n}\n\nimpl Into&lt;Number&gt; for i32 {\n    fn into(self) -&gt; Number {\n        Number { value: self }\n    }\n}\n\nfn main() {\n    let int = 5;\n    // Try removing the type annotation\n    let num: Number = int.into();\n    println!(\"My number is {:?}\", num);\n}\n\n\n\n\n\n\n\n\n\nCaution\n\n\n\n\n用于易出错的转换, 所以它的返回值是 Result 型\n\n\n\nuse std::convert::TryFrom;\nuse std::convert::TryInto;\n\n#[derive(Debug, PartialEq)]\nstruct EvenNumber(i32);\n\nimpl TryFrom&lt;i32&gt; for EvenNumber {\n    type Error = ();\n\n    fn try_from(value: i32) -&gt; Result&lt;Self, Self::Error&gt; {\n        if value % 2 == 0 {\n            Ok(EvenNumber(value))\n        } else {\n            Err(())\n        }\n    }\n}\n\nfn main() {\n    // TryFrom\n\n    assert_eq!(EvenNumber::try_from(8), Ok(EvenNumber(8)));\n    assert_eq!(EvenNumber::try_from(5), Err(()));\n\n    // TryInto\n\n    let result: Result&lt;EvenNumber, ()&gt; = 8i32.try_into();\n    assert_eq!(result, Ok(EvenNumber(8)));\n    let result: Result&lt;EvenNumber, ()&gt; = 5i32.try_into();\n    assert_eq!(result, Err(()));\n}\n\n\n\n\n\n\n\n\nCaution\n\n\n\n\n要把任何类型转换成 String, 只需要实现那个类型的 ToString trait. 然而不要直接这么做, 您应该实现fmt::Display trait,它会自动提供 ToString\n\n\n\nuse std::fmt;\n\nstruct Circle {\n    radius: i32\n}\n\nimpl fmt::Display for Circle {\n    fn fmt(&self, f: &mut fmt::Formatter) -&gt; fmt::Result {\n        write!(f, \"Circle of radius {}\", self.radius)\n    }\n}\n\nfn main() {\n    let circle = Circle { radius: 6 };\n    println!(\"{}\", circle.to_string());\n}\n\n\n\n\n\n\nTip\n\n\n\n只要对目标类型实现了 FromStr trait, 就可以用 parse 把字符串转换成目标类型\n\n\n\n\nFromStr定义一个类型如何从字符串转换而来\n\nuse std::str::FromStr;\n\n// 定义一个简单的结构体，它包含一个 u32 类型的值\nstruct MyNumber {\n    value: u32,\n}\n\n// 为 MyNumber 实现 FromStr trait\nimpl FromStr for MyNumber {\n    type Err = &'static str; // 定义错误类型为 &'static str\n\n    // from_str 方法尝试将字符串解析为 MyNumber\n    fn from_str(s: &str) -&gt; Result&lt;Self, Self::Err&gt; {\n        // 尝试将字符串转换为 u32\n        let value = s.parse::&lt;u32&gt;().map_err(|_| \"Parse error\")?;\n        // 如果成功，创建并返回 MyNumber 实例\n        Ok(Self { value })\n    }\n}\n\nfn main() {\n    // 使用 parse::&lt;MyNumber&gt;() 方法将字符串转换为 MyNumber\n    // 如果不实现 MyNumber 类型的from_str 方法, 是不能 parse的\n    let number = \"42\".parse::&lt;MyNumber&gt;().unwrap();\n    println!(\"Parsed value: {}\", number.value);\n\n    // 如果解析失败，会返回一个错误\n    if let Err(e) = \"not a number\".parse::&lt;MyNumber&gt;() {\n        println!(\"Failed to parse: {}\", e);\n    }\n\n    let parsed: i32 = \"5\".parse().unwrap();\n    let turbo_parsed = \"10\".parse::&lt;i32&gt;().unwrap();\n}\n\n\n\n\n\n\n4.2 打印相关\n\n4.2.1 Display\n\n\n\n\n\n\nNote\n\n\n\n\n实现了该trait, 类型就有了to_string方法\n只有实现了该trait , 才能使用 println!(\"{}\",x) 打印\n\n\n\nuse std::fmt;\n\nstruct Circle {\n    radius: i32\n}\n// 实现这个trait ,就有了 to_string 方法\nimpl fmt::Display for Circle {\n    fn fmt(&self, f: &mut fmt::Formatter) -&gt; fmt::Result {\n        write!(f, \"Circle of radius {}\", self.radius)\n    }\n}\n\nfn main() {\n    let circle = Circle { radius: 6 };\n    let c=circle.to_string();\n    println!(\"{}\", c);\n}\n\n\n\n4.3 index 索引操作 trait\nuse std::ops::{Index, IndexMut};\n\n// 定义一个简单的 Collection 类型\nstruct Collection&lt;T&gt; {\n    items: Vec&lt;T&gt;,\n}\n\n// 为 Collection 实现 Index trait（只读操作）\nimpl&lt;T&gt; Index&lt;usize&gt; for Collection&lt;T&gt; {\n    type Output = T;\n\n    fn index(&self, index: usize) -&gt; &Self::Output {\n        &self.items[index]\n    }\n}\n\n// 为 Collection 实现 IndexMut trait（可变操作）\nimpl&lt;T&gt; IndexMut&lt;usize&gt; for Collection&lt;T&gt; {\n    fn index_mut(&mut self, index: usize) -&gt; &mut Self::Output {\n        &mut self.items[index]\n    }\n}\n\nfn main() {\n    // 创建一个可变的 Collection 实例\n    let mut collection = Collection {\n        items: vec![10, 20, 30, 40, 50],\n    };\n\n    // 使用索引操作读取元素\n    println!(\"原始第一个元素: {}\", collection[0]);\n    println!(\"原始第三个元素: {}\", collection[2]);\n\n    // 使用索引操作修改元素\n    collection[0] = 100;\n    collection[2] = 300;\n\n    // 再次读取修改后的元素\n    println!(\"修改后第一个元素: {}\", collection[0]);\n    println!(\"修改后第三个元素: {}\", collection[2]);\n}"
  },
  {
    "objectID": "docs/basic/trait_advanced.html#derive-自动派生",
    "href": "docs/basic/trait_advanced.html#derive-自动派生",
    "title": "斯巴拉稀",
    "section": "5 derive 自动派生",
    "text": "5 derive 自动派生\n\n\n\n\n\n\nTip\n\n\n\n\n设计缘由\n\nrust 为某些类型实现某些trait时, 代码基本是固定的,重复的,是一件麻烦的事情, 不难想到应该实现自动化处理.\n\n使用方法\n\n因此rust设计一个属性, 就是在你想要实现名为XXX的trait的类型前面写#[derive(XXX)], 它可以自动为你的结构体或枚举实现某些 trait, 也就是rust 编译器会自动为你生成这些 traits 的实现代码\n\n以下是一些常用的可以通过 derive 自动实现的 trait:\n\nDebug: 用于格式化输出，使得结构体或枚举在调试时可以打印其字段\nClone: 允许创建一个值的副本\nCopy: 使得类型可以按位复制,而不是移动\nPartialEq 和 Eq: 用于比较两个值是否相等\nPartialOrd 和 Ord: 用于比较两个值的顺序\nDefault: 提供一个类型的默认值\nHash: 允许类型被用作哈希表中的键\n\n\n\n\n\n5.1 Debug\n派生Debug trait后, 才能使用println!(“{:?}”)中{:?}或{:#?}这种打印方式\n\n\n#[derive(Debug)]\n\nstruct Cat(i32);\n// 添加这个就自动实现了Debug trait\n/*\n编译器会自动为你 加上\nimpl Debug for Dog {\n  // ...\n}\n*/\n#[derive(Debug)] \nstruct Dog(i32);\nfn main() {\n    println!(\"Cat: {:?} \", Cat(5)); // 报错了\n    println!(\"Dog: {:?} \", Dog(5)); // ok\n}\n\n\n\n5.2 Default\n\n\n\n\n\n\nCaution\n\n\n\n\n一般我们也不用, 首先它相当于一个构造函数, 但是我们都会自己定义一个 名字可能是new 的 静态方法\n\n\n\n// 添加Default 派生宏\n#[derive(Debug, Default)]\nstruct Rectangle {\n    width: u32,\n    height: u32,\n}\nfn main() {\n    // 可以使用这种方式来创建一个实例\n    // 使用方式1\n    let rect1: Rectangle = Default::default();\n    println!(\"{:?}\", rect1); //\n    // 使用方式2\n    let rect2 = Rectangle::default();\n    println!(\"{:?}\", rect2);\n}"
  },
  {
    "objectID": "docs/basic/closure.html",
    "href": "docs/basic/closure.html",
    "title": "rust 闭包",
    "section": "",
    "text": "Tip\n\n\n\n\n闭包是可以捕获其定义所在的作用域的匿名函数\n闭包底层实际上是一个匿名的结构体,且实现了Fn,FnMut,FnOnce这三个trait中的一个或多个\n闭包会根据对捕获的变量的使用情况,推断出实现了哪些 trait\n\n\n\n我们先来看看下面的代码\n\n\n我们需要切换到nightly版本\n\n# 在 项目目录下执行, 只更换当前目录的rust版本\nrustup override set nightly\n\n\n例子1看底层结构例子2看什么叫只能实现FnOnce例子3看三个trait全部实现会执行哪个\n\n\n\n\n运行即可, 不会报错的\n\n#![feature(unboxed_closures)]\n#![feature(fn_traits)]\n\nstruct Adder {\n    a: u32\n}\n\n// Adder 只实现了FnOnce (后面我们还会提到什么叫只实现了)\nimpl FnOnce&lt;(u32, )&gt; for Adder {\n    type Output = u32;\n    extern \"rust-call\" fn call_once(self, b: (u32, )) -&gt; Self::Output {\n        // 相当于闭包的\"函数体\"\n        self.a + b.0\n    }\n}\n\nfn main() {\n    let x=3;\n    let adder = Adder { a: x }; // 相当于闭包将捕获的外部变量x存到结构体中的a\n    // adder 结构体实现了上面的FnOnce trait, 这里变成可以用函数的方式()去调用自身了\n    let res=adder(2);\n    // 提示错误, adder 被move掉了, 原因看最后\n    // adder(2);\n    println!(\"{}\",res);// 5\n\n    let adder = Adder { a: 3 };\n    // adder()是一种简写方式, 其实相当于调用如下\n    let res=adder.call_once((2,));\n    println!(\"{}\",res);// 5\n\n    let adder = Adder { a: 3 };\n    // adder.call_once 也是语法糖,这个我们在结构体章节中已经说到,\n    // 所以实际是这样调用 ,adder 作为参数传递给call_once 方法\n    let res=FnOnce::call_once(adder,(2,));\n    println!(\"{}\",res);// 5\n    // 提示adder已经被move了, 因为call_once 传递的是self\n    // println!(\"{:p}\",&adder);\n\n}\n\n\n\n\n\n\n\n\n\nImportant\n\n\n\n可以将2个trait方法里的 {self.a;} 代码注释,再执行看看\n\n\n#![feature(unboxed_closures)]\n#![feature(fn_traits)]\n\nstruct Adder&lt;'a&gt; {\n    a: String,\n    b: &'a str,\n    c: &'a mut u32,\n}\nimpl&lt;'a&gt; FnOnce&lt;(u32,)&gt; for Adder&lt;'a&gt; {\n    type Output = (); // 看你闭包实际的返回情况, 这里进行修改\n    extern \"rust-call\" fn call_once(self, b: (u32,)) -&gt; Self::Output{\n        println!(\"{}\",self.a);\n        println!(\"{}\",self.b);\n        *self.c=22;\n        {\n            self.a;\n        }\n    }\n}\nimpl&lt;'a&gt; FnMut&lt;(u32,)&gt; for Adder&lt;'a&gt; {\n    extern \"rust-call\" fn call_mut(&mut self, b: (u32,)) -&gt; Self::Output{\n        println!(\"{}\",self.a);\n        println!(\"{}\",self.b);\n        *self.c=22;\n        {\n            // 首先捕获 外部变量的所有权,模拟闭包捕获外部变量所有权\n                // 捕获变量的方式不是重点, 重要的是闭包内部对该变量的使用方式,才影响闭包实现了哪个trait的原因\n            // 如果闭包里想要将捕获的所有权变量 给弄失效,那么你就必须只能传递 self\n            // 所以这里你就实现不了FnMut trait,因为它传递的是&mut,是无法将a失效化的\n            // 这里当然报错了.\n            self.a;\n        }\n    }\n}\n\nfn main() {\n    let a = \"abc\".to_string();\n    let b = \"abc\";\n    let mut c = 11;\n    let mut adder = Adder {\n        a: a, // 模拟闭包捕获所有权\n        b: b,  // 模拟闭包捕获不可变借用\n        c: &mut c  // 模拟闭包捕获可变借用\n    };\n    // println!(\"{}\",a);\n    let res = adder(2);\n    println!(\"{}\",c);\n\n}\n\n\n\n\n\n\n\n\nCaution\n\n\n\n\n其实好理解,使用fn trait的方法是最好的, 因为FnOnce 那个没必要执行完就让结构体失效了, 也没必要用FnMut,它需要mut.\n看 一个闭包到底实现了 哪个trait,只要想象将闭包体放入3个trait的要实现的方法里看能否执行成功, 成功就表明实现了这个trait\n\n\n\n#![feature(unboxed_closures)]\n#![feature(fn_traits)]\n\nstruct Adder&lt;'a&gt; {\n    a: String,\n    b: &'a str,\n    c: &'a mut u32,\n}\nimpl&lt;'a&gt; FnOnce&lt;(u32,)&gt; for Adder&lt;'a&gt; {\n    type Output = (); // 看你闭包实际的返回情况, 这里进行修改\n    extern \"rust-call\" fn call_once(self, b: (u32,)) -&gt; Self::Output{\n        println!(\"{}\",self.a);\n        println!(\"{} call_once\",self.b);\n    }\n}\nimpl&lt;'a&gt; FnMut&lt;(u32,)&gt; for Adder&lt;'a&gt; {\n    extern \"rust-call\" fn call_mut(&mut self, b: (u32,)) -&gt; Self::Output{\n        println!(\"{}\",self.a);\n        println!(\"{} call_mut\",self.b);\n    }\n}\nimpl&lt;'a&gt; Fn&lt;(u32,)&gt; for Adder&lt;'a&gt; {\n    extern \"rust-call\" fn call(&self, b: (u32,)) -&gt; Self::Output{\n        println!(\"{}\",self.a);\n        println!(\"{} call\",self.b);\n    }\n}\nfn main() {\n    let a = \"abc\".to_string();\n    let b = \"abc\";\n    let mut c = 11;\n    // 这里其实不用mut, 因为最后实际是执行的 Fn trait\n    let mut adder = Adder {\n        a: a, // 捕获所有权\n        b: b,  // 捕获不可变借用\n        c: &mut c  // 捕获可变借用\n    };\n    // 实现全部trait的\"闭包\" ,执行看看是执行哪个trait的方法\n    let res = adder(2);\n    adder(2);\n}",
    "crumbs": [
      "核心基础",
      "基础篇",
      "闭包"
    ]
  },
  {
    "objectID": "docs/basic/closure.html#底层原理",
    "href": "docs/basic/closure.html#底层原理",
    "title": "rust 闭包",
    "section": "",
    "text": "Tip\n\n\n\n\n闭包是可以捕获其定义所在的作用域的匿名函数\n闭包底层实际上是一个匿名的结构体,且实现了Fn,FnMut,FnOnce这三个trait中的一个或多个\n闭包会根据对捕获的变量的使用情况,推断出实现了哪些 trait\n\n\n\n我们先来看看下面的代码\n\n\n我们需要切换到nightly版本\n\n# 在 项目目录下执行, 只更换当前目录的rust版本\nrustup override set nightly\n\n\n例子1看底层结构例子2看什么叫只能实现FnOnce例子3看三个trait全部实现会执行哪个\n\n\n\n\n运行即可, 不会报错的\n\n#![feature(unboxed_closures)]\n#![feature(fn_traits)]\n\nstruct Adder {\n    a: u32\n}\n\n// Adder 只实现了FnOnce (后面我们还会提到什么叫只实现了)\nimpl FnOnce&lt;(u32, )&gt; for Adder {\n    type Output = u32;\n    extern \"rust-call\" fn call_once(self, b: (u32, )) -&gt; Self::Output {\n        // 相当于闭包的\"函数体\"\n        self.a + b.0\n    }\n}\n\nfn main() {\n    let x=3;\n    let adder = Adder { a: x }; // 相当于闭包将捕获的外部变量x存到结构体中的a\n    // adder 结构体实现了上面的FnOnce trait, 这里变成可以用函数的方式()去调用自身了\n    let res=adder(2);\n    // 提示错误, adder 被move掉了, 原因看最后\n    // adder(2);\n    println!(\"{}\",res);// 5\n\n    let adder = Adder { a: 3 };\n    // adder()是一种简写方式, 其实相当于调用如下\n    let res=adder.call_once((2,));\n    println!(\"{}\",res);// 5\n\n    let adder = Adder { a: 3 };\n    // adder.call_once 也是语法糖,这个我们在结构体章节中已经说到,\n    // 所以实际是这样调用 ,adder 作为参数传递给call_once 方法\n    let res=FnOnce::call_once(adder,(2,));\n    println!(\"{}\",res);// 5\n    // 提示adder已经被move了, 因为call_once 传递的是self\n    // println!(\"{:p}\",&adder);\n\n}\n\n\n\n\n\n\n\n\n\nImportant\n\n\n\n可以将2个trait方法里的 {self.a;} 代码注释,再执行看看\n\n\n#![feature(unboxed_closures)]\n#![feature(fn_traits)]\n\nstruct Adder&lt;'a&gt; {\n    a: String,\n    b: &'a str,\n    c: &'a mut u32,\n}\nimpl&lt;'a&gt; FnOnce&lt;(u32,)&gt; for Adder&lt;'a&gt; {\n    type Output = (); // 看你闭包实际的返回情况, 这里进行修改\n    extern \"rust-call\" fn call_once(self, b: (u32,)) -&gt; Self::Output{\n        println!(\"{}\",self.a);\n        println!(\"{}\",self.b);\n        *self.c=22;\n        {\n            self.a;\n        }\n    }\n}\nimpl&lt;'a&gt; FnMut&lt;(u32,)&gt; for Adder&lt;'a&gt; {\n    extern \"rust-call\" fn call_mut(&mut self, b: (u32,)) -&gt; Self::Output{\n        println!(\"{}\",self.a);\n        println!(\"{}\",self.b);\n        *self.c=22;\n        {\n            // 首先捕获 外部变量的所有权,模拟闭包捕获外部变量所有权\n                // 捕获变量的方式不是重点, 重要的是闭包内部对该变量的使用方式,才影响闭包实现了哪个trait的原因\n            // 如果闭包里想要将捕获的所有权变量 给弄失效,那么你就必须只能传递 self\n            // 所以这里你就实现不了FnMut trait,因为它传递的是&mut,是无法将a失效化的\n            // 这里当然报错了.\n            self.a;\n        }\n    }\n}\n\nfn main() {\n    let a = \"abc\".to_string();\n    let b = \"abc\";\n    let mut c = 11;\n    let mut adder = Adder {\n        a: a, // 模拟闭包捕获所有权\n        b: b,  // 模拟闭包捕获不可变借用\n        c: &mut c  // 模拟闭包捕获可变借用\n    };\n    // println!(\"{}\",a);\n    let res = adder(2);\n    println!(\"{}\",c);\n\n}\n\n\n\n\n\n\n\n\nCaution\n\n\n\n\n其实好理解,使用fn trait的方法是最好的, 因为FnOnce 那个没必要执行完就让结构体失效了, 也没必要用FnMut,它需要mut.\n看 一个闭包到底实现了 哪个trait,只要想象将闭包体放入3个trait的要实现的方法里看能否执行成功, 成功就表明实现了这个trait\n\n\n\n#![feature(unboxed_closures)]\n#![feature(fn_traits)]\n\nstruct Adder&lt;'a&gt; {\n    a: String,\n    b: &'a str,\n    c: &'a mut u32,\n}\nimpl&lt;'a&gt; FnOnce&lt;(u32,)&gt; for Adder&lt;'a&gt; {\n    type Output = (); // 看你闭包实际的返回情况, 这里进行修改\n    extern \"rust-call\" fn call_once(self, b: (u32,)) -&gt; Self::Output{\n        println!(\"{}\",self.a);\n        println!(\"{} call_once\",self.b);\n    }\n}\nimpl&lt;'a&gt; FnMut&lt;(u32,)&gt; for Adder&lt;'a&gt; {\n    extern \"rust-call\" fn call_mut(&mut self, b: (u32,)) -&gt; Self::Output{\n        println!(\"{}\",self.a);\n        println!(\"{} call_mut\",self.b);\n    }\n}\nimpl&lt;'a&gt; Fn&lt;(u32,)&gt; for Adder&lt;'a&gt; {\n    extern \"rust-call\" fn call(&self, b: (u32,)) -&gt; Self::Output{\n        println!(\"{}\",self.a);\n        println!(\"{} call\",self.b);\n    }\n}\nfn main() {\n    let a = \"abc\".to_string();\n    let b = \"abc\";\n    let mut c = 11;\n    // 这里其实不用mut, 因为最后实际是执行的 Fn trait\n    let mut adder = Adder {\n        a: a, // 捕获所有权\n        b: b,  // 捕获不可变借用\n        c: &mut c  // 捕获可变借用\n    };\n    // 实现全部trait的\"闭包\" ,执行看看是执行哪个trait的方法\n    let res = adder(2);\n    adder(2);\n}",
    "crumbs": [
      "核心基础",
      "基础篇",
      "闭包"
    ]
  },
  {
    "objectID": "docs/basic/closure.html#简单使用",
    "href": "docs/basic/closure.html#简单使用",
    "title": "rust 闭包",
    "section": "2 简单使用",
    "text": "2 简单使用\nfn main() {\n    fn add_one_v1(x: u32) -&gt; u32 {\n        x + 1\n    }\n    // 闭包,匿名函数, |参数| -&gt; 返回值 { 函数体}\n    let add_one_v2 = |x: u32| -&gt; u32 { x + 1 };\n    // 等价与 |x| {x + 1}  因为只有一个表达式, 所以 {} 可以省略\n    let add_one_v3 = |x| x + 1;\n    // 上面的定义没有类型, 如果没有的调用语句, 是会报错的, 因为函数没有类型,内存占用无法确定\n    // 调用后, 编译器推断出参数类型,这个时候类型就确定了\n    let r = add_one_v3(1);\n    println!(\"{}\", r);\n    // 后续如果你用其他类型,就会报错的\n    // let r2 = add_one_v3(\"a\");\n}",
    "crumbs": [
      "核心基础",
      "基础篇",
      "闭包"
    ]
  },
  {
    "objectID": "docs/basic/closure.html#捕获值的方式",
    "href": "docs/basic/closure.html#捕获值的方式",
    "title": "rust 闭包",
    "section": "3 捕获值的方式",
    "text": "3 捕获值的方式\n\n3.1 捕获逻辑\n\n\n\n\n\n\nImportant\n\n\n\n\n在没有使用move 的情况下\n\n如果使用不可变借用就可以的, 那么就使用不可变借用(既然只要不可变就OK,何必搞其他的”权限”更多的捕获,很简单的道理)\n其次是需要修改的情况下,如果用可变借用就能完成逻辑,那就用可变借用\n最后没有办法,只能通过获取所有权来完成逻辑, 那么就只能获取所有权\n\nmove 关键字\n\n强制获取外部变量的所有权, 即使你本身可能不需要\n当然还有本身copy类型的变量, 不会让外部的变量失效\n\n\n\n\n\n\n3.2 不可变借用\n\n\n简单的明显的例子\n\nfn main() {\n    let list = vec![1, 2, 3];\n    println!(\"Before defining closure: {:?}\", list);\n    // 捕获了闭包所在环境, 变量list\n    let only_borrows = || {\n        // println!使用了 list的不可变借用\n        println!(\"From closure: {:?}\", list);\n    }\n\n    println!(\"Before calling closure: {:?}\", list);\n    only_borrows();\n    println!(\"After calling closure: {:?}\", list);\n}\n\n\n\n\n看起来有点不那么明显的例子\n\nfn main() {\n    let mut x = 1;\n    let f = |y: i32| x + y;\n    x = 3;  //报错了\n    let r = f(2);\n    let mut x = 1;\n    // 这里同样也是使用x的不可变借用\n    let f = Box::new(|y: i32| x + y);\n}\n\n\n\n\n\n\n\n结果可以发现是不可变借用\n\n\n\n\n运行根据提示的错误信息, 闭包里捕获的x 是 不可变借用\n根据前面的判断逻辑, 该闭包只要不可变借用就能完成它的逻辑,所以使用不可变借用\n\nfn main(){\n    let a = 1;\n    let b = 2;\n    let c = &a + b;  // 这种是ok的.会自动解引用的\n    println!(\"{c}\");\n}\n\n\n\nfn t&lt;'a&gt;(x: i32) -&gt; &'a i32 {\n    &x\n    // 执行完t(x) x就失效了, 而你返回了x的不可变借用,所以有问题\n}\n// 问题同上, 会报错\nfn ret_closure(x: i32) -&gt; Box&lt;dyn Fn(i32) -&gt; i32&gt; {\n    // 传来的x, 再调用完 ret_closure(x) 后, x 就失效了,\n    // 而这里返回的 ,使用了x的不可变借用\n    Box::new(|y: i32| x + y)\n}\n// 正确的写法\nfn ret_closure2(x: i32) -&gt; Box&lt;dyn Fn(i32) -&gt; i32&gt; {\n    // x的所有权转移 就OK了\n    Box::new(move |y: i32| x + y)\n}\n\n\n3.3 可变借用\nfn main() {\n    let mut list = vec![1, 2, 3];\n    println!(\"Before defining closure: {:?}\", list);\n    // 需要mut, 看闭包体里如何使用捕获的变量\n    let mut borrows_mutably = || list.push(7);\n\n    borrows_mutably();\n    println!(\"After calling closure: {:?}\", list); // [1, 2, 3, 7]\n}\n\n\n3.4 所有权\n\n\nmove 种类的类型\n\n#[derive(Debug)]\nstruct Foo;\nfn main() {\n    let a = Foo;\n    println!(\" {:p}\", &a);\n    // 整体去看闭包体{} 里是如何使用捕获的变量的.\n    // 一旦需要使用所有权这样的权限, 那么就 只能实现FnOnce 那个trait了.\n    let f =  || {\n        // a 最后被move掉了,那么就需要有它的所有权\n        // 那么首先 就是获取a的所有权\n        // 所以这里的a就已经是从外部转移所有权后的a, 那么就和外部的地址不一样\n        println!(\" {:p}\", &a);\n        // 最后转移了a的所有权了.\n        let b = a;\n    };\n    f();\n    // 报错,a已经在闭包内被b获取所有权了\n    // println!(\"{:?}\", a);\n}\n\n\n\n同上,例子2\n\nfn main() {\n    let mut farewell = \"goodbye\".to_owned();\n    let diary = || {\n        println!(\"I said {}.\", farewell);\n        {\n            farewell;\n        } // farewell 被drop掉了,\n    };\n    // println!(\"{}\", farewell);\n}\n\n\n\n使用move强制获取所有权,即使里面使用的只是不可变借用\n\nuse std::thread;\n\nfn main() {\n    let list = vec![1, 2, 3];\n    println!(\"Before defining closure: {:?}\", list);\n    // 指定move, 所有权移动\n    thread::spawn(move || println!(\"From thread: {:?}\", list))\n        .join()\n        .unwrap();\n    // println!(\"after defining closure: {:?}\", list); // 被move了,报错\n}\n\n\n\ncopy 种类的类型 使用move\n\nfn main() {\n    let x = 7;\n    println!(\"外部x变量地址: {:p}\", &x);\n    let f = move || {\n        // 虽然内部是用的 x 的不可变借用, 但是使用了move\n        // move 后, 这里的x 就已经是新的x ,而不是外部x的借用了\n        println!(\"move后 闭包内x变量地址: {:p}\", &x);\n        println!(\"{}\", x);\n    };\n    f();\n    println!(\"{}\", x); // copy 类型, 值还有效\n}\n\n\n\nMove 种类的类型 使用move,但是闭包内部没有使用到所有权的权限\n\nfn main() {\n    let x = \"abc\".to_string();\n    println!(\"外部x变量地址: {:p}\", &x);\n    let f = move || {\n        println!(\"move后 闭包内x变量地址: {:p}\", &x);\n        println!(\"{}\", x);\n    };\n    f();\n    // ok 说明其实 Fn trait也实现了\n    // 也说明了前面我们提到的, 将3个traint 都实现一遍, 看哪个能实现来判断\n    f();\n    // println!(\"{}\", x); // 报错了.\n}",
    "crumbs": [
      "核心基础",
      "基础篇",
      "闭包"
    ]
  },
  {
    "objectID": "docs/basic/closure.html#trait",
    "href": "docs/basic/closure.html#trait",
    "title": "rust 闭包",
    "section": "4 trait",
    "text": "4 trait\n\n4.1 FnOnce\n\n\n\n\n\n\nTip\n\n\n\n\nFnOnce表示可以被调用一次,很显然我们编写的闭包肯定是要能被调用至少一次的.只要能调用至少一次,那么它就实现了FnOnce trait\n如果只实现了 FnOnce这个trait, 其他trait没有实现,那么表示该闭包只能被调用一次, 反之亦然.\n当你闭包被调用一次后,里面的捕获的值如果就失效了,就能推断它 只实现了 FnOnce trait,因为它被调用一次后,里面变量值无效了,再调用就报错了]{.txt-highlight}\n\n\n\n\n\n\n源码定义\n\npub trait FnOnce&lt;Args: Tuple&gt; {\n    /// The returned type after the call operator is used.\n    #[lang = \"fn_once_output\"]\n    #[stable(feature = \"fn_once_output\", since = \"1.12.0\")]\n    type Output;\n\n    /// Performs the call operation.\n    #[unstable(feature = \"fn_traits\", issue = \"29625\")]\n    extern \"rust-call\" fn call_once(self, args: Args) -&gt; Self::Output;\n}\n\n\n\n\n\n\n\n得出结论\n\n\n\n\n当我们调用了只实现了 FnOnce trait的闭包比如 my_closure() 后, 它相当于调用 my_closure.call_once(),前面我们说过 闭包底层实际是一个结构体, 那么这里🈶转换为 相当于执行FnOnce::call_once(my_closure,args),转移所有权了, 所以只能调用一次\n结合底层原理章节看看\n所以很好理解, 为什么说只实现了 FnOnce trait的闭包 ,就只能调用一次\n这里再次强调: 具体实现了哪些trait,看底层原理将三个trait都套进去看能否成功执行\n\n\n\n\n\n\n有捕获可变借用,不可变借用和所有权, 最后是只实现了FnOnce trait的闭包\n\nfn main() {\n    let farewell = \"goodbye\".to_owned();\n    let mut b = 11;\n    let c = \"abc\".to_string();\n    println!(\"inner {:p}.\", &farewell);\n    let diary = || {\n        // farewell move给了diary(作为返回值),那么就需要有它的所有权\n        // 这个时候的farewell 就已经是获取了外部farewell所有权的新farewell\n        println!(\"inner farewell {:p}.\", &farewell);\n        println!(\"inner  {}.\", &mut b);\n        println!(\"inner  {}.\", &c);\n        farewell\n    };\n    diary();\n    // diary(); //报错\n    // println!(\"{}\", farewell); //报错\n}\n\n\n\n使用move但是实际可以被调用多次\n\nfn main() {\n    let farewell = \"goodbye\".to_owned();\n    let diary = move || {\n        println!(\"I said {}.\", farewell);\n    };\n    diary();\n    diary();\n}\n\n\n\n\n4.2 FnMut\n\n\n\n源码\n\npub trait FnMut&lt;Args: Tuple&gt;: FnOnce&lt;Args&gt; {\n    /// Performs the call operation.\n    #[unstable(feature = \"fn_traits\", issue = \"29625\")]\n    extern \"rust-call\" fn call_mut(&mut self, args: Args) -&gt; Self::Output;\n}\n\n\n\n\n\n\n\n得出结论\n\n\n\n\n我们可以看到,实现了FnMut trait的闭包,肯定也实现FnOnce trait\n只实现 FnMut和FnOnce2个trait 的闭包,调用时 相当于 FnMut::call_mut(&mut self,args)\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\n\n只要闭包最终只使用了捕获的值的可变借用,不管它是否真的进行修改,都说明只实现了FnMut+FnOnce\n\n\n\n\nfn apply&lt;F&gt;(mut f: F)\nwhere\n    F: FnMut(),\n{\n    f();\n    f();\n}\nfn main() {\n    let mut farewell = \"goodbye\".to_owned();\n    let mut diary = || {\n        // 可变借用 String::push_str(&mut self,string: &str)\n        farewell.push_str(\"hello\");\n    };\n    // 根据底层原理, 看 FnMut::call_mut(&mut self)\n    // 所以diary本身需要 let mut diary\n    diary();\n    apply(diary);\n}\n\n大概的底层结构相关可能需要了解的知识点\n\n\nfn main(){\n    struct Diary&lt;'a&gt; {\n       tmp: &'a mut String,\n    }\n    let mut s=\"goodbye\".to_string();\n    let mut diary=Diary{tmp:&mut s};\n    impl&lt;'a&gt; FnOnce&lt;(u32,)&gt; for Diary&lt;'a&gt; {\n        type Output = ();\n        extern \"rust-call\" fn call_once(self, b: (u32,)) -&gt; Self::Output{\n            self.tmp.push_str(\"hello\");\n            println!(\"{} call_once\",self.tmp);\n        }\n    }\n    impl&lt;'a&gt; FnMut&lt;(u32,)&gt; for Diary&lt;'a&gt; {\n        extern \"rust-call\" fn call_mut(&mut self, b: (u32,)) -&gt; Self::Output{\n            self.tmp.push_str(\"hello\");\n            println!(\"{} call_mut\",self.tmp);\n        }\n    }\n    // 实现不了该trait\n    // impl&lt;'a&gt; Fn&lt;(u32,)&gt; for Diary&lt;'a&gt; {\n    //     extern \"rust-call\" fn call(&self, b: (u32,)) -&gt; Self::Output{\n    //         /* \n    //         如果有些知识点不知道, 可能会觉得 这个好像也OK\n    //         String::push_str(&mut Self,&str)\n    //         因为self.tmp 是 &mut farewell,将它传递给String::push_str好像很符合\n    //         而实际上 会将&mut (*self.tmp)作为参数传递, self 是不可变借用, 这里又使用了可变借用,所以报错\n    //         */ \n    //         self.tmp.push_str(\"hello\");\n    //         println!(\"{} call_mut\",self.tmp);\n    //     }\n    // }\n    diary(1);\n}\n\n\n可变借用函数传参 reborrow\n\n\n下面的代码关注一下高亮行即可\n\nfn main() {\nstruct Adder&lt;'a&gt; {\n        a: String,\n        b: &'a str,\n        c: &'a mut u32,\n    }\n    let a = \"abc\".to_string();\n    let b = \"abc\";\n    let mut d = 11;\n    println!(\"{:p}\", &d);\n    let adder = Adder {\n        a: a,\n        b: b,\n        c: &mut d,\n    };\n    // *adder.c 是 *(adder.c)\n    let f = &(*adder.c);\n    print_type_of(f); //表示*adder.c 是d 就是 u32 类型\n    // 这是对 d的可变reborrow, 所以 后面的2个可变借用实际对d的修改操作 是ok的\n    let f = &mut (*adder.c);\n    print_type_of(&f); //表示&mut (*adder.c) 是 &mut u32 类型\n    *f = 22; // ok\n    *adder.c = 33;  // ok\n    println!(\"{}\", d);\n    println!(\"=============\");\n    //========================\n    let a = \"abc\".to_string();\n    let b = \"abc\";\n    let mut d = 11; \n    let adder = &Adder {\n        a: a,\n        b: b,\n        c: &mut d,\n    };\n    let f=&(adder.c);\n    //结果表示 adder.c是 &mut u32 类型\n    print_type_of(f); //&mut u32\n    let f=&(*adder.c);\n    // 结果表示 *adder.c 是 u32类型\n    print_type_of(f); // u32\n    //报错, 无法borrow 一个 &引用\n    // let f = &mut (*adder.c);\n}\nuse std::any::type_name;\n\nfn print_type_of&lt;T&gt;(_: &T) {\n    println!(\"{}\", type_name::&lt;T&gt;());\n}\n\n\n\n\n\nfn main() {\n    let mut farewell = \"goodbye\".to_owned();\n    // 需要 mut, 否则调用diary() 失败, 所以这里可以推断出只实现FnMut(含FnOnce)\n    let mut diary = || {\n        // fnMut trait call_mut(&mut self)\n        // 使用了可变借用\n        &mut farewell;\n        // 相当于 看drop 是 drop&lt;T&gt;(_x:T)\n        // 所以这里也是传递 &mut String 类型,同理 ,无法实现Fn trait\n        // drop( &mut farewell );\n    };\n    diary();\n    diary();\n}\n\n\n4.3 Fn\n\n\n\n源码定义\n\npub trait Fn&lt;Args: Tuple&gt;: FnMut&lt;Args&gt; {\n    /// Performs the call operation.\n    #[unstable(feature = \"fn_traits\", issue = \"29625\")]\n    extern \"rust-call\" fn call(&self, args: Args) -&gt; Self::Output;\n}\n\n\n\n\n\n\n\n得出结论\n\n\n\n\n我们可以看到,实现了Fn trait的闭包,肯定也实现FnMut, FnOnce 这2个trait\n实现了Fn trait的闭包(实际就是三个trait全部实现)的闭包,调用时相当于FnMut::call(&self,args)\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\n\n那种不捕获任何值的闭包或最终只使用捕获变量的不可变借用的闭包,就是实现Fn trait的闭包\n\n\n\nfn main() {\n    let farewell = \"goodbye\".to_owned();\n    let diary = move || {\n        println!(\"I said {}.\", farewell);\n    };\n    diary(); // ok\n    diary(); // ok\n}\nfn apply&lt;F&gt;(f: F)\nwhere\n    F: Fn(),\n{\n    f();\n}\n// 也是实现了 Fn() trait\nfn function() {\n    println!(\"I'm a function!\");\n}\nfn main() {\n    let x = 7;\n    let print = || {\n        // 对x的不可变借用\n        println!(\"{}\", x);\n    };\n    apply(print);\n    apply(function);\n    println!(\"{}\", x);\n}",
    "crumbs": [
      "核心基础",
      "基础篇",
      "闭包"
    ]
  },
  {
    "objectID": "docs/basic/closure.html#trait-bound",
    "href": "docs/basic/closure.html#trait-bound",
    "title": "rust 闭包",
    "section": "5 trait bound",
    "text": "5 trait bound\n\n\n实现了 FnMut trait的闭包用FnOnce() 做约束\n\n// trait 是FnOnce , 表示传递的参数必须是实现了FnOnce的闭包\n// 这里的写法 和一般的trait 不太一样\nfn apply&lt;F&gt;(f: F)\nwhere\n    F: FnOnce(),\n{\n    f();\n    // f(); 再次调用就报错了.\n}\nfn main() {\n    let mut farewell = \"goodbye\".to_owned();\n    let mut diary = || {\n        farewell.push_str(\" world\");\n        println!(\"{}\", farewell);\n    };\n    diary(); // diary 实现FnMut (也实现了 FnOnce)\n    apply(diary); // 可以传递给参数是闭包,类型为 FnOnce() 的函数\n\n\n\n实现了 Fn trait的闭包用FnMut() 做约束\n\nfn apply&lt;F&gt;(mut f: F)\nwhere\n    F: FnMut(),\n{\n    f();\n}\nfn main() {\n    let x = \"goodbye\".to_owned();\n    let diary = || {\n        // 对x 不可变借用的捕获\n        println!(\"{}\", x);\n    };\n    // diary 闭包实现了全部trait\n    diary();\n    // 可以传递给 参数是闭包, 类型是 FnMut() 的函数\n    apply(diary);\n}\n\n指定闭包的参数类型\n\n指定具体类型使用泛型\n\n\nfn apply&lt;F&gt;(f: F, v: i32)\nwhere\n    // 表示 传递的参数是闭包,然后必须携带一个i32的参数\n    F: FnOnce(i32),\n{\n    f(v);\n}\n\nfn main() {\n    let mut farewell = \"goodbye\".to_owned();\n    let mut diary = |x| {\n        println!(\"param: {}\", x);\n        farewell.push_str(\" hello\");\n    };\n    diary(22);\n    diary(21);\n    apply(diary, 33);\n    println!(\"{}\", farewell);\n}\n\n\n增加闭包的返回值\n\nfn apply&lt;F&gt;(f: F, v: i32)\nwhere\n    // 表示 传递的参数是闭包,然后必须携带一个i32的参数,有返回值且类型是i32\n    F: Fn(i32) -&gt; i32,\n{\n    f(v);\n}\n\nfn main() {\n    let diary = |x| {\n        println!(\"{x}\");\n        x + 1\n    };\n    diary(22);\n    diary(21);\n    apply(diary, 33);\n}\n\n\n\nfn apply&lt;F, T&gt;(f: F, v: T)\nwhere\n    // 表示 传递的参数是闭包,然后必须携带一个类型是T的参数\n    F: FnOnce(T),\n{\n    f(v);\n}\n\nfn main() {\n    let mut farewell = \"goodbye\".to_owned();\n    let mut diary = |x| {\n        println!(\"param: {}\", x);\n        farewell.push_str(\" hello\");\n    };\n    //如果这里调用这个一下, 会将闭包的参数进行推断,变成&str了,\n    diary(\"abc\");\n    apply(diary, \" world\");\n    println!(\"{}\", farewell);\n}",
    "crumbs": [
      "核心基础",
      "基础篇",
      "闭包"
    ]
  },
  {
    "objectID": "docs/basic/closure.html#闭包作为返回值",
    "href": "docs/basic/closure.html#闭包作为返回值",
    "title": "rust 闭包",
    "section": "6 闭包作为返回值",
    "text": "6 闭包作为返回值\nfn create_fn() -&gt; impl Fn() {\n    let text = \"Fn\".to_owned();\n    // move 必须要有,要不然最后 text 会被 drop\n    move || println!(\"This is a: {}\", text)\n}\n\nfn create_fnmut() -&gt; impl FnMut() {\n    let text = \"FnMut\".to_owned();\n    // 同样move\n    move || println!(\"This is a: {}\", text)\n}\n\nfn create_fnonce() -&gt; impl FnOnce() {\n    let text = \"FnOnce\".to_owned();\n\n    move || println!(\"This is a: {}\", text)\n}\n\nfn main() {\n    let fn_plain = create_fn();\n    let mut fn_mut = create_fnmut();\n    let fn_once = create_fnonce();\n\n    fn_plain();\n    fn_mut();\n    fn_once();\n}",
    "crumbs": [
      "核心基础",
      "基础篇",
      "闭包"
    ]
  },
  {
    "objectID": "docs/basic/closure.html#闭包的类型",
    "href": "docs/basic/closure.html#闭包的类型",
    "title": "rust 闭包",
    "section": "7 闭包的类型?",
    "text": "7 闭包的类型?\nfn main() {\n    let mut f = |x: i32| x + 1;\n    // 会报错, 前面说过, 编译器会给闭包生成一个匿名的结构体\n    // 就算闭包的参数和返回值一样, 也是不同的结构体, 所以是不同的类型\n    f = |x: i32| x + 1;\n}",
    "crumbs": [
      "核心基础",
      "基础篇",
      "闭包"
    ]
  },
  {
    "objectID": "docs/basic/share_code/modify_static_var.html",
    "href": "docs/basic/share_code/modify_static_var.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "可变的静态变量,修改需要unsafe\n\nstatic mut COUNTER: u32 = 0;\nfn add_to_count(inc: u32) {\n    unsafe {\n        COUNTER += inc;\n    }\n}\n\nfn main() {\n    add_to_count(3);\n\n    println!(\"COUNTER: {}\", unsafe { COUNTER });\n}\n\n\n\n\n Back to top"
  },
  {
    "objectID": "docs/basic/macro.html",
    "href": "docs/basic/macro.html",
    "title": "rust 宏",
    "section": "",
    "text": "Caution\n\n\n\ntodo…\n宏是用来编写可以生成其他代码的 代码 (metaprogramming)\n编译器编译时会将宏进行展开,就是会替换成具体的rust代码",
    "crumbs": [
      "核心基础",
      "基础篇",
      "宏"
    ]
  },
  {
    "objectID": "docs/basic/macro.html#println",
    "href": "docs/basic/macro.html#println",
    "title": "rust 宏",
    "section": "1 println!",
    "text": "1 println!\n我们之前一直用这个宏来打印信息, 因为这个标准输出宏可以在编译期进行格式检查,这样更安全",
    "crumbs": [
      "核心基础",
      "基础篇",
      "宏"
    ]
  },
  {
    "objectID": "docs/basic/trait.html",
    "href": "docs/basic/trait.html",
    "title": "rust trait",
    "section": "",
    "text": "Tip\n\n\n\n\ntrait在其他语言里,类似接口interface\ntrait里定义若干行为或者说功能(在代码中体现为方法)\n\n是一种约束\n\n类型是对变量申请的内存空间的一种约束\n泛型可以说就是因为类型约束的过于严格而产生的\n然后泛型又过于宽泛了,啥都行,我就想要符合某种特征(具有某些行为)的类型,这样就产生了trait用来约束泛型\n\n只要实现某个trait\n\n就具备了某种能力或功能\n共享了一些能力: trait 定义里有默认实现的方法,所有实现该trait的类型都可以直接用",
    "crumbs": [
      "核心基础",
      "基础篇",
      "trait"
    ]
  },
  {
    "objectID": "docs/basic/trait.html#定义",
    "href": "docs/basic/trait.html#定义",
    "title": "rust trait",
    "section": "",
    "text": "Tip\n\n\n\n\ntrait在其他语言里,类似接口interface\ntrait里定义若干行为或者说功能(在代码中体现为方法)\n\n是一种约束\n\n类型是对变量申请的内存空间的一种约束\n泛型可以说就是因为类型约束的过于严格而产生的\n然后泛型又过于宽泛了,啥都行,我就想要符合某种特征(具有某些行为)的类型,这样就产生了trait用来约束泛型\n\n只要实现某个trait\n\n就具备了某种能力或功能\n共享了一些能力: trait 定义里有默认实现的方法,所有实现该trait的类型都可以直接用",
    "crumbs": [
      "核心基础",
      "基础篇",
      "trait"
    ]
  },
  {
    "objectID": "docs/basic/trait.html#入门例子",
    "href": "docs/basic/trait.html#入门例子",
    "title": "rust trait",
    "section": "2 入门例子",
    "text": "2 入门例子\n\n\n\n\n\n\nImportant\n\n\n\n\n我们在结构体章节中已经提到, self 相当于 self: Self, Self是一种类型,表示结构体本身\ntrait中定义的方法里也是一样的省略写法\n\nSelf 表示实现了该trait的具体类型\nself = self: Self\n&self = self: &Self\n&mut self = self: &mut Self\n如果trait中定义的方法的第一个参数是以上三种(还有类似这种参数设置 self: Box&lt;Self&gt;), 那么表示这是一个实例方法, 其他情况则称为关联方法(或者称:静态方法)\n\n\n\n\ntrait ExampleTrait {\n    // 没有方法体的方法, 实现该trait的类型 必须实现该方法\n    // 使用 &self 参数的方法，不修改数据\n    fn inspect(&self) -&gt; &str;\n\n    // 使用 &mut self 参数的方法，可以修改数据\n    fn modify(&mut self, tmp: &str);\n\n    // 使用 self 参数的方法，通常用于消费 trait 对象本身\n    fn consume(self);\n    // 有默认实现的方法, 实现该trait的类型可以不用写\n    // 当然也可以重新写来覆盖这个方法的具体实现\n    // 可以说是一种代码共享了, 因为可以直接用了\n    fn say(&self) {\n        println!(\"hello rust\");\n    }\n    // 无接收者的静态方法\n    fn hello();\n    // 不是self:&Self, 用其他的名字看看\n    // 有默认实现\n    fn world(this: &Self) {\n        println!(\"use this\");\n    }\n}\n\nstruct ExampleStruct {\n    value: String,\n}\n\n// 为ExampleStruct实现 ExampleTrait\nimpl ExampleTrait for ExampleStruct {\n    fn inspect(&self) -&gt; &str {\n        &self.value\n    }\n    fn modify(&mut self, tmp: &str) {\n        self.value.push_str(tmp);\n    }\n    fn consume(self) {\n        println!(\"Consumed value: {}\", self.value);\n        // `self` 被消费，之后无法使用\n    }\n    // 必须实现这个\n    fn hello(){\n        println!(\"hello example\");\n    }\n}\n\nfn main() {\n    let mut example = ExampleStruct {\n        value: \"Hello\".to_string(),\n    };\n    // 直接调用trait里的已经实现了的方法\n    example.say();\n\n    ExampleStruct::hello(); // 调用静态函数\n    // 第一个参数名不是 self, 用其他, 只能用这种方式, 不能用 实例.方法()\n    ExampleTrait::world(&example); // 调用trait 有默认实现的静态方法\n\n    // 调用 inspect 方法, 相当于 ExampleTrait::inspect(&example)\n    println!(\"Before modification: {}\", example.inspect());\n    println!(\"Before modification: {}\", ExampleTrait::inspect(&example));\n\n    // 调用 modify 方法\n    example.modify(\" world\");\n\n    // 调用 inspect 方法，查看修改结果\n    println!(\"After modification: {}\", example.inspect());\n    // 相当于\n    ExampleTrait::modify(&mut example, \" rust\");\n    println!(\"After modification: {}\", example.inspect());\n\n    // 调用 consume 方法，这会消费 example，之后不能再使用 example\n    example.consume();\n    // 下面这行代码如果取消注释会导致编译错误，因为 example 已经被消费了\n    // println!(\"Cannot use example after consume: {}\", example.inspect());\n}\ntrait方法第一个参数的变量名是self, 但是类型是这种Box&lt;Self&gt; 的情况\ntrait ExampleTrait {\n    fn consume(self: Box&lt;Self&gt;);\n}\n\nstruct ExampleStruct {\n    value: String,\n}\n\nimpl ExampleTrait for ExampleStruct {\n    fn consume(self: Box&lt;Self&gt;) {\n        println!(\"Consumed value: {}\", (*self).value);\n        println!(\"Consumed value: {}\", self.value);\n    }\n}\nfn main() {\n    let example = Box::new(ExampleStruct {\n        value: \"Hello\".to_string(),\n    });\n\n    example.consume();\n}",
    "crumbs": [
      "核心基础",
      "基础篇",
      "trait"
    ]
  },
  {
    "objectID": "docs/basic/trait.html#给内置或外部类型实现trait",
    "href": "docs/basic/trait.html#给内置或外部类型实现trait",
    "title": "rust trait",
    "section": "3 给内置或外部类型实现trait",
    "text": "3 给内置或外部类型实现trait\n\n3.1 为i32 实现一个我们定义的trait\ntrait Pow {\n    fn pow(&self) -&gt; i32;\n}\nimpl Pow for i32 {\n    fn pow(&self) -&gt; i32 {\n        *self * *self\n    }\n}\nfn main() {\n    let a = 3;\n    println!(\"{}\", a.pow());\n}\n\n\n3.2 孤儿规则 (orphan rule)\n\n\n\n\n\n\nCaution\n\n\n\n\n如果你想要为类型A实现trait B,那么要么类型A是在当前的crate中定义的,要么trait B是在当前的crate中定义的\n如果要实现外部定义的trait需要先将其导入作用域\n再换句话说就是\n\n可以对外部类型实现自定义的trait\n可以对自定义类型上实现外部trait\n外部是指不是由当前crate,而是由外部定义的,比如标准库\n\n\n\n\n\n\n3.3 newtype”绕过”孤儿规则\nuse std::fmt;\n\n// only traits defined in the current crate can be implemented for types defined outside of the crate\n// define and implement a trait or new type instead\n// impl fmt::Display for Vec&lt;String&gt; {\n//     fn fmt(&self, f: &mut fmt::Formatter) -&gt; fmt::Result {\n//         write!(f, \"[{}]\", self.0.join(\", \"))\n//     }\n// }\n// 使用元祖结构体 变成一个新的类型,是本地的\n// Vec 是标准库里的,属于外部类型\nstruct Wrapper(Vec&lt;String&gt;);\n// fmt::Display 这个是外部trait\nimpl fmt::Display for Wrapper {\n    fn fmt(&self, f: &mut fmt::Formatter) -&gt; fmt::Result {\n        write!(f, \"[{}]\", self.0.join(\", \"))\n    }\n}\n\nfn main() {\n    let w = Wrapper(vec![String::from(\"hello\"), String::from(\"world\")]);\n    println!(\"w = {}\", w);\n}",
    "crumbs": [
      "核心基础",
      "基础篇",
      "trait"
    ]
  },
  {
    "objectID": "docs/basic/trait.html#完全限定语法",
    "href": "docs/basic/trait.html#完全限定语法",
    "title": "rust trait",
    "section": "4 完全限定语法",
    "text": "4 完全限定语法\n\n\n\n\n\n\nImportant\n\n\n\n\n当一个结构体实现了多个trait,而这些trait里有相同的方法,无法直接用实例.方法()来调用,那么如何调用这些方法呢?\n\n\n\n// 定义第一个trait，它有一个名为`announce`的方法\ntrait TraitOne {\n    fn announce(&self);\n}\n\n// 定义第二个trait，它也有一个名为`announce`的方法\ntrait TraitTwo {\n    fn announce(&self);\n}\n\n// 定义一个结构体`Speaker`\nstruct Speaker {\n    message: String,\n}\n\n// 为`Speaker`实现`TraitOne`\nimpl TraitOne for Speaker {\n    fn announce(&self) {\n        println!(\"traitOne: {}\", &self.message)\n    }\n}\n\n// 为`Speaker`实现`TraitTwo`\nimpl TraitTwo for Speaker {\n    fn announce(&self) {\n        println!(\"traitTwo: {}\", &self.message)\n    }\n}\n\nfn main() {\n    // 创建一个`Speaker`实例\n    let speaker = Speaker {\n        message: \"Hello\".to_string(),\n    };\n\n    // speaker.announce(); 报错了 提示用多个announce\n    // 使用完全限定语法调用`TraitOne`的`announce`方法\n    &lt;Speaker as TraitOne&gt;::announce(&speaker);\n    TraitOne::announce(&speaker);\n\n    // 使用完全限定语法调用`TraitTwo`的`announce`方法\n    &lt;Speaker as TraitTwo&gt;::announce(&speaker);\n    TraitTwo::announce(&speaker);\n}",
    "crumbs": [
      "核心基础",
      "基础篇",
      "trait"
    ]
  },
  {
    "objectID": "docs/basic/trait.html#trait-作为约束",
    "href": "docs/basic/trait.html#trait-作为约束",
    "title": "rust trait",
    "section": "5 trait 作为约束",
    "text": "5 trait 作为约束\n\n5.1 impl 写法\n参数item, 必须是实现了Summary这个trait的类型,这里是该类型的可变借用\npub fn notify(item: &impl Summary) {\n    println!(\"Breaking news! {}\", item.summarize());\n}\n\n\n5.2 泛型 写法\nimpl Summary 相比较这个写法, 我们一般用下面这样的写法\npub fn notify&lt;T: Summary&gt;(item: &T) {\n    println!(\"Breaking news! {}\", item.summarize());\n}\n\npub fn notify(item1: &impl Summary, item2: &impl Summary) {\n    // ...\n}\n// 多个参数, 这样写就比上面的简洁\npub fn notify&lt;T: Summary&gt;(item1: &T, item2: &T) {\n    // ...\n}\n\n\n指定多个trait\n\npub fn notify(item: &(impl Summary + Display)) {\n    // ...\n}\n\npub fn notify&lt;T: Summary + Display&gt;(item: &T) {\n    // ...\n}\n\n\n\n5.3 where 写法\n当我们在指定多个参数 然后每个参数要实现多个trait时, 写起来可能不是那么清晰, 这时我们可以使用where来简化\nfn some_function&lt;T: Display + Clone, U: Clone + Debug&gt;(t: &T, u: &U) -&gt; i32 {\n    //...\n}\n\n\n使用where的写法\n\nfn some_function&lt;T, U&gt;(t: &T, u: &U) -&gt; i32\nwhere\n    T: Display + Clone,\n    U: Clone + Debug,\n{\n    // ...\n}",
    "crumbs": [
      "核心基础",
      "基础篇",
      "trait"
    ]
  },
  {
    "objectID": "docs/basic/trait.html#trait的不同形式",
    "href": "docs/basic/trait.html#trait的不同形式",
    "title": "rust trait",
    "section": "6 trait的不同形式",
    "text": "6 trait的不同形式\n\n6.1 简单 trait\n入门例子中举的例子就属于非常简单的类型\ntrait ExampleTrait {\n    fn inspect(&self) -&gt; &str;\n}\n\n\n6.2 泛型 trait\n\n6.2.1 产生原因和使用方式\n\n\n不使用泛型的情况\n\n#[derive(Debug)]\nstruct Number {\n    value: i32,\n}\n// 定义一个trait\ntrait MyFrom {\n    // 这个\"行为\"的想法是 想从类型i32,生成一个类型 Self (即: 实现该trait的主体)\n    fn my_from(item: i32) -&gt; Self;\n}\nimpl MyFrom for Number {\n    fn my_from(item: i32) -&gt; Self {\n        Self { value: item }\n    }\n}\n#[derive(Debug)]\nstruct MyString {\n    value: String,\n}\ntrait MyFrom2 {\n    // 由于类型不同, 我们不得不 重新定义个 trait\n    // 里面的\"行为\" 实际它的逻辑一样, 都是从一个类型生成 Self 类型\n    // 但是我们不得不重新写一遍\n    fn my_from(item: String) -&gt; Self;\n}\nimpl MyFrom2 for MyString {\n    fn my_from(item: String) -&gt; Self {\n        Self { value: item }\n    }\n}\nfn main() {\n    let num = Number::my_from(30);\n    let str2 = MyString::my_from(\"hello\".to_string());\n    println!(\"My number is {:?}\", num);\n    println!(\"My string is {:?}\", str2);\n}\n\n\n可以从一种类型生成另外一种类型, 这个行为应该是非常抽象的, 是说几乎每个类型都可以有这样一个行为\n\n\n\n使用泛型参数的trait\n\n#[derive(Debug)]\nstruct Number {\n    value: i32,\n}\n// trait 定义的行为 依赖于多个不同类型, 我们就使用泛型\ntrait MyFrom&lt;T&gt; {\n    fn my_from(item: T) -&gt; Self;\n}\nimpl MyFrom&lt;i32&gt; for Number {\n    fn my_from(item: i32) -&gt; Self {\n        Number { value: item }\n    }\n}\n#[derive(Debug)]\nstruct MyString {\n    value: String,\n}\nimpl MyFrom&lt;String&gt; for MyString {\n    fn my_from(item: String) -&gt; Self {\n        Self { value: item }\n    }\n}\n\nfn main() {\n    let num = Number::my_from(30);\n    let str2 = MyString::my_from(\"hello\".to_string());\n    println!(\"My number is {:?}\", num);\n    println!(\"My string is {:?}\", str2);\n}\n\nuse std::fmt::Display;\n\ntrait Animal&lt;T&gt;\nwhere\n    T: Display,\n{\n    fn shout(&self, v: T);\n}\nstruct Dog;\n\n// impl&lt;T&gt; 中的&lt;T&gt; 是申明泛型\n// Aniaml&lt;T&gt; 中的T 就已经是在使用了,不是申明\nimpl&lt;T&gt; Animal&lt;T&gt; for Dog\nwhere\n    T: Display,\n{\n    fn shout(&self, v: T) {\n        println!(\"{}\", v);\n    }\n}\n// 这里会报错, 因为 前面 的  `impl&lt;T&gt; Animal&lt;T&gt; for Dog` 已经包含了这里的情况\n// 如果你 上面的不要写, 单独为Dog 实现多个 trait, `impl Animal&lt;String&gt;` ,`impl Animal&lt;i32&gt;`这样具化类型, 是可以的\n// impl Animal&lt;String&gt; for Dog {\n//     fn shout(&self, v: String) {\n//         println!(\"{}\", v);\n//     }\n// }\n\nfn main() {\n    let a = Dog;\n    // Dog 的实例实现了 trait (Animal&lt;T&gt;)的shout 方法\n    // shout 使用的参数类型, 具化了 T\n    // 下面2个都ok\n    a.shout(123);\n    a.shout(\"wang wang\");\n}\n\n\n6.2.2 设置泛型默认值\ntrait Summable&lt;T = i32&gt; {\n    fn sum(&self) -&gt; T;\n}\n\n// 实现Summable trait，使用默认的泛型类型 i32\nimpl Summable for Vec&lt;i32&gt; {\n    fn sum(&self) -&gt; i32 {\n        self.iter().sum()\n    }\n}\n\n// 实现Summable trait，但为泛型指定一个不同的类型 f64\nimpl Summable&lt;f64&gt; for Vec&lt;f64&gt; {\n    fn sum(&self) -&gt; f64 {\n        self.iter().sum()\n    }\n}\n\nfn main() {\n    let vec_i32: Vec&lt;i32&gt; = vec![1, 2, 3];\n    let vec_f64: Vec&lt;f64&gt; = vec![1.0, 2.0, 3.0];\n\n    // 使用默认的泛型类型 i32\n    println!(\"Sum of vec_i32: {}\", vec_i32.sum());\n\n    // 使用指定的泛型类型 f64\n    println!(\"Sum of vec_f64: {}\", vec_f64.sum());\n}\n\n\n\n6.3 关联类型 trait\n\n6.3.1 产生的原因和使用\n// 有一个trait, 需要多个泛型参数\ntrait ExampleTrait&lt;A, B, C&gt; {\n    fn tmp(&self, x: A, y: B) -&gt; C;\n    fn get(&self) -&gt; C;\n}\nstruct ExampleStruct {}\n// 每次你为某个结构体实现这个trait时, 就需要写 很多个泛型参数\n// 很麻烦\nimpl ExampleTrait&lt;i32, i64, i8&gt; for ExampleStruct {\n    fn tmp(&self, x: i32, y: i64) -&gt; i8 {\n        6i8\n    }\n    fn get(&self) -&gt; i8 {\n        self.tmp(1, 2)\n    }\n}\n// 当你写一个函数, 参数类型需要 实现ExampleTrait 的时候\n// 你需要这样写上一堆 泛型参数, 也很麻烦\nfn test&lt;A, B, C, D&gt;(x: &D) -&gt; C\nwhere\n    D: ExampleTrait&lt;A, B, C&gt;,\n{\n    x.get()\n}\n\n\n使用关联类型\n\ntrait ExampleTrait {\n    type A; // 像占位符一样\n    type B;\n    type C;\n    fn tmp(&self, x: Self::A, y: Self::B) -&gt; Self::C;\n    fn get(&self) -&gt; Self::C;\n}\nstruct ExampleStruct1 {}\nimpl ExampleTrait for ExampleStruct1 {\n    // 给具体类型实现 trait的时候\n    // 我们就写成具体的类型\n    type A = i32;\n    type B = i64;\n    type C = i8;\n    // 里面可以直接写 具体的类型\n    fn tmp(&self, x: i32, y: i64) -&gt; i8 {\n        // ... 这里无需关心具体实现.. 我们就只是说明关联类型的优点\n        6i8\n    }\n    fn get(&self) -&gt; i8 {\n        self.tmp(1, 2)\n    }\n}\nstruct ExampleStruct2 {}\nimpl ExampleTrait for ExampleStruct2 {\n    type A = i32;\n    type B = i64;\n    type C = i8;\n    // 当然可以写 Self::A 这种 (和前面写具体类型都是可以的)\n    fn tmp(&self, x: Self::A, y: Self::B) -&gt; Self::C {\n        1i8\n    }\n    fn get(&self) -&gt; Self::C {\n        self.tmp(1, 2)\n    }\n}\n// 有一个函数, 参数类型需要 实现ExampleTrait2\nfn test&lt;D&gt;(x: &D) -&gt; D::C\nwhere\n    D: ExampleTrait,\n{\n    x.get()\n}\nfn main() {\n    let a = ExampleStruct1 {};\n    let f = test(&a);\n    println!(\"{}\", f);\n    let b = ExampleStruct2 {};\n    let f = test(&b);\n    println!(\"{}\", f);\n}\n\n\n\n6.3.2 使用trait的关联类型来约束类型\ntrait Person {\n    type AAA;\n    fn shout(&self, msg: Self::AAA);\n}\n// 定义一个结构体,规定内部成员homeowner的类型必须实现Person这个trait\n// 成员 house_name 的类型 必须是 实现了Person 这个trait的类 中定义的关联类型 AAA\nstruct House&lt;T: Person&gt; {\n    homeowner: T,\n    house_name: T::AAA,\n}\n\nstruct Man {\n    name: String,\n}\nimpl Person for Man {\n    // 如果将这个 AAA 改成其他类型, 那么就会在实例化 House时house_name 也要改成这里指定的类型\n    type AAA = String;\n    fn shout(&self, msg: Self::AAA) {\n        println!(\"{}\", msg);\n    }\n}\nfn main() {\n    let s = House {\n        homeowner: Man {\n            name: \"jerry\".to_string(),\n        },\n        house_name: \"jerry's home\".to_string(),\n    };\n    s.homeowner.shout(\"啊啊啊\".to_string());\n}\n\n\n6.3.3 直接指定具体类型来约束关联类型\ntrait Person {\n    type AAA;\n    fn shout(&self, msg: Self::AAA);\n}\n// 定义一个结构体\n//  1. 约束了内部成员的类型必须实现Person这个trait\n//  2. Person实现这个trait的代码中使用的关联类型必须是String\nstruct House&lt;T: Person&lt;AAA = String&gt;&gt; {\n    homeowner: T,\n}\n\nstruct Man {\n    name: String,\n}\n// 为了实例化 House 中使用的字段 homeowner 可以用\n// 我们为其实现Person trait\nimpl Person for Man {\n    // 关联类型 设置为String\n    // 如果将这个 AAA 改成其他类型, 那么就会在实例化 House 那里报错\n    // 因为这样的 Man 不是我们要的\n    type AAA = String;\n    fn shout(&self, msg: Self::AAA) {\n        println!(\"{}\", msg);\n    }\n}\nfn main() {\n    let s = House {\n        homeowner: Man {\n            name: \"jerry\".to_string(),\n        },\n    };\n    s.homeowner.shout(\"啊啊啊\".to_string());\n}\n\n\n6.3.4 使用trait 约束关联类型\nuse std::fmt::Display;\n\ntrait Person {\n    type AAA: Display;\n    fn shout(&self, msg: Self::AAA);\n}\nstruct House&lt;T: Person&gt; {\n    homeowner: T,\n}\n\nstruct Man {\n    name: String,\n}\nimpl Person for Man {\n    type AAA = i32; //String 也行, 必须是实现了 Display 这个trait\n    fn shout(& self, msg: Self::AAA) {\n        println!(\"{}\", msg);\n    }\n}\nfn main() {\n    let  s = House {\n        homeowner: Man {\n            name: \"jerry\".to_string(),\n        },\n    };\n    s.homeowner.shout(123);\n}\n\n\n\n6.4 关联常量 trait\ntrait Country {\n    const HISTORY: u32 = 5000;\n    const INDEPENDENT: bool = true;\n    fn get_code(&self) -&gt; u32 {\n        Self::HISTORY\n    }\n}\n\nstruct China;\nimpl Country for China {\n    const HISTORY: u32 = 7000;\n}\n\nfn main() {\n    let c = China;\n    println!(\"{}\", c.get_code());\n    println!(\"{:?}\", China::HISTORY);\n    println!(\"{:?}\", &lt;China as Country&gt;::HISTORY);\n    println!(\"{:?}\", China::INDEPENDENT);\n    println!(\"{:?}\", &lt;China as Country&gt;::INDEPENDENT);\n}\n\n\n6.5 继承 trait\n\n\n\n\n\n\nCaution\n\n\n\n\n用继承这个词, 其实我觉得不太好\n比如如果说trait A继承了B, 但是实际A并没有B的行为, 只是你在实现trait A的时候,必须实现trait B\n\n\n\ntrait Animal {\n    fn shout(&self);\n}\n// 表示如果有类型要实现 Person 这个 trait, 那么它必须也要实现 Animal这个trait\n// 相当于 T: Person + Animal\ntrait Person: Animal {\n    fn speak(&self);\n    fn shout(&self);\n}\n\nstruct Student;\n\nimpl Person for Student {\n    fn speak(&self) {\n        println!(\"hello...\");\n    }\n    fn shout(&self) {\n        println!(\"person...\");\n    }\n}\nimpl Animal for Student {\n    fn shout(&self) {\n        println!(\"animal...\");\n    }\n}\nimpl Student {\n    // 如果没有自己实现自己的方法,\n    // 上面2个trait 中都有shout, main中调用 d.shout() 会报错\n    fn shout(&self) {\n        println!(\"类自己的方法...\");\n    }\n}\nfn main() {\n    let d = &Student;\n    d.shout(); // 类自己的方法...\n    // &lt;Type as Trait&gt;:: 完全限定语法,\n        // 在没有参数的情况下使用Person::shout()会报错, 需要用这个语法才可以\n    //  使用  Student 实现Person 这个trait 时的shout 方法\n    &lt;Student as Person&gt;::shout(d); // person...\n    Person::shout(d); // person...\n    &lt;Student as Animal&gt;::shout(d); // animal...\n    Animal::shout(d); // animal...\n}\n\n\n6.6 标记用 trait\n\n\n\n\n\n\nImportant\n\n\n\n\n这些trait 没有任何行为,里面是空的. 是给编译器用的, 会给类型打上一个标记,这些标记会影响编译器的静态检查和代码生成\n分别是 Copy ,Send, Sync, Sized 这4个\nSized trait\n\n表示类型能确定大小\n编译阶段能确定大小的类型,编译器就自动为其实现该trait\n\n\n\n\n我们分别在其他地方详细说明",
    "crumbs": [
      "核心基础",
      "基础篇",
      "trait"
    ]
  },
  {
    "objectID": "docs/basic/trait.html#返回值指定trait",
    "href": "docs/basic/trait.html#返回值指定trait",
    "title": "rust trait",
    "section": "7 返回值指定trait",
    "text": "7 返回值指定trait\nfn returns_summarizable() -&gt; impl Summary {\n    Tweet {\n        username: String::from(\"horse_ebooks\"),\n        content: String::from(\n            \"of course, as you probably already know, people\",\n        ),\n        reply: false,\n        retweet: false,\n    }\n}\n下面这个会报错\nfn returns_summarizable(switch: bool) -&gt; impl Summary {\n    if switch {\n        NewsArticle {\n            headline: String::from(\n                \"Penguins win the Stanley Cup Championship!\",\n            ),\n            location: String::from(\"Pittsburgh, PA, USA\"),\n            author: String::from(\"Iceburgh\"),\n            content: String::from(\n                \"The Pittsburgh Penguins once again are the best \\\n                 hockey team in the NHL.\",\n            ),\n        }\n    } else {\n        Tweet {\n            username: String::from(\"horse_ebooks\"),\n            content: String::from(\n                \"of course, as you probably already know, people\",\n            ),\n            reply: false,\n            retweet: false,\n        }\n    }\n}",
    "crumbs": [
      "核心基础",
      "基础篇",
      "trait"
    ]
  },
  {
    "objectID": "docs/basic/trait.html#运算符重载",
    "href": "docs/basic/trait.html#运算符重载",
    "title": "rust trait",
    "section": "8 运算符重载",
    "text": "8 运算符重载\nuse std::ops::Add;\n\n#[derive(Debug, Copy, Clone, PartialEq)]\nstruct Point {\n    x: i32,\n    y: i32,\n}\n// 给Point 实现Add trait, Add trait 定义了+加法 会如何操作\nimpl Add for Point {\n    type Output = Point;\n\n    fn add(self, other: Point) -&gt; Point {\n        Point {\n            x: self.x + other.x,\n            y: self.y + other.y,\n        }\n    }\n}\n\nfn main() {\n    assert_eq!(\n        Point { x: 1, y: 0 } + Point { x: 2, y: 3 },\n        Point { x: 3, y: 3 }\n    );\n}\n我们看下Add trait的定义,发现实际带有类型参数,默认值是Self\npub trait Add&lt;Rhs = Self&gt; {\n    // ...\n}\n不同类型的+ 加法重载\nuse std::ops::Add;\n\nstruct Millimeters(u32);\nstruct Meters(u32);\n\nimpl Add&lt;Meters&gt; for Millimeters {\n    type Output = Millimeters;\n\n    fn add(self, other: Meters) -&gt; Millimeters {\n        Millimeters(self.0 + (other.0 * 1000))\n    }\n}\n\nfn main() {\n    let mm = Millimeters(10);\n    let m = Meters(1);\n\n    let sum = mm + m;\n    // sum is of type Millimeters\n    println!(\"sum is {}\", sum.0); // 1010\n    // 注意这样是不行的, 顺序是有关系的\n    // let sum2 = m + mm;\n}",
    "crumbs": [
      "核心基础",
      "基础篇",
      "trait"
    ]
  },
  {
    "objectID": "docs/basic/trait.html#trait-object",
    "href": "docs/basic/trait.html#trait-object",
    "title": "rust trait",
    "section": "9 trait object",
    "text": "9 trait object\n\n9.1 使用\n我们有这样一个需求, 创建一个GUI 工具, 会遍历一个列表, 调用每个元素的draw方法\n我们很快就能想到使用泛型,试试看\npub trait Draw {\n    fn draw(&self);\n}\npub struct ScreenWithGeneric&lt;T: Draw&gt; {\n    pub components: Vec&lt;T&gt;,\n}\n\nimpl&lt;T&gt; ScreenWithGeneric&lt;T&gt;\nwhere\n    T: Draw,\n{\n    pub fn run(&self) {\n        for component in self.components.iter() {\n            component.draw();\n        }\n    }\n}\n\npub struct Button {}\n\nimpl Draw for Button {\n    fn draw(&self) {\n        println!(\"Button\");\n    }\n}\nstruct SelectBox {}\nimpl Draw for SelectBox {\n    fn draw(&self) {\n        println!(\"SelectBox\");\n    }\n}\n\nfn main() {\n    let botton = Button {};\n    let botton2 = Button {};\n    let select_box = SelectBox {};\n    let s = ScreenWithGeneric {\n        // 报错了, 类型不一致了\n        components: vec![botton, select_box],\n    };\n    s.run();\n}\n结果发现行不通, 问题的关键是我们只要列表里的元素能够执行 draw 方法就行, 不管它是什么类型. 有什么办法呢? trait object 可以解决这个问题\n\npub trait Draw {\n    fn draw(&self);\n}\npub struct Screen {\n    // Box&lt;dyn Draw&gt; : 定义了一个 trait object\n    // 表示 Box里的元素必须都实现了 Draw 这个trait 就行, 不管它是什么类型\n1    pub components: Vec&lt;Box&lt;dyn Draw&gt;&gt;,\n}\nimpl Screen {\n    pub fn run(&self) {\n        for component in self.components.iter() {\n            component.draw();\n        }\n    }\n}\npub struct Button {}\n\nimpl Draw for Button {\n    fn draw(&self) {\n        println!(\"Button\");\n    }\n}\nstruct SelectBox {}\nimpl Draw for SelectBox {\n    fn draw(&self) {\n        println!(\"SelectBox\");\n    }\n}\nfn main() {\n    let button = Button {};\n\n    let select_box = SelectBox {};\n    let s = Screen {\n        // 这里ok了\n        components: vec![Box::new(button), Box::new(select_box)],\n    };\n    s.run();\n}\n\n1\n\n使用Box 包起来很好理解, 因为实现了Draw 这个trait的类型的大小不知道,直接用指针指向,所以用Box装箱\n\n\n\n\n9.2 动态派发\n\n\n\n\n\n\nTip\n\n\n\n\n当你使用泛型函数或方法时，编译器会为每个具体使用的数据类型生成专门的代码。这种机制称为单态化（Monomorphization）,单态化后的代码 会执行静态派发\n\n\n\n// 使用trait约束泛型T，这里T必须实现了Summary trait\nfn notify&lt;T: Summary&gt;(item: T) {\n    println!(\"Breaking news! {}\", item.summarize());\n}\n\n// 编译器会为每个具体使用的数据类型生成专门的代码,这样，当调用notify(tweet)和notify(article)时，直接调用的就是针对Tweet和NewsArticle预先生成好的、类型特定的函数，这就是静态派发的过程\n\n// 为Tweet类型特化生成的notify函数\nfn notify_Tweet(item: Tweet) {\n    println!(\"Breaking news! {}\", item.summarize());\n}\n\n// 为NewsArticle类型特化生成的notify函数\nfn notify_NewsArticle(item: NewsArticle) {\n    println!(\"Breaking news! {}\", item.summarize());\n}\n动态派发 ,使用dyn trait会用动态派发, 无法在编译期确定你调用的是哪个方法,会在运行时确定\n\n\n\n9.3 对象安全\n只能把满足对象安全的trait 转为 trait object\n\n安全的标准\n\n方法返回类型不是Self\n方法中没有泛型类型参数",
    "crumbs": [
      "核心基础",
      "基础篇",
      "trait"
    ]
  },
  {
    "objectID": "docs/basic/trait.html#sized-trait",
    "href": "docs/basic/trait.html#sized-trait",
    "title": "rust trait",
    "section": "10 Sized Trait",
    "text": "10 Sized Trait\n\n动态大小的类型 DST (Dynamically Sized Types)\n\n\n\n\n\n\n\nNote\n\n\n\n\n类型可以说是规定了你如何去使用一块内存: 占用多少空间, 怎么读写,比如给你弄了写方法, 方便读写\n在数组里, [1i32,2] 占用了8字节 [1i32,2,3] 12个字节, 这2个是不同的类型, 虽然我们都说他们是数组\n\n\n\n\nlet s1: str = \"Hello there!\";\nlet s2: str = \"How's it going?\";\n\n// 这个就ok了, 因为这个 &str 类型的 占用空间是确定的,\n// 可以说动态类型的数据的一种通用使用方式, 就是一个指针去指向它的实际数据,其他比如长度等信息\nlet s3: &str = \"Hello there!\";\n\n\n\n\n\n\n上面报错了, 我们分析一下\n\n\n\n\n前面2行报错了, 你可能会疑惑? s1和s2的占用多少空间是很确定的样子,好像没问题?\ns1 s2 两个变量是同一个str类型,但是看起来他们占用的空间却不一样, 这就有问题了\nrust 需要在栈上为变量分配固定大小的内存空间, 这需要在编译期就知道类型的大小, 而该str类型大小不确定\n\n\n\n\n为了处理这种动态大小的类型,rust提供了Sized trait 来去确定一个类型的大小在编译器是否是已知的.\n在编译期知道大小的类型, rust会为其自动的实现一个trait (Sized)\nfn generic&lt;T&gt;(t: T) {\n    // --snip--\n}\n上面的代码实际上 等同与, rust 会为 每个泛型函数隐式添加 Sized trait约束\nfn generic&lt;T: Sized&gt;(t: T) {\n    // --snip--\n}\n默认情况下, 泛型函数只能在编译期知道其类型大小的情况下工作。但是, 你可以使用以下特殊语法来放宽这一限制:\n// ?Sized 表示 T的大小可能是不确定的\nfn generic&lt;T: ?Sized&gt;(t: &T) {\n    // --snip--\n}",
    "crumbs": [
      "核心基础",
      "基础篇",
      "trait"
    ]
  },
  {
    "objectID": "docs/basic/trait.html#一些trait",
    "href": "docs/basic/trait.html#一些trait",
    "title": "rust trait",
    "section": "11 一些trait",
    "text": "11 一些trait\n\n11.1 类型转换相关\n\nFrom & IntoTryFrom & TryIntoToString & FromStr\n\n\nFrom trait 让你可以从另外一个B类型的数据,创建一个A类型的数据\nlet my_str = \"hello\";\n// 我们常用到的 String::from  就是String 类型 实现了 From trait\nlet my_string = String::from(my_str);\n\n\n自定义实现From\n\nuse std::convert::From;\n\n#[derive(Debug)]\nstruct Number {\n    value: i32,\n}\n\nimpl From&lt;i32&gt; for Number {\n    fn from(item: i32) -&gt; Self {\n        Number { value: item  }\n    }\n}\n\nfn main() {\n    let num = Number::from(30);\n    println!(\"My number is {:?}\", num);\n\n    // 如果你实现了from , 那么对方也自动实现了into\n    let int = 5;\n    // 试试删除类型说明\n    let num: Number = int.into();\n    println!(\"My number is {:?}\", num);\n}\n\n\n\n自定义实现into\n\nuse std::convert::Into;\n\n#[derive(Debug)]\nstruct Number {\n    value: i32,\n}\n\nimpl Into&lt;Number&gt; for i32 {\n    fn into(self) -&gt; Number {\n        Number { value: self }\n    }\n}\n\nfn main() {\n    let int = 5;\n    // Try removing the type annotation\n    let num: Number = int.into();\n    println!(\"My number is {:?}\", num);\n}\n\n\n\n\n\n\n\n\n\nCaution\n\n\n\n\n用于易出错的转换, 所以它的返回值是 Result 型\n\n\n\nuse std::convert::TryFrom;\nuse std::convert::TryInto;\n\n#[derive(Debug, PartialEq)]\nstruct EvenNumber(i32);\n\nimpl TryFrom&lt;i32&gt; for EvenNumber {\n    type Error = ();\n\n    fn try_from(value: i32) -&gt; Result&lt;Self, Self::Error&gt; {\n        if value % 2 == 0 {\n            Ok(EvenNumber(value))\n        } else {\n            Err(())\n        }\n    }\n}\n\nfn main() {\n    // TryFrom\n\n    assert_eq!(EvenNumber::try_from(8), Ok(EvenNumber(8)));\n    assert_eq!(EvenNumber::try_from(5), Err(()));\n\n    // TryInto\n\n    let result: Result&lt;EvenNumber, ()&gt; = 8i32.try_into();\n    assert_eq!(result, Ok(EvenNumber(8)));\n    let result: Result&lt;EvenNumber, ()&gt; = 5i32.try_into();\n    assert_eq!(result, Err(()));\n}\n\n\n\n\n\n\n\n\nCaution\n\n\n\n\n要把任何类型转换成 String, 只需要实现那个类型的 ToString trait. 然而不要直接这么做, 您应该实现fmt::Display trait,它会自动提供 ToString\n\n\n\nuse std::fmt;\n\nstruct Circle {\n    radius: i32\n}\n\nimpl fmt::Display for Circle {\n    fn fmt(&self, f: &mut fmt::Formatter) -&gt; fmt::Result {\n        write!(f, \"Circle of radius {}\", self.radius)\n    }\n}\n\nfn main() {\n    let circle = Circle { radius: 6 };\n    println!(\"{}\", circle.to_string());\n}\n\n\n\n\n\n\nTip\n\n\n\n只要对目标类型实现了 FromStr trait, 就可以用 parse 把字符串转换成目标类型\n\n\n\n\nFromStr定义一个类型如何从字符串转换而来\n\nuse std::str::FromStr;\n\n// 定义一个简单的结构体，它包含一个 u32 类型的值\nstruct MyNumber {\n    value: u32,\n}\n\n// 为 MyNumber 实现 FromStr trait\nimpl FromStr for MyNumber {\n    type Err = &'static str; // 定义错误类型为 &'static str\n\n    // from_str 方法尝试将字符串解析为 MyNumber\n    fn from_str(s: &str) -&gt; Result&lt;Self, Self::Err&gt; {\n        // 尝试将字符串转换为 u32\n        let value = s.parse::&lt;u32&gt;().map_err(|_| \"Parse error\")?;\n        // 如果成功，创建并返回 MyNumber 实例\n        Ok(Self { value })\n    }\n}\n\nfn main() {\n    // 使用 parse::&lt;MyNumber&gt;() 方法将字符串转换为 MyNumber\n    // 如果不实现 MyNumber 类型的from_str 方法, 是不能 parse的\n    let number = \"42\".parse::&lt;MyNumber&gt;().unwrap();\n    println!(\"Parsed value: {}\", number.value);\n\n    // 如果解析失败，会返回一个错误\n    if let Err(e) = \"not a number\".parse::&lt;MyNumber&gt;() {\n        println!(\"Failed to parse: {}\", e);\n    }\n\n    let parsed: i32 = \"5\".parse().unwrap();\n    let turbo_parsed = \"10\".parse::&lt;i32&gt;().unwrap();\n}\n\n\n\n\n\n\n11.2 打印相关\n\n11.2.1 Display\n\n\n\n\n\n\nNote\n\n\n\n\n实现了该trait, 类型就有了to_string方法\n只有实现了该trait , 才能使用 println!(\"{}\",x) 打印\n\n\n\nuse std::fmt;\n\nstruct Circle {\n    radius: i32\n}\n// 实现这个trait ,就有了 to_string 方法\nimpl fmt::Display for Circle {\n    fn fmt(&self, f: &mut fmt::Formatter) -&gt; fmt::Result {\n        write!(f, \"Circle of radius {}\", self.radius)\n    }\n}\n\nfn main() {\n    let circle = Circle { radius: 6 };\n    let c=circle.to_string();\n    println!(\"{}\", c);\n}\n\n\n\n11.3 index 索引操作 trait\nuse std::ops::{Index, IndexMut};\n\n// 定义一个简单的 Collection 类型\nstruct Collection&lt;T&gt; {\n    items: Vec&lt;T&gt;,\n}\n\n// 为 Collection 实现 Index trait（只读操作）\nimpl&lt;T&gt; Index&lt;usize&gt; for Collection&lt;T&gt; {\n    type Output = T;\n\n    fn index(&self, index: usize) -&gt; &Self::Output {\n        &self.items[index]\n    }\n}\n\n// 为 Collection 实现 IndexMut trait（可变操作）\nimpl&lt;T&gt; IndexMut&lt;usize&gt; for Collection&lt;T&gt; {\n    fn index_mut(&mut self, index: usize) -&gt; &mut Self::Output {\n        &mut self.items[index]\n    }\n}\n\nfn main() {\n    // 创建一个可变的 Collection 实例\n    let mut collection = Collection {\n        items: vec![10, 20, 30, 40, 50],\n    };\n\n    // 使用索引操作读取元素\n    println!(\"原始第一个元素: {}\", collection[0]);\n    println!(\"原始第三个元素: {}\", collection[2]);\n\n    // 使用索引操作修改元素\n    collection[0] = 100;\n    collection[2] = 300;\n\n    // 再次读取修改后的元素\n    println!(\"修改后第一个元素: {}\", collection[0]);\n    println!(\"修改后第三个元素: {}\", collection[2]);\n}",
    "crumbs": [
      "核心基础",
      "基础篇",
      "trait"
    ]
  },
  {
    "objectID": "docs/basic/trait.html#derive-自动派生",
    "href": "docs/basic/trait.html#derive-自动派生",
    "title": "rust trait",
    "section": "12 derive 自动派生",
    "text": "12 derive 自动派生\n\n\n\n\n\n\nTip\n\n\n\n\n设计缘由\n\nrust 为某些类型实现某些trait时, 代码基本是固定的,重复的,是一件麻烦的事情, 不难想到应该实现自动化处理.\n\n使用方法\n\n因此rust设计一个属性, 就是在你想要实现名为XXX的trait的类型前面写#[derive(XXX)], 它可以自动为你的结构体或枚举实现某些 trait, 也就是rust 编译器会自动为你生成这些 traits 的实现代码\n\n以下是一些常用的可以通过 derive 自动实现的 trait:\n\nDebug: 用于格式化输出，使得结构体或枚举在调试时可以打印其字段\nClone: 允许创建一个值的副本\nCopy: 使得类型可以按位复制,而不是移动\nPartialEq 和 Eq: 用于比较两个值是否相等\nPartialOrd 和 Ord: 用于比较两个值的顺序\nDefault: 提供一个类型的默认值\nHash: 允许类型被用作哈希表中的键\n\n\n\n\n\n12.1 Debug\n派生Debug trait后, 才能使用println!(“{:?}”)中{:?}或{:#?}这种打印方式\n\n\n#[derive(Debug)]\n\nstruct Cat(i32);\n// 添加这个就自动实现了Debug trait\n/*\n编译器会自动为你 加上\nimpl Debug for Dog {\n  // ...\n}\n*/\n#[derive(Debug)] \nstruct Dog(i32);\nfn main() {\n    println!(\"Cat: {:?} \", Cat(5)); // 报错了\n    println!(\"Dog: {:?} \", Dog(5)); // ok\n}\n\n\n\n12.2 Default\n\n\n\n\n\n\nCaution\n\n\n\n\n一般我们也不用, 首先它相当于一个构造函数, 但是我们都会自己定义一个 名字可能是new 的 静态方法\n\n\n\n// 添加Default 派生宏\n#[derive(Debug, Default)]\nstruct Rectangle {\n    width: u32,\n    height: u32,\n}\nfn main() {\n    // 可以使用这种方式来创建一个实例\n    // 使用方式1\n    let rect1: Rectangle = Default::default();\n    println!(\"{:?}\", rect1); //\n    // 使用方式2\n    let rect2 = Rectangle::default();\n    println!(\"{:?}\", rect2);\n}",
    "crumbs": [
      "核心基础",
      "基础篇",
      "trait"
    ]
  },
  {
    "objectID": "docs/basic/lifetime.html",
    "href": "docs/basic/lifetime.html",
    "title": "rust 生命周期",
    "section": "",
    "text": "fn main() {\n    let r;\n\n    {\n        let x = 5;\n        r = &x;\n    }    // x 离开作用域，其值被丢弃\n\n    println!(\"r: {}\", r);\n}\ncargo run \n --&gt; src/main.rs:6:13\n  |\n5 |         let x = 5;\n  |             - binding `x` declared here\n6 |         r = &x;\n  |             ^^ borrowed value does not live long enough\n7 |     }\n  |     - `x` dropped here while still borrowed\n8 |\n9 |     println!(\"r: {}\", r);\n  |                       - borrow later used here\nrust编译器 如何发现问题的呢?",
    "crumbs": [
      "核心基础",
      "基础篇",
      "生命周期"
    ]
  },
  {
    "objectID": "docs/basic/lifetime.html#先看个例子",
    "href": "docs/basic/lifetime.html#先看个例子",
    "title": "rust 生命周期",
    "section": "",
    "text": "fn main() {\n    let r;\n\n    {\n        let x = 5;\n        r = &x;\n    }    // x 离开作用域，其值被丢弃\n\n    println!(\"r: {}\", r);\n}\ncargo run \n --&gt; src/main.rs:6:13\n  |\n5 |         let x = 5;\n  |             - binding `x` declared here\n6 |         r = &x;\n  |             ^^ borrowed value does not live long enough\n7 |     }\n  |     - `x` dropped here while still borrowed\n8 |\n9 |     println!(\"r: {}\", r);\n  |                       - borrow later used here\nrust编译器 如何发现问题的呢?",
    "crumbs": [
      "核心基础",
      "基础篇",
      "生命周期"
    ]
  },
  {
    "objectID": "docs/basic/lifetime.html#借用检查器",
    "href": "docs/basic/lifetime.html#借用检查器",
    "title": "rust 生命周期",
    "section": "2 借用检查器",
    "text": "2 借用检查器\nThe Borrow Checker\n\n\n\n\n\n\nCaution\n\n\n\n借用的生命周期必须比 所有者的生命周期 短, 就是 所有者离开作用域前,你才可以使用它的借用\n\n\nrust编译器 有一个 borrow checker 它会比较作用域来判断所有借用是否合法\n标注上变量的生命周期,我们看看\nfn main() {\n    let r;                // ---------+-- 'a\n                          //          |\n    {                     //          |\n        let x = 5;        // -+-- 'b  |\n        r = &x;           //  |       |\n    }                     // -+       |\n                          //          |\n    println!(\"r: {}\", r); //          |\n}                         // ---------+\n这里用 ’a 表示 变量r 的生命周期, ’b 表示变量x 的生命周期 变量r (借用了x)的生命周期 ’a 比 所有者x 的生命周期 ’b 长 , 而这个时候x的生命周期 ’b 已经结束了,x不可用了\n将上面的代码修改成如下,就ok了\nfn main() {\n    let x = 5;            // ----------+-- 'b\n                          //           |\n    let r = &x;           // --+-- 'a  |\n                          //   |       |\n    println!(\"r: {}\", r); //   |       |\n                          // --+       |\n}                         // ----------+",
    "crumbs": [
      "核心基础",
      "基础篇",
      "生命周期"
    ]
  },
  {
    "objectID": "docs/basic/lifetime.html#生命周期的标注",
    "href": "docs/basic/lifetime.html#生命周期的标注",
    "title": "rust 生命周期",
    "section": "3 生命周期的标注",
    "text": "3 生命周期的标注\n\n3.1 为什么需要\n\nfn longest(x: &str, y: &str) -&gt; &str {\n    if x.len() &gt; y.len() {\n        x\n    } else {\n        y\n    }\n}\nfn main() {\n    let string1 = String::from(\"long string is long\");\n    let result;\n    {\n        let string2 = \"xyz\".to_string();\n        result = longest(string1.as_str(), string2.as_str());\n    }\n    println!(\"The longest string is {}\", result);\n}\n\n\n\n\n\n\n分析一下上面例子\n\n\n\n\nlongest返回一个借用, 那么我们必须知道, 这个返回值(调用方的接收者)借用的值的生命周期要比这个借用长,编译器需要能够检查是否达到这样的要求\n因为函数内的局部变量在函数执行完毕后, 都会失效的, 所以返回值是借用的情况下, 它肯定只能是来至于函数参数且该参数必定是引用类型 (这里 暂不考虑 &’static ),只要知道它来至于哪个, 就能确定接收者和谁的生命周期有关\n现在所有问题的关键在于编译器不知道longest函数返回值来至于哪个参数,而生命周期标注最终就是为了让编译器知道它返回的引用与谁有关,这样就知道最后需要和谁的生命周期比较, 这样就帮助了编译器进行静态分析,去防止悬垂指针和其他内存安全问题\n生命周期标注 只是描述多个借用之间的关系, 并不会改变他们的生命周期\n上面的例子中编译器不知道返回哪个, 意味着编译器需要将2种情况都考虑,使用情况最坏的哪个,就是生命周期最短的哪个, 因为你不可能让编译器强制认为返回其中一个,让编译通过吧? 例子中 最坏的情况是返回 string2的借用, 因为string2 生命周期很短,会导致result 悬垂引用\n\n\n\n\n\n\n3.2 标注的真实含义\n\n\n\n\n\n\nNote\n\n\n\n\n只有引用类型才需要标注\n这个就类似类型来约束你申请的内存, 生命周期标注是表示你的生命周期在哪个范围 , 可以理解为: 生命周期标注表示生命周期的类型\n\n\n\n\n\n3.3 函数\n\n\n\n\n\n\n前置知识: 什么是函数的签名(Function Signature)\n\n\n\n在编程中, 是指函数的定义中描述函数接口的部分. 它通常包括以下几个方面:\n\n函数名: 函数的名称,用于标识和调用函数\n参数列表: 函数接受的参数及其类型. 参数列表定义了函数可以接收的数据类型和数量\n返回类型: 函数返回值的类型.如果函数不返回值,通常会标记为 void（在 C/C++ 中）或省略返回类型(在 Rust 中为 ())\n生命周期(在 Rust 中): Rust 中的函数签名还包括生命周期注解,用于描述引用之间的生命周期关系\n\n\n\n使用 ’a ’b 这种 单个简单字母, 放在 &后面\n&i32        // 一个借用\n&'a i32     // 一个带有显式生命周期的借用\n&'a mut i32 //\n也可以先去看 covariant-协变, 早期还没看covariant相关教程,只是看完book那个教程, 浪费了很多思考, 教程分不同批次,对于我来说是恶心的.\n\n例子1例子2例子3例子4 ’b:’a例子5例子6例子7\n\n\n\n\n\n报错了\n\nfn longest(x: &str, y: &str) -&gt; &str {\n    x\n}\nfn main() {\n    let string1 = String::from(\"long string is long\");\n    let result;\n    let string2 = String::from(\"xyz\");\n    result = longest(string1.as_str(), string2.as_str());\n}\n\n\n\n\n\n\n\n分析\n\n\n\n\n上面这个例子, 你可能最开始有这样的疑惑,这不是很明显返回的是x吗,还需要标注生命周期吗?\n提示错误说函数签名没有标注生命周期\n高亮第8行处, 实际上编译器在编译到这里的时候,它是只能根据函数签名的信息来判断返回值来至于哪里,所以它不知道该函数返回值和谁有关了., 我们继续看例子2\n\n\n\n\n\n\n\n\n\n还是报错了\n\n// 生命周期标注表示返回值与y 有关, 表示 返回值的生命周期必须符合 `'a`这样长的范围,至少和y 一样长\nfn longest&lt;'a&gt;(x: &str, y: &'a str) -&gt; &'a str {\n    x\n}\nfn main(){}\n\n\n\n\n\n\n\n分析\n\n\n\n\n好了,这样我们标注了 返回值和y有关, 唉? 这是不是感觉就行了啊?\n报错了, 因为编译器编译longest函数, 它确实肯定是知道返回值是x的, 然而我们设置的返回值类型是 &'a str, x能否转换为这个类型?\n\n不行!, 因为x的标注是 'b (没写就是默认自己的生命周期,这里就用'b表示) 与'a 没有指明任何关系, &'b str 类型 不能转换为 &'a str\n\n把’a 生命周期标注作为类型的一部分\n\n\n\n\n\n\n// 从代码上看 y和返回值 没有任何关系, 那么我们不需要标注\n// 表示 返回值的生命周期必须符合 'a这样长的范围\n// 就这个例子而言, 编译器编译这个函数时是知道它返回 了 x\n// 而x 符合 返回类型 &'a str , 本身就是 'a 这样的长度\n// 'a 的长度或说范围 是实际调用该函数时传递的参数的生命周期, 实际调用处是string1 是main函数都有效的生命周期\n// 然后实际调用处接收者 result的生命周期 比如说是 'c , 将 'a 类型的 赋值给 'c 类型的 能否成功,  这里是可以的, 他们生命周期长度一样.\n// 赋值相当于类型转换, 'a 类型 转换为 'c 类型, 'a 如果是 'c 的子类 就可以了, 表示 'a的生命周期 &gt;= 'c\nfn longest&lt;'a&gt;(x: &'a str, y: &str) -&gt; &'a str {\n    x\n}\nfn main() {\n    let string1 = String::from(\"long string is long\");\n    let result;\n    {\n        let string2 = String::from(\"xyz\");\n        // 注意编译器编译到这里, 它是不关注函数体的, 它只会关注到函数的签名\n        // 如果函数签名没有生命周期标注,它根本不知道返回值和哪个参数有关.\n        // 现在发现有了生命周期标注, 表示返回值和string1有关系\n        // 那么 string2的死活与它无关了.\n        result = longest(string1.as_str(), string2.as_str());\n    } // 这个时候 string2 指向的 xyz (在堆上) 已经被free了\n      // 而编译器知道 longest 返回的是来至于第一个参数x: string1.as_str()\n      // 这个所谓的知道是通过 生命周期标注 知道的\n      // ok\n    println!(\"The longest string is {}\", result);\n}\n\n\n\n\n\n\n\n\nCaution\n\n\n\n例子2里我们说 ’b 因为没有指明 和’a的关系, 所以他们之间不能转换, 那么他们需要什么样的关系才能转换能?\n\n\n// 设置返回值生命周期 约束为 'a , 表示至少和y 一样长\n// 但是实际返回值是x, 它的生命周期 是 'b\n// 'b 能不能转为 'a  就是问题的关键了. 当'b 是 'a的子类就可以了,('b:'a) 表示'b 生命周期比 &gt;= 'a\n// 子类, 就是继承了父类 所有特征的类, 所以它可以转换为 父类, 这个好理解的(这里是子类生命周期比父类长)\nfn longest&lt;'a,'b:'a&gt;(x: &'b str, y: &'a str) -&gt; &'a str {\n    x\n}\nfn longest2&lt;'a, 'b&gt;(x: &'b str, y: &'a str) -&gt; &'a str\nwhere // 和泛型 使用方式类似, 可以这样写\n    'b: 'a,\n{\n    x\n}\nfn main(){\n    let string1 = String::from(\"long string is long\");\n    let result;\n    {\n        let string2 = String::from(\"xyz\");\n        // string1 的生命周期比 string2 长\n        // 为了符合 签名中 'b 要&gt;= 'a , 只能转换为 'b = string2的生命周期\n        // 这样 'b = 'a  符合 'b:'a\n        // 所以实际返回的x 它的生命周期变成了 string2 一样了,\n        // 当然根据签名我们直接知道与string2有关,\n        //      它的生命周期就是string2的生命周期,因为string2 能活多久,它就多久\n        // 编译直接报错,提示string2, borrowed value does not live long enough\n        // 从代码角度看, 返回的值的生命周期和 string2一样, 而result的生命周期 比这个长,\n        // 无法从一个 短的生命周期 赋值给一个长的生命周期, 可理解为父类无法转换为子类\n        result = longest(string1.as_str(), string2.as_str());\n    } // string2 释放\n    println!(\"The longest string is {}\", result);\n}\n\n\n\n\n报错了\n\n// 生命周期标注表示返回值与x,y有关, 表示 返回值的生命周期必须符合 'a这样长的范围\n// 返回值 x 符合 'a 类型的生命周期 编译通过\n// 传递来的时候, 确定出 'a =x的实参的生命周期 , 然后又确定出 'a=y的实参的生命周期\n// 最终是 'a = x和y 实参生命周期短的那个\nfn longest&lt;'a&gt;(x: &'a str, y: &'a str) -&gt; &'a str {\n    x\n}\nfn main(){\n    let string1 = String::from(\"long string is long\");\n    let result;\n    {\n        let string2 = String::from(\"xyz\");\n        // 注意编译器编译到这里, 它是不关心函数体的, 它只会关注到函数的签名\n        // 所以它根本不知道返回值和哪个参数有关.(虽然函数内部很明显返回了谁)\n        // 现在看了函数签名, 发现有了生命周期标注, 表示string1,string2有关系\n        // 从人的角度看, 可以理解为, 编译器在这种情形下会考虑最坏的情况,\n        // 所以这里认为返回值 返回生命周期短的那个, 就是string2,所以最终和string2有关\n        // 从代码角度看, 返回的值的生命周期是 string2, 而result的生命周期 比这个长,\n        // 无法从一个 短的生命周期 赋值给一个长的生命周期, 可理解为父类无法转换为子类.\n        result = longest(string1.as_str(), string2.as_str());\n    } // 这个时候 string2 指向的 xyz (在堆上) 已经被free了\n    // 报错了\n    println!(\"The longest string is {}\", result);\n}\n\n\n\nfn longest&lt;'a&gt;(x: &'a str, y: &'a str) -&gt; &'a str {\n    if x.len() &gt; y.len() {\n        x\n    } else {\n        y\n    }\n}\nfn main() {\n    let string1 = String::from(\"long string is long\");\n    let result;\n    {\n        let string2 = \"xyz\";\n        result = longest(string1.as_str(), string2);\n    } // string2 所借用的 xyz 这个数据实际是在 只读区中分配的,生命周期是到程序运行结束,所以到这里,没有被free掉\n      // println!(\"{}\", string2); 注意这个还是会报错的, 因为变量string2 离开作用域 已经不可用了\n      // OK\n    println!(\"The longest string is {}\", result);\n}\n\n\nfn longest&lt;'a&gt;(x: &'a str, y: &'a str) -&gt; &'a str {\n    if x.len() &gt; y.len() {\n        x\n    } else {\n        y\n    }\n}\nfn main() {\n    let string1 = String::from(\"long string is long\");\n    let result;\n    {\n        let string2 = String::from(\"xyz\");\n        result = longest(string1.as_str(), string2.as_str());\n    } \n    println!(\"The longest string is {}\", result);\n}\n\n\n\n\n\n\n\n\n\n生命周期的总结\n\n\n\n\n返回值的 ’a 标注 如果与多个函数参数有关, 那么选择 生命周期短的那个参数, 表示 返回值与 该参数有关, 最后借用检查就知道返回值的生命周期和谁做比较\n如果返回值 ’a 就和一个参数有关, 那么就和它有关\n\n\n\n// 不带参数的函数, 不过有一个生命周期参数 'a\n// 'a: 表示至少和函数的生命周期一样长 : &gt;=\nfn failed_borrow&lt;'a&gt;() {\n    let _x = 12;\n\n    // 报错：_x 的生命周期不够长\n    let y: &'a i32 = &_x;\n    // 在函数内部使用生命周期 'a 作为显式类型标注将导致失败\n    // 因为 &_x 的生命周期比 y 的短. 短生命周期不能强制转换成长生命周期.\n}\nfn main(){}\n\n\n3.4 结构体\n\n\n\n\n\n\nImportant\n\n\n\n\n生命周期标注 ’a 表明这两个字段的生命周期是相同的,并且它们至少活得和 Book 实例一样久\n如果没有生命周期标注,编译器就无法确定title 和 author 引用的数据是否会在 Book 实例化之前被释放\n生命周期标注提供了一种方式,让编译器能够检查引用是否在有效范围内,从而确保内存安全\n\n\n\nstruct Book&lt;'a&gt; {\n    title: &'a str,\n    author: &'a str,\n}\n\nfn main() {\n    let title = \"The Rust Programming Language\";\n    let author = \"Steve Klabnik and Carol Nichols\";\n    let book = Book { title, author };\n\n    println!(\"Book title: {}\", book.title);\n    println!(\"Book author: {}\", book.author);\n}\n\n\n3.5 约束\n\n\n\n\n\n\nImportant\n\n\n\n\nT: ’a\n\n在 T 中的 所有引用都必须至少和生命周期 ’a 活得一样长 (&gt;=’a)\n\nT: Trait + ’a\n\nT 类型必须实现 Trait trait, 并且在 T 中的所有引用都必须至少和 ’a 活得一样长\n\n&’a T\n\n’a 表示T 的生命周期至少和’a 一样长\n\n\n\n\nfn main() {\n    let s2 = \"hello\".to_string();\n    test2(&s2); // ok\n    test2(&&s2); // 报错了\n    test1(&s2) // 报错了 &'static T , T 需要满足'static\n}\nfn test1&lt;T&gt;(_arg: &'static T) {\n    println!(\"hello\");\n}\n// T: 'static 表示T中使用的引用 必须至少 比'static 一样长\n// test2(&s2); 调用的情况 这里T 是 String 类型, 不是引用类型,所以啥都行\nfn test2&lt;T: 'static&gt;(_arg: &T) {\n    println!(\"hello\");\n}\n\n\n3.6 &’static\n\n\n\n\n\n\nTip\n\n\n\n整个程序的持续时间就是静态生命周期\n\n\nlet s: &'static str = \"I have a static lifetime.\";\n\n\n3.7 泛型,trait\n\n\n\n\n\n\nImportant\n\n\n\nlifetimes are a type of generic,所以会将它和泛型T的申明放在一起\n\n\nuse std::fmt::Display;\n\nfn longest_with_an_announcement&lt;'a, T&gt;(\n    x: &'a str,\n    y: &'a str,\n    ann: T,\n) -&gt; &'a str\nwhere\n    T: Display,\n{\n    println!(\"Announcement! {}\", ann);\n    if x.len() &gt; y.len() {\n        x\n    } else {\n        y\n    }\n}\n\n\n3.8 标注省略三规则\n// 早期像这样的,都是需要 进行生命周期标注的\n// fn first_word(s: &str) -&gt; &str {\nfn first_word&lt;'a&gt;(s: &'a str) -&gt; &'a str {\n    let bytes = s.as_bytes();\n\n    for (i, &item) in bytes.iter().enumerate() {\n        if item == b' ' {\n            return &s[0..i];\n        }\n    }\n    &s[..]\n}\n\n\n\n\n\n\n三个规则\n\n\n\n\nrust的开发人员注意到, 每次都要写很多这种标注, 很麻烦, 于是总结了一些规则,让编译器自动处理\n概念说明\n\n生命周期在函数的参数时,被称为输入生命周期\n生命周期在函数的返回值时,被称为输出生命周期\n\n三个规则\n\n每个引用参数都有自己的生命周期参数\n如果只有一个输入生命周期参数，那么它被赋予所有输出生命周期参数\n如果有多个输入生命周期参数, 且其中一个是&self 或 &mut self(是方法), 则self的生命周期会被赋予所有的输出生命周期参数\n\n如果编译器应用完这3个规则,还有无法确定生命周期,那么就报错\n\n\n\n// 我们写的代码\nfn first_word(s: &str) -&gt; &str {}\n// 1. 编译器应用第一条规则后\nfn first_word&lt;'a&gt;(s: &'a str) -&gt; &str {}\n// 2. 编译器应用第二条规则后\nfn first_word&lt;'a&gt;(s: &'a str) -&gt; &'a str {}\n\n// 我们写的代码\nfn longest(x: &str, y: &str) -&gt; &str {}\n// 1. 编译器应用第一条规则后\nfn longest&lt;'a, 'b&gt;(x: &'a str, y: &'b str) -&gt; &str {\n// 2. 编译器应用第二条规则,发现有多个输入参数,pass\n// 3. 编译器应用第三条规则,发现是个函数,不是方法,pass\n//  结果, 返回值的生命周期 还是不确定, 所以报错了\n结构体方法生命周期\n// 需要在 impl后面申明,这个生命周期是结构体类型的一部分\nimpl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {\n    fn level(&self) -&gt; i32 {\n        3\n    }\n}\n// 1. 编译器应用第一条规则, &'a self, 所以我们不用标注了\n\n// 我们来看看方法中多个参数的情况,\nimpl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {\n    fn announce_and_return_part(&self, announcement: &str) -&gt; &str {\n        println!(\"Attention please: {}\", announcement);\n        self.part\n    }\n}\n// 1. 编译器应用第一条规则后,\n    fn announce_and_return_part(&'a self, announcement: &'a str) -&gt; &str {}\n// 2. 编译器应用第三条规则后,\n    fn announce_and_return_part&lt;'a&gt;(&'a self, announcement: &'a str) -&gt; &'a str {}",
    "crumbs": [
      "核心基础",
      "基础篇",
      "生命周期"
    ]
  },
  {
    "objectID": "docs/basic/lifetime.html#drop-check",
    "href": "docs/basic/lifetime.html#drop-check",
    "title": "rust 生命周期",
    "section": "4 drop check",
    "text": "4 drop check",
    "crumbs": [
      "核心基础",
      "基础篇",
      "生命周期"
    ]
  },
  {
    "objectID": "docs/basic/lifetime.html#subtyping1",
    "href": "docs/basic/lifetime.html#subtyping1",
    "title": "rust 生命周期",
    "section": "5 subtyping1",
    "text": "5 subtyping1\n\n\n\n\n\n\nImportant\n\n\n\n\n在前面章节中 我们看到下面这样的代码\n这里 其实明确表示 需要传递的参数的 生命周期是一样长的,然而在实际调用的时候, 传递的参数的生命周期不一样,为什么可以这样呢\n还有返回值的生命周期类型 和接收者的生命周期类型 也是不一样的, 为什么也可以成功赋值呢\n之前就说到子类可以转换为 父类,rust 提供这样的机制,可以让子类生命周期(长生命周期)降级转换为父类生命周期(短生命周期), 所以编译不会报错\n\n\n\n// x 生命周期长的情况, 就降级转换为 和 y一样的短的生命周期\nfn longest&lt;'a&gt;(x: &'a str, y: &'a str) -&gt; &'a str {\n    x\n}\nfn main() {\n    let string1 = String::from(\"long string is long\");\n    let result;\n    {\n        let string2 = String::from(\"xyz\");\n        result = longest(string1.as_str(), string2.as_str());\n    }\n    println!(\"The longest string is {}\", result);\n}",
    "crumbs": [
      "核心基础",
      "基础篇",
      "生命周期"
    ]
  },
  {
    "objectID": "docs/basic/lifetime.html#variance-型变2",
    "href": "docs/basic/lifetime.html#variance-型变2",
    "title": "rust 生命周期",
    "section": "6 Variance 型变2",
    "text": "6 Variance 型变2\n\n\n\nType\nVariance in ’a\nVariance in T\n\n\n\n\n&'a T\ncovariant\ncovariant\n\n\n&'a mut T\ncovariant\ninvariant\n\n\nBox&lt;T&gt;\n\ncovariant\n\n\nVec&lt;T&gt;\n\ncovariant\n\n\n*const T\n\ncovariant\n\n\n*mut T\n\ninvariant\n\n\n[T] and [T; n]\n\ncovariant\n\n\nfn() -&gt; T\n\ncovariant\n\n\nfn(T) -&gt; ()\n\ncontravariant\n\n\nstd::cell::UnsafeCell&lt;T&gt;\n\ninvariant\n\n\nstd::cell::Cell&lt;T&gt;\n\ninvariant\n\n\ndyn Trait&lt;T&gt; + 'a\ncovariant\ninvariant\n\n\n\n\n6.1 covariant 协变\n\n\n\n\n\n\nTip\n\n\n\n\n协变指的是在类型层次中, 子类型可以替代父类型\n当T:U(T是U的子类) 时, F&lt;T&gt; 如果也是 F&lt;U&gt;的子类,那么就称为 F&lt;T&gt; 对于参数T 是协变关系\n在rust中, 生命周期有这类机制\n\n\n\n\n&’a T有趣的例子(重要)&’a mut TBox&lt;T&gt;fn() -&gt; T\n\n\n\n\n\n\n\n\n\n协变规则\n\n\n\n\n&'a T 对于 'a 是协变的, 当 'a:'b ,那么 &'a T 也是 &'b T 的子类\n\n\n\n\n\n例子说明\n\n// 要求 2个借用变量的生命周期一样长, 而实际上传递的参数的生命周期不一样\n// rust 会通过将长的生命周期的参数 降级为 短生命周期参数一样长的 生命周期\nfn debug&lt;'a&gt;(a: &'a str, b: &'a str) {\n    println!(\"a = {a:?} b = {b:?}\");\n}\n\nfn main() {\n    let hello: &'static str = \"hello\";\n    {\n        let world = String::from(\"world\");\n        // 'world 生命周期短于 'static\n        let world = &world;\n        // hello 隐式的从 &'static str 降级 或者说转换为 &'world str\n        // &'static str是  &'world str 的子类, 所以可以执行成功\n        debug(hello, world);\n    }\n}\n\n\n\n\n\n\n\n\n\n协变规则\n\n\n\n\n&'a T 对于 T 是协变的, 当 T:U ,那么 &'a T 也是 &'a U 的子类\n\n\n\n\n\n例子说明\n\n// 这里T 是 &'b str ,U 是 &'a str, 根据前面的因为'b:'a 则 &'b str 是&'a str 的子类\n// 现在程序OK, 就说明了, &'a &'b str 是 &'a &'a str 的子类了\nfn covariant_ref&lt;'a, 'b: 'a&gt;(x: &'a &'b str) -&gt; &'a &'a str {\n    x\n}\n\nfn main() {\n    let x: &'static str = \"hello\";\n    let y: &&str = covariant_ref(&x);\n    println!(\"{}\", y);\n}\n\n\n\n\n// 根据前面结构体章节, 我们知道 该结构体对于T 和 'a 都是协变的\nstruct MyStruct&lt;'a, T: 'a&gt; {\n    ptr: &'a T,\n}\n// 编译通过, 可能没想到 这个竟然能通过\n// 看参数 我们知道T:'a 表示T 中引用必须至少和'a 一样长,\n// 传递的T = &'b str, 这个时候T的生命周期是'b,\n// 它必须活着至少&gt;= 'a ,则MyStruct&lt;'a, &'b str&gt; 推断出  'b:'a\n// 看返回值 MyStruct&lt;'b, &'a str&gt;,T的生命周期是'a, 它至少和'b 一样长, 即推断出: 'a:'b\n// 现在'a:'b  'b:'a  , 其实 'a='b\nfn test1&lt;'a, 'b&gt;(v: MyStruct&lt;'a, &'b str&gt;) -&gt; MyStruct&lt;'b, &'a str&gt; {\n    v\n}\n// 看看下面4个测试 来间接说明我们test1 的判断\n// 这个符合我们的判断对于 参数'a 和T 都是协变的, 很容易理解的版本\nfn test2&lt;'a: 'c, 'b: 'd, 'c, 'd&gt;(v: MyStruct&lt;'a, &'b str&gt;) -&gt; MyStruct&lt;'c, &'d str&gt; {\n    v\n}\n\n// 很容易得出 我们需要 'b:'c 才能通过编译\nfn test3&lt;'a, 'b: 'c, 'c&gt;(v: MyStruct&lt;'a, &'b str&gt;) -&gt; MyStruct&lt;'a, &'c str&gt; {\n    v\n}\n// 现在我们看看这个,'b:'c 才能通过编译, 而这里我们用 'a:'c 也能通过, 间接说明 'b:'a\nfn test4&lt;'a: 'c, 'b, 'c&gt;(v: MyStruct&lt;'a, &'b str&gt;) -&gt; MyStruct&lt;'a, &'c str&gt; {\n    v\n}\n// 通过编译的.\n// 参数推断出 'a:'b  , 返回值推断出 'b:'c\n// 刚好符合 我们的要求, 直接不用设置了\nfn test5&lt;'a, 'b, 'c&gt;(v: MyStruct&lt;'b, &'a str&gt;) -&gt; MyStruct&lt;'c, &'b str&gt; {\n    v\n}\nfn main(){}\n\n\n\n\n\n\n\n\n\n协变规则\n\n\n\n\n&'a mut T 对于 'a 是协变的\n\n\n\n\n\n例子说明\n\n// 'b: 'a  ,这里没有报错, 则表示 &'b mut T 也是  &'a mut T 的子类\nfn invariant_mut&lt;'a, 'b: 'a, T&gt;(x: &'b mut T) -&gt; &'a mut T {\n    x\n}\n\nfn main() {\n    let mut x = 5;\n    let y = invariant_mut(&mut x);\n    *y += 1;\n    println!(\"{}\", x);\n}\n\n\n\n\n\n\n\n\n\n\n\n协变规则\n\n\n\n\nBox&lt;T&gt; 对于 T 是协变的\n\n\n\n\n\n例子说明\n\nfn set_box_ref&lt;'a&gt;(x: Box&lt;&'static str&gt;) {\n    let s: Box&lt;&'a str&gt; = x;\n    println!(\"{s}\");\n}\n\nfn main() {\n    let hello: Box&lt;&'static str&gt; = Box::new(\"hello\");\n    set_box_ref(hello);\n}\n\n\n\n\n\n\n\n\n\n\n\n协变规则\n\n\n\n\nfn() -&gt; T 对于 T 是协变的\n\n\n\n\n\n例子说明\n\nfn set_fn_ret&lt;'a&gt;(f: fn() -&gt; &'static str) {\n    let _: fn() -&gt; &'a str = f;\n}\n// 直接报错的, 说明不是逆变的\n// fn set_fn_ret2&lt;'a&gt;(f: fn() -&gt; &'a str) {\n//     let _: fn() -&gt; &'static str = f;\n// }\nfn main() {\n    fn test() -&gt; &'static str {\n        \"hello\"\n    }\n    set_fn_ret(test);\n}\n\n\n\n\n\n\n\n6.2 Contravariance 逆变\n\n\n\n\n\n\nTip\n\n\n\n逆变指的是在类型层次中, 父类型可以替代子类型\n\n\n\nfn(T) -&gt; ()\n\n\n\n\n\n\n\n\n\n逆变规则\n\n\n\n\nfn(T) -&gt; () 对于 T 是逆变的\n\n\n\n// OK , 说明是逆变的\nfn set_fn_arg&lt;'a&gt;(f: fn(&'a str)) {\n    let _: fn(&'static str) = f;\n}\n// 报错了, 不是协变\nfn set_fn_arg2&lt;'a&gt;(f: fn(&'static str)) {\n    let _: fn(&'a str) = f;\n}\nfn main() {}\n\n\n\n\n\n\n6.3 invariant 不变\n\n\n\n\n\n\nImportant\n\n\n\n不是协变也不是逆变的情况, 就是不变\n\n\n\n&’a mut T\n\n\n\n\n\n\n\n\n\n不变规则\n\n\n\n\n&'a mut T 对于 T 是不变的, 这意味着你不能将 &'a mut T 隐式地转换成 &'a mut U 即使 T 是 U 的子类型或者父类型\n和 协变规则2 比较一下\n\n\n\n\n\n例子说明\n\n// 前面已经验证 &'b str 是&'a str 的子类\n// T 就是 &'b str ,U 是 &'a str\n// 然而编译报错, 说明了&'a mut &'b str 不是 &'a mut &'a str 的子类\n// vscode 提示的错误 ,可以了解到 &'a mut T 对于T 是不变的\nfn covariant_ref&lt;'a, 'b: 'a&gt;(x: &'a mut &'b str) -&gt; &'a mut &'a str {\n    x\n}\n\nfn main() {\n    let mut x: &str = \"hello\";\n    let y: &&str = covariant_ref(&mut x);\n    println!(\"{}\", y);\n}\n\n\n\n\n\n\n\n6.4 自定义类型的情况\n\n\n\n\n\n\n\n看下面代码\n\n\n\n\n如果所有使用泛型A 的成员 对A 都是 协变的, 那么 MyType 对于A 就是 协变的\n如果所有使用泛型A 的成员 对A 都是 逆变的, 那么 MyType 对于A 就是 逆变的\n否则就是不变的\n\n\n\nuse std::cell::Cell;\nstruct MyType&lt;'a, 'b, A: 'a, B: 'b, C, D, E, F, G, H, In, Out, Mixed&gt; {\n    a: &'a A,     // covariant over 'a and A\n    b: &'b mut B, // covariant over 'b and invariant over B\n\n    c: *const C,  // covariant over C\n    d: *mut D,    // invariant over D\n\n    e: E,         // covariant over E\n    f: Vec&lt;F&gt;,    // covariant over F\n    g: Cell&lt;G&gt;,   // invariant over G\n\n    h1: H,        // would also be covariant over H except...\n    h2: Cell&lt;H&gt;,  // invariant over H, because invariance wins all conflicts\n\n    i: fn(In) -&gt; Out,       // contravariant over In, covariant over Out\n\n    k1: fn(Mixed) -&gt; usize, // would be contravariant over Mixed except..\n    k2: Mixed,              // invariant over Mixed, because invariance wins all conflicts\n}\n\n\n\n\n\n\n\n\n举例 a: &’a A\n\n\n\n\n注意 &'b Cat&lt;'c, T&gt; 对于 'b 是协变的(将 Cat&lt;'c, T&gt; 看成一个整体 就是前面说过的 &'a T 对于 'a 是协变的 )\nCat&lt;'c, T&gt; 因为成员对于 'c 是协变的, 所以 Cat&lt;'c, T&gt; 对于 'c 也是协变的\n\n\n\n\n\n运行OK\n\nfn covariant_mut&lt;'a, 'b: 'a, 'c: 'd, 'd, T&gt;(x: &'b Cat&lt;'c, T&gt;) -&gt; &'a Cat&lt;'d, T&gt; {\n    x\n}\n\nstruct Cat&lt;'a, T&gt; {\n    name: &'a T,\n}\nfn main() {}",
    "crumbs": [
      "核心基础",
      "基础篇",
      "生命周期"
    ]
  },
  {
    "objectID": "docs/basic/lifetime.html#phantomdata-类型3",
    "href": "docs/basic/lifetime.html#phantomdata-类型3",
    "title": "rust 生命周期",
    "section": "7 PhantomData 类型3",
    "text": "7 PhantomData 类型3\n\nphantom: 幽灵, 无形的东西, 假象,虚构的事物 PhantomData 翻译为 幽灵数据 好了…\n\n\n7.1 为什么需要4\n\nstruct Iter&lt;'a, T: 'a&gt; {// 没有使用到生命周期参数 'a\n    ptr: *const T,\n    end: *const T,\n}\nstruct Dog&lt;T&gt; { // 没有使用到类型参数 T\n    data: i32\n}\n\n\n\n\n\n\n分析\n\n\n\n\n在自定义类型的情况中,我们提到自定义类型对泛型参数A(生命周期也是一种泛型参数)的型变关系需要通过成员对A的型变关系来推断, 但是上面代码struct Iter&lt;'a,T:'a&gt;申明了生命周期参数, 但是实际光有申明又没法使用它(裸指针本身不带生命周期参数), 这样导致无法知道该类型的型变关系, 因此编译器会报错\nstruct Dog&lt;T&gt; 申明了泛型T 但是实际里面没有使用它, Dog&lt;i32&gt;和Dog&lt;i64&gt;就没有什么区别, 那么编译器会推断他们是可以互换的,这就很不合理\nPhantomData 类型可以解决这些问题,std::marker::PhantomData是一个特殊的标记类型, 不占用任何内存空间 ZST\n作用\n\n向编译器提供对静态分析有用的信息, 比如正确处理 泛型参数(T和生命周期)的 型变\n它用于在类型系统中表示和某类型有关, 但实际上并不存储该类型的值, 可以消除未使用类型参数的警告\n控制 Variance (协变,逆变还是不变)\n\n\n\n\n\n\n\n7.2 消除未使用类型参数的错误\nuse std::marker::PhantomData;\nstruct Dog&lt;T&gt; {\n    data: i32,\n    // 这个字段不会增加结构体的内存占用\n    // 表示尽管结构体没有使用泛型T, 但是这里就认为它使用了T\n    // 像一个幽灵一样, 我们假装有这个一个字段 使用了 T , 就好比一个字段名 _marker:T 这样\n    // 只是表明该结构体 和 T 有关\n    _marker: PhantomData&lt;T&gt;,\n}\n\n\n7.3 控制Variance\n\n7.3.1 控制 T\n\n\n\nType\nVariance in T\n\n\n\n\nPhantomData&lt;T&gt;\ncovariant\n\n\nPhantomData&lt;fn(T)&gt;\ncontravariant\n\n\nPhantomData&lt;Cell&lt;T&gt;&gt;\ninvariant\n\n\n\n\nPhantomData&lt;T&gt;PhantomData&lt;fn(T)&gt;PhantomData&lt;Cell&lt;T&gt;&gt;\n\n\n\n\n\n\n\n\nImportant\n\n\n\n\n使整个结构体对于 T 是协变的\n\n\n\nstruct Dog&lt;T&gt; {\n    data: i32,\n    _marker: PhantomData&lt;T&gt;,\n}\n\nfn test1&lt;'a: 'b, 'b&gt;(v: Dog&lt;&'a str&gt;) -&gt; Dog&lt;&'b str&gt; {\n    v\n}\nfn main(){}\n\n\n\n\n\n\n\n\nImportant\n\n\n\n\n使整个结构体对于 T 是逆变的\n\n\n\nstruct MyStruct&lt;T&gt; {\n    data: i32,\n    _marker: PhantomData&lt;fn(T)&gt;,\n}\n\nfn test1&lt;'a, 'b: 'a&gt;(v: MyStruct&lt;&'a str&gt;) -&gt; MyStruct&lt;&'b str&gt; {\n    v\n}\n\n\n\n\n\n\n\n\nImportant\n\n\n\n\n使整个结构体对于 T 是不变的\n根据前面型变表格, 你可以使用其他比如PhantomData&lt;*mut T&gt;\n\n\n\nstruct MyStruct&lt;T&gt; {\n    data: i32,\n    _marker: PhantomData&lt;std::cell::Cell&lt;T&gt;&gt;,\n}\n\nfn test1&lt;'a: 'b, 'b: 'a&gt;(v: MyStruct&lt;&'a str&gt;) -&gt; MyStruct&lt;&'b str&gt; {\n    v\n}\n\n\n\n\n\n7.3.2 控制 ’a\n\n\n\nType\nVariance in ’a\n\n\n\n\nPhantomData&lt;&'a ()&gt;\ncovariant\n\n\nPhantomData&lt;fn(&'a ())&gt;\ncontravariant\n\n\nPhantomData&lt;Cell&lt;&'a ()&gt;&gt;\ninvariant\n\n\n\n\nPhantomData&lt;&’a ()&gt;PhantomData&lt;fn(&’a ())&gt;PhantomData&lt;Cell&lt;&’a ()&gt;&gt;\n\n\n\n\n\n\n\n\nImportant\n\n\n\n\n使整个结构体对于 ’a 是协变的\n\n\n\n\n\nPhantomData&lt;&'a ()&gt;\n\nuse std::marker::PhantomData;\n\nstruct MyIter&lt;'a, T: 'a&gt; {\n    ptr: *const T,\n    end: *const T,\n    // 我们知道结构体对于'a 的型变关系 取决于 里面的成员对于'a 的型变关系\n    // 本来结构体没有使用'a , 现在我们假装有一个成员 是 &'a (), 比如假装一个成员是 name: &'a ()\n    // &'a () 对'a 是协变的, 只要该成员使用了'a ,那么整个结构体对于'a 就是协变的了 (因为只有这个成员使用了'a)\n    // 而对于T 来说, 看ptr 和end 成员就知道了, 他们对T 是协变的, 所以结构体对于T 也是协变的了\n    // 可能有人会说 为什么不用 PhantomData&lt;&'a T&gt; , 因为结构体对于T 的型变规则已经决定了, 由成员ptr 和end 确定\n    // 所以你没有这个意图去写成 () , 等下后面的例子我们 改成 mut T 就能更理解了.\n    _marker: PhantomData&lt;&'a ()&gt;,\n}\n// 编译ok\nfn test1&lt;'a: 'b, 'b, T: 'a&gt;(v: MyIter&lt;'a, T&gt;) -&gt; MyIter&lt;'b, T&gt; {\n    v\n}\n// 编译ok了,  T这个时候=&'a str  返回值的T 是&'c str\n//  说明了  MyIter 对于T 是协变\nfn test2&lt;'a: 'c, 'b, 'c&gt;(v: MyIter&lt;'b, &'a str&gt;) -&gt; MyIter&lt;'b, &'c str&gt; {\n    v\n}\n\nfn main() {}\n\n\n\nPhantomData&lt;&'a mut T&gt;\n\nuse std::marker::PhantomData;\nstruct MyIter&lt;'a, T: 'a&gt; {\n    ptr: *const T,\n    end: *const T,\n    // 注意这里 T 实际是不可能这样写的, 因为关于结构体对T的协变规则编译器已经能得出了, 你是没有意图去这样做的\n    // 相当于假装这里有个成员 , 它的类型是 &'a mut T\n    // &mut T对T 是不可变的, 那么现在整个结构体对于T 从原来的协变 变成 不变了.\n    // 这改变了 原本对T 的型变情况(*const T 对T 是协变的), 是完全没有必要的, 没有这个意图的.\n    // 所以我们对这种情况使用 PhantomData&lt;&'a ()&gt; 就可以了.\n    _marker: PhantomData&lt;&'a mut T&gt;,\n}\n// 编译ok ,'a 是协变的\nfn test1&lt;'a: 'b, 'b, T: 'a&gt;(v: MyIter&lt;'a, T&gt;) -&gt; MyIter&lt;'b, T&gt; {\n    v\n}\n// 'a:'c , 'c:'a 说明需要'a='c, T 是不变的\nfn test2&lt;'a: 'c, 'b, 'c: 'a&gt;(v: MyIter&lt;'b, &'a str&gt;) -&gt; MyIter&lt;'b, &'c str&gt; {\n    v\n}\n// 编译ok\n// 参数推断出'a:'b , 返回值推断出'b:'c\n// 因为我们需要  'a='b , 设置 'b:'a 就能编译通过.\n// 这里我们设置 'c:'a  能得出 'a='b='c了, 也是ok的\n// 对于T 是不变的\nfn test3&lt;'a, 'b, 'c: 'a&gt;(v: MyIter&lt;'b, &'a str&gt;) -&gt; MyIter&lt;'c, &'b str&gt; {\n    v\n}\n\nfn main(){}\n\n\n\nPhantomData&lt;&'a T&gt;\n\nuse std::marker::PhantomData;\n\nstruct MyIter&lt;'a, T: 'a&gt; {\n    ptr: *mut T,\n    end: *mut T,\n    // 因为自定义类型 对T 的型变要看成员对T的型变\n    // 所以这里 PhantomData&lt;&'a T&gt;,设置上对T 是协变的\n    // 但是实际上 是 不变的, 因为 成员类型*mut T对T 是不变的\n    _marker: PhantomData&lt;&'a T&gt;,\n}\n// 编译ok\nfn test&lt;'a: 'b, 'b, T: 'a&gt;(v: MyIter&lt;'a, T&gt;) -&gt; MyIter&lt;'b, T&gt; {\n    v\n}\n// 编译错误, 因为MyIter 对于T 是不变的\nfn test2&lt;'a: 'b, 'b&gt;(v: MyIter&lt;'b, &'a str&gt;) -&gt; MyIter&lt;'b, &'b str&gt; {\n    v\n}\nfn main(){}\n\n\n\n\n\n\n\n\n\nImportant\n\n\n\n\n使整个结构体对于 ’a 是逆变的\n\n\n\nuse std::marker::PhantomData;\nstruct MyStruct&lt;'a&gt; {\n    data: i32,\n    _marker: PhantomData&lt;fn(&'a ())&gt;,\n}\n\nfn test1&lt;'a, 'b: 'a&gt;(v: MyStruct&lt;'a&gt;) -&gt; MyStruct&lt;'b&gt; {\n    v\n}\nfn main() {}\n\n\n\n\n\n\n\n\nImportant\n\n\n\n\n使整个结构体对于 ’a 是不变的\n\n\n\nuse std::marker::PhantomData;\nstruct MyStruct&lt;'a&gt; {\n    data: i32,\n    _marker: PhantomData&lt;std::cell::Cell&lt;&'a ()&gt;&gt;,\n}\n\nfn test1&lt;'a: 'b, 'b: 'a&gt;(v: MyStruct&lt;'a&gt;) -&gt; MyStruct&lt;'b&gt; {\n    v\n}\nfn main() {}",
    "crumbs": [
      "核心基础",
      "基础篇",
      "生命周期"
    ]
  },
  {
    "objectID": "docs/basic/lifetime.html#footnotes",
    "href": "docs/basic/lifetime.html#footnotes",
    "title": "rust 生命周期",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nsubtyping↩︎\nvariance↩︎\nphantom-data↩︎\nrust rfcs#0738↩︎",
    "crumbs": [
      "核心基础",
      "基础篇",
      "生命周期"
    ]
  },
  {
    "objectID": "docs/basic/generic.html",
    "href": "docs/basic/generic.html",
    "title": "rust 泛型",
    "section": "",
    "text": "fn largest_i32(list: &[i32]) -&gt; &i32 {\n    let mut largest = &list[0];\n\n    for item in list {\n        if item &gt; largest {\n            largest = item;\n        }\n    }\n\n    largest\n}\n\nfn largest_char(list: &[char]) -&gt; &char {\n    let mut largest = &list[0];\n\n    for item in list {\n        if item &gt; largest {\n            largest = item;\n        }\n    }\n\n    largest\n}\n\nfn main() {\n    let number_list = vec![34, 50, 25, 100, 65];\n\n    let result = largest_i32(&number_list);\n    println!(\"The largest number is {}\", result);\n\n    let char_list = vec!['y', 'm', 'a', 'q'];\n\n    let result = largest_char(&char_list);\n    println!(\"The largest char is {}\", result);\n}\n我们发现 同样的逻辑代码,我们写了2遍, 很麻烦,重复代码, 使用泛型来作为具体类型的抽象\n泛型是一种类型,在函数中使用它作为参数的类型,是需要申明的,首先肯定不会和参数的申明放在一块,所以rust在函数名和参数列表之间使用&lt;T&gt;,一般用T来作为泛型标识\n// T: std::cmp::PartialOrd\n// 这里的代码 运行会提示错误, 很显然 不是所有的类型都能做比较大小的操作的\n// 将T改成 T: std::cmp::PartialOrd 就ok了, 后面trait 里会说\nfn largest&lt;T&gt;(list: &[T]) -&gt; &T {\n    let mut largest = &list[0];\n\n    for item in list {\n        if item &gt; largest {\n            largest = item;\n        }\n    }\n\n    largest\n}\n\nfn main() {\n    let number_list = vec![34, 50, 25, 100, 65];\n\n    let result = largest(&number_list);\n    println!(\"The largest number is {}\", result);\n\n    let char_list = vec!['y', 'm', 'a', 'q'];\n\n    let result = largest(&char_list);\n    println!(\"The largest char is {}\", result);\n}",
    "crumbs": [
      "核心基础",
      "基础篇",
      "泛型"
    ]
  },
  {
    "objectID": "docs/basic/generic.html#在函数中使用",
    "href": "docs/basic/generic.html#在函数中使用",
    "title": "rust 泛型",
    "section": "",
    "text": "fn largest_i32(list: &[i32]) -&gt; &i32 {\n    let mut largest = &list[0];\n\n    for item in list {\n        if item &gt; largest {\n            largest = item;\n        }\n    }\n\n    largest\n}\n\nfn largest_char(list: &[char]) -&gt; &char {\n    let mut largest = &list[0];\n\n    for item in list {\n        if item &gt; largest {\n            largest = item;\n        }\n    }\n\n    largest\n}\n\nfn main() {\n    let number_list = vec![34, 50, 25, 100, 65];\n\n    let result = largest_i32(&number_list);\n    println!(\"The largest number is {}\", result);\n\n    let char_list = vec!['y', 'm', 'a', 'q'];\n\n    let result = largest_char(&char_list);\n    println!(\"The largest char is {}\", result);\n}\n我们发现 同样的逻辑代码,我们写了2遍, 很麻烦,重复代码, 使用泛型来作为具体类型的抽象\n泛型是一种类型,在函数中使用它作为参数的类型,是需要申明的,首先肯定不会和参数的申明放在一块,所以rust在函数名和参数列表之间使用&lt;T&gt;,一般用T来作为泛型标识\n// T: std::cmp::PartialOrd\n// 这里的代码 运行会提示错误, 很显然 不是所有的类型都能做比较大小的操作的\n// 将T改成 T: std::cmp::PartialOrd 就ok了, 后面trait 里会说\nfn largest&lt;T&gt;(list: &[T]) -&gt; &T {\n    let mut largest = &list[0];\n\n    for item in list {\n        if item &gt; largest {\n            largest = item;\n        }\n    }\n\n    largest\n}\n\nfn main() {\n    let number_list = vec![34, 50, 25, 100, 65];\n\n    let result = largest(&number_list);\n    println!(\"The largest number is {}\", result);\n\n    let char_list = vec!['y', 'm', 'a', 'q'];\n\n    let result = largest(&char_list);\n    println!(\"The largest char is {}\", result);\n}",
    "crumbs": [
      "核心基础",
      "基础篇",
      "泛型"
    ]
  },
  {
    "objectID": "docs/basic/generic.html#在结构体中使用",
    "href": "docs/basic/generic.html#在结构体中使用",
    "title": "rust 泛型",
    "section": "2 在结构体中使用",
    "text": "2 在结构体中使用\nstruct Point&lt;T&gt; {\n    x: T,\n    y: T,\n}\n\nfn main() {\n    let integer = Point { x: 5, y: 10 };\n    let float = Point { x: 1.0, y: 4.0 };\n}\n使用多个泛型\nstruct Point&lt;T, U&gt; {\n    x: T,\n    y: U,\n}\n\nfn main() {\n    let both_integer = Point { x: 5, y: 10 };\n    let both_float = Point { x: 1.0, y: 4.0 };\n    // 这样你随便写啥都行\n    let integer_and_float = Point { x: 5, y: 4.0 };\n}",
    "crumbs": [
      "核心基础",
      "基础篇",
      "泛型"
    ]
  },
  {
    "objectID": "docs/basic/generic.html#在枚举中使用",
    "href": "docs/basic/generic.html#在枚举中使用",
    "title": "rust 泛型",
    "section": "3 在枚举中使用",
    "text": "3 在枚举中使用\nenum Option&lt;T&gt; {\n    Some(T),\n    None,\n}\n\nenum Result&lt;T, E&gt; {\n    Ok(T),\n    Err(E),\n}\n\nfn main() {\n    let some_value = Option::Some(5);\n    let none_value = Option::None;\n\n    let integer_value = Result::Ok(5);\n    let error_value = Result::Err(5);\n}",
    "crumbs": [
      "核心基础",
      "基础篇",
      "泛型"
    ]
  },
  {
    "objectID": "docs/basic/generic.html#impl中使用",
    "href": "docs/basic/generic.html#impl中使用",
    "title": "rust 泛型",
    "section": "4 impl中使用",
    "text": "4 impl中使用\nstruct Point&lt;T&gt; {\n    x: T,\n    y: T,\n}\n// 在impl 后&lt;T&gt; 是申明泛型参数 T\n// 来表明是为  Point&lt;T&gt; 这个类型实现方法,这里的T就使用了前面申明的T\nimpl&lt;T&gt; Point&lt;T&gt; {\n    fn x(&self) -&gt; &T {\n        &self.x\n    }\n}\n// 可以为 某个具体的类型实现方法\n// 因为上面的泛型包含了这种情况, 所以同时存在会报错\n// impl Point&lt;i32&gt; {\n//     fn x(&self) -&gt; &i32 {\n//         &self.x\n//     }\n// }\nfn main() {\n    let p = Point { x: 5, y: 10 };\n\n    println!(\"p.x = {}\", p.x());\n}\n方法与结构体使用不同的泛型\nstruct Point&lt;X1, Y1&gt; {\n    x: X1,\n    y: Y1,\n}\n\nimpl&lt;X1, Y1&gt; Point&lt;X1, Y1&gt; {\n    // 这里mixup后申明的X2,Y2,表示 方法里使用了X2,Y2泛型,与Point&lt;X1, Y1&gt;中的X1,Y1不一样\n    fn mixup&lt;X2, Y2&gt;(self, other: Point&lt;X2, Y2&gt;) -&gt; Point&lt;X1, Y2&gt; {\n        Point {\n            x: self.x,\n            y: other.y,\n        }\n    }\n}\n\nfn main() {\n    let p1 = Point { x: 5, y: 10.4 };\n    let p2 = Point { x: \"Hello\", y: 'c' };\n\n    let p3 = p1.mixup(p2);\n\n    println!(\"p3.x = {}, p3.y = {}\", p3.x, p3.y);\n}",
    "crumbs": [
      "核心基础",
      "基础篇",
      "泛型"
    ]
  },
  {
    "objectID": "docs/basic/generic.html#t",
    "href": "docs/basic/generic.html#t",
    "title": "rust 泛型",
    "section": "5 ::<T>",
    "text": "5 ::&lt;T&gt;\nfn main() {\n    // 声明一个类型为 Vec&lt;i32&gt; 的变量，并初始化它\n    let numbers: Vec&lt;i32&gt; = Vec::new();\n\n    // 泛型函数\n    fn create_empty_vec&lt;T&gt;() -&gt; Vec&lt;T&gt; {\n        Vec::new()\n    }\n\n    let empty_int_vec = create_empty_vec::&lt;i32&gt;();\n    let empty_int_vec2: Vec&lt;i32&gt; = create_empty_vec();\n}\ntrait Hello {\n    fn world(&self);\n}\nimpl&lt;T&gt; Hello for Vec&lt;T&gt; {\n    fn world(&self) {\n        println!(\"hello\");\n    }\n}\nfn main() {\n    // 声明一个类型为 Vec&lt;i32&gt; 的变量，并初始化它\n    let numbers: Vec&lt;i32&gt; = Vec::new();\n    numbers.world();\n    // Vec::&lt;i32&gt; 表示元素是i32类型的 Vec\n    Vec::&lt;i32&gt;::world(&numbers);\n}",
    "crumbs": [
      "核心基础",
      "基础篇",
      "泛型"
    ]
  },
  {
    "objectID": "docs/basic/generic.html#性能问题",
    "href": "docs/basic/generic.html#性能问题",
    "title": "rust 泛型",
    "section": "6 性能问题",
    "text": "6 性能问题\n\n\n\n\n\n\nTip\n\n\n\n其实泛型相当于占位符,然后把你编写的代码理解成模板, 编译器编译的时候,会将这些占位符替换成具体的类型, 比如上面的例子, 编译器会根据你实际使用的情况,将T替换成具体的类型比如 i32,f64,会生成对应的代码, 这个叫单态化, 这样运行时不会有额外的开销\n\n\nimpl Point&lt;i32&gt; {\n    fn x(&self) -&gt; &i32 {\n        &self.x\n    }\n}\n\nimpl Point&lt;f64&gt; {\n    fn x(&self) -&gt; &f64 {\n        &self.x\n    }\n}",
    "crumbs": [
      "核心基础",
      "基础篇",
      "泛型"
    ]
  },
  {
    "objectID": "docs/basic/unsafe.html",
    "href": "docs/basic/unsafe.html",
    "title": "rust unsafe",
    "section": "",
    "text": "为什么需要?\n\n\n\n\nRust 是一种系统编程语言, 强调内存安全、数据竞争自由和并发性. 尽管 Rust 提供了许多机制来保证内存安全, 但有时程序员需要执行一些操作,这些操作无法通过 Rust 的安全抽象来表示, 或者执行起来效率较低.\n在这种情况下, Rust 提供了 unsafe 块或 unsafe 函数\nunsafe 代码表明 可能有不安全的操作, 因为里面编写的代码 ,一些检查可能是不执行的, 需要程序员自己注意代码的编写, 写的没问题 ,那实际上就是安全的, 换句话说如果没写unsafe 编译器会报错, 是为了提醒你 这块代码 可能有不安全的操作, 需要你注意代码的编写\n根据上面的说法, 显然 unsafe代码块里的 代码 本来会做的检查还是会做",
    "crumbs": [
      "核心基础",
      "基础篇",
      "unsafe"
    ]
  },
  {
    "objectID": "docs/basic/unsafe.html#为什么需要以及它的作用",
    "href": "docs/basic/unsafe.html#为什么需要以及它的作用",
    "title": "rust unsafe",
    "section": "",
    "text": "为什么需要?\n\n\n\n\nRust 是一种系统编程语言, 强调内存安全、数据竞争自由和并发性. 尽管 Rust 提供了许多机制来保证内存安全, 但有时程序员需要执行一些操作,这些操作无法通过 Rust 的安全抽象来表示, 或者执行起来效率较低.\n在这种情况下, Rust 提供了 unsafe 块或 unsafe 函数\nunsafe 代码表明 可能有不安全的操作, 因为里面编写的代码 ,一些检查可能是不执行的, 需要程序员自己注意代码的编写, 写的没问题 ,那实际上就是安全的, 换句话说如果没写unsafe 编译器会报错, 是为了提醒你 这块代码 可能有不安全的操作, 需要你注意代码的编写\n根据上面的说法, 显然 unsafe代码块里的 代码 本来会做的检查还是会做",
    "crumbs": [
      "核心基础",
      "基础篇",
      "unsafe"
    ]
  },
  {
    "objectID": "docs/basic/unsafe.html#裸指针",
    "href": "docs/basic/unsafe.html#裸指针",
    "title": "rust unsafe",
    "section": "2 裸指针",
    "text": "2 裸指针\n\n\n直接访问和操作内存指向不合法内存,忽略借用检查Box的裸指针不自动清理\n\n\nfn main() {\n    struct Two {\n        first: i8,\n        second: i8,\n    }\n    let mut num = 777i32;\n    // 0000 0011  0000 1001\n    println!(\"num的二进制表示: {:b}\", num);\n    // 先将地址 &num 转换为 指针 *const i32 ,\n    // 然后将它转换为 *const i8, 表示现在是以一个字节的方式读取这块内存地址\n    let r1 = &num as *const i32 as *const i8;\n    // 步进1后的指针, 这里就表示该指针指向 r1 所在地址下一个字节的内存\n    // 这些操作无需 unsafe 包裹\n    let f = r1.wrapping_add(1);\n    // 转换为结构体的方式来读取这块内存\n    let r2 = &num as *const i32 as *const Two;\n    // 转换为以数组的方式来读写这块内存\n    let r3 = &mut num as *mut i32 as *mut [i8; 2];\n    // 在解引用操作的时候,才需要unsafe包裹\n    unsafe {\n        println!(\"num第一个字节==&gt; r1 : {}\", *r1); // 9\n        println!(\"num第二个字节==&gt; r1 : {}\", *f);  // 3\n        println!(\"num第一个字节==&gt; r2 : {:?}\", (*r2).first); // 9\n        println!(\"num第二个字节==&gt; r2 : {}\", (*r2).second);  // 3\n        println!(\"转换为数组 r3,num第一个字节:{}-num第二个字节:{}\", (*r3)[0], (*r3)[1]);\n        (*r3)[0] = 11; // 将第一个字节修改为11\n        println!(\"{num}\");\n    }\n\n}\n\n\nfn main() {\n    let b;\n    {\n        let a = \"hello\".to_string();\n        b = &a as *const String;\n    } // 编译器没有报错, 说明忽略了借用检查\n    let c = b.wrapping_add(1);\n    unsafe {\n        let d = b as *const [u64; 3];\n        println!(\"{}-0x{:x}-{}\", (*d)[0], (*d)[1], (*d)[2])\n    }\n    // 可以指向不合理的内存地址, 这里也说明了, 它不会像智能指针那样自动清理, 如果清理了, 那还得了\n    let address = 0x012345usize;\n    let r = address as *const i32;\n\n    // 空指针, 不指向任何有效的i32值\n    let p = std::ptr::null::&lt;i32&gt;();\n    println!(\"p 是否为空指针 {}\", p.is_null());\n}\n\n\nfn main() {\n    let f;\n    {\n        let b = Box::new(5);\n        println!(\"{:p}\", b); // 堆上的5的地址\n        println!(\"{:p}\", &b); // 栈上b变量的地址\n        // 将 b 转换为 *mut T 可变裸指针\n        // c 的类型是 这里是 *mut i32\n        // b 被move 掉了,但是这个c指向了 b指向的内存,且c没有这块内存的所有权\n        let c = Box::into_raw(b);\n        println!(\"{:p}\", c); // 堆上5的地址\n        unsafe {\n            println!(\"{}\", *c);\n            *c = 23;\n            f = &*c;\n            // Box::from_raw 重新获取所有权,这样离开作用域后, 回收了\n            // 取消注释后, *f 的值就不对了, 因为堆上的数据5被回收了\n            // let s = Box::from_raw(c);\n        }\n    }// 由于没有 变量对 堆上的数据5  拥有所有权, 所以没 回收\n    println!(\"f=={}\", *f);\n}\n\n\n\n\n需要 cargo add libc\n\nfn main() {\n    // 使用 libc 库中的 malloc 函数分配内存\n    let raw_ptr = unsafe { libc::malloc(std::mem::size_of::&lt;i32&gt;() as libc::size_t) as *mut i32 };\n    println!(\n        \"raw_ptr在栈上分配的地址: {:p}\\nraw_ptr申请的堆地址: {:p}\",\n        &raw_ptr,\n        unsafe { &*raw_ptr }\n    );\n    let b = Box::new(11);\n    println!(\"b指向的堆地址: {:p}\", b);\n    if raw_ptr.is_null() {\n        eprintln!(\"Memory allocation failed\");\n        return;\n    }\n\n    // 安全地使用裸指针\n    unsafe {\n        // 初始化内存\n        *raw_ptr = 42;\n\n        // 打印内存中的值\n        println!(\"Value at raw pointer: {}\", *raw_ptr);\n    }\n\n    // 注意：这里没有释放内存，这将导致内存泄漏\n    // 正确的做法应该是调用 libc::free 来释放内存\n    unsafe {\n        libc::free(raw_ptr as *mut libc::c_void);\n        println!(\"free 后 raw_ptr指向的值: {}\", *raw_ptr); // 0\n    }\n}",
    "crumbs": [
      "核心基础",
      "基础篇",
      "unsafe"
    ]
  },
  {
    "objectID": "docs/basic/unsafe.html#修改可变静态变量",
    "href": "docs/basic/unsafe.html#修改可变静态变量",
    "title": "rust unsafe",
    "section": "3 修改可变静态变量",
    "text": "3 修改可变静态变量\n\n\n可变的静态变量,修改需要unsafe\n\nstatic mut COUNTER: u32 = 0;\nfn add_to_count(inc: u32) {\n    unsafe {\n        COUNTER += inc;\n    }\n}\n\nfn main() {\n    add_to_count(3);\n\n    println!(\"COUNTER: {}\", unsafe { COUNTER });\n}",
    "crumbs": [
      "核心基础",
      "基础篇",
      "unsafe"
    ]
  },
  {
    "objectID": "docs/basic/unsafe.html#unsafe-fn",
    "href": "docs/basic/unsafe.html#unsafe-fn",
    "title": "rust unsafe",
    "section": "4 unsafe fn",
    "text": "4 unsafe fn\n\n\n\n\n\n\nTip\n\n\n\nunsafe函数或方法: 就是在定义前面加上unsafe关键字.\n\n\nunsafe fn dangerous() {}\nfn main() {\n    // 需要unsafe\n    unsafe {\n        dangerous();\n    }\n}\n\n\n\n调用内部实现有unsafe代码块的函数或方法,不需要unsafe包裹\n\nfn main() {\n    let mut v = vec![1, 2, 3, 4, 5, 6];\n\n    let r = &mut v[..];\n    // 切分成2个切片 [0,mid) [mid,len)\n    // split_at_mut 方法里面有 unsafe 代码块, 但是我们这里调用的时候 不需要unsafe\n    let (a, b) = r.split_at_mut(3);\n\n    assert_eq!(a, &mut [1, 2, 3]);\n    assert_eq!(b, &mut [4, 5, 6]);\n}\n\n\n\nsplit_at_mut源码\n\nuse std::slice;\n\nfn split_at_mut(values: &mut [i32], mid: usize) -&gt; (&mut [i32], &mut [i32]) {\n    let len = values.len();\n    let ptr = values.as_mut_ptr();\n\n    assert!(mid &lt;= len);\n\n    unsafe {\n        (\n            slice::from_raw_parts_mut(ptr, mid),\n            slice::from_raw_parts_mut(ptr.add(mid), len - mid),\n        )\n    }\n}\n\n\n\n\n直接使用std::slice库\n\nuse std::slice;\nfn main() {\n    let mut a = [1, 2, 3, 4, 5];\n    let b = &mut a;\n    let r = b as *mut i32; // a.as_mut_ptr()\n    let values: &[i32] = unsafe { slice::from_raw_parts_mut(r, 2) };\n    println!(\"{:?}\", values);\n}",
    "crumbs": [
      "核心基础",
      "基础篇",
      "unsafe"
    ]
  },
  {
    "objectID": "docs/basic/unsafe.html#unsafe-trait-unsafe-impl",
    "href": "docs/basic/unsafe.html#unsafe-trait-unsafe-impl",
    "title": "rust unsafe",
    "section": "5 unsafe trait, unsafe impl",
    "text": "5 unsafe trait, unsafe impl\nunsafe trait Foo {\n    // methods go here\n}\n\nunsafe impl Foo for i32 {\n    // method implementations go here\n}\n\nfn main() {}",
    "crumbs": [
      "核心基础",
      "基础篇",
      "unsafe"
    ]
  },
  {
    "objectID": "docs/basic/unsafe.html#extern-调用外部函数ffi",
    "href": "docs/basic/unsafe.html#extern-调用外部函数ffi",
    "title": "rust unsafe",
    "section": "6 extern 调用外部函数(FFI)",
    "text": "6 extern 调用外部函数(FFI)\n\n\n\n\n\n\nTip\n\n\n\n\nFFI: Foreign Function Interface 外部函数接口, 可以让一种编程语言定义函数,然后其他语言可以调用\n\n\n\n\n6.1 rust 调用C\nextern \"C\" {\n    // 我们想要调用的外部函数的名称和参数返回值定义\n    fn abs(input: i32) -&gt; i32;\n}\n\nfn main() {\n    unsafe {\n        println!(\"Absolute value of -3 according to C: {}\", abs(-3));\n    }\n}\n\n\n6.2 c语言调用rust\n\ncargo new ccc\ntree\n.\n├── Cargo.lock\n├── Cargo.toml\n├── main.c\n├── src\n│   └── lib.rs\n\nCargo.toml 添加src/lib.rsmain.c最后ubuntu下执行过程\n\n\n[package]\nname = \"ccc\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[dependencies]\n[lib]\ncrate-type = [\"cdylib\"]\n\n\n#[no_mangle]\npub extern \"C\" fn call_from_c() {\n    println!(\"Just called a Rust function from C!\");\n}\n\n\n#include &lt;stdio.h&gt;\n\n// 声明 Rust 函数\nextern int call_from_c();\n\nint main() {\n    call_from_c();\n    return 0;\n}\n\n\n# 编译rust lib, 会在 target/release目录下生成 libccc.so\n# 不同的操作系统 生成的不太一样.\ncargo build --release\n# 编译 main.c, -lccc 中的ccc 是rust lib package name\ngcc -o main main.c -L target/release -lccc -Wl,-rpath,target/release\n# 运行编译后的c程序\n./main\n\n\n\n\n\n\n\n\n\n\n#[no_mangle] 关于名称混淆(Name Mangling)\n\n\n\n\n名称混淆是编译器的一种行为,它会根据函数的参数类型、返回类型、函数名、命名空间等信息生成一个唯一的名称\n这个过程确保即使在同一个程序中存在多个同名但参数类型不同的函数时,编译后的二进制文件中也不会出现命名冲突\n#[no_mangle] 的作用\n\n当你使用 #[no_mangle] 属性时,Rust 编译器会保留函数的原始名称,而不是生成一个混淆后的名称\n当你需要从其他语言（如 C 或 C++）调用 Rust 函数时, 才可以通过这个函数名找到对应的函数\n所以你在rust中定义的rust函数必须全局唯一的函数名",
    "crumbs": [
      "核心基础",
      "基础篇",
      "unsafe"
    ]
  },
  {
    "objectID": "docs/basic/unsafe.html#禁用-unsafe",
    "href": "docs/basic/unsafe.html#禁用-unsafe",
    "title": "rust unsafe",
    "section": "7 禁用 unsafe",
    "text": "7 禁用 unsafe\n\n\n在文件顶部写上\n\n#![forbid(unsafe_code)]\nfn main() {\n    // 执行 程序, 会报错, 提示你不能用unsafe{}\n    unsafe{\n\n    }\n}",
    "crumbs": [
      "核心基础",
      "基础篇",
      "unsafe"
    ]
  },
  {
    "objectID": "docs/basic/unsafe.html#内置函数",
    "href": "docs/basic/unsafe.html#内置函数",
    "title": "rust unsafe",
    "section": "8 内置函数",
    "text": "8 内置函数",
    "crumbs": [
      "核心基础",
      "基础篇",
      "unsafe"
    ]
  },
  {
    "objectID": "docs/basic/ownership.html",
    "href": "docs/basic/ownership.html",
    "title": "rust 所有权",
    "section": "",
    "text": "所有权是rust用来管理内存的一系列规则",
    "crumbs": [
      "核心基础",
      "基础篇",
      "所有权与借用"
    ]
  },
  {
    "objectID": "docs/basic/ownership.html#所有权规则",
    "href": "docs/basic/ownership.html#所有权规则",
    "title": "rust 所有权",
    "section": "",
    "text": "所有权是rust用来管理内存的一系列规则",
    "crumbs": [
      "核心基础",
      "基础篇",
      "所有权与借用"
    ]
  },
  {
    "objectID": "docs/basic/ownership.html#move-语义",
    "href": "docs/basic/ownership.html#move-语义",
    "title": "rust 所有权",
    "section": "2 move 语义",
    "text": "2 move 语义\n\nfn main() {\n    let x = 12;\n    let y = x;\n    println!(\"{}\", x);\n\n    let x = \"abc\".to_string();\n    let y = x;\n    // println!(\"{}\", x);\n}\n\n\n\n\n\n\n分析一下到底会如何执行\n\n\n\n\n先有设计思想(即: 所有权三个规则),然后才去设计代码如何执行, 现在我们根据这个思想看第3行和第7行, 我们推断一下代码的执行\n因为值只能有一个所有者原则(所有者的概念有一重点,就是只有它可以将值销毁),所以\n\n第3行, 因为x变量内容只在栈上分配,let y=x; 会将x的值复制给 y, 就是将x变量存放的内容复制到y变量所在内存上,这个时候有2种选择\n\n使x失效(表示无法再通过变量x来访问x所在的那块内存), 这样给人感觉 值 12 只有一个所有者了, 给人一种 x “move 移动” y的感觉\n使x还是有效, 这样2个值都有自己的所有者, 注意这本身就不违反值只有一个所有者(因为是其实是2个不同地方的值了,提醒下所有权规则是为了内存管理,这里的情况就各自管理各自的值, 不会有安全问题)\n\n第7行, x变量是字符串,在栈上分配的内存存放的数据,里面有一个是指向堆内存数据的指针, 那么let y=x;的操作可能有3种选择\n\n将堆上的数据复制一份, 然后栈上的数据也复制后,把里面指向实际字符串的指针设置指向新复制的堆内存, 这个操作如果是默认行为的, 那显然很蛋疼,不可能如此设计\n只复制栈上的数据, y和x 同时有效, 但是这违反了, 只有一个所有者的规则, 因为他们2个还都指向了同一个值:堆上的数据, 有2个所有者,当离开作用域时,会导致释放同一个块内存,出现double free error 这样的安全问题 , 这就是String字符串为啥设计成move的原因\n只复制栈上的数据, 使x失效, 给人一种 x “move 移动” y 的感觉\n\n\n根据上面的思考, 既然设计思想里是 值 只有一个所有者, 那么 默认上(注意这个默认), 应该是使用 “move 移动”的.\n运行上面代码结果 是, 第4行 ok, 第8行 错误. 按照设计,默认来说, 第4行应该也报错才对, 没错就说明 rust 对 i32类型做了特殊处理,就是前面说的复制,但是变量不失效\n结论: 关于Move和Copy:\n\nrust 默认使用 Move 语义, 就是转移所有权\nrust 会给一些基本类型 自动实现一个 std::markder::Copy 这样一个标记型 trait, 来表明它会用复制但变量不失效的处理方式. 这个就是 Copy 语义. 我们也可以手动为某类型实现 Copy trait, 这样它就是Copy 语义的了.\n当你看到一个变量和它的类型时, 先是默认Move,然后思考它会不会设计成 Copy 语义\n\n\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\n\n来看 Move 语义的例子, 涉及到 裸指针相关知识点\n\n\n\n\n结构体字符串 String\n\n\nfn main() {\n    #[derive(Debug)]\n    struct Dog {\n        age: i32,\n        weight: i32,\n    }\n    let a = Dog {\n        age: 11,\n        weight: 22,\n    };\n    // 裸指针 没有指向的数据的所有权. 可以指向任意地方\n    let c = &a as *const Dog;\n    let mut b = a;\n    b.age = 10;\n    b.weight = 20;\n    // 报错,  自定义类型结构体默认是move\n    // println!(\"{:?}\",a);\n    unsafe {\n        println!(\"原a变量所在内存现在的内容: {:?}\", *c);\n        println!(\"原a变量  age 字段的地址: {:p}\", &(*c).age);\n        println!(\"原a变量weight字段的地址: {:p}\", &(*c).weight);\n    }\n    println!(\"原a变量地址: {:p}\", c);\n    println!(\"c 变量地址: {:p}\", &c);\n    println!(\"b 变量地址: {:p}\", &b);\n    println!(\"b.age 地址:{:p}\", &b.age);\n    println!(\"b.weight 地址:{:p}\", &b.weight);\n    // 是move ,实际也是 复制, 只不过让 a 失效\n    println!(\"b 的值: {:?}\", b);\n}\n\n\nfn main() {\n    let a = \"abc\".to_string(); // a 拥有 字符串的所有权\n    let c = &a as *const String as *const [u64; 3];\n    let b = a;  // a 将 abc字符串的所有权转移给了 ,a 失效了,处于不可用状态\n    // move 了, a 变量失效, 无法通过a 来读取原来的数据,报错了\n    // println!(\"{}\", a);\n\n    unsafe {\n        println!(\"原a变量所在内存内容: {:?}\", *c);\n        println!(\"原a变量字符串 中ptr字段的值: 0x{:x}\", (*c)[1]);\n    }\n    println!(\"原a 变量地址 {:p}\", c);\n    println!(\"c 变量地址: {:p}\", &c);\n    println!(\"b 变量地址: {:p}\", &b);\n    println!(\"b 变量字符串 中ptr字段的值{:p}\", b.as_ptr());\n}\n\n\n\n\n\n\n\n\n\n\nImportant\n\n\n\nrust 永远不会做深拷贝的事情,因为开销大,当然除非你主动\n\n\nfn main(){\n    let s1 = String::from(\"hello\");\n    // 深拷贝了\n    let s2 = s1.clone();\n    println!(\"s1 = {}, s2 = {}\", s1, s2);\n}",
    "crumbs": [
      "核心基础",
      "基础篇",
      "所有权与借用"
    ]
  },
  {
    "objectID": "docs/basic/ownership.html#copy-语义",
    "href": "docs/basic/ownership.html#copy-语义",
    "title": "rust 所有权",
    "section": "3 copy 语义",
    "text": "3 copy 语义\n\n3.1 谁能实现Copy 语义\n\n\n\n\n\n\nImportant\n\n\n\n\n前面我们提到 实现Copy 语义,需要给类型实现 Copy trait\n类型的值可以通过简单的位拷贝来复制, 这意味着类型在内存中的表示可以直接复制而不需要进行任何其他操作(不会产生任何内存安全问题),那种还有指向堆上数据的类型就不可以实现Copy\n\n\n\n\n\n3.2 这些类型是Copy\n\nCopy\n\n整型不可变借用数组\n\n\nfn main() {\n    let x = 5;\n    // 将x的值copy 给y, 2个变量同时存在\n    // 因为这里是直接在栈上,拷贝起来是非常快的\n    // 所以在设计上就直接简单复制,对比看后面的字符串的情况\n    let y = x;\n    println!(\"{:p}-{:p}\", &x, &y);\n    println!(\"{x},{y}\");\n}\n\n\nfn main() {\n    let a = 1;\n    let b = &a;\n    let c = b; // copy\n\n    println!(\"{b}\"); //ok\n    println!(\"{c}\");\n}\n\n\nfn main() {\n    // 元素是整型, 则是copy\n    let a = [1, 2, 3];\n    let b = a; // 栈上的 数据会复制一份给b\n    println!(\"{:?}-{:p}\", a, &a);\n    println!(\"{:?}-{:p}\", b, &b);\n}\n\n\n\nMove\n\n可变借用的赋值结构体\n\n\nfn main() {\n    let mut a = 1;\n    let b = &mut a;\n    let _c = b;\n    // 报错了\n    // 因为 b 已经移动给了 c, b 已经不可用了\n    println!(\"{b}\");\n}\n\n\nfn main() {\n    struct Dog {\n        age: u8,\n    }\n    let a = Dog { age: 1 };\n    let _b = a;\n    // 根据图5所示,move类型, 所以这里报错了,提示a已经被move了\n    println!(\"{}\", a.age);\n}\n\n\n\n\n\n3.3 给类型实现Copy\n\n\n\nCopy trait定义\n\npub trait Copy: Clone {\n    // Empty.\n}\n\n\n\n\n\n\n\nImportant\n\n\n\n\n实现Copy trait 必须也实现 Clone trait\n\n\n\n\n\n\n\n\n\n\nImportant\n\n\n\n\n自定义类型比如struct和enum,只有所有成员都能实现了Copy trait, 该类型才能实现Copy trait\n\n\n\n\n\n字段是整型的结构体\n\nfn main() {\n    // 自动给实现Copy Clone\n    #[derive(Copy, Clone, Debug)]\n    struct Dog {\n        age: u8,\n    }\n    let a = Dog { age: 1 };\n    let _b = a;\n    println!(\"{:?}\", a);  // OK\n}\n\n\n\n报错: 字段含字符串的结构体\n\nfn main() {\n    // 自动给实现Copy Clone\n    #[derive(Copy, Clone, Debug)] // 直接报错这里\n    struct Dog {\n        name: String,\n    }\n    let a = Dog { name: \"tom\".to_string() };\n    let _b = a;\n    println!(\"{:?}\", a);\n}",
    "crumbs": [
      "核心基础",
      "基础篇",
      "所有权与借用"
    ]
  },
  {
    "objectID": "docs/basic/ownership.html#变量作用域",
    "href": "docs/basic/ownership.html#变量作用域",
    "title": "rust 所有权",
    "section": "4 变量作用域",
    "text": "4 变量作用域\n\n\n\n\n\n\nImportant\n\n\n\n\n一个变量的生命周期: 一个变量的出生到死亡的整个过程\n一个变量离开它的作用域时, 就是它死亡的时候, 会释放资源\n\n\n\n\n\n&str 变量离开作用域后\n\nfn main() {\n    let ptr;\n    {   // 这一行时 a变量 还没申明, 不可用\n        let a = \"hello\"; // a 变量可用\n        // a.as_ptr() 就是 a as *const str\n        ptr = a as *const str;\n        unsafe {\n            println!(\"a指向的实际字符串的地址上的数据:  {}\", &*ptr);\n        }\n    } // a 离开作用域, a变量无效了\n    unsafe {\n        // 我们发现数据还在, 这是因为 a 是&str类型, 没有 \"hello\" 的所有权,\n        // 它只是它的借用, 实际字符串数据放在只读区\n        println!(\"离开作用域后,a指向的实际字符串的地址上的数据: {}\", &*ptr);\n    }\n    // println!(\"{}\", a); // cannot find value s in this scope\n}\n\n\n\nString字符串离开作用域后查看其指向的堆内存的内容\n\nfn main() {\n    let c;\n    {\n        let mut a = \"hello\".to_string();\n        a.push_str(\"tom\");\n        c = &a as *const String as *const (u64, *const u8, u64);\n        unsafe {\n            let len = (*c).2 as usize;\n            let ptr = (*c).1;\n            print!(\"|\");\n            let mut d;\n            for i in 0..len {\n                d = ptr.add(i);\n                // hellotom\n                print!(\"{}\", *d as char);\n            }\n            println!(\"|\");\n        }\n    } // a 离开作用域, 释放资源\n    unsafe {\n        let len = (*c).2 as usize;\n        let ptr = (*c).1;\n        print!(\"|\");\n        let mut d;\n        // 这里打印是空的了, 堆上的内存被释放了.\n        for i in 0..len {\n            d = ptr.add(i);\n            print!(\"{}\", *d as char);\n        }\n        println!(\"|\");\n    }\n}",
    "crumbs": [
      "核心基础",
      "基础篇",
      "所有权与借用"
    ]
  },
  {
    "objectID": "docs/basic/ownership.html#析构函数-drop",
    "href": "docs/basic/ownership.html#析构函数-drop",
    "title": "rust 所有权",
    "section": "5 析构函数 drop",
    "text": "5 析构函数 drop\n\n\n\n\n\n\n为什么内存在持有它的变量离开作用域后会被无效了呢?\n\n\n\n\n当变量离开作用域, Rust 会调用一个名为drop的特殊函数\n设计string类型的作者可以在该drop函数中写一些释放内存的代码,以此实现自动释放内存的功能,这样就实现资源的自动管理\n不同类型变量的drop的实现可能不一样\nRust 在结尾的 } 处会自动调用 drop\n\n\n\n\n\n\n\n\n\nImportant\n\n\n\n\n实现Copy trait的类型 无法实现 drop trait\n\n\n\n\n\n自定义析构函数\n\n#[derive(Debug)]\nstruct Dog {\n    age: i32,\n}\n// 实现 std::ops::Drop 这个trait\nimpl Drop for Dog {\n    fn drop(&mut self) {\n        println!(\"dog drop...{}\", self.age);\n    }\n}\nfn main() {\n    {\n        let a = Dog { age: 1 }; // 最先 drop\n    } // 离开作用域, 会自动调用drop 方法\n    let b = Dog { age: 2 }; // 最后一个drop\n    let c = Dog { age: 3 };  // 这个是第二个drop ,局部变量 先进后出\n}\n\n\n\n\n主动触发析构drop\n\n// #[derive(Copy,Clone,Debug)]\n#[derive(Debug)]\nstruct Dog {\n    age: i32,\n}\n// 实现 std::ops::Drop 这个trait\nimpl Drop for Dog {\n    fn drop(&mut self) {\n        // 传递的是可变借用\n        println!(\"dog drop...{}\", self.age);\n    }\n}\n\nfn main() {\n    {\n        let a = Dog { age: 1 };\n    }\n    let b = Dog { age: 2 };\n    std::mem::drop(b);\n    let c = Dog { age: 3 };\n}\n\n\n执行结果std::mem::drop 源码\n\n\ndog drop...1\ndog drop...2\ndog drop...3\n\n\n\n我们发现, 其实这个就是进行了主动的move 操作,转移所有权,然后函数调用结束,参数的生命周期结束了,触发析构函数drop\n这样看来, Copy 语义的类型, 使用这个drop 没有任何意义, 所以直接就是实现Copy trait的类型无法实现 drop trait\n\npub fn drop&lt;T&gt;(_x: T) {\n    // 函数体是空的\n}\n\n\n\n\n\n\n变量shadowing\n\n#[derive(Debug)]\nstruct Dog {\n    age: i32,\n}\n// 实现 std::ops::Drop 这个trait\nimpl Drop for Dog {\n    fn drop(&mut self) {\n        println!(\"dog drop...{}\", self.age);\n    }\n}\n\nfn main() {\n    {\n        let a = Dog { age: 1 };\n    }\n    // 之前说过,变量shadowing ,2个就是不通的变量\n    let b = Dog { age: 2 };\n    let b = Dog { age: 3 };\n}\n\n\n\n_\n\n#[derive(Debug)]\nstruct Dog {\n    age: i32,\n}\n// 实现 std::ops::Drop 这个trait\nimpl Drop for Dog {\n    fn drop(&mut self) {\n        println!(\"dog drop...{}\", self.age);\n    }\n}\n\nfn main() {\n    {\n        let a = Dog { age: 1 };\n    }\n    // _ 这样的 会马上执行 析构函数\n    let _ = Dog { age: 2 };\n    let b = Dog { age: 3 };\n}",
    "crumbs": [
      "核心基础",
      "基础篇",
      "所有权与借用"
    ]
  },
  {
    "objectID": "docs/basic/ownership.html#函数传参所有权问题",
    "href": "docs/basic/ownership.html#函数传参所有权问题",
    "title": "rust 所有权",
    "section": "6 函数传参所有权问题",
    "text": "6 函数传参所有权问题\n\nfn main() {\n    let s = String::from(\"hello\");\n    // s move into 函数\n    takes_ownership(s);\n    // 所以s 这个时候已经不可用了.\n    // println!(\"{s}\"); //报错了\n\n    let x = 5;\n    // x would move into the function,\n    // 但是 x 是i32 类型,在栈上,前面说过它会 copy 操作\n    makes_copy(x);\n    println!(\"{x}\"); // 这里还是可以访问的\n} // Here, x goes out of scope, then s. But because s's value was moved, nothing\n  // special happens.\n\nfn takes_ownership(some_string: String) {\n    // some_string comes into scope\n    println!(\"{}\", some_string);\n} // 跳出作用域,some_string 指向的堆以及自身(栈会弹)都会被drop, 内存会释放\n\nfn makes_copy(some_integer: i32) {\n    // some_integer comes into scope\n    println!(\"{}\", some_integer);\n} // Here, some_integer goes out of scope. Nothing special happens.",
    "crumbs": [
      "核心基础",
      "基础篇",
      "所有权与借用"
    ]
  },
  {
    "objectID": "docs/basic/ownership.html#函数返回值所有权",
    "href": "docs/basic/ownership.html#函数返回值所有权",
    "title": "rust 所有权",
    "section": "7 函数返回值所有权",
    "text": "7 函数返回值所有权\nfn main() {\n    let s1 = gives_ownership();\n\n    let s2 = String::from(\"hello\");\n\n    // s2 move 给了 takes_and_gives_back的参数\n    // takes_and_gives_back 返回值 move 给了 调用者, 给了s3\n    let s3 = takes_and_gives_back(s2);\n} // Here, s3 goes out of scope and is dropped. s2 was moved, so nothing\n  // happens. s1 goes out of scope and is dropped.\n\n// 会将返回值 move 给它的调用者\nfn gives_ownership() -&gt; String {\n    let some_string = String::from(\"yours\");\n\n    // 这个会作为返回值, move 给 当前函数的调用者\n    some_string\n}\n\n// This function takes a String and returns one\nfn takes_and_gives_back(a_string: String) -&gt; String {\n    // a_string comes into\n    // scope\n\n    a_string // a_string is returned and moves out to the calling function\n}",
    "crumbs": [
      "核心基础",
      "基础篇",
      "所有权与借用"
    ]
  },
  {
    "objectID": "docs/basic/ownership.html#借用-borrow",
    "href": "docs/basic/ownership.html#借用-borrow",
    "title": "rust 所有权",
    "section": "8 借用 borrow",
    "text": "8 借用 borrow\n前面调用函数我们发现,每次调用函数,都会有 taking ownership 和 returning ownership,很烦, 有没有可以直接使用某个值,而不需要转移所有权的呢? –&gt; 借用\n\n\n\n\n\n\nTip\n\n\n\n\n你借给别人你的书, 书的所有权还是你的,别人只是借用一下.\n你借给别人书时,说只能看,别涂涂画画的, =&gt; 不可变借用\n你借给别人书时,说可以写写画画, =&gt; 可变借用\n\n\n\n& 表示引用某些值, 而不取得其所有权, 所以是没有权限去管理值的销毁的\nfn main() {\n    let s1 = String::from(\"hello\");\n    // &s1, 引用s1,  知道s1的地址, 就意味着 知道它的值\n    let len = calculate_length(&s1);\n\n    println!(\"The length of '{}' is {}.\", s1, len);\n}\n\nfn calculate_length(s: &String) -&gt; usize {\n    s.len()\n}//s 并不拥有 s1变量指向的值的所有权, 所以当 drop 后, s1变量指向的值不会free\n\n8.1 不可变和可变\nfn main() {\n    let s = String::from(\"hello\");\n\n    // changeImmutable(&s);\n\n    // 字符串 需要 可变\n    let mut s2 = String::from(\"hello\");\n    // 引用也需要可变\n    changeMutable(&mut s2);\n    println!(\"{:?}-{:?}\", s.as_ptr(), s2.as_ptr());\n\n}\n\nfn changeImmutable(some_string: &String) {\n    some_string.push_str(\", world\");  //报错了\n}\n// 参数需要可变\nfn changeMutable(some_string: &mut String) {\n    // some_string.push_str(\", world\");\n    some_string.pop();\n}\nstruct Sheep&lt;'a&gt; {\n    a: &'a mut i32,\n}\nfn main() {\n    // 表示c 可变, 意思是它可以重新绑定数据(重新赋值)\n    let mut c = 11;\n    // 表示d 指向的数据 是可变的.\n    // d本身不可变\n    let d = &mut c;\n    // 这里实际修改的c,所以d不需要mut\n    // 对谁做修改,谁就要mut\n    *d = 12;\n    // ====\n    let mut c = 11;\n    // d 本身可变, 就是说 我可以 d = &mut 12\n    let mut d = &mut c;\n    let f = &mut d;\n    // *f 是对d 修改, d就要mut\n    **f = 12;\n    // ====\n    let mut c = 11;\n    // 这里需要mut\n    let d = &mut Sheep { a: &mut c };\n    println!(\"{}\", d.a);\n    // 这里修改d.a, 就是对d 进行了修改,需要d &mut\n    // 虽然实际上a的值没有修改, 修改的是a指向的内存的值\n    *d.a = 22;\n    println!(\"{}\", d.a);\n}\n\n\n8.2 编译是否成功的判断方法\n\n\n\n\n\n\n含借用的代码,编译是否成功的判断逻辑\n\n\n\n\nrust 希望你是明确知道自己是想要如何使用这块内存,然后正确定义合适的变量\n如果你使用不可变借用\n\n那么定义这个不可变引用后到最后一次使用它之前, 你肯定是希望它指向的数据不会被修改, 要不然你用个屁的不可变啊\n所以在定义一个不可变借用后 &a, 接着有代码修改了a的数据, 然后你再使用这个不可变引用,那么就报错了,因为这和你的初衷是违背的\n\n如果你使用了可变借用\n\n那么定义这个可变借用后到最后一次使用它之前, 你肯定不希望有其他人来修改它,你希望只有你自己可以修改a的值,就是你在最后使用它之前,对 a 完全可控的,你不希望在读取它之前,被其他人修改\n所以在定义一个可变借用后, 你要确保你最后在使用它之前, 没有其他人修改它\n\n你可以认为 从你定义借用变量到最后一次使用这个借用变量,这段代码块是你这个借用变量的作用域, 在这样一个作用域内不能有对一个变量的多个可变借用 , 类似于读写锁, 某一时间内只能有一个写操作\n以上我是从 rust为什么要这样设计 这个角度去思考得出的结论, 现在应该不难判断了.\n\n\n\n报错的\nfn main() {\n    let mut a = 3;\n    let b = &mut a;\n    a = 31; // 这里提示错误\n    // 在使用这个 可变引用前,有其他人对a做了修改了\n    // 这不符合 定义可变引用的初衷\n    println!(\"{}\", b);\n}\n正确的\nfn main() {\n    let mut a = 3;\n    let b = &mut a;\n    *b = 11;\n    // 前面自己修改, 最后使用的地方, 都是想要的结果\n    // 用作用域来理解 也ok的\n    println!(\"{}\", b);\n    a = 31;\n    println!(\"{}\", a);\n}\n作用域\nfn main() {\n    let mut s2 = String::from(\"hello\");\n    {\n        let r3 = &mut s2;\n        println!(\"{}\", r3);\n    } // 这个时候r3 drop了. 所以后面 可以有 r4\n    let r4 = &mut s2;\n    println!(\"{}\", r4);\n}\n多个可变引用,ok的\nfn main() {\n    let mut a = 3;\n    let b = &mut a;\n    println!(\"{}\", b);\n    let c = &mut a;\n    println!(\"{}\", c);\n}\n报错的\nfn main() {\n    let mut a = 3;\n    let b = &mut a;\n    let c = &mut a;\n    // 你使用b的时候,前面有 个c 可能做 对a的修改\n    // 这样你这里使用b时,可能就不是你想要的结果了.\n    // 按照前面的说法, 可以理解为: 一个作用域内 只能有一个可变引用\n    println!(\"{}\", b);\n    println!(\"{}\", c);\n}\n报错了\nfn main() {\n    let mut a = 3;\n    let b = &a;\n    let c = &mut a;\n    // 报错了, 你使用不可变引用,但是前面c 可能会修改a\n    println!(\"{}\", b);\n    println!(\"{}\", c);\n}\n多个不可变引用\nfn main() {\n    let mut s = String::from(\"hello\");\n    // 在有一个可变引用之前的 多个不可变引用, 完全ok\n    // 这个道理很好理解,因为在 可变引用之前,变量不存在竞争\n    let a1 = &s; // 不可变引用\n    let a2 = &s; // 多个不可变引用 ,可以的\n    // 关键: 因为在可变引用之前,所以使用的时候,不会出现被修改的情况\n    println!(\"{}-{}\", a1, a2);\n    let x1 = &mut s; // 可变引用\n    println!(\"{}\", x1);\n}\n报错\nfn main() {\n    let mut s = String::from(\"hello\");\n    let a1 = &s;\n    let a2 = &s;\n    s.push_str(\"world\");  // 同样会报错\n    // 因为这个时候, s 已经被修改了, 不可变引用的意义没了\n    println!(\"{}-{}\", a1, a2);\n}\n\n\n8.3 悬挂引用\nrust 编译器会直接报错\nfn main() {\n    let reference_to_nothing = dangle();\n}\n\nfn dangle() -&gt; &String {\n    let s = String::from(\"hello\");\n\n    &s\n} // s drop 掉了, 所在内存被释放了. &s 引用了一个不可控的内存\n\n\n8.4 reborrow?\n\n8.4.1 可变借用直接赋值\n报错的\nfn main() {\n    let mut a = 3;\n    let b = &mut a;\n    // 可变借用是move类比, 因此b move 给了c\n    let c = b;\n    println!(\"{}\", b); //报错\n    println!(\"{}\", c);\n}\n报错了, 你可能以为这不和上面一样吗, b move给了c, 你打印b肯定错了\nfn main() {\n    let mut a = 3;\n    let b = &mut a;\n    let c: &mut i32 = b;\n    println!(\"{}\", b);\n    println!(\"{}\", c);\n}\n实际上我们看下报错信息,非常有意思, 竟然说b被可变借用了,而不是move给了c?\n\n\nerror信息\n\nerror[E0502]: cannot borrow `b` as immutable because it is also borrowed as mutable\n --&gt; src/main.rs:5:20\n  |\n4 |     let c: &mut i32 = b;\n  |                       - mutable borrow occurs here\n5 |     println!(\"{}\", b);\n  |                    ^ immutable borrow occurs here\n6 |     println!(\"{}\", c); //\n  |                    - mutable borrow later used here\n\n先看下这个类比\nfn main() {\n    let mut b = 1;\n    let c=&mut b;\n    // 使用b 前, 可能已经被修改了(因为c), 所以报错\n    println!(\"{}\", b);\n    println!(\"{}\", c);\n}\n再看看前面的 let c: &mut i32 = b; 说是b被可变借用了,怎么就可变借用了? 只有下面这种可能了 let c: &mut i32 = b; 估计是等价于\nlet c= &mut *b; // 这样b 确实可以说被可变借用了\n完整类比\nfn main() {\n    let mut a = 3;\n    let b = &mut a;\n    let c = &mut *b;\n    println!(\"{}\", b);\n    println!(\"{}\", c);\n}\n现在在看看正确的\nfn main() {\n    let mut a = 3;\n    let b = &mut a;\n    // c是(*b)的可变借用,认为与a无关, 虽然实际和 &mut a一样\n    // 这样 实际上 对于a来说,有2个可变借用,且还有交集的样子\n    // 但是对于b 来说, 只有一个对b的可变借用, 在这个可变借用 折腾完后,再使用b 是ok的.\n    let c = &mut *b;\n    *c = 4;\n    /* 类比这个肯定最后报错\n    let d= &mut a;\n    *d = 4;\n    */\n    println!(\"{}\", c);\n    println!(\"{}\", b);\n}\n\n\n8.4.2 可变借用函数传参\n我是最先测试函数传可变借用时,发现奇怪现象的\nfn main() {\n    let mut a = 3;\n    let b = &mut a;\n    ppp(b);\n    // 对比这个,如果用这个,就会报错了\n    // 因为这样就有2个a的可变借用且作用域有交叉(后面使用了b的,但是在之前有对a新的可变借用)\n    // ppp(&mut a);\n    println!(\"{b}\"); // ok\n}\n// 相当于 let s:&mut i32=b;\nfn ppp(s: &mut i32) {\n    *s = 11;\n}\n同样的,b 没有发生 move\n\n\n再来看看这个例子,相当于存在2个a的可变借用\n\nfn main() {\n    let mut a = 3;\n    let b = &mut a;\n    // 通过一个函数使用该可变借用, 来修改数据,这样的功能需求很正常\n    // 当然这里我们返回了这个可变借用,一般不会这么做,这里只是演示\n    let c = new_mut_borrow(b);\n    *c = 33;\n    println!(\"{b}\"); // ok\n}\n// 相当于 let s:&mut i32=b;\nfn new_mut_borrow(s: &mut i32) -&gt; &mut i32 {\n    *s = 11;\n    s\n}\n\n\n\n8.4.3 可变借用函数传参为何这样设计\nstruct Cat&lt;'a&gt; {\n    a: &'a mut String,\n}\nimpl&lt;'a&gt; Cat&lt;'a&gt; {\n    fn mut_fn(&'a mut self, n: &'a str) {\n        // self= &mut Cat\n        // let mut c = Cat { a: &mut s }; 为例\n        // self.a 变量是 &mut s ,是可变借用类型\n        // push_str=&gt; String::push_str(&mut self, )\n        // 会使用reborrow , =&gt; 将&mut (*self.a) 作为 String::push_str() 的参数\n        self.a.push_str(n);\n    }\n}\nfn main() {\n    let mut s = \"hello\".to_string();\n    // 如果 去掉mut c的mut, 会提示, can't mutate immutable variable 'c'\n    let mut c = Cat { a: &mut s };\n    // 因为 Cat::mut_fn(&mut c)\n    c.mut_fn(\" world\");\n\n    let mut c = Cat { a: &mut s };\n    // 如果去掉&mut c的mut,则提示\n    // can't borrow `*d` as mutable\n    // mut_fn 是对 *d 的 可变借用 &(*d)\n    // 这和我们之前说的一致 reborrow\n    let d = &mut c;\n    // 如果不是用reborrow, 直接move 的形式 (可变借用本身是move,前面说过),\n    // 那么执行完后, d 失效了.. 除非你返回又接收.. ,不太好!\n    d.mut_fn(\"abc\");\n    // 还有比如这个, 你不用执行完后, d.a 失效了...\n    d.a.push_str(\"string\");\n}\n\n\n\n\n\n\nImportant\n\n\n\n\n看上面例子, 从功能上讲, 使用reborrow 更加方便, 我们传递一个可变借用给函数, 在这个函数空间内,是独立作用域,会创建一个临时的可变借用,函数执行完毕, 该临时可变借用就失效了. 外部一开始的可变借用可以继续使用. 这个应该是你开发人员希望的, 因为自己清楚使用可变借用传递给函数是做某种修改,后续可能还继续使用另外一个函数来修改",
    "crumbs": [
      "核心基础",
      "基础篇",
      "所有权与借用"
    ]
  },
  {
    "objectID": "docs/hands-on/compiler/index.html",
    "href": "docs/hands-on/compiler/index.html",
    "title": "rust实战编译器",
    "section": "",
    "text": "BrainFuck八种符号\n\n\n\n\n\n\n字符\n含义\n\n\n&gt;\n指针加一\n\n\n&lt;\n指针减一\n\n\n+\n指针指向的字节的值加一\n\n\n-\n指针指向的字节的值减一\n\n\n.\n输出指针指向的单元内容（ASCⅡ码）\n\n\n,\n输入内容到指针指向的单元（ASCⅡ码）\n\n\n[\n如果指针指向的单元值为零，向后跳转到对应的]指令的次一指令处\n\n\n]\n如果指针指向的单元值不为零，向前跳转到对应的[指令的次一指令处\n打印Hello World!1",
    "crumbs": [
      "解释器",
      "brainFuck"
    ]
  },
  {
    "objectID": "docs/hands-on/compiler/index.html#footnotes",
    "href": "docs/hands-on/compiler/index.html#footnotes",
    "title": "rust实战编译器",
    "section": "Footnotes",
    "text": "Footnotes\n\n\n图形化查看代码执行过程↩︎",
    "crumbs": [
      "解释器",
      "brainFuck"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": ":   ",
    "section": "",
    "text": ":   \n\n\n\n\n\n\n最后的最后就再折腾2个\n\n\n\n\n doing\n todo\n\n\n\n\n\n\n\n Back to top"
  }
]
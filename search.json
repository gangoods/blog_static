[
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "References\n\n\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "docs/quarto/basic.html",
    "href": "docs/quarto/basic.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "git clone --depth=1 https://github.com/quarto-dev/quarto-web.git\ncd quarto-web\n# 查看官方文档的本地离线版本\nquarto preview\n# 我们指定端口, 然后不要自动打开浏览器,\n# 有时候 你需要重新执行时,就不会打开浏览器了\nquarto preview --port 4858 --no-browser\n# 使用这个 生成静态文件, 然后直接打开那个 index.html 也可以\nquarto render",
    "crumbs": [
      "快速入门"
    ]
  },
  {
    "objectID": "docs/quarto/basic.html#安装quarto1",
    "href": "docs/quarto/basic.html#安装quarto1",
    "title": "斯巴拉稀",
    "section": "",
    "text": "git clone --depth=1 https://github.com/quarto-dev/quarto-web.git\ncd quarto-web\n# 查看官方文档的本地离线版本\nquarto preview\n# 我们指定端口, 然后不要自动打开浏览器,\n# 有时候 你需要重新执行时,就不会打开浏览器了\nquarto preview --port 4858 --no-browser\n# 使用这个 生成静态文件, 然后直接打开那个 index.html 也可以\nquarto render",
    "crumbs": [
      "快速入门"
    ]
  },
  {
    "objectID": "docs/quarto/basic.html#website-book",
    "href": "docs/quarto/basic.html#website-book",
    "title": "斯巴拉稀",
    "section": "2 website book",
    "text": "2 website book\nvscode command+shift+p create project -&gt; website 或者book\n或者使用命令来创建\nquarto create project\nquarto create project &lt;type&gt; &lt;name&gt;\n# 安装主题\n# 可直接使用Footnotes提到的25个主题,不需要安装\n# quarto add schochastics/quarto-sketchy-html\n_quarto.yml 修改主题\nformat:\n# 发布的时候, 会生成的格式类型,如果只要html, 其他可以删除\n  html:\n    theme: sketchy # 修改主题为我们前面添加的\n  # 输出多种格式\n  pdf:\n    documentclass: scrreport\n  epub:\n    cover-image: cover.png",
    "crumbs": [
      "快速入门"
    ]
  },
  {
    "objectID": "docs/quarto/basic.html#静态目录配置",
    "href": "docs/quarto/basic.html#静态目录配置",
    "title": "斯巴拉稀",
    "section": "3 静态目录配置",
    "text": "3 静态目录配置\n_quarto.yml\nproject:\n  type: website\n  # output-dir: _site\n  # 设置 resources, quarto render时,会将下列设置的目录 复制到 _site目录下\n  # 这样 当你访问url /stylesheets/custom.scss 时, 就可以访问到该文件\n  resources:\n    - \"/stylesheets\"\n    - \"/.diagram\"\n我们可以统一将图片放到这里,然后 markdown中 这样插入图片\n![](/.diagram/xxx.png)",
    "crumbs": [
      "快速入门"
    ]
  },
  {
    "objectID": "docs/quarto/basic.html#siderbar",
    "href": "docs/quarto/basic.html#siderbar",
    "title": "斯巴拉稀",
    "section": "4 siderbar",
    "text": "4 siderbar",
    "crumbs": [
      "快速入门"
    ]
  },
  {
    "objectID": "docs/quarto/basic.html#发布部署",
    "href": "docs/quarto/basic.html#发布部署",
    "title": "斯巴拉稀",
    "section": "5 发布部署",
    "text": "5 发布部署\n# 预览, 开发阶段 这样看\nquarto preview\n# 生成\nquarto render   # render all formats\nquarto render --to pdf  # render PDF format only\n_book/\n    index.html # and other book files\n    rust.pdf\n    rust.epub",
    "crumbs": [
      "快速入门"
    ]
  },
  {
    "objectID": "docs/quarto/basic.html#页面format设置",
    "href": "docs/quarto/basic.html#页面format设置",
    "title": "斯巴拉稀",
    "section": "6 页面format设置",
    "text": "6 页面format设置\n我们在某个页面这样设置, 然后 quarto preview 执行后,打开的网页里, 你点击该页面会看到实际打开的是一个pdf了, 不是web 页面了\n---\ntitle: \"Hello Typst!\"\nformat:\n  typst:\n    toc: true\n    section-numbering: 1.1.a\n    columns: 2\n---",
    "crumbs": [
      "快速入门"
    ]
  },
  {
    "objectID": "docs/quarto/basic.html#配置评论",
    "href": "docs/quarto/basic.html#配置评论",
    "title": "斯巴拉稀",
    "section": "7 配置评论",
    "text": "7 配置评论\n\ngiscus\n文档\n\n默认已经全局设置, 想要单个取消显示评论\n---\ncomments: false\n---",
    "crumbs": [
      "快速入门"
    ]
  },
  {
    "objectID": "docs/quarto/basic.html#footnotes",
    "href": "docs/quarto/basic.html#footnotes",
    "title": "斯巴拉稀",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nquarto官网awesome-quarto可以选择看看效果quarto bootstrap 主题githubrough-notation这个主题quarto-sketchy-html和原生带的sketchy 是有点不一样的.(支持高亮文字), 我们直接用原生的就行了↩︎",
    "crumbs": [
      "快速入门"
    ]
  },
  {
    "objectID": "docs/quarto/markdown.html",
    "href": "docs/quarto/markdown.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "可以查看该颜色相近的一些颜色\n\n@startuml\ncolors chocolate\n@enduml",
    "crumbs": [
      "markdown"
    ]
  },
  {
    "objectID": "docs/quarto/markdown.html#color",
    "href": "docs/quarto/markdown.html#color",
    "title": "斯巴拉稀",
    "section": "",
    "text": "可以查看该颜色相近的一些颜色\n\n@startuml\ncolors chocolate\n@enduml",
    "crumbs": [
      "markdown"
    ]
  },
  {
    "objectID": "docs/quarto/markdown.html#html",
    "href": "docs/quarto/markdown.html#html",
    "title": "斯巴拉稀",
    "section": "2 html",
    "text": "2 html\n直接写原生的html代码来渲染,参考sketchy\n\n  \n    Cras justo odio\n    14\n  \n  \n    Dapibus ac facilisis in\n    2\n  \n  \n    Morbi leo risus\n    1\n  \n    Cras justo odio\n    5\n  \n  \n    Dapibus ac facilisis in\n    4\n  \n  \n    Morbi leo risus\n    9\n  \n  \n    Morbi leo risus\n    8\n  \n  \n    Morbi leo risus\n    0",
    "crumbs": [
      "markdown"
    ]
  },
  {
    "objectID": "docs/quarto/markdown.html#table",
    "href": "docs/quarto/markdown.html#table",
    "title": "斯巴拉稀",
    "section": "3 table",
    "text": "3 table\n\nPlatform Command\n\n\n\n\n\n\nPlatform\nCommand\n\n\n\n\nMac/Linux\nconda activate ./env\n\n\nWindows\nconda activate .\\env\n\n\n\n控制 颜色,在table代码下方写上\n: Platform Command {.striped .hover tbl-colwidths=\"[35,75]\"}",
    "crumbs": [
      "markdown"
    ]
  },
  {
    "objectID": "docs/quarto/markdown.html#code",
    "href": "docs/quarto/markdown.html#code",
    "title": "斯巴拉稀",
    "section": "4 code",
    "text": "4 code\n\n4.1 line-numbers\n{.bash code-line-numbers=\"false\"} 全局已经设置显示行号, 这里可以临时禁止\nls -l\n\n\n4.2 filename\n\n\nmain.py\n\nprint(1)\n\n\n\n4.3 code annotation\n---\n1code-annotations: hover\n---\n\n1\n\n还可以设置成 below,会在下方直接显示, select 则需要点击\n\n\nlibrary(tidyverse)\nlibrary(palmerpenguins)\n1penguins |&gt;\n2  mutate(\n    bill_ratio = bill_depth_mm / bill_length_mm,\n    bill_area  = bill_depth_mm * bill_length_mm\n  )\n\n1\n\nTake penguins, and then,\n\n2\n\nadd new columns for the bill ratio and bill area.\n\n\n\n\n4.4 include code file\nfn main() {\n    let mut x = 5;\n    println!(\"{x}\");\n}",
    "crumbs": [
      "markdown"
    ]
  },
  {
    "objectID": "docs/quarto/markdown.html#highlight",
    "href": "docs/quarto/markdown.html#highlight",
    "title": "斯巴拉稀",
    "section": "5 highlight",
    "text": "5 highlight\nThis is some text\nhello world\nhello world\nhello world",
    "crumbs": [
      "markdown"
    ]
  },
  {
    "objectID": "docs/quarto/markdown.html#card",
    "href": "docs/quarto/markdown.html#card",
    "title": "斯巴拉稀",
    "section": "6 card",
    "text": "6 card\n生成后是 .class_name的div结构 ,去看 sketchy 里的元素源码来搞\n\n\nHere is a warning.\n\n\nabc",
    "crumbs": [
      "markdown"
    ]
  },
  {
    "objectID": "docs/quarto/markdown.html#icon",
    "href": "docs/quarto/markdown.html#icon",
    "title": "斯巴拉稀",
    "section": "7 icon",
    "text": "7 icon\nhttps://icons.getbootstrap.com/ ## panel-tabset\n::: {.panel-tabset}\n## Python\nabc\n\n## rust\nefg\n:::\n\ncode结果\n\n\n::: {.panel-tabset}\n## Python\nabc\n\n## rust\nefg\n:::\n\n\n\nPythonrust\n\n\nabc\n\n\nefg",
    "crumbs": [
      "markdown"
    ]
  },
  {
    "objectID": "docs/quarto/markdown.html#callout",
    "href": "docs/quarto/markdown.html#callout",
    "title": "斯巴拉稀",
    "section": "8 callout",
    "text": "8 callout\n\n\n\n\n\n\nnote with Title\n\n\n\nNote that there are five types of callouts, including: note, warning, important, tip, and caution.\n\n\n\n\n\n\n\n\nTip with Title\n\n\n\nThis is an example of a callout with a title.\n\n\n\n\n\n\n\n\nExpand To Learn About Collapse\n\n\n\n\n\nThis is an example of a ‘folded’ caution callout that can be expanded by the user. You can use collapse=\"true\" to collapse it by default or collapse=\"false\" to make a collapsible callout that is expanded by default.\n\n\n\n\n\n\n\n\n\nPowerShell Note\n\n\n\nSome quick example text to build on the card title and make up the bulk of the card’s content.",
    "crumbs": [
      "markdown"
    ]
  },
  {
    "objectID": "docs/quarto/markdown.html#citation-footnote-and-cross-reference",
    "href": "docs/quarto/markdown.html#citation-footnote-and-cross-reference",
    "title": "斯巴拉稀",
    "section": "9 citation, footnote and cross-reference",
    "text": "9 citation, footnote and cross-reference\n鼠标移动到 Xie (2015) 上面 knitr1. Listing 1 shows you how to disable hover behaviour.\n\n\n\nListing 1\n\n\nformat:\n  html:\n    citations-hover: false\n    footnotes-hover: false\n    crossrefs-hover: false\n\n\n\n添加class 让这个隐藏了, 这样只有我们hover 才会显示, 暂时还有问题,这个移动移出有2种显示..\n\n\nreferences.bib 添加如下\n\n@Book{xie2015,\n  title = {Dynamic Documents with {R} and knitr},\n  author = {Yihui Xie},\n  publisher = {Chapman and Hall/CRC},\n  address = {Boca Raton, Florida},\n  year = {2015},\n  edition = {2nd},\n  note = {ISBN 978-1498716963},\n  url = {https://yihui.name/knitr/},\n}\n\n\n\n_quarto.yml 添加如下设置\n\nbibliography: references.bib\n\nHere is an inline note.2 longnote3",
    "crumbs": [
      "markdown"
    ]
  },
  {
    "objectID": "docs/quarto/markdown.html#extension",
    "href": "docs/quarto/markdown.html#extension",
    "title": "斯巴拉稀",
    "section": "10 extension",
    "text": "10 extension\n\n10.1 quarto-rust\n将代码块 中使用的 rust改成 playground-rust, 用{} 包起来\n\n\n10.2 kroki\nquarto install extension pandoc-ext/diagram\nquarto add data-intuitive/quarto-d2\ndiagram d2\n上面2个扩展可以抛弃了, 使用下面这个就足够了.\n这个插件有问题, 需要自己修改, 我已经修复bug, 并且增加了会下载生成的svg到本地\nquarto add GabrielCoffee9/quarto-kroki\n_quarto.yml 配置自己的kroki 服务器\nkroki:\n  serviceUrl: \"http://192.168.1.103:8000\"\n在页面文件里头部写上, 使用kroki过滤, 到时候就会执行 _extension/xxxx/kroki.lua\n---\nfilters:\n- kroki\n---\n\n10.2.1 plantuml等\n```{kroki-plantuml}\n@startuml\nBob -&gt; Alice : hello\n@enduml\n```\n\n\n\n\n10.2.2 excalidraw\n\n\n\n\n\n\nTip\n\n\n\n\n以导入文件的方式来, 其他diagram 也可以\n使用这种方式,如果你修改了 diagram文件,是不会重新生成图片的,你可以代码块里 加一行空格,保存\n\n\n\n\n\n\n10.2.3 d24\n生成的svg 太大了,可以使用svgo进行压缩,我已经修改了_extension扩展下相关文件,增加了压缩svg的代码\nnpm install -g svgo\nsvgo one.svg two.svg -o one.min.svg two.min.svg\n我发现 不要用302主题, 会变小多了, 然后 sketch: true 不要用,再变小\nd2 themes # 查看可用的主题\nclasses: {\n  empty: {\n    label: \"\"\n    style: {\n      fill: transparent\n      stroke-width: 0\n    }\n  }\n  text: {\n    style: {\n      fill: transparent\n      stroke-width: 0\n    }\n  }\n  cluster: {\n    style: {\n      fill: transparent\n      stroke-dash: 4\n      stroke: \"#C6D3DF\"\n    }\n  }\n  grid: {\n    grid-columns: 1\n    label: \"\"\n    style: {\n      fill: white\n      stroke-width: 0\n    }\n  }\n  row: {\n    grid-rows: 1\n    label: \"\"\n    style: {\n      fill: transparent\n      stroke-width: 0\n    }\n  }\n}\n\nvars: {\n  left-cluster: {\n    label: \"n-sized Vector\"\n    class: cluster\n    0*.style.fill: \"#DFEFFA\"\n    0*.style.stroke: black\n    grid-rows: 1\n    grid-gap: 0\n    label.near: outside-top-left\n\n    \"0.62\"\n    \"0.15\"\n    empty1.class: empty\n    n.class: text\n    empty2.class: empty\n    \"0.91\"\n    \"0.48\"\n\n    \"0.15\" &lt;- n -&gt; \"0.91\"\n  }\n  right-cluster: {\n    label: \"m-sized Vector\"\n    class: cluster\n    0*.style.fill: \"#72F5FF\"\n    0*.style.stroke: black\n    grid-rows: 1\n    grid-gap: 0\n    label.near: outside-top-left\n\n    \"0.62\"\n    \"0.15\"\n    empyt1.class: empty\n    m.class: text\n    empty2.class: empty\n    \"0.91\"\n    \"0.48\"\n\n    \"0.15\" &lt;- m -&gt; \"0.91\"\n  }\n}\n\ngrid-rows: 2\n\ntop-row: {\n  class: row\n  empty.class: empty\n  empty.width: 1100\n\n  Random Matrix Generator: {\n    width: 300\n    height: 170\n    style.font-size: 20\n    style.fill: \"#A7BBCF\"\n    style.stroke: black\n    style.border-radius: 10\n  }\n}\n\nbottom-row: {\n  class: row\n  left-grid: {\n    class: grid\n\n    1: ${left-cluster}\n    2: ${left-cluster}\n    3: ${left-cluster}\n  }\n\n  dot-container: {\n    class: empty\n    grid-columns: 1\n    empty1.class: empty\n    dot: Dot product {\n      class: text\n      circle: \"\" {\n        shape: circle\n        style.fill: black\n        style.stroke-width: 0\n        width: 20\n        height: 20\n      }\n      label.near: outside-bottom-center\n    }\n  }\n\n  matrix-container: {\n    class: empty\n    grid-columns: 1\n    matrix: Target dimension matrix {\n      label.near: outside-top-center\n      grid-rows: 4\n      grid-gap: 0\n      *.width: 100\n      *.height: 100\n      *.style.fill: \"#F1F6F9\"\n      *.style.stroke: black\n      \"0.41\"\n      \"0.32\"\n      \"0.92\"\n      \"0.13\"\n\n      \"0.74\"\n      \"0.15\"\n      \"0.53\"\n      \"0.21\"\n\n      \"0.97\"\n      \"0.45\"\n      \"0.11\"\n      \"0.05\"\n\n      \"0.61\"\n      \"0.77\"\n      \"0.59\"\n      \"0.83\"\n    }\n  }\n\n  empty.class: empty\n\n  right-grid: {\n    class: grid\n\n    1: ${right-cluster}\n    2: ${right-cluster}\n    3: ${right-cluster}\n  }\n\n  matrix-container -&gt; right-grid\n}\n\ntop-row.Random Matrix Generator -&gt; bottom-row.matrix-container.matrix",
    "crumbs": [
      "markdown"
    ]
  },
  {
    "objectID": "docs/quarto/markdown.html#footnotes",
    "href": "docs/quarto/markdown.html#footnotes",
    "title": "斯巴拉稀",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nmarkdown 文档↩︎\n直接写在这里.↩︎\nHere’s one with multiple blocks.\n\npython\n\nprintln(1)\n\nrust\n\n↩︎\nhttps://d2lang.com↩︎",
    "crumbs": [
      "markdown"
    ]
  },
  {
    "objectID": "docs/netprog/tcp.html",
    "href": "docs/netprog/tcp.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "Warning\n\n\n\n未完待续",
    "crumbs": [
      "tcp"
    ]
  },
  {
    "objectID": "docs/netprog/tcp.html#socket",
    "href": "docs/netprog/tcp.html#socket",
    "title": "斯巴拉稀",
    "section": "1 socket",
    "text": "1 socket\n\n与网络中的其他应用进行通信的函数接口\n封装了传输层的协议, tcp udp\n既然是与网络中的其他应用程序通信, 那么我们可以推断socket套接字肯定有ip(确定主机)和port(确定应用),用来明确是哪个应用",
    "crumbs": [
      "tcp"
    ]
  },
  {
    "objectID": "docs/netprog/tcp.html#代码",
    "href": "docs/netprog/tcp.html#代码",
    "title": "斯巴拉稀",
    "section": "2 代码",
    "text": "2 代码\n\n客户端服务端\n\n\n\n\nclient.c\n\n#include &lt;stdio.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;sys/types.h&gt;\n#include &lt;sys/stat.h&gt;\n#include &lt;string.h&gt;\n#include &lt;arpa/inet.h&gt;\n#include &lt;fcntl.h&gt;\n\n// tcp client\nint main(int argc, const char* argv[])\n{\n    // 创建套接字\n    int fd = socket(AF_INET, SOCK_STREAM, 0);\n    if(fd == -1)\n    {\n        perror(\"socket error\");\n        exit(1);\n    }\n\n    // 连接服务器\n    struct sockaddr_in serv_addr;\n    // 将serv_addr 结构体 所占内存内容置为0, 等价于 bzero(&serv_addr, sizeof(serv_addr));\n    memset(&serv_addr, 0, sizeof(serv_addr));\n    serv_addr.sin_family = AF_INET;\n    //网络传输数据采用的是大端 ,所以这里端口要转换为大端\n    // h: host, to:to, n: net, s:short int (unsigned)\n    // 将主机字节序转为网络字节序(大端)\n    serv_addr.sin_port = htons(9999);\n    // 将ip转换为网络字节序, 是将字符串(ip) 转为int型(大端方式)\n    // 直接修改 &serv_addr.sin_addr.s_addr\n    // inet_pton转换成功则返回1,转换失败返回 0,如果指定的地址类型协议簇不合法,将返回-1\n    inet_pton(AF_INET, \"127.0.0.1\", &serv_addr.sin_addr.s_addr);\n    int ret = connect(fd, (struct sockaddr*)&serv_addr, sizeof(serv_addr));\n    if(ret == -1)\n    {\n        perror(\"connect error\");\n        exit(1);\n    }\n\n    // 通信\n    while(1)\n    {\n        // 写数据\n        // 接收键盘输入\n        char buf[512];\n        printf(\"input: \\n\");\n        fgets(buf, sizeof(buf), stdin);\n        // 这里如果输入的小于512 会就最后的回车符号也发送过去.(详情见fgets的说明)\n        // 你可以自己将最后的回车符处理掉...\n        // 发送给服务器, +1 是把最后的\\0 也发送过去.\n        write(fd, buf, strlen(buf)+1);\n\n        // 接收服务器端的数据\n        int len = read(fd, buf, sizeof(buf));\n        if(len == -1)\n        {\n            perror(\"read error\");\n            break;\n        }\n        else if( len == 0 )\n        {\n            printf(\"服务端关闭了连接 ...\\n\");\n            break;\n        } else if(len &gt; 0)\n        {\n            printf(\"read buf = %s, len = %d\\n\", buf, len);\n        }\n    }\n    close(fd);\n    return 0;\n}\n\n\n\n\n\nserver.c\n\n#include &lt;stdio.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;sys/types.h&gt;\n#include &lt;sys/stat.h&gt;\n#include &lt;string.h&gt;\n#include &lt;sys/socket.h&gt;\n#include &lt;arpa/inet.h&gt;\n#include &lt;ctype.h&gt;\n\n\nint main(int argc, const char* argv[])\n{\n    // 创建用于监听的套节字\n    int listen_fd = socket(AF_INET, SOCK_STREAM, 0);\n    if(listen_fd == -1)\n    {\n        perror(\"socket error\");\n        exit(1);\n    }\n\n    struct sockaddr_in serv_addr;\n    memset(&serv_addr, 0, sizeof(serv_addr));\n    serv_addr.sin_family = AF_INET;     // 地址族协议ipv4\n    serv_addr.sin_port = htons(9999);   // 本地端口需要转换为大端\n    // ip转为网络字节序(大端)\n    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);  // 0表示用本机的任意IP\n\n    int ret = bind(listen_fd, (struct sockaddr*)&serv_addr, sizeof(serv_addr));\n    if(ret == -1)\n    {\n        perror(\"bind error\");\n        exit(1);\n    }\n\n    // 设置监听\n    ret = listen(listen_fd, 64);\n    if(ret == -1)\n    {\n        perror(\"listen error\");\n        exit(1);\n    }\n\n    // 等待并接受连接请求\n    struct sockaddr_in client_addr;\n    socklen_t client_len = sizeof(client_addr);\n    int client_fd = accept(listen_fd, (struct sockaddr*)&client_addr, &client_len);\n    if(client_fd == -1)\n    {\n        perror(\"accept error\");\n        exit(1);\n    }\n    char client_ip_buf[64];\n    // 网络字节序 转换为 主机字节序, 结果存储到client_ip_buf\n    // 返回值是个指向client_ip_buf 的指针\n    const char* client_ip=inet_ntop(AF_INET, &client_addr.sin_addr.s_addr, client_ip_buf, sizeof(client_ip_buf));\n    printf(\"client ip: %s, port: %d\\n\", client_ip, ntohs(client_addr.sin_port));\n\n    // 通信\n    while(1)\n    {\n        // 先接收数据\n        char buf[1024] = {0};\n        int len = read(client_fd, buf, sizeof(buf));\n        if(len == -1)\n        {\n            perror(\"read error\");\n            break;\n        }\n        else if(len &gt; 0)\n        {\n            // 顺利读出了数据\n            printf(\"read buf = %s\\n\", buf);\n            for(int i=0; i&lt;len; ++i)\n            {\n                buf[i] = toupper(buf[i]);\n            }\n            printf(\" toupper: %s\\n\", buf);\n\n            // 数据发送给客户端\n            write(client_fd, buf, strlen(buf)+1);\n        }\n        else if( len == 0 )\n        {\n            printf(\"client disconnect ...\\n\");\n            break;\n        }\n    }\n\n    close(listen_fd);\n    close(client_fd);\n\n    return 0;\n}\n\n\n\n\ngcc client.c -o client\ngcc server.c -o server\n./server\n./client",
    "crumbs": [
      "tcp"
    ]
  },
  {
    "objectID": "docs/netprog/tcp.html#tcp-报文",
    "href": "docs/netprog/tcp.html#tcp-报文",
    "title": "斯巴拉稀",
    "section": "3 tcp 报文",
    "text": "3 tcp 报文",
    "crumbs": [
      "tcp"
    ]
  },
  {
    "objectID": "docs/netprog/tcp.html#握手-传输-挥手",
    "href": "docs/netprog/tcp.html#握手-传输-挥手",
    "title": "斯巴拉稀",
    "section": "4 握手-传输-挥手",
    "text": "4 握手-传输-挥手",
    "crumbs": [
      "tcp"
    ]
  },
  {
    "objectID": "docs/netprog/tcp.html#滑动窗口",
    "href": "docs/netprog/tcp.html#滑动窗口",
    "title": "斯巴拉稀",
    "section": "5 滑动窗口",
    "text": "5 滑动窗口",
    "crumbs": [
      "tcp"
    ]
  },
  {
    "objectID": "docs/netprog/tcp.html#修改缓冲区大小",
    "href": "docs/netprog/tcp.html#修改缓冲区大小",
    "title": "斯巴拉稀",
    "section": "6 修改缓冲区大小",
    "text": "6 修改缓冲区大小\n\n6.1 系统tcp缓冲设置\n\n\n查看配置\n\ncat /proc/sys/net/ipv4/tcp_rmem\n4096    87380   5369920\n# 4096 是说接收缓冲区(读缓冲区)的最小值\n# 87380 表示默认值 该值会覆盖rmem_default, 不是被覆盖, 网络上很多说被覆盖.. 真的服了\n# 5369920 接收缓冲区空间的最大字节数(该值会被rmem_max覆盖)\ncat /proc/sys/net/core/rmem_max  #一个socket的读缓冲区可由程序设置的最大值\n212992\ncat /proc/sys/net/core/rmem_default #一个socket的被创建出来时，默认的读缓冲区大小\n212992\n\n\n\n临时修改配置,重启后失效\n\nsysctl -w net.ipv4.tcp_wmem=\"1 1 1\"\nsysctl -w net.core.wmem_max=5000\n\n\n\n6.2 查看linux关于缓冲的源码\n\n\nlinux4.9源码 net/core/sock.h\n\n#define TCP_SKB_MIN_TRUESIZE    (2048 + SKB_DATA_ALIGN(sizeof(struct sk_buff)))\n\n#define SOCK_MIN_SNDBUF     (TCP_SKB_MIN_TRUESIZE * 2)\n#define SOCK_MIN_RCVBUF      TCP_SKB_MIN_TRUESIZE\n\n\n\nlinux4.9源码 net/core/sock.c\n\nswitch (optname) {\n    case SO_SNDBUF:\n        // 如果 val&gt; /proc/sys/net/core/wmem_max ,则设置成wmem_max 的值\n        val = min_t(u32, val, sysctl_wmem_max);\nset_sndbuf:\n        sk-&gt;sk_userlocks |= SOCK_SNDBUF_LOCK;\n        // 如果 val值的 2倍 还小于最小值, 那么 使用 最小值,否而就是 val值的2倍\n        sk-&gt;sk_sndbuf = max_t(int, val * 2, SOCK_MIN_SNDBUF);\n        sk-&gt;sk_write_space(sk);\n        break;\n    case SO_RCVBUF:\n        val = min_t(u32, val, sysctl_rmem_max);\nset_rcvbuf:\n        sk-&gt;sk_userlocks |= SOCK_RCVBUF_LOCK;\n        sk-&gt;sk_rcvbuf = max_t(int, val * 2, SOCK_MIN_RCVBUF);\n        break;\n}\n\n\n\n\n\n\n\n得出结论\n\n\n\n\n如果你设置的值 &gt; 最大值,则 设置为 最大值的2倍\n如果你设置的值的2倍 &lt; 最小值,则 设置为 最小值\n其他情况 ,则设置为 该值的2倍\n\n\n\n\n\n6.3 代码修改缓冲\n\n\nserver.c\n\n#include &lt;stdio.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;sys/types.h&gt;\n#include &lt;sys/stat.h&gt;\n#include &lt;string.h&gt;\n#include &lt;sys/socket.h&gt;\n#include &lt;arpa/inet.h&gt;\n#include &lt;ctype.h&gt;\n#include &lt;unistd.h&gt;\n\nvoid getsockopts(char* s ,int sockfd){\n    printf(\"===%s===\\n\",s);\n    int opt_val;\n    socklen_t opt_len=sizeof(opt_val);\n    if (getsockopt(sockfd,SOL_SOCKET, SO_SNDBUF, &opt_val, &opt_len)!=0){\n        perror(\"getsocketopt error\");\n        exit(1);\n    }\n    printf(\"写缓冲区大小: %d\\n\", opt_val);\n    opt_val=0;\n    if (getsockopt(sockfd,SOL_SOCKET, SO_RCVBUF, &opt_val, &opt_len)!=0){\n        perror(\"getsocketopt error\");\n        exit(1);\n    }\n    printf(\"读缓冲区大小: %d\\n\", opt_val);\n    opt_val=0;\n    if (getsockopt(sockfd,SOL_SOCKET, SO_SNDLOWAT, &opt_val, &opt_len)!=0){\n        perror(\"getsocketopt error\");\n        exit(1);\n    }\n    printf(\"发送低潮限度大小: %d\\n\", opt_val);\n\n}\n\nvoid setsockopts(int sockfd,int nRecvBuf,int nSendBuf){\n    // 接收缓冲区\n    int ret=setsockopt(sockfd,SOL_SOCKET,SO_RCVBUF,(const char*)&nRecvBuf,sizeof(int));\n    if (ret !=0){\n        perror(\"setsocketopt error\");\n    }\n    //发送缓冲区\n    ret =setsockopt(sockfd,SOL_SOCKET,SO_SNDBUF,(const char*)&nSendBuf,sizeof(int));\n    if (ret !=0){\n        perror(\"setsocketopt error\");\n    }\n}\nint main(int argc, const char* argv[])\n{\n    // printf(\"argcount: %d\\n\",argc);\n    if (argc!=3){\n    printf(\"请输入要设置的读缓冲和写缓冲\\n\");\n    printf(\"usage: %s 读缓冲值 写缓冲值\\n\",argv[0]);\n    exit(1);\n    }\n    // 创建用于监听的套节字\n    int listen_fd = socket(AF_INET, SOCK_STREAM, 0);\n    if(listen_fd == -1)\n    {\n        perror(\"socket error\");\n        exit(1);\n    }\n    getsockopts(\"before set\",listen_fd);\n    // 这里不严谨,随便用用\n    setsockopts(listen_fd,atoi(argv[1]),atoi(argv[2]));\n    getsockopts(\"after set\",listen_fd);\n    struct sockaddr_in serv_addr;\n    memset(&serv_addr, 0, sizeof(serv_addr));\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(9999);\n    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);\n    int ret = bind(listen_fd, (struct sockaddr*)&serv_addr, sizeof(serv_addr));\n    if(ret == -1)\n    {\n        perror(\"bind error\");\n        exit(1);\n    }\n\n    // 设置监听\n    ret = listen(listen_fd, 64);\n    if(ret == -1)\n    {\n        perror(\"listen error\");\n        exit(1);\n    }\n\n    // 等待并接受连接请求\n    struct sockaddr_in client_addr;\n    socklen_t client_len = sizeof(client_addr);\n    int client_fd = accept(listen_fd, (struct sockaddr*)&client_addr, &client_len);\n    if(client_fd == -1)\n    {\n        perror(\"accept error\");\n        exit(1);\n    }\n    char client_ip_buf[64];\n    const char* client_ip=inet_ntop(AF_INET, &client_addr.sin_addr.s_addr, client_ip_buf, sizeof(client_ip_buf));\n    printf(\"client ip: %s, port: %d\\n\", client_ip, ntohs(client_addr.sin_port));\n\n    // 通信\n    while(1)\n    {\n        sleep(3);\n    }\n    close(listen_fd);\n    close(client_fd);\n    return 0;\n}\n\n./server2 212993 1\n    argcount: 3\n    ===before set===\n    写缓冲区大小: 16384\n    读缓冲区大小: 87380\n    发送低潮限度大小: 1\n    ===after set===\n    写缓冲区大小: 4608 # 最小值\n    读缓冲区大小: 425984 # 最大值的2倍\n    发送低潮限度大小: 1\n\n./server2 212991 1\n    ===before set===\n    写缓冲区大小: 16384\n    读缓冲区大小: 87380\n    发送低潮限度大小: 1\n    ===after set===\n    写缓冲区大小: 4608\n    读缓冲区大小: 425982 # 设置的值的2倍\n    发送低潮限度大小: 1",
    "crumbs": [
      "tcp"
    ]
  },
  {
    "objectID": "docs/netprog/tcp.html#阻塞",
    "href": "docs/netprog/tcp.html#阻塞",
    "title": "斯巴拉稀",
    "section": "7 阻塞",
    "text": "7 阻塞\n阻塞 ,阻塞, 啥是阻塞? 1. 假设快递, 在没有蜂巢的情况下, 快递员带着包裹来了, 你人不在, GG 2. 有蜂巢后, 包裹到了, 快递员发现蜂巢满了, GG",
    "crumbs": [
      "tcp"
    ]
  },
  {
    "objectID": "docs/netprog/https.html",
    "href": "docs/netprog/https.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "HTTP 是明文传输的协议,数据在传输过程中不加密, 容易被窃听篡改和劫持",
    "crumbs": [
      "https"
    ]
  },
  {
    "objectID": "docs/netprog/https.html#http的问题",
    "href": "docs/netprog/https.html#http的问题",
    "title": "斯巴拉稀",
    "section": "",
    "text": "HTTP 是明文传输的协议,数据在传输过程中不加密, 容易被窃听篡改和劫持",
    "crumbs": [
      "https"
    ]
  },
  {
    "objectID": "docs/netprog/https.html#解决方案",
    "href": "docs/netprog/https.html#解决方案",
    "title": "斯巴拉稀",
    "section": "2 解决方案",
    "text": "2 解决方案\n\n2.1 1. 对称加密\n\n\n\n\n\n\n什么是对称加密\n\n\n\n\n能使用同一个密钥用来加密和解密\n这也是普通人立马就可以想到的方式\n举个随便设计的算法:\n\n发送 hello world, 加密方法是 将字符加上在单词上的索引*密钥,这里密钥=1\n\nh 索引是1 -&gt; h+1*1=i\ne 索引是2 -&gt; e+2*1=g\nhello world =&gt; igopt xqupi\n\n知道密钥就可以解密了\n\n\n\n\n\n\n\n\n\n\n\n结论\n\n\n\n加密算法和密钥都可能被拦截, 不安全.\n\n\n\n\n\n2.2 2. 非对称加密\n\n\n\n\n\n\n非对称加密\n\n\n\n\n它使用了一对密钥，分别是公钥（Public Key）和私钥(Private Key)\n浏览器发送数据时用公钥对数据进行加密, 服务端使用配对的私钥对数据进行解密\n服务端返回数据给浏览器时用私钥进行加密, 浏览器用公钥进行解密\n加密解密都相对比较耗时\n\n\n\n\n\n\n\n\n\n如何解决对称加密中密钥传输安全问题?\n\n\n\n\n使用非对称加密算法, 私钥放在服务器,被拦截黑客也无法获取,公钥在浏览器\n浏览器使用公钥加密对称加密用的密钥, 服务器使用私钥解密得到真实这个密钥.\n是不是觉得多此一举了, 直接用非对称加密算法加密数据不就得了??\n\n非对称加密解密耗时, 每次数据传输都这样 ,伤不起\n密钥由服务器生成, 只生成一对, 如果来一个客户端就生成一对,还是耗时.\n所以只要浏览器访问它就会得到这个公钥, 黑客也能得到, 如果它拦截了服务器返回给客户端的数据,可以解密\n所以我们使用结合2个算法,保证一开始对称加密的密钥(盐)传输安全就行了,对对称加密的密钥用公钥加密,黑客截取数据,因为它只有公钥,是无法解密的\n这样服务端知道了 对称加密的密钥, 这之后就用对称加密算法对数据进行加密来传输\n\n\n\n\n\n\n\n\n\n\n\n思考?\n\n\n\n事情好像完美解决了,真的安全了吗?\n\n\n\n\n\n2.3 3. 中间人攻击\n\n\n\n\n\n\n前面的问题\n\n\n\n\n黑客可以在浏览器获取服务器发送的公钥的阶段拦截,那它可以伪造成服务器,作为一个中间人\n浏览器发送到了 中间人, 中间人自己生成一对公钥私钥, 它将自己的这个公钥返回给浏览器,自己再向真正的服务器发起请求\n浏览器得到一个假的公钥, 然后它发送的数据全部被中间人截获,可以解密…\n问题的关键是, 浏览器确保得到服务端真正下发的公钥\n\n\n\n\n\n\n\n\n\n如何解决呢?\n\n\n\n\n现实的一个例子\n\n假设我去一家某某明星开的店买东西, 我要先确认这家店是不是真的, 我们就去看营业执照\n一看盖章是真的. 这就行了吗? 一个人想开个店 ,他自己去申请营业执照, 那这个章也是真的啊, 光看章这样还不行!!!\n那我看看营业执照上写的法人是谁不就行了吗? 对!\n审批人员, 盖章的时候看身份证和脸写上法人,而不是让申请者随便写,然后在名字上盖章,这样没法篡改了.\n\n现在我们改进我们之前的设计(仅仅是自己的思考过程,与实际https不一样):\n\n服务端将 它的公钥 发送给 值得信赖第三方证书颁发机构CA,CA用自己的一对密钥中的私钥对服务端公钥进行加密\n服务端 把从CA那里获取的密文发送给浏览器, 浏览器用 CA的公钥进行解密.这里的关键就是操作系统安装后就有一些CA的公钥,所以浏览器无需通过网络获取CA公钥,要不然又重复之前的问题了.只要浏览器能用这个CA公钥解密, 就说明数据是通过CA加密的.\n那中间人将自己的公钥发送给CA,CA用私钥加密后发送给中间人,中间人再转发给浏览器,这个时候浏览器是可以解密的,就以为是ok的了! 不行!!\n那CA给你公钥加密的时候, 再带上发起请求的网站的域名不就ok了. 这样即使中间人请求CA,CA加密会带上中间人的域名, 浏览器解密后发现域名不是自己想要访问的网站. 中间人向CA申请证书时,会递交个人信息, CA会审核真实性, 所以不会让它随便写域名,无法冒充原来我们真正请求的那个服务器\n\n\n\n\n\n\n\n\n\n\n问题\n\n\n\n\n中间人把自己当成CA 做证书发给浏览器行吗?\n\n这样浏览器查看证书颁发机构, 它操作系统就没有,因为只有内置的那些可靠的, 所以没有对应的公钥来解密\n当然如果你的系统被黑客安装了它自己生成的证书, 那么浏览器就会找到对应的公钥来解密了,不过这是你的问题\n\n\n\n\n\n\n2.4 4. https 最终方案",
    "crumbs": [
      "https"
    ]
  },
  {
    "objectID": "docs/netprog/https.html#证书相关",
    "href": "docs/netprog/https.html#证书相关",
    "title": "斯巴拉稀",
    "section": "3 证书相关",
    "text": "3 证书相关\nRoot CA 会给二级 CA 颁发证书,\n一般用户网站的证书 由 二级CA颁发.\n操作系统默认就安装了很多Root CA\n\n\n\n\n\n\nTip\n\n\n\nX.509 是一种常用的数字证书格式标准,定义了证书的结构和内容\n\n\n\n3.1 openssl 相关操作\n\n# 私钥\n# 记得权限设置600最好\n# 非对称算法 使用rsa 生成\nopenssl genrsa -out server.key 2048\n# 表示会对生成的key 进行一次对称加密, 会提示你输入密码\n# 不过不推荐, 需要你输入密码解密.麻烦\nopenssl genrsa -out server-des.key -des 2048\n# 从私钥提取公钥 ,这里要对应的算法, rsa\nopenssl rsa -in server.key -pubout -out server.pub\n# 会提示你输入密码,才能提取公钥\nopenssl rsa -in server-des.key -pubout -out server-des.pub\n# 将加密过的私钥 转换为 不加密的\nopenssl rsa -in server-des.key -out server-des-remove.key\n\necho 123 &gt; tmp.txt\n# 使用公钥加密\nopenssl rsautl -encrypt -in  tmp.txt -inkey server.pub -pubin -out tmp.txt.encry\n\n# 使用私钥解密\n# 输出到文件\nopenssl rsautl -decrypt -in  tmp.txt.encry -inkey server.key  -out tmp.txt.dencry\n# 直接输出解密后的内容\nopenssl rsautl -decrypt -in  tmp.txt.encry -inkey server.key\n\n# 使用私钥加密(签名)\nopenssl rsautl -sign -in  tmp.txt -inkey server.key  -out tmp.txt.sign\n# 使用公钥解密(验签)\nopenssl rsautl -verify -in  tmp.txt.sign -inkey server.pub -pubin\n\n\n3.2 模拟CA颁发证书\n\n\n\n\n\n\nImportant\n\n\n\n注意这里是我们模拟CA机构, 所以步骤很多, 如果只是简单的为我们服务器生成一个证书, 不需要这样,见快速自签名证书\n\n\n\n3.2.1 配置CA\nopenssl ca # 会看到配置文件\n\n\n/etc/pki/tls/openssl.cnf\n\n[ ca ]\ndefault_ca      = CA_default    #默认CA的设置是哪个,  下面那个配置就是了.\n\n####################################################################\n[ CA_default ]\n\ndir             = /etc/pki/CA           # \ncerts           = $dir/certs            # 发布的证书放这个目录\ncrl_dir         = $dir/crl              # 证书吊销列表存放目录\ndatabase        = $dir/index.txt        # 颁发给谁等等信息数据的索引\n#unique_subject = no                    # 默认是yes ,表示 证书申请者主体 唯一, 不能用同一个csr申请多个证书\nnew_certs_dir   = $dir/newcerts         # 新颁发的证书存放目录,当然上面的certs 也会有新颁发的证书存放\ncertificate     = $dir/cacert.pem       # CA的证书 (我们自己测试就一个Root CA就行)\nserial          = $dir/serial           # 每个证书都有编号, 这里是下一个要颁发的证书的编号\ncrlnumber       = $dir/crlnumber        # 吊销的编号,同上\ncrl             = $dir/crl.pem          # 包含之前所有吊销证书的列表\nprivate_key     = $dir/private/cakey.pem# CA的私钥\nRANDFILE        = $dir/private/.rand    # private random number file\nx509_extensions = usr_cert              # The extentions to add to the cert\nname_opt        = ca_default            # Subject Name options\ncert_opt        = ca_default            # Certificate field options\n\ndefault_days    = 365                   # 证书默认有效期 天 ,可以改成3650\ndefault_crl_days= 30                    # how long before next CRL\ndefault_md      = sha256                # use SHA-256 by default\npreserve        = no                    # keep passed DN ordering\npolicy          = policy_match #匹配下面的 表示使用这个安全策略\n[ policy_match ] # 你在生成证书的时候会提示你输入这些信息\n# match 表示将来你用户网站申请证书时填写东西必须与CA的一致\n# 也就是说你网站申请时 国家 部门,公司必须和CA的一致\n# 我们自己 内部用, 可以用这个策略来\ncountryName             = match\nstateOrProvinceName     = match # 州名或省份名称，可以是中文或英文\norganizationName        = match   # 公司名称，可以是中文或英文\norganizationalUnitName  = optional # 部门名称，可以是中文或英文\ncommonName              = supplied #必须输入 申请 SSL 证书的具体网站域名\nemailAddress            = optional # optional 可写可不写\n\n[ policy_anything ] # 你可以选择这个策略\ncountryName             = optional\nstateOrProvinceName     = optional\nlocalityName            = optional\norganizationName        = optional\norganizationalUnitName  = optional\ncommonName              = supplied\nemailAddress            = optional\n\n\n\n3.2.2 CA生成根证书\n# 模拟CA,本地自定义CA,我们假设在一台服务器上 是专门弄CA的\n/etc/pki/CA\n├── certs\n├── crl\n├── newcerts\n└── private\ncd /etc/pki/CA\ntouch index.txt\n# 16进制\necho 01 &gt; serial\n# 生成CA的私钥\nopenssl genrsa -out ./private/cakey.pem 2048\n# 生成CA自签名证书 cacert.pem\n    # x509表示输出这种格式的证书\nopenssl req -x509 -new -key ./private/cakey.pem  \\\n    -days 5000 \\\n    -out cacert.pem\n    # 直接指定\nopenssl req -x509 -new -key ./private/cakey.pem \\\n    -subj \"/CN=example1.com/C=CN/O=taobao/ST=BJ\" \\\n    -days 5000 \\\n    -out cacert.pem\n\n# 验签, 用颁发证书的 x 去验证 被签发的 y\nopenssl verify -CAfile cacert.pem cacert.pem\n# 查看证书内容, 如果直接用base64 -d 解码会看到一些乱码.\n#  也可以将这个文件 打开 (在mac或windows上 会用默认的程序打开,可以看到相关信息)\nopenssl x509 -in cacert.pem -noout -text\n\n因为我们的配置文件里有 x509_extensions = v3_ca The extentions to add to the self signed cert\n\n\n所以这些相应的会在自签名证书里添加\n\n[ v3_ca ]\nsubjectKeyIdentifier=hash\nauthorityKeyIdentifier=keyid:always,issuer\nbasicConstraints = CA:true\n\nCertificate:\nData:\n    Version: 3 (0x2)\n    Serial Number:\n        ee:e1:85:de:8f:2a:00:76\nSignature Algorithm: sha256WithRSAEncryption\n    # 证书颁发者\n    Issuer: C=XX, L=Default City, O=Default Company Ltd, CN=example1.com\n    Validity\n        Not Before: Aug  1 16:51:52 2023 GMT\n        Not After : Apr  9 16:51:52 2037 GMT\n    # 证书申请者, 颁发给谁 ,这里和 颁发者一样, 自签名\n    Subject: C=XX, L=Default City, O=Default Company Ltd, CN=example1.com\n    Subject Public Key Info:\n        Public Key Algorithm: rsaEncryption\n            Public-Key: (2048 bit)\n            Modulus:\n                00:98:ad:ff:cc:a1:2d:2c:24:30:d4:87:14:02:06:\n                0f:50:60:ec:b2:0c:19:09:7c:96:74:82:46:c0:a3:\n                bc:86:77:7e:b2:fb:9e:a1:4f:fd:2b:3a:02:20:2b:\n                a1:94:d4:49:62:ce:36:1f:80:a8:71:fb:1e:3f:e3:\n                90:d3:78:f7:74:86:4f:3b:8c:85:d1:ae:4f:26:23:\n                15:29:f0:ed:0f:ee:a7:08:f5:3c:70:f2:b5:1c:f1:\n                71:e1:73:79:85:9d:11:64:2f:84:29:93:5b:df:d7:\n                a2:32:19:fe:c4:72:70:a9:d1:b3:54:22:6e:77:27:\n                2d:43:ec:5c:06:6a:7b:65:07:a9:ba:9a:35:db:2a:\n                7c:6f:f5:d6:27:59:15:d5:40:d3:94:dc:4c:7d:25:\n                8e:a3:3d:23:d1:5b:4e:6a:35:cf:ee:b4:0f:59:ec:\n                65:bb:b6:75:21:c5:6d:dd:a6:87:a7:15:af:bb:e1:\n                a5:75:6c:6c:36:da:60:13:41:f3:a8:11:b1:3f:8f:\n                bd:d4:03:c7:e0:f5:2f:68:76:7f:d0:67:45:eb:48:\n                8a:ad:70:34:3f:6b:fa:fc:bb:83:4f:e8:a0:3c:5c:\n                77:b5:c6:10:e0:b3:a8:fc:66:8c:56:e8:9d:64:6e:\n                8c:fe:42:65:02:c5:1d:81:66:e4:60:f2:5b:6d:e1:\n                cc:cb\n            Exponent: 65537 (0x10001)\n    X509v3 extensions:\n        X509v3 Subject Key Identifier:\n            3C:CE:32:F7:55:76:EB:E7:4D:CF:10:26:F0:35:D2:24:3B:89:6B:94\n        X509v3 Authority Key Identifier:\n            keyid:3C:CE:32:F7:55:76:EB:E7:4D:CF:10:26:F0:35:D2:24:3B:89:6B:94\n\n        X509v3 Basic Constraints:\n            CA:TRUE\nSignature Algorithm: sha256WithRSAEncryption\n        49:b0:f1:1b:58:06:be:02:e7:8a:7e:f0:59:d1:96:22:9f:62:\n        ba:e0:a3:09:5c:56:b3:2b:8c:a4:9d:6b:4f:dc:ea:af:39:b1:\n        05:01:78:ed:7d:c6:84:59:3b:a6:d4:c4:5f:ae:d9:d3:82:80:\n        be:41:e0:c5:ae:ff:40:89:c5:2a:bd:f3:5b:20:c6:c5:59:6d:\n        32:3c:19:b2:9b:4d:7f:c3:ef:a1:ab:51:6e:19:b7:88:45:91:\n        ef:ab:e7:c9:bd:c0:ca:c0:fa:48:58:cf:a0:e3:d2:bb:41:e8:\n        60:da:6b:0b:1f:91:fa:cb:08:9c:4f:4e:05:3b:80:2a:ad:63:\n        b1:75:c1:57:1a:08:27:a2:d6:06:52:00:d4:d2:41:3a:ad:27:\n        11:67:ba:de:85:57:24:d5:cf:77:d7:b7:a7:8a:9e:c2:29:e4:\n        41:ce:4a:37:8f:db:14:50:32:60:80:9a:92:f1:76:7e:73:80:\n        37:cc:6c:fb:ca:82:02:8b:8f:62:5c:91:b1:0a:ad:72:57:e0:\n        6d:a1:12:0b:c7:86:ef:9f:47:35:52:96:65:e0:cf:b2:65:d5:\n        45:a1:8f:db:12:2a:e8:ae:c6:f3:08:97:b5:1a:7a:4c:f9:92:\n        30:bd:ce:28:94:84:a9:67:f4:d5:2a:87:cc:da:6e:4c:ad:a6:\n        18:39:d5:32\n\n\n3.2.3 用户服务器提交申请\n# 现在扮演 用户网站申请证书, 假定在另外一台服务器\n# 先创建网站的私钥\nopenssl genrsa -out server.key 2048\n# 直接创建证书签名请求csr文件\n# 注意 由于我们配置了 policy_match ,所以几个 需要和CA的一致\n# 指定 server.key 是因为csr信息 需要包含服务端的公钥,公钥可以从私钥提取.\n#  说明这些是想说 写的时候 知道为啥需要这些参数\nopenssl req -new -key server.key -subj \"/CN=example1.com/C=CN/O=taobao/ST=BJ\" -out server.csr\n\n# 查看一下csr\nopenssl req -in server.csr -text -noout\n# 将它 发送给 CA服务器\n\n\n3.2.4 CA根据申请生成证书\n# 可以指定 -policy ,这样不用与ca 某些一致\n# openssl ca -in server.csr -policy policy_anything -out certs/server.crt -days 3650\n# 回到 CA 的服务器 ,拿到 用户网站的csr文件, 签署生成证书,最后你发送给申请者\nopenssl ca -in server.csr  -out certs/server.crt -days 3650 #(1)\n\n\n执行的提示信息\n\n...\nSerial Number: 1 (0x1) # 可以看到编号\nSign the certificate? [y/n]:  # 提示要签名了\n1 out of 1 certificate requests certified, commit? [y/n]y\nWrite out database with 1 new entries\nData Base Updated\n\n/etc/pki/CA\n├── newcerts # 这个目录下会自动有这次颁发的证书\n│   └── 01.pem # 里面的内容更多, 会增加解码后的内容\n# 验签\nopenssl verify -CAfile cacert.pem certs/server.crt\n\n# 查看证书, 查看部分内容, -text 会显示所有 -issuer  颁发者 -dates 有效期\nopenssl x509 -in certs/server.crt -noout -subject -issuer -dates\n# 查看证书状态,验证有效与否  01 是serial 证书编号\nopenssl ca -status 01\n# 默认不能使用同一个csr 申请 另外一个证书, 不过可以修改 使它可以\n# 除了 前面的配置文件, 我们可以 修改 index.txt.attr\n    unique_subject = yes # 改成no 就可以\n\n\n3.2.5 客户端安装证书\n\n客户端(浏览器的系统) 需要安装 上面创建的根证书 cacert.pem,这样你操作系统就有了CA的公钥了,就好像系统安装后默认的那些Root CA一样 \n访问 golang web https服务 https://example1.com, 会提示你安装证书\n\ntree\n├── go.mod\n├── main.go\n├── pki\n│   ├── server.crt # 上面我们创建的\n│   ├── server.key # 上面我们创建的\npackage main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"net/http\"\n)\n\nfunc main() {\n    http.HandleFunc(\"/\", handler)\n    log.Fatal(http.ListenAndServeTLS(\":443\", \"./pki/server.crt\", \"./pki/server.key\", nil))\n}\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n    fmt.Fprintln(w, \"Hello, HTTPS!\")\n}\ngo run main.go\n\n\n/etc/hosts\n\n192.168.1.100 example1.com\n\n# 将server.crt 发送到其他机器, 可以在这样的机器上 curl\ncurl --cacert server.crt --resolve example1.com:443:192.168.1.104 https://example1.com/\nHello, HTTPS!\n\n\n\n\n\n\nchrome/edge 浏览器问题\n\n\n\n\n访问网页会提示你 Subject Alternative Name Missing\n提示 net: cert_invalid\n\n\nCA解决步骤简单快速自签名方法\n\n\n\n\n/etc/pki/tls/openssl.cnf 添加\n\n# 这个表示添加到证书请求里的配置\nreq_extensions = v3_req # The extensions to add to a certificate request\n[ v3_req ]\nbasicConstraints = CA:FALSE\nkeyUsage = nonRepudiation, digitalSignature, keyEncipherment\nsubjectAltName = @alt_names # 添加这行\n[alt_names]  # 添加\nDNS.1   = example1.com # 添加我们访问的域名\n\n\n\n生成证书等步骤稍作变更\n\nopenssl genrsa -out ./private/cakey.pem 2048\n# 根证书 -extensions v3_req 需要显式指定\nopenssl req -x509 -new -key ./private/cakey.pem \\\n    -subj \"/CN=example1.com/C=CN/O=taobao/ST=BJ\" \\\n    -extensions v3_req -days 5000 \\\n    -out cacert.pem\n\nopenssl genrsa -out server.key 2048\n# csr  默认就会应用配置里的 req_extensions = v3_req ,因为就是req 生成csr 请求文件 的操作\n# 如果前面的 req_extensions = v3_req 被注释了, 则需要 显式指定-extensions v3_req\nopenssl req -new -key server.key -subj \"/CN=example1.com/C=CN/O=taobao/ST=BJ\" -out server.csr\n# 生成证书\n# 如果不指定 -extensions v3_req 则会使用配置文件里  user_cert 指定的配置.\n# x509_extensions = usr_cert  # The extentions to add to the cert\n# [ usr_cert ]\n# These extensions are added when 'ca' signs a request.\nopenssl ca -in server.csr -extensions v3_req  -out /etc/pki/CA/certs/server.crt -days 3650\n# 查看一下, 会看到版本是3 等信息\n\n\n\nopenssl genrsa -out server.key 2048\n# 实际上就是使用临时的openssl.cnf (多包含了我们设置的[SAN] 扩展,名字随便起, -extensions 指定就行)\n# 生成的 server.crt 里  X509v3 extensions: 就只会有 subjectAltName\nopenssl req -x509 -new \\\n    -key server.key \\\n    -subj \"/CN=example1.com/C=CN/O=taobao/ST=BJ\" \\\n    -extensions SAN \\\n    -config &lt;(cat /etc/pki/tls/openssl.cnf &lt;(echo [SAN];echo subjectAltName=DNS.1:example1.com)) \\\n    -days 1000 \\\n    -out server.crt\n\n\n\n最后好像除了ca根证书安装, 网站服务器的证书还是要手动安装?\n\n\n\n\n3.2.6 99.吊销证书\n# 吊销证书, 指定证书路径即可, 结果看 index.txt  证书状态变成 R 表示revoke\nopenssl ca -revoke  newcerts/01.pem\n# 更新吊销列表\n# 指定要吊销的证书编号,第一次需要这样,\necho 01 &gt; /etc/pki/CA/crlnumber\nopenssl ca -gencrl -out /etc/pki/CA/crl.pem\n# 查看吊销列表\nopenssl crl -in /etc/pki/CA/crl.pem -noout -text\n\n\n\n3.3 快速生成证书\n\n\n\n\n\n\nTip\n\n\n\n不用模拟ca那样\n\n\n# 不需要ca根证书的, 自签名证书, 自己给自己签名,\n# 客户端直接安装这个,里面有公钥,然后服务端也是发送这个证书\n# 客户端发送操作系统有这个证书的颁发机构, 其实就是它自己\nopenssl genrsa -out server.key 2048\nopenssl req -x509 -new -key server.key -subj \"/CN=example1.com/C=CN/O=taobao/ST=BJ\" -days 5000 -out server.crt\n\n# centos 7有自带的Makefile\ncd /etc/pki/tls/certs/\nmake # 会提示使用方法\n\n# 需要根证书的\n # 根 私钥\nopenssl genrsa  -out ca.key 2048\n# 根证书\nopenssl req -x509 -nodes -new -key ca.key -subj \"/CN=example1.com/C=CN/O=tb/ST=BJ\" -days 5000 -out ca.crt\n# 服务器 私钥\nopenssl genrsa -out server.key 2048\n# csr\nopenssl req -new -key server.key -subj \"/CN=example1.com/C=CN/O=tb/ST=BJ\" -out server.csr\n# 之前的这个操作,会去找配置中的 ca私钥\n# openssl ca -in server.csr  -out server.crt -days 3650\n# 这里我们直接指定  -CAcreateserial 加上这个表示会创建编号文件 ca.srl\n# -extfile        - configuration file with X509V3 extensions to add\n# -extensions     - section from config file with X509V3 extensions to add\n# 前面我们提到chrome 提示有问题, 应该 只要服务器证书 设置 subjectAltName 就行了.\n# 指定ca.crt 那是因为 生成的证书需要颁发机构的信息.\nopenssl x509 -req -CA ca.crt \\\n    -CAkey ca.key -CAcreateserial \\\n    -in server.csr -out server.crt \\\n    -extensions v3_req \\\n    -extfile &lt;(cat /etc/pki/tls/openssl.cnf &lt;(cat &lt;&lt;EOF\n[ v3_req ]\nbasicConstraints = CA:FALSE\nkeyUsage = nonRepudiation, digitalSignature, keyEncipherment\nsubjectAltName = @alt_names\n[alt_names]\nDNS.1 = example1.com\nEOF\n))\n# 查看\nopenssl x509 -in server.crt -noout -text #(1)\n\n\nopenssl x509 -in server.crt -noout -text 扩展的一些信息\n\nX509v3 extensions:\n    X509v3 Basic Constraints:\n        CA:FALSE\n    X509v3 Key Usage:\n        Digital Signature, Non Repudiation, Key Encipherment\n    X509v3 Subject Alternative Name:\n        DNS:example1.com\n\n\n\n3.4 关于证书的总结\n\n\n\n\n\n\nTip\n\n\n\n客户端安装根证书(自签名证书也一样)是为了解密服务端传过来的证书内容,以获取服务端的公钥, 然后使用公钥加密随机密钥(用来对称加密用),将这密钥安全发送给服务端,最后用这个密钥加密传输的数据,以达到安全的目的",
    "crumbs": [
      "https"
    ]
  },
  {
    "objectID": "docs/netprog/https.html#抓包分析https",
    "href": "docs/netprog/https.html#抓包分析https",
    "title": "斯巴拉稀",
    "section": "4 抓包分析https",
    "text": "4 抓包分析https\n\n\n\n\n\n\nNote\n\n\n\ngo web程序在虚拟机中, 在宿主机浏览器访问\n\n\n\n\n虚拟机中运行\n\ngo run main.go\n# 抓包\ntcpdump -i eth1 -nn -X -S  tcp port 443 -w go.pcap\n\n宿主机中用safari访问 https://example1.com, 等一段时间,将虚拟机中的抓取的包go.pcap 在宿主机中用wireshark 打开这个\n\n\n\n\n\n\nCaution\n\n\n\nTODO",
    "crumbs": [
      "https"
    ]
  },
  {
    "objectID": "docs/netprog/https.html#其他安全相关",
    "href": "docs/netprog/https.html#其他安全相关",
    "title": "斯巴拉稀",
    "section": "5 其他安全相关",
    "text": "5 其他安全相关\n\n5.1 摘要算法\n\n\n\n\n\n\nTip\n\n\n\n\n摘要算法（Hash Algorithm）也叫哈希算法、散列算法, 它是一种将任意长度的数据映射为固定长度摘要（哈希值）的算法.摘要算法常用于验证数据的完整性和唯一性,以及密码学中的数字签名、密码校验等应用\n任意长度–&gt; 固定长度, 很显然不可能从映射后的摘要值推导出原来的数据.",
    "crumbs": [
      "https"
    ]
  },
  {
    "objectID": "docs/rust/basic/10.error.html",
    "href": "docs/rust/basic/10.error.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "越界\nfn main() {\n    let v = vec![1, 2, 3];\n\n    v[99];\n}\nfn main() {\n    panic!(\"crash and burn\"); // 后面的不会执行\n    println!(\"1\");\n}",
    "crumbs": [
      "基础篇",
      "错误处理"
    ]
  },
  {
    "objectID": "docs/rust/basic/10.error.html#unrecoverable-errors",
    "href": "docs/rust/basic/10.error.html#unrecoverable-errors",
    "title": "斯巴拉稀",
    "section": "",
    "text": "越界\nfn main() {\n    let v = vec![1, 2, 3];\n\n    v[99];\n}\nfn main() {\n    panic!(\"crash and burn\"); // 后面的不会执行\n    println!(\"1\");\n}",
    "crumbs": [
      "基础篇",
      "错误处理"
    ]
  },
  {
    "objectID": "docs/rust/basic/10.error.html#recoverable-errors",
    "href": "docs/rust/basic/10.error.html#recoverable-errors",
    "title": "斯巴拉稀",
    "section": "2 Recoverable Errors",
    "text": "2 Recoverable Errors\nenum Result&lt;T, E&gt; {\n    Ok(T),\n    Err(E),\n}\n\n2.1 match\nuse std::fs::File;\n\nfn main() {\n    let greeting_file_result = File::open(\"hello.txt\");\n\n    let greeting_file = match greeting_file_result {\n        Ok(file) =&gt; file, // 返回给 greeting_file\n        Err(error) =&gt; {\n            // 直接panic\n            panic!(\"Problem opening the file: {:?}\", error);\n        }\n    };\n}\nuse std::fs::File;\nuse std::io::ErrorKind;\n\nfn main() {\n    let greeting_file_result = File::open(\"hello.txt\");\n\n    let greeting_file = match greeting_file_result {\n        Ok(file) =&gt; file,\n        Err(error) =&gt; match error.kind() {\n            // 匹配不同的错误\n            ErrorKind::NotFound =&gt; match File::create(\"hello.txt\") {\n                Ok(fc) =&gt; fc,\n                Err(e) =&gt; panic!(\"Problem creating the file: {:?}\", e),\n            },\n            other_error =&gt; {\n                panic!(\"Problem opening the file: {:?}\", other_error);\n            }\n        },\n    };\n}\n\n\n2.2 unwrap_or_else\n使用 Result&lt;T, E&gt; 的方法 unwrap_or_else\nuse std::fs::File;\nuse std::io::ErrorKind;\n\nfn main() {\n    let greeting_file = File::open(\"hello.txt\").unwrap_or_else(|error| {\n        if error.kind() == ErrorKind::NotFound {\n            File::create(\"hello.txt\").unwrap_or_else(|error| {\n                panic!(\"Problem creating the file: {:?}\", error);\n            })\n        } else {\n            panic!(\"Problem opening the file: {:?}\", error);\n        }\n    });\n}\n\n\n2.3 unwrap\nuse std::fs::File;\n\nfn main() {\n    // unwrap 方法会返回一个 Result 枚举，\n    // 如果 Result 枚举是 Ok 类型，则 unwrap 会返回 Ok 中的值，\n    // 如果 Result 枚举是 Err 类型，则 unwrap 会panic Err 中的错误信息, 程序退出\n    let greeting_file = File::open(\"hello.txt\").unwrap();\n}\n\n\n2.4 expect\n相比unwrap 就是能定义输出的错误信息\nuse std::fs::File;\n\nfn main() {\n    let greeting_file = File::open(\"hello.txt\")\n        .expect(\"hello.txt 文件不存在 \");\n}\n\n\n2.5 ?\nuse std::fs::File;\nuse std::io::{self, Read};\nfn main() {\n    read_username_from_file().unwrap();\n}\nfn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {\n    let username_file_result = File::open(\"hello.txt\");\n    // 错误的情况, 返回 result&lt;String,Error&gt;\n    let mut username_file = match username_file_result {\n        Ok(file) =&gt; file,\n        // return 会退出函数, 返回Err(e) 给read_username_from_file\n        Err(e) =&gt; return Err(e),\n    };\n\n    let mut username = String::new();\n    // 不管结果如何, 都返回 ,让给调用者处理\n    match username_file.read_to_string(&mut username) {\n        Ok(_) =&gt; Ok(username),\n        Err(e) =&gt; Err(e),\n    }   // 注意这里是没有 ; 的, 因为要返回 result&lt;T,E&gt;\n}\n上面的写法, 你会发现, 有同样类似的逻辑, 就是将结果result 给调用者自己处理, 使用? 简化代码\nuse std::fs::File;\nuse std::io::{self, Read};\nfn main() {\n    read_username_from_file().unwrap();\n}\nfn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {\n    // \\? 放在 Result 类型的返回值上\n    // 如果返回值是 Ok,那么Ok包含的value 会被返回, 程序继续执行\n    // 如果返回值是 Err, 则返回 Err\n    let mut username_file = File::open(\"hello.txt\")?;\n    let mut username = String::new();\n    let s = username_file.read_to_string(&mut username)?;\n    println!(\"s:=={}\", s); // 读取的字节书\n    Ok(username)\n}\n更简洁\nuse std::fs::File;\nuse std::io::{self, Read};\n\nfn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {\n    let mut username = String::new();\n\n    File::open(\"hello.txt\")?.read_to_string(&mut username)?;\n\n    Ok(username)\n}\n当然 标准库 提供了 上面的需求的更好的方法, 知道就行, 这不是我们讨论的点.\nuse std::fs;\nuse std::io;\n\nfn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {\n    fs::read_to_string(\"hello.txt\")\n}\n\n\n\n\n\n\nCaution\n\n\n\n\n? 只能被用在 函数里\n只能用在 Result, Option, 或者其他 实现了 FromResidual的 类型上\n\n\n\n下面代码报错了\nuse std::fs::File;\n\nfn main() {\n    let greeting_file = File::open(\"hello.txt\")?;\n}",
    "crumbs": [
      "基础篇",
      "错误处理"
    ]
  },
  {
    "objectID": "docs/rust/basic/17.macro.html",
    "href": "docs/rust/basic/17.macro.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "宏是用来编写可以生成其他代码的 代码 (metaprogramming)\n编译器编译时会将宏进行展开,就是会替换成具体的rust代码\n\n\n\n Back to top",
    "crumbs": [
      "基础篇",
      "宏"
    ]
  },
  {
    "objectID": "docs/rust/basic/04.struct.html",
    "href": "docs/rust/basic/04.struct.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "1#[derive(Debug)]\nstruct User {\n    active: bool,\n    username: String,\n    email: String,\n    sign_in_count: u64,\n}\n\nfn main() {\n2    let mut u = build_user(\"username123\".to_string(), \"someone@example.com\".to_string());\n\n    println!(\"{}\", u.email);\n    u.active = false;\n    println!(\"{}\", u);\n\n    let u1 = build_user(\"u1@hotmail\".to_string(), \"u1\".to_string());\n    let u2 = User {\n        // 覆盖 base struct的对应字段, 或者说 base struct会 指定剩余没设置值的字段\n        email: String::from(\"u2@hotmail\"),\n\n3        ..u1\n    };\n    println!(\"{:?}\", u2);\n    println!(\"{:#?}\", u2); // 更加直观的打印\n\n4    // println!(\"{:?}\", u1);\n5    println!(\"{:?}\", u1.email);\n\n}\nfn build_user(email: String, username: String) -&gt; User {\n    User {\n        active: true,\n6        username,\n        email,\n        sign_in_count: 1,\n    }\n}\n\n1\n\n需要实现 std::fmt::Debug trait才能 println!\n\n2\n\n不能给单独某个字段设置成 可变,只能整个设置 每个字段都必须设置值, 否则报错\n\n3\n\n作为 base struct 必须放在最后, 否则是报错的\n\n4\n\n报错了, 因为u1里的设置u2那里 username 被 move 掉了.\n\n5\n\n单独某个没有被move的字段还是可以打印的\n\n6\n\n同名,可以这样简便写法\n\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\n\ntuple structs\n只有字段的类型,没有name\n\n\n\n// 虽然元素类型一样, 但是2个结构体是不同的类型\nstruct Color(i32, i32, i32);\nstruct Point(i32, i32, i32);\n\nfn main() {\n    let black = Color(0, 0, 0);\n    let origin = Point(0, 0, 0);\n    // 同元祖访问\n    println!(\"{}\", black.0);\n}\n\n\n\nunit-like structs, 没有字段的结构体\n\nstruct AlwaysEqual;\n\nfn main() {\n    // 实例化了\n    let subject = AlwaysEqual;\n}",
    "crumbs": [
      "基础篇",
      "结构体"
    ]
  },
  {
    "objectID": "docs/rust/basic/04.struct.html#三种形式",
    "href": "docs/rust/basic/04.struct.html#三种形式",
    "title": "斯巴拉稀",
    "section": "",
    "text": "1#[derive(Debug)]\nstruct User {\n    active: bool,\n    username: String,\n    email: String,\n    sign_in_count: u64,\n}\n\nfn main() {\n2    let mut u = build_user(\"username123\".to_string(), \"someone@example.com\".to_string());\n\n    println!(\"{}\", u.email);\n    u.active = false;\n    println!(\"{}\", u);\n\n    let u1 = build_user(\"u1@hotmail\".to_string(), \"u1\".to_string());\n    let u2 = User {\n        // 覆盖 base struct的对应字段, 或者说 base struct会 指定剩余没设置值的字段\n        email: String::from(\"u2@hotmail\"),\n\n3        ..u1\n    };\n    println!(\"{:?}\", u2);\n    println!(\"{:#?}\", u2); // 更加直观的打印\n\n4    // println!(\"{:?}\", u1);\n5    println!(\"{:?}\", u1.email);\n\n}\nfn build_user(email: String, username: String) -&gt; User {\n    User {\n        active: true,\n6        username,\n        email,\n        sign_in_count: 1,\n    }\n}\n\n1\n\n需要实现 std::fmt::Debug trait才能 println!\n\n2\n\n不能给单独某个字段设置成 可变,只能整个设置 每个字段都必须设置值, 否则报错\n\n3\n\n作为 base struct 必须放在最后, 否则是报错的\n\n4\n\n报错了, 因为u1里的设置u2那里 username 被 move 掉了.\n\n5\n\n单独某个没有被move的字段还是可以打印的\n\n6\n\n同名,可以这样简便写法\n\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\n\ntuple structs\n只有字段的类型,没有name\n\n\n\n// 虽然元素类型一样, 但是2个结构体是不同的类型\nstruct Color(i32, i32, i32);\nstruct Point(i32, i32, i32);\n\nfn main() {\n    let black = Color(0, 0, 0);\n    let origin = Point(0, 0, 0);\n    // 同元祖访问\n    println!(\"{}\", black.0);\n}\n\n\n\nunit-like structs, 没有字段的结构体\n\nstruct AlwaysEqual;\n\nfn main() {\n    // 实例化了\n    let subject = AlwaysEqual;\n}",
    "crumbs": [
      "基础篇",
      "结构体"
    ]
  },
  {
    "objectID": "docs/rust/basic/04.struct.html#方法和关联函数",
    "href": "docs/rust/basic/04.struct.html#方法和关联函数",
    "title": "斯巴拉稀",
    "section": "2 方法和关联函数",
    "text": "2 方法和关联函数\n#[derive(Debug)]\nstruct Rectangle {\n    width: u32,\n    height: u32,\n}\n// impl 块里的所有东西都和 Rectangle 类型产生关联\nimpl Rectangle {\n    // 第一个参数是 &self 是 self: &Self的简写, 是不可变借用\n    // 如果想用 所有权的, 就 用 self 是 self: Self的简写\n    // 如果想用可变借用 就用&mut self 是self: &mut Self 的简写\n    // 调用方法实际上是将调用者作为第一个参数传递给方法\n    fn area_borrows_immutably(&self) -&gt; u32 {\n        println!(\" width... {}\", (*self).width);\n        self.width * self.height\n    }\n\n    fn area_move(self) -&gt; u32 {\n        println!(\" width... {}\", self.width);\n        self.width * self.height\n    }\n    fn area_borrows_mutably(&mut self) -&gt; u32 {\n        println!(\" width... {}\", (*self).width);\n        self.width * self.height\n    }\n\n    fn change_width(&mut self, width: u32) {\n        self.width = width;\n    }\n\n    // 关联函数\n    // 例子: 正方形 ,这里没有用到 &self 作为第一个参数\n    fn square(size: u32) -&gt; Self {\n        Self {\n            width: size,\n            height: size,\n        }\n    }\n    // rust没有专门的构造函数,需要自己定义,我们一般用new 这个方法名,\n    pub fn new(width: u32, height: u32) -&gt; Self {\n        Rectangle {\n            width,\n            height,\n        }\n    }\n}\n\nfn main() {\n    let rect1 = Rectangle {\n        width: 30,\n        height: 50,\n    };\n    // area_borrows_immutably(&rect1)\n    println!(\"{}\", rect1.area_borrows_immutably());\n    println!(\"{:?}\", rect1);\n    println!(\"{}\", rect1.area_move());\n    // 报错, move掉了, 说明 我们的结构体是move 属性的,\n    // println!(\"{:?}\", rect1);\n    let mut rect1 = Rectangle {\n        width: 30,\n        height: 50,\n    };\n    println!(\"{}\", rect1.area_borrows_mutably());\n\n    let mut rect2 = Rectangle {\n        width: 30,\n        height: 50,\n    };\n    // 调用的时候根据方法的第一个参数类型,会自动转为 比如 可变借用\n    rect2.change_width(35);\n    println!(\"{}\", rect2.area_borrows_immutably());\n\n    // 这样的方式调用\n    let r = &mut rect2;\n    Rectangle::change_width(r, 40);\n    println!(\"{}\", r.height);\n    println!(\"{}\", rect2.area_borrows_immutably());\n\n    // 使用 :: 来调用\n    let sq = Rectangle::square(3);\n    println!(\"{}\", sq.area_borrows_immutably());\n}\nDefautl\n// 添加Default 派生宏\n#[derive(Debug, Default)]\nstruct Rectangle {\n    width: u32,\n    height: u32,\n}\nfn main() {\n    // 可以使用这种方式来创建一个实例\n    // 使用方式1\n    let rect1: Rectangle = Default::default();\n    println!(\"{:?}\", rect1);\n    // 使用方式2\n    let rect2 = Rectangle::default();\n    println!(\"{:?}\", rect2);\n}",
    "crumbs": [
      "基础篇",
      "结构体"
    ]
  },
  {
    "objectID": "docs/rust/basic/01.env.html",
    "href": "docs/rust/basic/01.env.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "配置国内源1然后查看官方安装教程2\n# 添加, 让下面的安装快点\necho 'export RUSTUP_UPDATE_ROOT=https://mirrors.tuna.tsinghua.edu.cn/rustup/rustup' &gt;&gt; ~/.zshrc\necho 'export RUSTUP_DIST_SERVER=https://mirrors.tuna.tsinghua.edu.cn/rustup' &gt;&gt; ~/.zshrc\n# 安装\ncurl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n安装过程我们可以看到 info: installing component 'rust-docs' 这类信息,说明安装了不少组件\n所有的组件到安装到 ~/.cargo/bin 这个目录\ntree ~/.cargo/bin\n~/.cargo/bin\n├── cargo\n├── cargo-clippy\n├── cargo-fmt\n├── cargo-miri\n├── clippy-driver\n├── rls\n├── rust-analyzer\n├── rust-gdb\n├── rust-gdbgui\n├── rust-lldb\n├── rustc\n├── rustdoc\n├── rustfmt\n└── rustup\n\n\n\n\n\n\nTip\n\n\n\nrustup 是专门管理rust安装的工具, 相当于 node 的nvm\n\n\n配置\n# zsh\necho 'source \"$HOME/.cargo/env\"' &gt;&gt; ~/.zshrc\n# path环境变量的设置\n#  $HOME/.cargo/bin:$PATH\n# fish shell 的配置\n# vim ~/.config/fish/config.fish 添加如下. 然后 source一下即可\n# set -x  PATH ~/.cargo/bin $PATH\n验证安装\nrustc --version\ncargo --version\n\n\n\n\n\n\nTip\n\n\n\ncargo: Rust 的编译工具,包管理器,可以帮助你编译代码,运行,测试,下载代码所依赖的外部库等等\n\n\n安装库\n# RLS的全称是:'Rust Language Server',是一个守护进程\n# 用于和开发时使用的IDE进行IPC通信,完成代码提示、跳转到定义、显示变量类型等功能\n# 这2个库,前面安装的时候已经自动安装了.\nrustup component add rls           --toolchain stable    # RLS\nrustup component add rust-analysis --toolchain stable    # 分析工具\n#std是Rust的标准库. 默认情况下,Rust安装的是标准库的二进制码,而添加源码后容易方便我们查询部分标准库的实现\nrustup component add rust-src      --toolchain stable    # std源码",
    "crumbs": [
      "基础篇",
      "环境准备"
    ]
  },
  {
    "objectID": "docs/rust/basic/01.env.html#安装",
    "href": "docs/rust/basic/01.env.html#安装",
    "title": "斯巴拉稀",
    "section": "",
    "text": "配置国内源1然后查看官方安装教程2\n# 添加, 让下面的安装快点\necho 'export RUSTUP_UPDATE_ROOT=https://mirrors.tuna.tsinghua.edu.cn/rustup/rustup' &gt;&gt; ~/.zshrc\necho 'export RUSTUP_DIST_SERVER=https://mirrors.tuna.tsinghua.edu.cn/rustup' &gt;&gt; ~/.zshrc\n# 安装\ncurl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n安装过程我们可以看到 info: installing component 'rust-docs' 这类信息,说明安装了不少组件\n所有的组件到安装到 ~/.cargo/bin 这个目录\ntree ~/.cargo/bin\n~/.cargo/bin\n├── cargo\n├── cargo-clippy\n├── cargo-fmt\n├── cargo-miri\n├── clippy-driver\n├── rls\n├── rust-analyzer\n├── rust-gdb\n├── rust-gdbgui\n├── rust-lldb\n├── rustc\n├── rustdoc\n├── rustfmt\n└── rustup\n\n\n\n\n\n\nTip\n\n\n\nrustup 是专门管理rust安装的工具, 相当于 node 的nvm\n\n\n配置\n# zsh\necho 'source \"$HOME/.cargo/env\"' &gt;&gt; ~/.zshrc\n# path环境变量的设置\n#  $HOME/.cargo/bin:$PATH\n# fish shell 的配置\n# vim ~/.config/fish/config.fish 添加如下. 然后 source一下即可\n# set -x  PATH ~/.cargo/bin $PATH\n验证安装\nrustc --version\ncargo --version\n\n\n\n\n\n\nTip\n\n\n\ncargo: Rust 的编译工具,包管理器,可以帮助你编译代码,运行,测试,下载代码所依赖的外部库等等\n\n\n安装库\n# RLS的全称是:'Rust Language Server',是一个守护进程\n# 用于和开发时使用的IDE进行IPC通信,完成代码提示、跳转到定义、显示变量类型等功能\n# 这2个库,前面安装的时候已经自动安装了.\nrustup component add rls           --toolchain stable    # RLS\nrustup component add rust-analysis --toolchain stable    # 分析工具\n#std是Rust的标准库. 默认情况下,Rust安装的是标准库的二进制码,而添加源码后容易方便我们查询部分标准库的实现\nrustup component add rust-src      --toolchain stable    # std源码",
    "crumbs": [
      "基础篇",
      "环境准备"
    ]
  },
  {
    "objectID": "docs/rust/basic/01.env.html#rustup",
    "href": "docs/rust/basic/01.env.html#rustup",
    "title": "斯巴拉稀",
    "section": "2 rustup",
    "text": "2 rustup\n更新\nrustup update\n安装指定版本\nrustup install  1.20.0\n查看已经安装的版本\nrustup toolchain list\n卸载\n# 会删除所有的工具链,\n# 包括rustup, rustc, cargo, rls, rust-analysis, rust-src等等\n# 注意, 卸载后, 需要重新安装\nrustup self uninstall\n切换版本\n# 全局切换\nrustup default stable/nightly/beta\n# 工作目录切换版本\ncd rust代码目录\nrustup override set 1.20.0\n# 取消当前目录的版本 ,重新设置为默认的全局版本\nrustup override unset",
    "crumbs": [
      "基础篇",
      "环境准备"
    ]
  },
  {
    "objectID": "docs/rust/basic/01.env.html#查看文档",
    "href": "docs/rust/basic/01.env.html#查看文档",
    "title": "斯巴拉稀",
    "section": "3 查看文档",
    "text": "3 查看文档\n查看本地离线的rust文档,浏览器会自动打开文档, 可以看到好多教程可以点击查看\nrustup doc\n这个会打开 The Rust Programming Language 这本教程\nrustup docs --book\n# 查看帮助,可以看到其他book的 命令\nrustup docs --help\n# 直接打开 rust-by-example 这本书\nrustup docs --rust-by-example",
    "crumbs": [
      "基础篇",
      "环境准备"
    ]
  },
  {
    "objectID": "docs/rust/basic/01.env.html#cargo简单介绍",
    "href": "docs/rust/basic/01.env.html#cargo简单介绍",
    "title": "斯巴拉稀",
    "section": "4 cargo简单介绍",
    "text": "4 cargo简单介绍\ncargo new hello \ncd hello\ntree -a\n# 会创建目录world, 并且 直接有 .git 纳入git管理\n.\n├── .git\n├── .gitignore\n1├── Cargo.toml\n└── src\n    └── main.rs\n\n1\n\ncargo.toml package的一些基本信息 toml参考\n\n\n\n\nCargo.toml\n\n[package]\nname = \"hello\"\n# 注意开发时第一个 version 一般是用0.1.0 不是0.0.1\nversion = \"0.1.0\"\nedition = \"2021\"\n\n\n\nsrc/main.rs\n\nfn main() {\n    println!(\"Hello, world!\");\n}\n\n\n\n执行命令\n\ncargo run\n\n\n\n运行打印的信息\n\n1       Fresh hello v0.1.0 (~/rust2024/hello)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.00s\n2     Running `target/debug/hello`\n3Hello, world!\n\n\n1\n\ncargo 调用 rust编译器 rustc来编译代码,生成可执行文件,会放到 target/debug 目录下\n\n2\n\n运行 可执行文件\n\n3\n\n输出结果\n\n\n配置crates国内源3, 下载依赖包就快了\nmkdir -vp ${CARGO_HOME:-$HOME/.cargo}\n\ncat &lt;&lt; EOF | tee -a ${CARGO_HOME:-$HOME/.cargo}/config\n[source.crates-io]\nreplace-with = 'ustc'\n\n[source.ustc]\nregistry = \"sparse+https://mirrors.ustc.edu.cn/crates.io-index/\"\nEOF\n或者\nmkdir -vp ${CARGO_HOME:-$HOME/.cargo}\n\ncat &lt;&lt; EOF | tee -a ${CARGO_HOME:-$HOME/.cargo}/config\n[source.crates-io]\nreplace-with = 'mirror'\n\n[source.mirror]\nregistry = \"sparse+https://mirrors.tuna.tsinghua.edu.cn/crates.io-index/\"\nEOF",
    "crumbs": [
      "基础篇",
      "环境准备"
    ]
  },
  {
    "objectID": "docs/rust/basic/01.env.html#footnotes",
    "href": "docs/rust/basic/01.env.html#footnotes",
    "title": "斯巴拉稀",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nrustup国内源↩︎\n官方安装教程↩︎\n中科大开源镜像站 清华大学开源软件镜像站↩︎",
    "crumbs": [
      "基础篇",
      "环境准备"
    ]
  },
  {
    "objectID": "docs/rust/basic/06.collection.html",
    "href": "docs/rust/basic/06.collection.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "Tip\n\n\n\n\n只能存储相同类型的数据\n在内存中连续存放\n容量可以在执行过程中动态扩大和缩放\n\n既然是动态的,那么它必定是要在堆上分配的.\n\n\n\n\n\n\nfn main() {\n    // 第一种方式,存放的类型是i32,\n    // 也可以不指定是什么类型的(去掉Vec&lt;i32&gt;),push 后 就推断出什么类型了\n    let mut v: Vec&lt;i32&gt; = Vec::new();\n    // 添加\n    v.push(5);\n    v.push(6);\n    // 第二种定义方式\n    // 宏等价于调用 Vec::new 创建一个新的空 vector，然后向其中添加元素\n    let mut y=vec![1,2,3,4,5];\n    // 第三种 通过迭代器创建\n    let v: Vec&lt;i32&gt; = (0..5).collect();\n    println!(\"{:?}\", v);\n    // 第四中 设置 capacity\n    let mut v = Vec::with_capacity(5);\n    v.push(1);\n    println!(\"{}-{}\", v.capacity(), v.len());\n\n    // 插入和删除\n    let mut v = vec![10, 20, 30, 40, 50];\n    // 在索引为 3的地方插入 35\n    v.insert(3, 35);\n    assert_eq!(v, [10, 20, 30, 35, 40, 50]);\n    // 移除索引为 1的元素\n    v.remove(1);\n    assert_eq!(v, [10, 30, 35, 40, 50])\n}\n\n\n\n#[test]\nfn test() {\n    let v = vec![1, 2, 3, 4, 5];\n\n    let third: &i32 = &v[2];\n    println!(\"The third element is {third}\");\n\n    // get的返回类型是  Option\n    let third: Option&lt;&i32&gt; = v.get(2);\n    match third {\n        Some(third) =&gt; println!(\"The third element is {third}\"),\n        None =&gt; println!(\"There is no third element.\"),\n    }\n}\n越界,报错\n#[test]\nfn test() {\n    let v = vec![1, 2, 3, 4, 5];\n    // 会直接panic: index out of bounds\n    let does_not_exist = &v[100];\n    // 这个不会报错\n    let does_not_exist = v.get(100);\n}\n\n\n\nenum SpreadsheetCell {\n    Int(i32),\n    Float(f64),\n    Text(String),\n}\nfn main() {\n    let row = vec![\n        SpreadsheetCell::Int(3),\n        SpreadsheetCell::Text(String::from(\"blue\")),\n        SpreadsheetCell::Float(10.12),\n    ];\n}\n\n\n\n#[test]\nfn test() {\n    let v = vec![100, 32, 57];\n    // 不可变借用 遍历\n    for i in &v {\n        println!(\"{i}\");\n    }\n\n    let mut v2 = vec![100, 32, 57];\n    // 可变借用,然后修改元素\n    for i in &mut v2 {\n        *i += 50;\n    }\n    println!(\"{:?}\", v2)\n}",
    "crumbs": [
      "基础篇",
      "集合"
    ]
  },
  {
    "objectID": "docs/rust/basic/06.collection.html#vector",
    "href": "docs/rust/basic/06.collection.html#vector",
    "title": "斯巴拉稀",
    "section": "",
    "text": "Tip\n\n\n\n\n只能存储相同类型的数据\n在内存中连续存放\n容量可以在执行过程中动态扩大和缩放\n\n既然是动态的,那么它必定是要在堆上分配的.\n\n\n\n\n\n\nfn main() {\n    // 第一种方式,存放的类型是i32,\n    // 也可以不指定是什么类型的(去掉Vec&lt;i32&gt;),push 后 就推断出什么类型了\n    let mut v: Vec&lt;i32&gt; = Vec::new();\n    // 添加\n    v.push(5);\n    v.push(6);\n    // 第二种定义方式\n    // 宏等价于调用 Vec::new 创建一个新的空 vector，然后向其中添加元素\n    let mut y=vec![1,2,3,4,5];\n    // 第三种 通过迭代器创建\n    let v: Vec&lt;i32&gt; = (0..5).collect();\n    println!(\"{:?}\", v);\n    // 第四中 设置 capacity\n    let mut v = Vec::with_capacity(5);\n    v.push(1);\n    println!(\"{}-{}\", v.capacity(), v.len());\n\n    // 插入和删除\n    let mut v = vec![10, 20, 30, 40, 50];\n    // 在索引为 3的地方插入 35\n    v.insert(3, 35);\n    assert_eq!(v, [10, 20, 30, 35, 40, 50]);\n    // 移除索引为 1的元素\n    v.remove(1);\n    assert_eq!(v, [10, 30, 35, 40, 50])\n}\n\n\n\n#[test]\nfn test() {\n    let v = vec![1, 2, 3, 4, 5];\n\n    let third: &i32 = &v[2];\n    println!(\"The third element is {third}\");\n\n    // get的返回类型是  Option\n    let third: Option&lt;&i32&gt; = v.get(2);\n    match third {\n        Some(third) =&gt; println!(\"The third element is {third}\"),\n        None =&gt; println!(\"There is no third element.\"),\n    }\n}\n越界,报错\n#[test]\nfn test() {\n    let v = vec![1, 2, 3, 4, 5];\n    // 会直接panic: index out of bounds\n    let does_not_exist = &v[100];\n    // 这个不会报错\n    let does_not_exist = v.get(100);\n}\n\n\n\nenum SpreadsheetCell {\n    Int(i32),\n    Float(f64),\n    Text(String),\n}\nfn main() {\n    let row = vec![\n        SpreadsheetCell::Int(3),\n        SpreadsheetCell::Text(String::from(\"blue\")),\n        SpreadsheetCell::Float(10.12),\n    ];\n}\n\n\n\n#[test]\nfn test() {\n    let v = vec![100, 32, 57];\n    // 不可变借用 遍历\n    for i in &v {\n        println!(\"{i}\");\n    }\n\n    let mut v2 = vec![100, 32, 57];\n    // 可变借用,然后修改元素\n    for i in &mut v2 {\n        *i += 50;\n    }\n    println!(\"{:?}\", v2)\n}",
    "crumbs": [
      "基础篇",
      "集合"
    ]
  },
  {
    "objectID": "docs/rust/basic/06.collection.html#hashmap",
    "href": "docs/rust/basic/06.collection.html#hashmap",
    "title": "斯巴拉稀",
    "section": "2 hashmap",
    "text": "2 hashmap\nuse std::collections::HashMap;\nfn main() {\n    // 如果仅仅只有这个语句, 则会报错,因为编译器无法知道数据类型,就无法分配内存了\n    // let mut s = HashMap::new();\n    // 这样就不会了\n    let mut scores: HashMap&lt;String, i32&gt; = HashMap::new();\n    // 插入元素\n    scores.insert(String::from(\"Blue\"), 10);\n    scores.insert(String::from(\"Yellow\"), 50);\n\n    // 读取\n    let team_name = String::from(\"Blue2\");\n    // get() 返回 类型是Option&lt;&V&gt;,没有的话就是 返回 None\n    // copied() 将 返回的Option&lt;&i32&gt; 变成 Option&lt;i32&gt;\n    // unwrap_or(0)  表示如果该key ,则返回一个 0\n    let score = scores.get(&team_name).copied().unwrap_or(2);\n    println!(\"{}\", score);\n\n    // 遍历\n    for (key, value) in &scores {\n        println!(\"{key}: {value}\");\n    }\n\n    // 更新元素, 还是用insert 会覆盖\n    scores.insert(String::from(\"Blue\"), 12);\n\n    // key Yellow 不存在,才添加\n    // 返回一个value的可变借用\n    scores.entry(String::from(\"Yellow\")).or_insert(50);\n\n    let text = \"hello world wonderful world\";\n    let mut map = HashMap::new();\n    for word in text.split_whitespace() {\n        // 第一次 word  key 不存在的时候, 插入 0, 返回value的可变借用\n        // 下面的操作才会是  *count +=1\n        // 第二次来, 存在, 返回旧 value 的可变借用 ,后面 还是 *count +=1\n        let count = map.entry(word).or_insert(0);\n        *count += 1;\n    }\n\n    println!(\"{:?}\", map);\n    println!(\"{:#?}\",map); // 格式化打印\n}\n所有权\nuse std::collections::HashMap;\nfn main() {\n    let field_name = String::from(\"Favorite color\");\n    let field_value = String::from(\"Blue\");\n\n    let mut map = HashMap::new();\n    map.insert(field_name, field_value);\n    //  field_name, field_value  已经被move 了. 报错了. 看值的类型\n    // println!(\"{}-{}\", field_name, field_value);\n}",
    "crumbs": [
      "基础篇",
      "集合"
    ]
  },
  {
    "objectID": "docs/rust/basic/06.collection.html#字符串",
    "href": "docs/rust/basic/06.collection.html#字符串",
    "title": "斯巴拉稀",
    "section": "3 字符串",
    "text": "3 字符串\n可对比一下go的字符串设计\n\n\n字符串相关的几种定义\n\n\n3.1 str\nfn main(){\n    let a = \"abc\";\n    let b = \"hello\";\n}\n\n我们可以得到这个a和b的类型是 &str,在没有学习切片前,仅从这个类型名称看,我们可以推断 &str 是一个指向字符串字面量的指针.\n既然是 &这个操作, 那么*a 指向的类型似乎就是str了,a和b指向的str类型占用的空间不同,这样说来str类型的长度是可变的.\n所以我们无法在代码中直接使用str类型, 因为编译期间需要确定变量的大小.\n那么不难推断出&str这种引用可变长度类型的类型, 除了有指针指向str外, 还必须有一个信息来存储你引用的长度.\n\n\n\n3.2 &str\n字符串切片: 只是对一块内存空间的借用,无所有权\nuse std::mem;\nfn main() {\n    // 字符切片 &str , abc 这个是 字符串字面量\n    let x = \"abc\";\n    println!(\n        \"x指向的字符串实际地址:{:p}--长度:{}--占用字节数: {}\",\n        x.as_ptr(),\n        x.len(),\n        mem::size_of_val(&x)\n    );\n    let y: &'static str = \"abc\";\n    println!(\n        \"y指向的字符串实际地址:{:p}--长度:{}--占用字节数: {}\",\n        y.as_ptr(),\n        y.len(),\n        mem::size_of_val(&y)\n    );\n    // 字符串 String\n    let z = String::from(x);\n    println!(\"z指向的字符串的地址:{:p}\", z.as_ptr());\n    let s = String::from(\"hello world\");\n    // 字符串切片\n    let s2 = &s[0..4]; // s2 内容是 \"hell\"\n    println!(\"String s:{:p}\", s.as_ptr());\n    println!(\"&str s2:{:p}\", s2.as_ptr());\n    println!(\"{s}-{s2}\");\n}\n看看是否能修改\nfn main() {\n    // 会直接提示不需要mut\n    let mut a = \"abc\";\n    // let mut a = \"abc\".to_string();\n    let b = a.as_ptr() as *mut i8;\n    unsafe {\n        println!(\"11\");\n        *b = 98; // 修改字符串内容\n        println!(\"22\"); // 上一步无法成功执行,但是没报错, 这里不会执行打印\n    }\n    println!(\"x{}\", a);\n}\nfn main() {\n    // 不会转义, 原样输出\n    let a = r\"\\a\\b\";\n    println!(\"{}\", a);\n    println!(\n        r#\"hello\nworld \\n ('\"')\n\"#\n    )\n}\n\n\n3.3 String\n字符串:有这块内存空间的所有权\n是一种集合类型,所以前面集合类型的操作也适用\n\n3.3.1 基础操作\nuse std::mem;\nfn main() {\n    let s1 = \"hello\".to_string();\n    // 空字符串\n    let s2 = String::new();\n    let s3 = \" world\".to_string();\n    // + 法 , 第二个变量 要是 字符串的借用\n    let c = s1 + &s3; //s1 被move 了\n    println!(\"{}\", c);\n\n    // format! 宏 来拼接字符串, 类似 println! ,只不过返回结果,不打印\n    let s1 = String::from(\"tic\");\n    let s2 = String::from(\"tac\");\n    let s3 = String::from(\"toe\");\n    // let s = s1 + \"-\" + &s2 + \"-\" + &s3;\n    let s = format!(\"{s1}-{s2}-{s3}\");\n    println!(\"{}-{}-{}\", s1, s2, s3); // 都可用\n\n    let mut x = String::from(\"abc\");\n    println!(\"{:p}\", &x);\n    println!(\"{}\", mem::size_of_val(&x));\n    x.push_str(\"我们\");\n    println!(\"{}\", x);\n    println!(\"{}\", mem::size_of_val(&x));\n    println!(\"{:?}-{}-{}\", x.as_ptr(), x.len(), x.capacity());\n    x.pop();\n    println!(\"{:?}-{}-{}\", x.as_ptr(), x.len(), x.capacity());\n    x.push('x');\n    println!(\"{:?}-{}-{}\", x.as_ptr(), x.len(), x.capacity());\n    // cap 这个显示的值和 内部实际预留空间,应该是不同, 参考go的设计\n    x.push_str(\"hello world python golang rust c++ c# java php\");\n    println!(\"{:?}-{}-{}\", x.as_ptr(), x.len(), x.capacity());\n}\n\n\n3.3.2 切片\nfn main() {\n    let s = String::from(\"hello\");\n    // [start_index..end_index]\n    let slice1 = &s[0..2];\n    let slice2 = &s[..2]; // 同上\n    println!(\"{}-{}\", slice1, slice2);\n\n    let len = s.len();\n\n    let slice3 = &s[3..len];\n    let slice4 = &s[3..]; //同上\n    println!(\"{}-{}\", slice3, slice4);\n\n    let slice5 = &s[0..len];\n    let slice6 = &s[..]; // 同上\n    println!(\"{}-{}\", slice5, slice6);\n}\n\n\n3.3.3 索引操作?\nString 类型无法进行 索引操作\nfn main() {\n    let s1 = String::from(\"hello\");\n    let h = s1[0]; // 报错\n}\n\n\n3.3.4 三种方式读取\nString 类型是对 Vec[u8]的一种包装\nfn main() {\n    let s1 = String::from(\"नमस्ते\");\n    println!(\"{}\", s1.len());\n    // 1. 以字节(byte) 的形式\n    for b in s1.bytes() {\n        println!(\"{b}\");\n    }\n    // 2. 以unicode 标量值(scalar values)的形式\n\n    // 打印了 每一个字(或字母)\n    for c in \"hello我们\".chars() {\n        println!(\"{}\", c);\n    }\n    // 但是 这个好像不对了,\n    // .chars()  用unicode 编码的方式来读取,按理说应该能读取到想要的字才对\n    // 毕竟 unicode 编码了全世界的字符(每个字符都有对应的unicode编码)\n    // 原因是 梵文中的某些字符可能由多个Unicode标量值组成，这些标量值在视觉上被视为一个整体\n    // 所以 这里只打印了 \"真正字符\"的一部分\n    for c in s1.chars() {\n        println!(\"{}\", c);\n    }\n    println!(\"=============\");\n    // 3. 获取真正更接近 字母的 字形簇 (grapheme clusters)\n    // 需要添加 第三方crate: cargo add unicode_segmentation\n    use unicode_segmentation::UnicodeSegmentation;\n    for grapheme in s1.graphemes(true) {\n        println!(\"{}\", grapheme);\n    }\n}\n\n\n\n3.4 字节字符串\n这个实际是字节数组\nuse std::any::type_name;\n\nfn print_type_of&lt;T&gt;(_: &T) {\n    println!(\"{}\", type_name::&lt;T&gt;());\n}\nfn main() {\n    let a = b\"hello\";\n    // &[u8; 5]  结果发现是 [u8;5] 这种数组的引用\n    print_type_of(&a);\n    let b = a as &[u8]; // 转切片\n}",
    "crumbs": [
      "基础篇",
      "集合"
    ]
  },
  {
    "objectID": "docs/rust/basic/05.enum-match.html",
    "href": "docs/rust/basic/05.enum-match.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "枚举是这样一种类型,允许你通过列举可能的成员(variants:变体)来定义一个类型\nenum IpAddrKind {\n    V4,\n    V6,\n}\n\nstruct IpAddr {\n    kind: IpAddrKind,\n    address: String,\n}\n\nfn main() {\n    // 下面2个的类型都是 IpAddrKind\n    // 他们的值,只能是枚举定义里的成员的其中一个\n    let four = IpAddrKind::V4;\n    let six = IpAddrKind::V6;\n    // 任何一个传给函数的参数类型是 IpAddrKind ,是ok的\n    route(IpAddrKind::V4);\n    route(IpAddrKind::V6);\n\n    let home = IpAddr {\n        kind: IpAddrKind::V4,\n        address: String::from(\"127.0.0.1\"),\n    };\n\n    let loopback = IpAddr {\n        kind: IpAddrKind::V6,\n        address: String::from(\"::1\"),\n    };\n}\n\nfn route(ip_kind: IpAddrKind) {}\n\n\n上面的例子中, 我们可能会问, 枚举的成员本身要是能携带数据岂不是更好?\nenum IpAddr {\n    // 可以设置携带不同类型的数据\n    // 就好像一个构造方法一样了\n    V4(u8, u8, u8, u8),\n    V6(String),\n}\nenum Message {\n    Quit,\n    // 像一个结构体一样\n    Move { x: i32, y: i32 },\n    Write(String),\n    ChangeColor(i32, i32, i32),\n}\n\nfn main() {\n    // 就好像调用了构造方法,返回类型 IpAddr的一个实例\n    let home = IpAddr::V4(127, 0, 0, 1);\n\n    let loopback = IpAddr::V6(String::from(\"::1\"));\n\n    let m = Message::Move { x: 22, y: 11 };\n}\n上面的message 的成员就好像 不同的 struct\nstruct QuitMessage; // unit struct\nstruct MoveMessage {\n    x: i32,\n    y: i32,\n}\nstruct WriteMessage(String); // tuple struct\nstruct ChangeColorMessage(i32, i32, i32); // tuple struct\n\n\n\n可以像 struct 一样 设置方法\nenum Message {\n    Quit,\n    // 像一个结构体一样\n    Move { x: i32, y: i32 },\n    Write(String),\n    ChangeColor(i32, i32, i32),\n    // hello(),\n}\nimpl Message {\n    // 方法\n    fn call(&self) {\n        // method body would be defined here\n    }\n    // 如果 Message的成员里有个成员名字和这个一样\n    // 那么 Message::hello()  会被认为是 成员,类型是Message\n    fn hello() {}\n}\n\nfn main() {\n    let m = Message::Write(String::from(\"hello\"));\n    m.call();\n    // 注意这里的f 的类型 是() 单元类型\n    let f = Message::hello();\n}\n\n\n\nrust 标准库里有一个 Option 枚举, 后面我们再讨论\n// 在rust 中用 Option 枚举来表示一个值是存在的还是缺失的\nenum Option&lt;T&gt; {\n    None,\n    // T 泛型, 这里说明Some这个成员可以携带任何数据\n    Some(T),\n}\n\n\n\n// An attribute to hide warnings for unused code.\n#![allow(dead_code)]\n\n// 从0开始自增\nenum Number {\n    Zero,\n    One,\n    Two,\n}\n// 从3 开始自增\nenum Number2 {\n    Zero = 3,\n    One,\n    Two,\n}\n\n// 明确指定值\nenum Color {\n    Red = 0xff0000,\n    Green = 0x00ff00,\n    Blue = 0x0000ff,\n}\n\nfn main() {\n    // `enums` 使用 as 进行转换, 获取数据.\n    println!(\"zero is {}\", Number::Zero as i32);\n    println!(\"one is {}\", Number::One as i32);\n    println!(\"number2 one is {}\", Number2::One as i32); //4\n    println!(\"number2 two is {}\", Number2::Two as i32); //5\n\n    println!(\"roses are #{:06x}\", Color::Red as i32);\n    println!(\"violets are #{:06x}\", Color::Blue as i32);\n}\n\n\n\n#![allow(dead_code)]\nenum Status {\n    Rich,\n    Poor,\n}\n\nfn main() {\n    // 使用use ,这样使用的时候,不用 写前面的 Status\n    // 可以这样, use crate::Status::*;\n    use crate::Status::{Poor, Rich};\n    // 等价于 `Status::Poor`.\n    let status = Poor;\n}",
    "crumbs": [
      "基础篇",
      "枚举和match"
    ]
  },
  {
    "objectID": "docs/rust/basic/05.enum-match.html#枚举",
    "href": "docs/rust/basic/05.enum-match.html#枚举",
    "title": "斯巴拉稀",
    "section": "",
    "text": "枚举是这样一种类型,允许你通过列举可能的成员(variants:变体)来定义一个类型\nenum IpAddrKind {\n    V4,\n    V6,\n}\n\nstruct IpAddr {\n    kind: IpAddrKind,\n    address: String,\n}\n\nfn main() {\n    // 下面2个的类型都是 IpAddrKind\n    // 他们的值,只能是枚举定义里的成员的其中一个\n    let four = IpAddrKind::V4;\n    let six = IpAddrKind::V6;\n    // 任何一个传给函数的参数类型是 IpAddrKind ,是ok的\n    route(IpAddrKind::V4);\n    route(IpAddrKind::V6);\n\n    let home = IpAddr {\n        kind: IpAddrKind::V4,\n        address: String::from(\"127.0.0.1\"),\n    };\n\n    let loopback = IpAddr {\n        kind: IpAddrKind::V6,\n        address: String::from(\"::1\"),\n    };\n}\n\nfn route(ip_kind: IpAddrKind) {}\n\n\n上面的例子中, 我们可能会问, 枚举的成员本身要是能携带数据岂不是更好?\nenum IpAddr {\n    // 可以设置携带不同类型的数据\n    // 就好像一个构造方法一样了\n    V4(u8, u8, u8, u8),\n    V6(String),\n}\nenum Message {\n    Quit,\n    // 像一个结构体一样\n    Move { x: i32, y: i32 },\n    Write(String),\n    ChangeColor(i32, i32, i32),\n}\n\nfn main() {\n    // 就好像调用了构造方法,返回类型 IpAddr的一个实例\n    let home = IpAddr::V4(127, 0, 0, 1);\n\n    let loopback = IpAddr::V6(String::from(\"::1\"));\n\n    let m = Message::Move { x: 22, y: 11 };\n}\n上面的message 的成员就好像 不同的 struct\nstruct QuitMessage; // unit struct\nstruct MoveMessage {\n    x: i32,\n    y: i32,\n}\nstruct WriteMessage(String); // tuple struct\nstruct ChangeColorMessage(i32, i32, i32); // tuple struct\n\n\n\n可以像 struct 一样 设置方法\nenum Message {\n    Quit,\n    // 像一个结构体一样\n    Move { x: i32, y: i32 },\n    Write(String),\n    ChangeColor(i32, i32, i32),\n    // hello(),\n}\nimpl Message {\n    // 方法\n    fn call(&self) {\n        // method body would be defined here\n    }\n    // 如果 Message的成员里有个成员名字和这个一样\n    // 那么 Message::hello()  会被认为是 成员,类型是Message\n    fn hello() {}\n}\n\nfn main() {\n    let m = Message::Write(String::from(\"hello\"));\n    m.call();\n    // 注意这里的f 的类型 是() 单元类型\n    let f = Message::hello();\n}\n\n\n\nrust 标准库里有一个 Option 枚举, 后面我们再讨论\n// 在rust 中用 Option 枚举来表示一个值是存在的还是缺失的\nenum Option&lt;T&gt; {\n    None,\n    // T 泛型, 这里说明Some这个成员可以携带任何数据\n    Some(T),\n}\n\n\n\n// An attribute to hide warnings for unused code.\n#![allow(dead_code)]\n\n// 从0开始自增\nenum Number {\n    Zero,\n    One,\n    Two,\n}\n// 从3 开始自增\nenum Number2 {\n    Zero = 3,\n    One,\n    Two,\n}\n\n// 明确指定值\nenum Color {\n    Red = 0xff0000,\n    Green = 0x00ff00,\n    Blue = 0x0000ff,\n}\n\nfn main() {\n    // `enums` 使用 as 进行转换, 获取数据.\n    println!(\"zero is {}\", Number::Zero as i32);\n    println!(\"one is {}\", Number::One as i32);\n    println!(\"number2 one is {}\", Number2::One as i32); //4\n    println!(\"number2 two is {}\", Number2::Two as i32); //5\n\n    println!(\"roses are #{:06x}\", Color::Red as i32);\n    println!(\"violets are #{:06x}\", Color::Blue as i32);\n}\n\n\n\n#![allow(dead_code)]\nenum Status {\n    Rich,\n    Poor,\n}\n\nfn main() {\n    // 使用use ,这样使用的时候,不用 写前面的 Status\n    // 可以这样, use crate::Status::*;\n    use crate::Status::{Poor, Rich};\n    // 等价于 `Status::Poor`.\n    let status = Poor;\n}",
    "crumbs": [
      "基础篇",
      "枚举和match"
    ]
  },
  {
    "objectID": "docs/rust/basic/05.enum-match.html#模式匹配pattern-match",
    "href": "docs/rust/basic/05.enum-match.html#模式匹配pattern-match",
    "title": "斯巴拉稀",
    "section": "2 模式匹配(pattern match)",
    "text": "2 模式匹配(pattern match)\n\n2.1 match\n\n2.1.1 枚举\n判断是枚举的哪个成员(变体)\nenum Coin {\n    Penny,\n    Nickel,\n    Dime(String),\n    Quarter,\n}\n\nfn main() {\n    let c = Coin::Penny;\n    let d = Coin::Dime(\"hello\".to_string());\n    let r = match d {\n        Coin::Penny =&gt; {\n            println!(\"Lucky penny!\");\n            1\n        }\n        Coin::Nickel =&gt; 5,\n        Coin::Dime(s) =&gt; {\n            println!(\"{}\", s); // 可以在这边获取枚举成员携带的数据\n            10 //返回值\n        }\n        // 必须把所有成员匹配都写上,否则报错, 去看 Pattern Syntax\n        Coin::Quarter =&gt; 25,\n    };\n    println!(\"{}\", r);\n}\n\n\n2.1.2 结构体\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nfn main() {\n    let p = Point { x: 10, y: 0 };\n\n    match p {\n        Point { x, y: 0 } =&gt; println!(\"y=0 才能匹配上 {}\", x),\n        Point { x, y: 0..=2 } =&gt; println!(\"y&gt;=0 &lt;=2 是才匹配上 {}\", x),\n        Point { x: 0, y } =&gt; println!(\"x=0 才能匹配上 {}\", y),\n        Point { x, y } =&gt; println!(\"都能匹配上 ({}, {})\", x, y),\n    }\n}\n\n\n\n2.2 if let\n相当于 使用 match ,然后只匹配一个成员,然后执行代码块, 更加简洁\n    let config_max = Some(3u8);\n    match config_max {\n        Some(max) =&gt; println!(\"The maximum is configured to be {}\", max),\n        _ =&gt; (),\n    }\nenum Number {\n    Zero,\n    One,\n    Two,\n}\nfn main() {\n    // Some 这个是Option&lt;t&gt; 枚举里的成员, 因为 默认 use了,所以可以直接拿来用\n    let config_max = Some(3u8);\n    // 相当于上面的 match 里不用写 _\n    if let Some(max) = config_max {\n        println!(\"The maximum is configured to be {}\", max);\n    }\n\n    let n = Number::One;\n    // else\n    if let Number::Two = n {\n        println!(\"{}\", 1);\n    } else {\n        println!(\"{}\", 2);\n    }\n}\n\n\n2.3 while let\nfn main() {\n    let mut optional = Some(0);\n\n    while let Some(i) = optional {\n        if i &gt; 9 {\n            println!(\"Greater than 9, quit!\");\n            optional = None;\n        } else {\n            println!(\"`i` is `{:?}`. Try again.\", i);\n            optional = Some(i + 1);\n        }\n    }\n}\n\n\n2.4 let 本身\nlet PATTERN = EXPRESSION;\nstruct Person {\n    name: String,\n    age: i32,\n}\nfn main() {\n    // 这种其实就是模式匹配\n    // x 就是pattern , 然后1 就是能匹配到的所有\n    let x = 1;\n    let a = (1, 2);\n    // 我们在其他语言也有看到这种,其实就是模式匹配\n    let (b, c) = a;\n    println!(\"{}-{}\", b, c);\n\n    let p1 = Person {\n        name: \"zhang fei\".to_string(),\n        age: 22,\n    };\n    let Person { name: n, age: m } = p1;\n    println!(\"{} : {}\", n, m);\n\n    let p2 = Person {\n        name: \"liu bei\".to_string(),\n        age: 32,\n    };\n    // 名字与字段名一样的情况,可以省略\n    let Person { name, age } = p2;\n    println!(\"{} : {}\", name, age);\n}\n函数参数的情况\nfn print_coordinates(&(x, y): &(i32, i32)) {\n    println!(\"Current location: ({}, {})\", x, y);\n}\n\nfn main() {\n    let point = (3, 5);\n    print_coordinates(&point);\n}\n\n\n2.5 ref\nref 是模式的一部分, 而 & 是借用运算符,是表达式的一部分\nfn main() {\n    let ref_c2 = &1;\n    // 等价上面,  如果是ref mut 就是可变借用了\n    let ref ref_c1 = 1;\n    println!(\"{}-{}\", *ref_c1, *ref_c2);\n\n\n}\n看一下这个例子, 报错了\nstruct Person {\n    name: String,\n    age: i32,\n}\nfn main() {\n    let p1 = Person {\n        name: \"zhang fei\".to_string(),\n        age: 22,\n    };\n    let Person { name: n, age: m } = p1;\n    println!(\"{} : {}\", n, m);\n\n    // 我们发现这里会报错,提示 p1.name 以及被move给前面的 n了\n    let Person { name, age } = p1;\n    println!(\"{} : {}\", name, age);\n}\n实际上,我们只需要 借用 p1的name,因为我们只需要它的值而已,不需要move, 我们使用ref\nstruct Person {\n    name: String,\n    age: i32,\n}\nfn main() {\n    let p1 = Person {\n        name: \"zhang fei\".to_string(),\n        age: 22,\n    };\n    // 我们发现这里会报错,提示 p1.name 以及被move给前面的 n了\n    let Person { ref name, age } = p1;\n    println!(\"{} : {}\", name, age);\n    // 这里 ref name 会错的, 似乎只能上面的简写方式里用ref?\n    let Person { name: n, age: m } = p1;\n    println!(\"{} : {}\", n, m);\n}\n再看个例子,下面报错了\nfn main() {\n    let x: Option&lt;String&gt; = Some(\"hello\".to_string());\n    match x {\n        Some(e) =&gt; println!(\"{}\", e),\n        _ =&gt; println!(\"other\"),\n    }\n    // x中的数据被转移所有权了. 给了e,所以这里报错了\n    println!(\"{:?}\", x);\n}\n添加ref\nfn main() {\n    let x: Option&lt;String&gt; = Some(\"hello\".to_string());\n    match x {\n        // 加上ref ,表示这里e 是 借用了 x里面的数据\n        // x 数据是完整的, 后面就不会报错了.\n        Some(ref e) =&gt; println!(\"hello{}\", e),\n        _ =&gt; println!(\"other\"),\n    }\n\n    println!(\"{:?}\", x);\n}\n\n\n2.6 Pattern Syntax\n\n2.6.1 .. 剩余\nstruct Point {\n    x: i32,\n    y: i32,\n    z: i32,\n}\nfn main() {\n    let (a, ..) = (1, 2, 3, 4, 5);\n    println!(\"{}\", a); // 1\n    let (b, .., c) = (1, 2, 3, 4, 5);\n    println!(\"{}-{}\", b, c); // 1-5\n\n    // 结构体 不能 将.. 放中间\n    let Point { x: x1, .. } = Point {\n        x: 11,\n        y: 22,\n        z: 33,\n    };\n    println!(\"{}\", x1); // 1\n}\n\n\n2.6.2 _ 忽略绑定\nfn main() {\n    let (_, x, _) = (1, 2, 3);\n    println!(\"{}\", x);\n\n    let y = Some(String::from(\"hello\"));\n    // - 没有绑定, 所以没有move,后面的y打印不会报错\n    if let Some(_) = y {\n        println!(\"ss\");\n    };\n    println!(\"{:?}\", y);\n}\n\n\n2.6.3 _ 剩余部分\n成员不用全部写上的方式\nenum Coin {\n    Penny,\n    Nickel,\n    Dime(String),\n    Quarter,\n}\n\nfn main() {\n    let d = Coin::Dime(\"hello\".to_string());\n    let r = match d {\n        Coin::Penny =&gt; {\n            println!(\"Lucky penny!\");\n            1\n        }\n        // 用other 表示其他情况\n        other =&gt; 666,\n    };\n    println!(\"{}\", r);\n}\n使用_来表示不匹配的情况,这里的和枚举显然不一样,在枚举里如果要写,是肯定能匹配上的,这里是完全可能匹配不上,所以用 _ 来区分 前面用的other.\n其实都用 _ 就行\nfn main() {\n    let d = 3;\n    let r = match d {\n        1 =&gt; 11,\n        2 =&gt; 22,\n        _ =&gt; 888,\n    };\n    println!(\"{}\", r);\n}\n\n\n2.6.4 | 和 if\nfn main() {\n    let x = 4;\n    let y = true;\n\n    match x {\n        // 或者等4或5,或6 并且 y为真才行, y是外部定义的那个y\n        4 | 5 | 6 if y =&gt; println!(\"yes\"),\n        7 | 8 =&gt; println!(\"7-8\"),\n        _ =&gt; println!(\"no\"),\n    }\n}\nfn main() {\n    let x = Some(5);\n    let y = 5;\n\n    match x {\n        Some(50) =&gt; println!(\"50\"),\n        // ==y 的y 是外部 定义的 y =5\n        // Some(y) 的y 与外部无关\n        Some(y) if y == y =&gt; {\n            println!(\"Matched, n = {}\", y)\n        }\n        _ =&gt; println!(\"Default case, x = {:?}\", x),\n    }\n}\n\n\n2.6.5 ..= 范围\n&gt;=xx &lt;=yy\nfn main() {\n    let x = 5i32;\n\n    match x {\n        1..=5 =&gt; println!(\"&gt;=1 &lt;=5\"),\n        _ =&gt; println!(\"something else\"),\n    }\n    println!(\"i32最小值{}\", i32::MIN);\n    match x {\n        i32::MIN..=2_i32 =&gt; println!(\"&lt;=2\"),\n        3 =&gt; println!(\"=3\"),\n        4 =&gt; println!(\"=4\"),\n        5_i32..=i32::MAX =&gt; println!(\"&gt;=5\"),\n    };\n}\n\n\n2.6.6 @\nenum Student {\n    primary { age: i32 },\n    junior { age: i32 },\n}\nfn main() {\n    let s = Student::primary { age: 3 };\n\n    match s {\n        Student::primary { age: primary_age } if primary_age &gt;= 7 && primary_age &lt;= 11 =&gt; {\n            println!(\"Hello\")\n        }\n        // 相当于上面 primary_age &gt;= 3 && primary_age &lt;= 6\n        // @前面是绑定的变量\n        Student::primary {\n            age: primary_age @ 3..=6,\n        } =&gt; println!(\"是 &gt;=3 &lt;=6 岁的小学生: {}\", primary_age),\n        Student::junior { age: 10..=12 } =&gt; {\n            println!(\"10-12 岁的初中生\")\n        }\n        Student::junior { age } =&gt; println!(\"Found: {}\", age),\n        _ =&gt; (),\n    }\n}\nfn main() {\n    let x = 11;\n    match x {\n        // | 多个情况 绑定\n        e @ 11 | e @ 1..=3 =&gt; println!(\"{}\", e),\n        _ =&gt; println!(\"other\"),\n    }\n}",
    "crumbs": [
      "基础篇",
      "枚举和match"
    ]
  },
  {
    "objectID": "docs/rust/basic/15.concurrency.html",
    "href": "docs/rust/basic/15.concurrency.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "rust 标准库就提供1:1 模型的实现, 第三方crate 有m:n模型的实现",
    "crumbs": [
      "基础篇",
      "并发"
    ]
  },
  {
    "objectID": "docs/rust/basic/15.concurrency.html#实现模型",
    "href": "docs/rust/basic/15.concurrency.html#实现模型",
    "title": "斯巴拉稀",
    "section": "",
    "text": "rust 标准库就提供1:1 模型的实现, 第三方crate 有m:n模型的实现",
    "crumbs": [
      "基础篇",
      "并发"
    ]
  },
  {
    "objectID": "docs/rust/basic/15.concurrency.html#使用线程",
    "href": "docs/rust/basic/15.concurrency.html#使用线程",
    "title": "斯巴拉稀",
    "section": "2 使用线程",
    "text": "2 使用线程\nuse std::thread;\nuse std::time::Duration;\n\nfn main() {\n\n    thread::spawn(|| {\n        for i in 1..10 {\n            println!(\"hi number {} from the spawned thread!\", i);\n            thread::sleep(Duration::from_millis(1));\n        }\n    });\n\n    for i in 1..5 {\n        println!(\"hi number {} from the main thread!\", i);\n        thread::sleep(Duration::from_millis(1));\n    }\n}\n线程没有完全执行完,就退出了\n等待线程完成\nuse std::thread;\nuse std::time::Duration;\n\nfn main() {\n    //thread::spawn 的返回类型是 JoinHandle,它有值的所有权\n    let handle = thread::spawn(|| {\n        for i in 1..10 {\n            println!(\"hi number {} from the spawned thread!\", i);\n            thread::sleep(Duration::from_millis(1));\n        }\n    });\n\n    for i in 1..5 {\n        println!(\"hi number {} from the main thread!\", i);\n        thread::sleep(Duration::from_millis(1));\n    }\n    // 等待其他线程执行完成\n    handle.join().unwrap();\n}",
    "crumbs": [
      "基础篇",
      "并发"
    ]
  },
  {
    "objectID": "docs/rust/basic/15.concurrency.html#move-闭包",
    "href": "docs/rust/basic/15.concurrency.html#move-闭包",
    "title": "斯巴拉稀",
    "section": "3 move 闭包",
    "text": "3 move 闭包\n报错\nuse std::thread;\n\nfn main() {\n    let v = vec![1, 2, 3];\n    // 闭包使用外部数据,是一种借用\n    // rust无法确定 子线程什么时候结束, 而线程使用的借用数据可能被其他线程修改(比如主线程),这样就有问题了\n    let handle = thread::spawn(|| {\n        println!(\"Here's a vector: {:?}\", v);\n    });\n\n    handle.join().unwrap();\n}\n使用move\nuse std::thread;\n\nfn main() {\n    let v = vec![1, 2, 3];\n    // v的所有权被move到闭包中\n    let handle = thread::spawn(move || {\n        println!(\"Here's a vector: {:?}\", v);\n    });\n    // println!(\"{:?}\", v);  // 提示v 已经被move了, 无法借用\n    handle.join().unwrap();\n}",
    "crumbs": [
      "基础篇",
      "并发"
    ]
  },
  {
    "objectID": "docs/rust/basic/15.concurrency.html#channel-使用消息传递",
    "href": "docs/rust/basic/15.concurrency.html#channel-使用消息传递",
    "title": "斯巴拉稀",
    "section": "4 channel 使用消息传递",
    "text": "4 channel 使用消息传递\n类似go的channel, 线程之间通过发送消息来通信\nmpsc : multiple producer, single consumer\nuse std::sync::mpsc;\nuse std::thread;\n\nfn main() {\n    //tx 发送端, rx 接收端\n    let (tx, rx) = mpsc::channel();\n\n    thread::spawn(move || {\n        let val = String::from(\"hi\");\n        // send() 返回    Result&lt;T, E&gt;\n        tx.send(val).unwrap();\n    });\n    // recv 会堵塞, 直到channel 有数据发送过来\n    // 成功返回 Result&lt;T,E&gt; 发送端关闭,会返回错误\n    let received = rx.recv().unwrap();\n    println!(\"Got: {}\", received);\n}\n使用for in来接收数据\nuse std::sync::mpsc;\nuse std::thread;\nuse std::time::Duration;\n\nfn main() {\n    let (tx, rx) = mpsc::channel();\n\n    thread::spawn(move || {\n        let vals = vec![\n            String::from(\"hi\"),\n            String::from(\"from\"),\n            String::from(\"the\"),\n            String::from(\"thread\"),\n        ];\n\n        for val in vals {\n            tx.send(val).unwrap();\n            thread::sleep(Duration::from_secs(1));\n        }\n    });\n\n    for received in rx {\n        println!(\"Got: {}\", received);\n    }\n}\n多个生产者\nuse std::sync::mpsc;\nuse std::thread;\nuse std::time::Duration;\n\nfn main() {\n    // --snip--\n\n    let (tx, rx) = mpsc::channel();\n\n    let tx1 = tx.clone();\n    thread::spawn(move || {\n        let vals = vec![\n            String::from(\"hi\"),\n            String::from(\"from\"),\n            String::from(\"the\"),\n            String::from(\"thread\"),\n        ];\n\n        for val in vals {\n            tx1.send(val).unwrap();\n            thread::sleep(Duration::from_secs(1));\n        }\n    });\n\n    thread::spawn(move || {\n        let vals = vec![\n            String::from(\"more\"),\n            String::from(\"messages\"),\n            String::from(\"for\"),\n            String::from(\"you\"),\n        ];\n\n        for val in vals {\n            tx.send(val).unwrap();\n            thread::sleep(Duration::from_secs(1));\n        }\n    });\n\n    for received in rx {\n        println!(\"Got: {}\", received);\n    }\n}",
    "crumbs": [
      "基础篇",
      "并发"
    ]
  },
  {
    "objectID": "docs/rust/basic/15.concurrency.html#共享状态的并发",
    "href": "docs/rust/basic/15.concurrency.html#共享状态的并发",
    "title": "斯巴拉稀",
    "section": "5 共享状态的并发",
    "text": "5 共享状态的并发\nShared-State Concurrency\n多所有权, 多个线程同时访问一块内存 ### Mutex\nuse std::sync::Mutex;\n\nfn main() {\n    // 返回Mutex&lt;T&gt;  也是智能指针\n    let m = Mutex::new(5);\n\n    {\n        // 通过.lock() 获取锁, 如果获取不到,就会阻塞当前线程\n        // 返回值是 MutexGuard 类型,它实现了 Deref trait 和Drop trait\n        let mut num = m.lock().unwrap();\n        *num = 6;\n        // 报错, 锁还没释放, 下面的代码不能执行\n        // let mut num2 = m.lock().unwrap();\n    }\n    // 这里 m 已经释放锁(drop 操作), 下面的代码可以执行\n    let mut num2 = m.lock().unwrap();\n\n    println!(\"m = {:?}\", m);\n}\n\n5.1 Rc? 多个线程send\n报错了, rc 是不能在线程间安全发送,因为没有实现 Send trait\nuse std::rc::Rc;\nuse std::sync::Mutex;\nuse std::thread;\n\nfn main() {\n    let counter = Rc::new(Mutex::new(0));\n    let mut handles = vec![];\n\n    for _ in 0..10 {\n        let counter = Rc::clone(&counter);\n        let handle = thread::spawn(move || {\n            let mut num = counter.lock().unwrap();\n\n            *num += 1;\n        });\n        handles.push(handle);\n    }\n\n    for handle in handles {\n        handle.join().unwrap();\n    }\n\n    println!(\"Result: {}\", *counter.lock().unwrap());\n}\n\n\n5.2 Arc\nArc= atomic rc\nuse std::sync::{Arc, Mutex};\nuse std::thread;\n\nfn main() {\n    let counter = Arc::new(Mutex::new(0));\n    let mut handles = vec![];\n\n    for _ in 0..10 {\n        let counter = Arc::clone(&counter);\n        let handle = thread::spawn(move || {\n            let mut num = counter.lock().unwrap();\n\n            *num += 1;\n        });\n        handles.push(handle);\n    }\n\n    for handle in handles {\n        handle.join().unwrap();\n    }\n\n    println!(\"Result: {}\", *counter.lock().unwrap());\n}",
    "crumbs": [
      "基础篇",
      "并发"
    ]
  },
  {
    "objectID": "docs/rust/basic/15.concurrency.html#send-sync-trait",
    "href": "docs/rust/basic/15.concurrency.html#send-sync-trait",
    "title": "斯巴拉稀",
    "section": "6 Send Sync trait",
    "text": "6 Send Sync trait\n\nSend\n\n实现Send trait的类型, 就可以线程间转移所有权\n几乎所有类型都实现了Send, 但是Rc 没有实现,它只能用于单线程\n由Send 成员组成的类型 也是Send\n\nSync\n\n实现Sync trait的类型,可以安全的被多线程引用\nT 是 Sync, 那么 &T 就是 Send\n基础类型都实现了 Sync, 完全由Sync组成的类型 也是Sync\nRc,RefCell, Cell不是 Sync, Mutex是Sync\n\n\n手动实现Send和Sync 是很难做到安全的",
    "crumbs": [
      "基础篇",
      "并发"
    ]
  },
  {
    "objectID": "docs/rust/basic/16.unsafe.html",
    "href": "docs/rust/basic/16.unsafe.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "之前我们说到的代码都是安全的,(就是编译器编译时会做检查,确保内存安全).",
    "crumbs": [
      "基础篇",
      "unsafe"
    ]
  },
  {
    "objectID": "docs/rust/basic/16.unsafe.html#解引用原始指针",
    "href": "docs/rust/basic/16.unsafe.html#解引用原始指针",
    "title": "斯巴拉稀",
    "section": "1 解引用原始指针",
    "text": "1 解引用原始指针\n\nstruct Two {\n    first: i8,\n    second: i8,\n}\nfn main() {\n    //  0000 0011  0000 1001\n    let mut num = 777;\n    let r1 = &num as *const i32 as *const i8;\n    // 想一下 golang\n    let r2 = &num as *const i32 as *const Two;\n\n    let r3 = &mut num as *mut i32;\n    // 解引用的时候,需要unsafe 包裹\n    unsafe {\n        println!(\"num第一个字节==&gt; r1 is: {}\", *r1); // 9\n        let f = r1.wrapping_add(1);\n        println!(\"num第二个字节==&gt;f is :{}\", *f); //3\n\n        println!(\"num第一个字节==&gt; r1 is: {:?}\", (*r2).first); // 9\n        println!(\"num第二个字节==&gt;f is :{}\", (*r2).second); //3\n\n        println!(\"r2 is: {}\", *r3);\n    }\n    // 可以指向不合理的内存地址\n    let address = 0x012345usize;\n    let r = address as *const i32;\n}",
    "crumbs": [
      "基础篇",
      "unsafe"
    ]
  },
  {
    "objectID": "docs/rust/basic/16.unsafe.html#调用unsafe函数或方法",
    "href": "docs/rust/basic/16.unsafe.html#调用unsafe函数或方法",
    "title": "斯巴拉稀",
    "section": "2 调用unsafe函数或方法",
    "text": "2 调用unsafe函数或方法\n\n\n\n\n\n\nTip\n\n\n\nunsafe函数或方法: 就是在定义前面加上unsafe关键字.\n\n\nunsafe fn dangerous() {}\nfn main() {\n    unsafe {\n        dangerous();\n    }\n}\n函数或方法内部有unsafe代码块,调用这样的函数或方法,不需要unsafe包裹.\nfn main() {\n    let mut v = vec![1, 2, 3, 4, 5, 6];\n\n    let r = &mut v[..];\n    // 切分成2个切片 [0,mid) [mid,len)\n    // split_at_mut 方法里面有 unsafe 代码块, 但是我们这里调用的时候 不需要unsafe\n    let (a, b) = r.split_at_mut(3);\n\n    assert_eq!(a, &mut [1, 2, 3]);\n    assert_eq!(b, &mut [4, 5, 6]);\n}\nsplit_at_mut\nuse std::slice;\n\nfn split_at_mut(values: &mut [i32], mid: usize) -&gt; (&mut [i32], &mut [i32]) {\n    let len = values.len();\n    let ptr = values.as_mut_ptr();\n\n    assert!(mid &lt;= len);\n\n    unsafe {\n        (\n            slice::from_raw_parts_mut(ptr, mid),\n            slice::from_raw_parts_mut(ptr.add(mid), len - mid),\n        )\n    }\n}\nuse std::slice;\nfn main() {\n    let mut a = [1, 2, 3, 4, 5];\n    let b = &mut a;\n    let r = b as *mut i32; // a.as_mut_ptr()\n    let values: &[i32] = unsafe { slice::from_raw_parts_mut(r, 2) };\n    println!(\"{:?}\", values);\n}\n\n2.1 extern 调用外部函数(FFI)\nFFI: 外部函数接口, 可以让一种编程语言定义函数,然后其他语言可以调用\nrust 调用C\nextern \"C\" {\n    // 我们想要调用的外部函数的名称和参数返回值定义\n    fn abs(input: i32) -&gt; i32;\n}\n\nfn main() {\n    unsafe {\n        println!(\"Absolute value of -3 according to C: {}\", abs(-3));\n    }\n}\n其他语言调用rust\n#[no_mangle]\npub extern \"C\" fn call_from_c() {\n    println!(\"Just called a Rust function from C!\");\n}",
    "crumbs": [
      "基础篇",
      "unsafe"
    ]
  },
  {
    "objectID": "docs/rust/basic/16.unsafe.html#读写可变的静态变量",
    "href": "docs/rust/basic/16.unsafe.html#读写可变的静态变量",
    "title": "斯巴拉稀",
    "section": "3 读写可变的静态变量",
    "text": "3 读写可变的静态变量\n// 类型要指定\nstatic HELLO_WORLD: &str = \"Hello, world!\";\n\nstatic mut COUNTER: u32 = 0;\n\nfn add_to_count(inc: u32) {\n    unsafe {\n        COUNTER += inc;\n    }\n}\n\nfn main() {\n    add_to_count(3);\n\n    unsafe {\n        println!(\"COUNTER: {}\", COUNTER);\n    }\n}\nstatic mut COUNTER: u32 = 0;\nconst COUNTER2: i32 = 1;\nstatic mut S1: &str = \"bello\";\nconst S2: &str = \"bello\";\nfn main() {\n    let a = 1;\n    println!(\"{:p}\", &a);\n    let b = Box::new(5);\n    let c = Box::into_raw(b);\n    println!(\"{:p}\", c);\n    unsafe {\n        println!(\"{}\", *c);\n    }\n\n    println!(\"{:p}\", &COUNTER2);\n    unsafe {\n        println!(\"{:p}\", &COUNTER);\n    }\n    unsafe {\n        let s11 = S1.as_ptr();\n        println!(\"{:p}\", s11);\n        println!(\"{}\", *s11);\n        S1 = \"aorld\";\n        let s11 = S1.as_ptr();\n        // let s11 = S1.as_ptr() as *mut u8;\n        println!(\"{:p}\", s11);\n        println!(\"{}\", *s11);\n        let s22 = S2.as_ptr();\n        println!(\"s22={:p}\", s22);\n        println!(\"*s22={}\", *s22);\n    }\n\n    // {\n    //     static mut COUNTER3: u32 = 3;\n    // }\n    // println!(\"{}\", &COUNTER3);\n}",
    "crumbs": [
      "基础篇",
      "unsafe"
    ]
  },
  {
    "objectID": "docs/rust/basic/16.unsafe.html#实现unsafe-trait",
    "href": "docs/rust/basic/16.unsafe.html#实现unsafe-trait",
    "title": "斯巴拉稀",
    "section": "4 实现unsafe trait",
    "text": "4 实现unsafe trait\nunsafe trait Foo {\n    // methods go here\n}\n\nunsafe impl Foo for i32 {\n    // method implementations go here\n}\n\nfn main() {}",
    "crumbs": [
      "基础篇",
      "unsafe"
    ]
  },
  {
    "objectID": "docs/rust/async/01.future.html",
    "href": "docs/rust/async/01.future.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "async-std tokio https://tokio.rs/tokio/tutorial\n\n\n\n Back to top"
  },
  {
    "objectID": "docs/rust/web/actix-web/index.html#footnotes",
    "href": "docs/rust/web/actix-web/index.html#footnotes",
    "title": "斯巴拉稀",
    "section": "Footnotes",
    "text": "Footnotes\n\n\ngithubhttps://actix.rs/docs/↩︎"
  },
  {
    "objectID": "docs/rust/web/test2.html",
    "href": "docs/rust/web/test2.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "web test2 ## tt ff"
  },
  {
    "objectID": "docs/rust/web/test2.html#tttt",
    "href": "docs/rust/web/test2.html#tttt",
    "title": "斯巴拉稀",
    "section": "",
    "text": "web test2 ## tt ff"
  },
  {
    "objectID": "docs/rust/advanced/01.mem.html",
    "href": "docs/rust/advanced/01.mem.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "以1个字节1个字节的方式来读写原本4个字节类型的内存空间\n\n\n\n\n\nfn main() {\n    // 10 00000100 00000011 00000001\n    let mut a = 33817345i32;\n    struct FourI8 {\n        first: i8,\n        second: i8,\n        third: i8,\n        fourth: i8,\n    }\n    let b = &mut a as *mut i32 as *mut FourI8;\n    unsafe {\n        println!(\n            \"{} {} {} {}\",\n            (*b).first,\n            (*b).second,\n            (*b).third,\n            (*b).fourth\n        );\n        (*b).first = 2;\n        // 10 00000100 00000011 00000010\n        println!(\"{:b}\", a);\n    }\n}",
    "crumbs": [
      "进阶",
      "内存"
    ]
  },
  {
    "objectID": "docs/rust/advanced/01.mem.html#类型",
    "href": "docs/rust/advanced/01.mem.html#类型",
    "title": "斯巴拉稀",
    "section": "",
    "text": "以1个字节1个字节的方式来读写原本4个字节类型的内存空间\n\n\n\n\n\nfn main() {\n    // 10 00000100 00000011 00000001\n    let mut a = 33817345i32;\n    struct FourI8 {\n        first: i8,\n        second: i8,\n        third: i8,\n        fourth: i8,\n    }\n    let b = &mut a as *mut i32 as *mut FourI8;\n    unsafe {\n        println!(\n            \"{} {} {} {}\",\n            (*b).first,\n            (*b).second,\n            (*b).third,\n            (*b).fourth\n        );\n        (*b).first = 2;\n        // 10 00000100 00000011 00000010\n        println!(\"{:b}\", a);\n    }\n}",
    "crumbs": [
      "进阶",
      "内存"
    ]
  },
  {
    "objectID": "docs/rust/advanced/01.mem.html#内存对齐",
    "href": "docs/rust/advanced/01.mem.html#内存对齐",
    "title": "斯巴拉稀",
    "section": "2 内存对齐",
    "text": "2 内存对齐\n\n代码可能的对齐方式一可能的对齐方式二实际测试结果\n\n\nstruct A {\n    a: u8,\n    b: u32,\n    c: u16,\n}\n\n\n// 这种对齐 12个字节\nstruct A {\n    a: u8,\n    _pad1: [u8; 3], // to align `b`\n    b: u32,\n    c: u16,\n    _pad2: [u8; 2], // to make overall size multiple of 4\n}\n\n\n// 这种对齐 8个字节\nstruct A {\n    b: u32,\n    c: u16,\n    a: u8,\n    _pad: u8,\n}\n\n\nuse std::mem;\n\nstruct A {\n    a: u8,\n    b: u32,\n    c: u16,\n}\n\nfn main() {\n    let x = A { a: 1, b: 2, c: 3 };\n    println!(\"{}\", mem::size_of_val(&x)); // 8\n    // 0x0x7ff7bf6930be-0x0x7ff7bf6930b8-0x0x7ff7bf6930bc\n    // 也就是说实际优化成\n    struct A {\n        b: u32,\n        c: u16,\n        a: u8,\n    }\n    println!(\"0x{:p}-0x{:p}-0x{:p}\", &x.a, &x.b, &x.c);\n}",
    "crumbs": [
      "进阶",
      "内存"
    ]
  },
  {
    "objectID": "docs/rust/advanced/01.mem.html#union",
    "href": "docs/rust/advanced/01.mem.html#union",
    "title": "斯巴拉稀",
    "section": "3 union",
    "text": "3 union\n\nunion是一种允许在相同的内存位置存储多种类型的数据结构\n因此该类型大小等于内存占用最大的那个成员的内存大小\n\nunion MyUnion {\n    j: i32,\n    i: i8,\n}\n\nfn main() {\n    let mut my_union = MyUnion { j: 260 };\n    // 把它当作i32整型来使用, 需要 unsafe 块，因为这可能涉及内存重新解释\n    // 和前面类型章节中,我们一个字节一个字节的方式去重新读原本4个字节类型的内存空间一个道理\n    println!(\"j value: {}\", unsafe { my_union.j });\n    // 我们直接打印 i 看看,发现 是260 低位的一个字节的值\n    println!(\"i value: {}\", unsafe { my_union.i });\n    // 注意：在访问了union的一个字段后，访问其他字段之前,最好先进行“重置”或明确知道内存布局\n    // 否则可能会读取到无效的、未初始化的或者非预期的数据\n    my_union.i = 3;\n    println!(\"j value: {}\", unsafe { my_union.j }); // 259\n}",
    "crumbs": [
      "进阶",
      "内存"
    ]
  },
  {
    "objectID": "docs/rust/advanced/01.mem.html#enum",
    "href": "docs/rust/advanced/01.mem.html#enum",
    "title": "斯巴拉稀",
    "section": "4 enum",
    "text": "4 enum\n\n\n\n\n\n\n\n例子1,运行看看, 然后取消注释b257再运行\n\n\n\n\n\nenum Cat {\n    b1,\n    b2,\n    b3,\n    b4,\n    b5,\n    b6,\n    b7,\n    b8,\n    b9,\n    b10,\n    b11,\n    b12,\n    b13,\n    b14,\n    b15,\n    b16,\n    b17,\n    b18,\n    b19,\n    b20,\n    b21,\n    b22,\n    b23,\n    b24,\n    b25,\n    b26,\n    b27,\n    b28,\n    b29,\n    b30,\n    b31,\n    b32,\n    b33,\n    b34,\n    b35,\n    b36,\n    b37,\n    b38,\n    b39,\n    b40,\n    b41,\n    b42,\n    b43,\n    b44,\n    b45,\n    b46,\n    b47,\n    b48,\n    b49,\n    b50,\n    b51,\n    b52,\n    b53,\n    b54,\n    b55,\n    b56,\n    b57,\n    b58,\n    b59,\n    b60,\n    b61,\n    b62,\n    b63,\n    b64,\n    b65,\n    b66,\n    b67,\n    b68,\n    b69,\n    b70,\n    b71,\n    b72,\n    b73,\n    b74,\n    b75,\n    b76,\n    b77,\n    b78,\n    b79,\n    b80,\n    b81,\n    b82,\n    b83,\n    b84,\n    b85,\n    b86,\n    b87,\n    b88,\n    b89,\n    b90,\n    b91,\n    b92,\n    b93,\n    b94,\n    b95,\n    b96,\n    b97,\n    b98,\n    b99,\n    b100,\n    b101,\n    b102,\n    b103,\n    b104,\n    b105,\n    b106,\n    b107,\n    b108,\n    b109,\n    b110,\n    b111,\n    b112,\n    b113,\n    b114,\n    b115,\n    b116,\n    b117,\n    b118,\n    b119,\n    b120,\n    b121,\n    b122,\n    b123,\n    b124,\n    b125,\n    b126,\n    b127,\n    b128,\n    b129,\n    b130,\n    b131,\n    b132,\n    b133,\n    b134,\n    b135,\n    b136,\n    b137,\n    b138,\n    b139,\n    b140,\n    b141,\n    b142,\n    b143,\n    b144,\n    b145,\n    b146,\n    b147,\n    b148,\n    b149,\n    b150,\n    b151,\n    b152,\n    b153,\n    b154,\n    b155,\n    b156,\n    b157,\n    b158,\n    b159,\n    b160,\n    b161,\n    b162,\n    b163,\n    b164,\n    b165,\n    b166,\n    b167,\n    b168,\n    b169,\n    b170,\n    b171,\n    b172,\n    b173,\n    b174,\n    b175,\n    b176,\n    b177,\n    b178,\n    b179,\n    b180,\n    b181,\n    b182,\n    b183,\n    b184,\n    b185,\n    b186,\n    b187,\n    b188,\n    b189,\n    b190,\n    b191,\n    b192,\n    b193,\n    b194,\n    b195,\n    b196,\n    b197,\n    b198,\n    b199,\n    b200,\n    b201,\n    b202,\n    b203,\n    b204,\n    b205,\n    b206,\n    b207,\n    b208,\n    b209,\n    b210,\n    b211,\n    b212,\n    b213,\n    b214,\n    b215,\n    b216,\n    b217,\n    b218,\n    b219,\n    b220,\n    b221,\n    b222,\n    b223,\n    b224,\n    b225,\n    b226,\n    b227,\n    b228,\n    b229,\n    b230,\n    b231,\n    b232,\n    b233,\n    b234,\n    b235,\n    b236,\n    b237,\n    b238,\n    b239,\n    b240,\n    b241,\n    b242,\n    b243,\n    b244,\n    b245,\n    b246,\n    b247,\n    b248,\n    b249,\n    b250,\n    b251,\n    b252,\n    b253,\n    b254,\n    b255,\n    b256,\n    // b257,\n}\nfn main() {\n    let x = Cat::b1;\n    println!(\"{}\", mem::size_of::&lt;Cat&gt;());\n}\n\n\n\n\n\n\n\n\n\n例子2\n\n\n\n\n\n\ncode内存结构图\n\n\nenum Cat {\n    Tiger(i32), //tag =0\n    Lion(i8),  // tag =1\n    Dog(i16), // tag =2\n}\n\nuse std::mem;\nfn main() {\n    let lion = Cat::Lion(66);\n    println!(\"lion : {}\", mem::size_of_val(&lion)); // 8\n    unsafe {\n        let d = &lion as *const Cat as *const u64;\n        //0x4201 --&gt; 0x42=66 这个是data 0x01=1 这个是tag\n        //实际: 第一个字节存tag, 第二个字节存携带的数据 (因为这里Lion携带的数据是i8用一个字节就行了)\n        println!(\"0x{:x}\", *d);\n    }\n    let dog = Cat::Dog(66);\n    println!(\"Dog : {}\", mem::size_of_val(&dog));  // 8\n    unsafe {\n        let d = &dog as *const Cat as *const u64;\n        //0x420002 --&gt; 0x42=66 这个是data 0x0002 这个是tag\n        //Dog 携带的数据是i16  是2个字节, 所以这里tag和携带的数据各占用两个字节\n        println!(\"0x{:x}\", *d);\n    }\n\n    let tiger = Cat::Tiger(66);\n    println!(\"Tiger : {}\", mem::size_of_val(&tiger)); // 8\n    unsafe {\n        let d = &tiger as *const Cat as *const u64;\n        //0x4200000000 --&gt; 0x42=66 , 0x00 这个是tag\n        println!(\"0x{:x}\", *d);\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n例子3: 我们来看看枚举中变体携带String的情况\n\n\n\n\n\n\ncode内存结构图\n\n\nenum Message {\n    Quit,                    // 不需要占用内存空间, 0\n    Move { x: i32, y: i32 }, // 8bytes\n    Write(String),           // 24\n    ChangeColor(i32, i32, i32), // 12\n    // Read(String),\n}\nstruct enumStringStruct {\n    a: u64,\n    b: u64,\n    c: u64,\n    // d: u64,\n}\n\nfn main() {\n    let mut s = \"hello\".to_string();\n    println!(\"{}-{}\", s.len(), s.capacity());\n    s.push_str(\"x\");\n    println!(\"{}-{}\", s.len(), s.capacity());\n    println!(\"{:p}\", s.as_ptr()); //0x7f8144705f90\n    let m = Message::Write(s);\n    println!(\"{}\", mem::size_of_val(&m)); // 24\n    let b = &m as *const Message as *const enumStringStruct;\n    unsafe {\n        // 发现没有 这个 携带String的没有tag信息, 无tag信息来表示这个是携带String的变体\n        // 0xa-0x7f8144705f90-0x6\n        println!(\"Write: 0x{:x}-0x{:x}-0x{:x}\", (*b).a, (*b).b, (*b).c);\n    }\n    // 取消注释掉下面的代码, 和上面定义的枚举Message中的Read(String) 变体 ,再看看,会发现有各自的tag信息, 总体的内存占用变为32个字节了\n    //---\n    // let mut s = \"hello\".to_string();\n    // s.push_str(\"x\");\n    // println!(\"{:p}\", s.as_ptr()); \n    // let m = Message::Read(s);\n    // println!(\"{}\", mem::size_of_val(&m)); // 24\n    // let b = &m as *const Message as *const enumStringStruct;\n    // unsafe {\n    //     println!(\n    //         \"Read: 0x{:x}-0x{:x}-0x{:x}\",\n    //         (*b).a,\n    //         (*b).b,\n    //         (*b).c,\n    //         (*b).d\n    //     );\n    // }\n    //---\n    let m = Message::Move { x: 11, y: 22 };\n    println!(\"{}\", mem::size_of_val(&m)); // 24\n    let b = &m as *const Message as *const enumStringStruct;\n    unsafe {\n        //                tag    y       x\n        // 0x8000000000000001-0x160000000b-0x0\n        println!(\"Move: 0x{:x}-0x{:x}-0x{:x}\", (*b).a, (*b).b, (*b).c);\n    }\n\n    let m = Message::ChangeColor(6, 7, 8);\n    println!(\"{}\", mem::size_of_val(&m)); // 24\n    let b = &m as *const Message as *const enumStringStruct;\n    unsafe {\n        //                tag   7       6   8\n        // 0x8000000000000003-0x700000006-0x8\n        println!(\"ChangeColor: 0x{:x}-0x{:x}-0x{:x}\", (*b).a, (*b).b, (*b).c);\n    }\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n例子4: 只有一个成员且不携带数据的枚举\n\n\n\n\n\n\n\n不需要tag来区分哪个变体,所以不需要空间来存储tag\n\nfn main() {\n    enum MyEnum {\n        Cat,\n    }\n    let a = MyEnum::Cat;\n    println!(\"{}\", mem::size_of_val(&a));//0\n}\n\n\n\n\n\n\n\n\n\n\nImportant\n\n\n\n\n根据实际情况, 我们看到, 在上面的例子中 携带String的 枚举变体实际上没有存储tag信息,其他变体存了tag,且在高位估计是为了区分Write变体存的cap而增加了一个0x80 (注意: 这只是这个例子的推测)\n如果将上面的例子中的 Read(String) 取消注释, 这样就有2个携带String的变体了,这个时候怎么区分了,可以试试看, 结果是该枚举的大小变成了32字节了,需要新的内存空间来区分它们\n实际源码根据不同情况是如何优化的,我没去看, 但是通过上面的例子,我们大概了解了一些情况,我觉得ok",
    "crumbs": [
      "进阶",
      "内存"
    ]
  },
  {
    "objectID": "docs/rust/advanced/01.mem.html#box",
    "href": "docs/rust/advanced/01.mem.html#box",
    "title": "斯巴拉稀",
    "section": "5 Box",
    "text": "5 Box\nfn main() {\n    // 5 是在 堆上分配的, 栈上的变量b 指向了它\n    let b = Box::new(5);\n    let a = 11i64;\n    let c = Box::new(&a);\n    println!(\"b的值 = {:p}\", b);\n    println!(\"c的地址 : {:p}\", &c);\n    println!(\"a的地址 : {:p}\", &a);\n    println!(\"c的值: {:p}\", c);\n    let d = &c as *const Box&lt;&i64&gt; as *const u64;\n    unsafe {\n        // c的值是个地址,指向堆上的内存\n        println!(\"c的值: 0x{:x}\", *d);\n        let dd = *d as *const u64;\n        // c的值是地址,该地址所在内存 存的是 a的地址\n        println!(\"0x{:x}\", *dd);\n    }\n}",
    "crumbs": [
      "进阶",
      "内存"
    ]
  },
  {
    "objectID": "docs/rust/advanced/01.mem.html#vectnt",
    "href": "docs/rust/advanced/01.mem.html#vectnt",
    "title": "斯巴拉稀",
    "section": "6 Vec,[T;N],&[T]",
    "text": "6 Vec,[T;N],&[T]\nfn main() {\n    let mut vec: Vec&lt;i32&gt; = vec![1, 2, 3, 4];\n    let arr = [1, 2, 3, 4];\n    vec.push(5);\n    let (ptr, len, cap) = (vec.as_ptr(), vec.len(), vec.capacity());\n    println!(\"Vec 的指针: {:?}\", ptr);\n    println!(\"Vec 的长度: {}\", len);\n    println!(\"Vec 的容量: {}\", cap);\n    // 等价于 let slice_v:&[i32]=&v;\n    // let slice_v = &v[..];\n    let slice_vec = &vec as &[i32];\n\n    // 等价于 let slice_arr:&[i32]=&arr;\n    // let slice_arr = &arr[..];\n    let slice_arr = &arr as &[i32];\n    println!(\n        \"vec的ptr:{:p}-slice_vec的ptr:{:p}-{}\",\n        vec.as_ptr(),\n        slice_vec.as_ptr(),\n        slice_vec.len()\n    );\n    println!(\n        \"arr地址:{:p}-slice_arr的ptr:{:p}-{}\",\n        &arr,\n        slice_arr.as_ptr(),\n        slice_arr.len()\n    );\n\n    struct SliceStruct {\n        a: usize,\n        b: usize,\n    }\n\n    unsafe {\n        let b = &slice_vec as *const &[i32] as *const SliceStruct;\n        // a: cap, b:ptr,c:len\n        println!(\"0x{:x}-0x{:x}\", (*b).a, (*b).b);\n    }\n    struct VecStruct {\n        a: usize,\n        b: usize,\n        c: usize,\n    }\n\n    unsafe {\n        let b = &vec as *const Vec&lt;i32&gt; as *const VecStruct;\n        // a: cap, b:ptr,c:len\n        println!(\"0x{:x}-0x{:x}-0x{:x}\", (*b).a, (*b).b, (*b).c);\n    }\n}",
    "crumbs": [
      "进阶",
      "内存"
    ]
  },
  {
    "objectID": "docs/rust/advanced/01.mem.html#stringstr",
    "href": "docs/rust/advanced/01.mem.html#stringstr",
    "title": "斯巴拉稀",
    "section": "7 String,&str",
    "text": "7 String,&str\nfn main() {\n    let a = \"hello\";\n    let b = \"world\".to_string();\n    println!(\"{:p}-{:p}\", &a, a.as_ptr());\n    println!(\"{:p}-{:p}-{}-{}\", &b, b.as_ptr(), b.capacity(), b.len());\n    unsafe {\n        let c = a.as_ptr() as *const u8;\n        println!(\"{:p}\", c);\n        let mut d;\n        for i in 0..10 {\n            // 一个字节一个字节的打印\n            d = c.add(i);\n            // h-e-l-l-o-w-o-r-l-d-\n            print!(\"{}-\", *d as char);\n        }\n        println!(\"\")\n    }\n\n    let e = &b[1..];\n    println!(\"{:p}-{:p}\", &e, e.as_ptr());\n\n    struct StringStruct {\n        a: usize, // cap\n        b: usize, // ptr\n        c: usize, // len\n    }\n    let mut s = \"hello\".to_string();\n    s.push_str(\"x\");\n    // 6-10\n    println!(\"{}-{}\", s.len(), s.capacity());\n    let b = &s as *const String as *const StringStruct;\n    unsafe {\n        // 0xa-0x7f8fbb705f90-0x6\n        println!(\"0x{:x}-0x{:x}-0x{:x}\", (*b).a, (*b).b, (*b).c);\n    }\n}",
    "crumbs": [
      "进阶",
      "内存"
    ]
  },
  {
    "objectID": "docs/rust/advanced/01.mem.html#todo",
    "href": "docs/rust/advanced/01.mem.html#todo",
    "title": "斯巴拉稀",
    "section": "8 TODO",
    "text": "8 TODO",
    "crumbs": [
      "进阶",
      "内存"
    ]
  },
  {
    "objectID": "docs/go/pkg/ast.html",
    "href": "docs/go/pkg/ast.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "Back to top"
  },
  {
    "objectID": "docs/go/pkg/dlv.html",
    "href": "docs/go/pkg/dlv.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "go install github.com/go-delve/delve/cmd/dlv@latest\n# 安装的路径在, 需要export\ngo env GOPATH",
    "crumbs": [
      "工具与实用库",
      "dlv调试"
    ]
  },
  {
    "objectID": "docs/go/pkg/dlv.html#安装",
    "href": "docs/go/pkg/dlv.html#安装",
    "title": "斯巴拉稀",
    "section": "",
    "text": "go install github.com/go-delve/delve/cmd/dlv@latest\n# 安装的路径在, 需要export\ngo env GOPATH",
    "crumbs": [
      "工具与实用库",
      "dlv调试"
    ]
  },
  {
    "objectID": "docs/go/pkg/dlv.html#常用命令",
    "href": "docs/go/pkg/dlv.html#常用命令",
    "title": "斯巴拉稀",
    "section": "2 常用命令",
    "text": "2 常用命令\ndlv attach pid #对正在运行的进程直接进行调试\ndlv debug main.go\ndlv exec 可执行文件\nhelp # 查看帮助\n# b  打断点 包名.方法名\nb main.main\nc\n# 在上面的c 执行后,才可以这样b 到行号\nb 11 # 直接行号 打断点\n# 或者 一开始这样直接打 行号的断点\nb main.go:12\nbp # 打印所有断点\np a # 打印变量a\n# 打印 某个内存地址的内容,比如想看 sp寄存器指向的内存\np *(*uint64)(0x000000c000050758)\ns # 逐行执行代码 遇到函数会进入内部\nsi # step-instruction  逐个 cpu指令的 执行\nso # stepout 跳出函数\nn # 逐行执行代码 不进入函数内\nargs #查看被调用函数所传入的参数值\nlocals #查看所有局部变量\nlocals 变量名 # 查看具体变量\nclear 编号 # 删除指定断点 ,bp 打印可以看到编号\nclearall #  删除所有断点\nregs # 打印寄存器信息\ngrs # goroutines  显示所有协程,有编号 , *表示当前执行的协程\ngr # goroutine 编号  切换协程\nl # 打印代码\n\nr # restart 重启当前进程\n# 查看汇编代码\ndisassemble -l main.main",
    "crumbs": [
      "工具与实用库",
      "dlv调试"
    ]
  },
  {
    "objectID": "docs/go/pkg/dlv.html#调试-_test.go-文件",
    "href": "docs/go/pkg/dlv.html#调试-_test.go-文件",
    "title": "斯巴拉稀",
    "section": "3 调试 _test.go 文件",
    "text": "3 调试 _test.go 文件\nfunc TestBasic(t *testing.T) {\n    a := struct{}{}\n    b := struct{}{}\n    fmt.Println(unsafe.Sizeof(a)) //0\n    // 相同\n    fmt.Printf(\"%p,%p\\n\", &a, &b)\n    fmt.Println(11)\n}\n# Double-dashes `--` can be used to pass arguments to the test program\n# dlv test [package] -- -test.run TestSomething -test.v -other-argument\ndlv test -- -test.run TestBasic -test.v\n# b 打断点 后面的是 Test 的方法名\n(dlv) b TestBasic\n(dlv) c  # 执行到断点位置\n(dlv) n # 下一行\n(dlv) n # 下一行\n(dlv) p &a",
    "crumbs": [
      "工具与实用库",
      "dlv调试"
    ]
  },
  {
    "objectID": "docs/go/pkg/gdb.html",
    "href": "docs/go/pkg/gdb.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "pt ptype\n\n\n\n Back to top"
  },
  {
    "objectID": "docs/go/pkg/lancet.html",
    "href": "docs/go/pkg/lancet.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "Back to top"
  },
  {
    "objectID": "docs/go/pkg/gorm.html",
    "href": "docs/go/pkg/gorm.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "待整理"
  },
  {
    "objectID": "docs/go/pkg/gorm.html#关联关系",
    "href": "docs/go/pkg/gorm.html#关联关系",
    "title": "斯巴拉稀",
    "section": "1 关联关系",
    "text": "1 关联关系\n\n1.1 属于\n\nuser 属于某个profile, profile表没有user的任何信息 可以说 一个profile 可以让多个user 使用, 所以使用这种方式来设计表 后面可以看看 包含关系的理解\n\n\nForeignKey AssociationForeignKey如何填 如下为例 我们要得到Profile ,肯定是根据某个字段 关联到Profile表才行 这个关联的字段就是 ForeignKey,外键,这个值不是随便插入的,是另外一个表的数据 不管是包含还是属于,思考一下,我要得到这个 profile 是根据哪个字段 就写哪个 这个字段可能在 User表 也可能在Profile表(不同的关系,在不同的表) 而AssociationForeignKey 填的 就是你写的外键是与哪个字段 进行关联的,一般可能是主键\n\ntype MyUser struct {\n    gorm.Model\n    // 在属于关系中,ForeignKey 表示 当前User表中 ProfileID 属于外键\n    // 就是说该值不是随便插入到user表的, 他的值 来自于 Profile表的 某个字段,这样2个表就将建立了关系了\n    //AssociationForeignKey 这个就是来指定 是来自于哪个字段的,\n    Profile   Profile `gorm:\"ForeignKey:ProfileID;AssociationForeignKey:ID\"`\n    ProfileID int\n}\n\ntype MyProfile struct {\n    gorm.Model\n    Name string\n}\nctx = context.Background()\ndb, err:= gorm.Open(\"mysql\", \"root:@tcp(127.0.0.1:3306)/hx?charset=utf8&parseTime=True&loc=Local\")\nfmt.Println(err)\ndb.LogMode(true)\ndefer db.Close()\ndb.Set(\"gorm:table_options\", \"ENGINE=InnoDB\").AutoMigrate(&User{},&Profile{})\n\n\np:=MyProfile{}\nu:=MyUser{}\ndb.First(&u)\n// 下面这个会报错的, 查看Related的源码, 能发现问题\n// 如果我们的模型名字和外键名字不这样起的话,就不会有问题\ndb.Model(&u).Related(&p)\n// 正确的方式需要 指定外键 或者 是  MyProfile (MyUser模型的属性) \ndb.Model(&u).Related(&p,\"ProfileID\")\n// 也可以这样\ndb.Model(&u).Related(&u.MyProfile,\"ProfileID\")\n\n// 一步走到位\n// u.MyProfile 也有了\n// 先查询my_users 表, 得到profile_id,然后去查询my_profiles 表\ndb.Model(&u).Preload(\"MyProfile\").First(&u)\n\n\n1.2 包含一个\n// User 包含一个 CreditCard, UserID 为外键\ntype User struct {\n    gorm.Model\n    CreditCard   CreditCard\n}\n\ntype CreditCard struct {\n    gorm.Model\n    UserID   uint\n    Number   string\n}\n\nvar card CreditCard\ndb.Model(&user).Related(&card, \"CreditCard\")\n//// SELECT * FROM credit_cards WHERE user_id = 123; // 123 is user's primary key\n// CreditCard是user的字段名称，这意味着获得user的CreditCard关系并将其填充到变量\n// 如果字段名与变量的类型名相同，如上例所示，可以省略，如：\ndb.Model(&user).Related(&card)\n\n指定外键和关联外键\n\n// 这个例子中 ,与之前的属于,做个对比\n// 我们可以看出从  数据库设计上, 一个User是可以有多个Profile的\n// 只不过这里User模型 的Profile 属性 类型是单一对象, 表示 只有一个profile,\n// 如果是包含多个, 就用 []Profile 就行了\ntype Profile struct {\n  gorm.Model\n  Name   string\n  UserID uint\n}\n\ntype User struct {\n  gorm.Model\n  Refer   string\n  // User得到Profile 是根据 Profile表的UserID外键, \n  // 该外键是 与 User表的 Refer 字段关联的,就是说外键的值来自于 Refer,默认不写的话是ID\n  Profile Profile `gorm:\"ForeignKey:UserID;AssociationForeignKey:Refer\"`\n}\n\n// 另外一个例子\ntype MyUser struct {\n    gorm.Model\n    Ids int64\n    MyProfile   MyProfile   `gorm:\"ForeignKey:ProfileID;AssociationForeignKey:ID\"` \n    ProfileID int\n    Name string\n    // 同理\n    Email Email `gorm:\"ForeignKey:UserID;AssociationForeignKey:IDs\"`\n}\ntype Email struct{\n    UserID int64\n    gorm.Model\n    Em string\n}\ntype MyProfile struct {\n    gorm.Model\n    Height int64\n    Name string\n    T int64\n}\n\n\n1.3 包含多个\n// User 包含多个 emails, UserID 为外键\ntype User struct {\n    gorm.Model\n    Emails   []Email\n}\n\ntype Email struct {\n    gorm.Model\n    Email   string\n    UserID  uint\n}\n\ndb.Model(&user).Related(&emails)\n\n\n1.4 通过主键(或者其他字段)判断如果有记录则更新,否则创建新的记录\n\n不会使用你传递的主键的\n\nr := Reviewer{}\n    // b := Reviewer{Name: \"yy\"}\n    // id是主键, 在 assign里不要添加 id ,否则会修改的\n    // 这里的意思即使 找id=1的记录,如果有则更新,否则创建\n    // 如果assign 参数使用的 是 对象 ,则里面如果有的值是0 或者false,是不执行的\n    // 而使用map则可以. 因为0,false 可能是默认值,处理上 不去执行了\n    err = db.Model(&r).Where(\"id=1\").Assign(map[string]interface{}{\n        \"name\": \"ioioxx\",\n    }).FirstOrCreate(&r).Error\n\n注意实际上上面的用法 一般用在一定要先判断是否存在的那种需求,而且查询的条件不是id 像上面的 用 判断id是否==0 =0则创建,!=0 则修改  会更好, 不用每次都查询 如果是判断表里是否有title为xx的记录,没有则写入,有则修改这样的需求 则用上面的\n\n\n\n1.5 hooks\n\n1.5.1 针对单个模型的钩子\nfunc (m *Course) AfterCreate(scope *gorm.Scope) error {\n    // scope.SetColumn(\"ID\", uuid.New())\n    fmt.Println(scope.FieldByName(\"title\"))\n    // fmt.Println(len(*scope.Fields))\n    // 可以获取到模型设置的值, 模型中可以设置数据库不需要的值\n    // Bbb         string      `gorm:\"-\"`  需要有 `gorm:\"-\"`\n    for _, v := range scope.Fields() {\n        fmt.Println(*v)\n    }\n    fmt.Println(scope.IndirectValue)\n    return nil\n}\nfunc (cp *CourseProgress) AfterDelete() error {\n    // 一条语句删除多条记录,只会触发一次这个\n    // cp的属性值,并不会从数据库里读取什么, 还是原来调用时的样子\n    fmt.Println(\"x\", cp)\n    return nil\n}\nfunc (m *Course) AfterUpdate(scope *gorm.Scope) error {\n    // 更新多条语句只会触发一次这个操作\n    // m的值 是之前 调用update 时的模型,以及 update() 中设置要更新的属性的值都会赋值给模型m, 还有更新时间会有\n    // fmt.Println(scope.FieldByName(\"ID\"))\n    fmt.Println(scope.CombinedConditionSql())\n    fmt.Println(scope.SQLVars)\n    fmt.Println(scope.SQL)\n    // fmt.Println(scope.Search)\n    fmt.Println(scope.SelectAttrs())\n    for _, vv := range scope.Fields() {\n        fmt.Println(vv.Name, vv.Field)\n    }\n    // fmt.Println(scope.IndirectValue)\n    return nil\n}\n\n\n1.5.2 callback中的事务问题\n// 从gorm 源码中 callback_create.go  callMethod去看\n// 根据不同的回调方法(其实就是参数不同的情况下)不同的执行方式\n// 使用scope *gorm.DB\n// scope.Create(&a) 正确执行,然后后面返回err, 这种情况, 都回滚了\nfunc (m *ModuleQuiz) AfterCreate(scope *gorm.DB) error {\n a := Lesson{CourseID: 1234, Payload: \"{}\", Covers: \"{}\"}\n scope.Create(&a)\n\n return errors.New(\"abc\")\n}\n\n// scope *gorm.Scope\nfunc (m *ModuleQuiz) AfterCreate(scope *gorm.Scope) error {\n a := Lesson{CourseID: 1234, Payload: \"{}\", Covers: \"{}\"}\n scope.DB().Create(&a) //  这个会执行的, 即使后面返回了error\n\n return errors.New(\"abc\")\n}\n\n\n\n1.6 preload\n\npreload 的意义是啥,脑子里想一想, preload里的东西一定是根据你外部的表的一个 字段来关联,然后查询数据 我们可以通过查看sql 得出 ,实际上就只有2条sql语句,一条是得到course的记录 一条是获取课程的课节的信息,  这条的sql是 这样的 course_id in(…) , 然后实际上 应该是做了一个循环,根据lesson的course_id来拼接到数组里,所以我们的prelaod的查询语句如果是自己做了些定义,必须带上 course_id ,否则 你无法获取,这就是为什么 下面的语句,看起来只要获取count就可以,为什么还要获取course_id这个字段的原因 记得还要group_by , 想想 2条sql语句就知道了\n\nerr := resource.GetDB().Model(&Course{}).\n        Count(&cnt).\n        Scopes(PageAndSize(page, size)).\n        Preload(\"Lesson\", func(db *gorm.DB) *gorm.DB {\n            // 获取 必须要带上 一个course_id, 这里的As count 可以 as id ,这样你的Lesson模型不用添加额外的属性\n            return db.Select(\"course_id,count(id) AS count\").Group(\"course_id\")\n        }).\n        Find(&cl).Error\n// 每个lesson都有一个对应的progress\n// 我们需要所有的Lesson的progress时 ,用 Lessons.Progress\n// 如果使用Lesson.Progress 只会获取一个\nerr = resource.GetDB().Model(c).Where(courseIDs).\n  Preload(\"Lessons\", func(db *gorm.DB) *gorm.DB {\n   return db.Order(\"id\")\n  }).\n  Preload(\"Lessons.Progress\", func(db *gorm.DB) *gorm.DB {\n\n\n1.7 update create save\n\n1.7.1 update\n\nupdate 凡是默认值得,都不会更新, 有就是说如果你需要将status修改为0, 你肯定传递过来0, 而实际上 不会修改, 因为0是默认值\n\n\n所以建议表里的字段的值设置不要有0\n\n\n\n1.7.2 save\n\n都会更新 是不是默认值不管, 使用模型的默认值 进行写入数据库了\n\n\n\n1.7.3 create\n\n使用模型的默认值, 所以你不传递的字段,会使用模型的默认值来进行初始化,写入数据库中 这种 也不好, 因为数据库表设计有可能有默认值 比如1, 那这种情况就会导致写入0了\n\n\n\n1.7.4 默认值问题\ntype Animal struct {\n    ID   int64\n    Name string `gorm:\"default:'galeone'\"`\n    Age  int64\n}\n\n然后测试 写入和获取 以及更新时 是该默认值 会不会更新\n\n\n好像根本不会写入默认值到数据库\n\n\n使用下面2种方式\n\n\n这样没有传递的时候,是不会用所谓的默认值写入到数据库的 create\n\n\n// Use pointer value\ntype User struct {\n  gorm.Model\n  Name string\n  Age  *int   //\n}\n\n// Use scanner/valuer\ntype User struct {\n  gorm.Model\n  Name string\n  Age  sql.NullInt64  //\n}\n\n个人觉得可能还是这样处理\n\n如果数据库里需要NUll 这样的,则用* 或者nullint64这种\n如果数据库默认值为&gt;0的,然后create时,没有传递,想要使用数据库中的默认值,则代码中直接写上,if =0 {} else {} 设置模型的值为数据库默认值 ? 好?\nupdate 时模型是默认值 是不更新的,所以尽量不要使用0\n添加时想要使用数据库的默认值 是否可以  gorm:\"-\" 来处理该字段 (获取的时候应该 是可以的?)\n\n\n\n\n\n1.8 使用omit来排除不要insert的和update的 解决上面的问题\n\n\n1.9 使用[]byte来处理json类型的字段\n// 将proto message 里的字段定义为bytes ,==&gt; go ==&gt; []byte\n// gorm model 字段也设置为[]byte ,可以从数据库里读取到数据, 写入也是ok的,\n//  如果我们想要将json格式的数据 返回到浏览器那边 是json的格式的话, 将[]byte 格式 写成 json.RawMessage 即可\n// 正常情况下我们会这样处理\na:=`{\"name\":\"x\",\"school\":{\"name\":\"qh\",\"class\":11}}`\ntype Person struct{\n    Age int64\n    Sch string\n}\np:=Person{\n    Age:11,\n    Sch:a\n}\njson.Marshal(p)  ==&gt; 得到的sch 还是个字符串\ntype Person struct{\n    Age int64\n    Sch json.RawMessage  ==&gt; 实际就是[]byte, 可以看看源码\n}\n\np:=Person{\n    Age:11,\n    Sch:(json.RawMessage)(a)\n}\njson.Marshal(p)  ==&gt; 可以都变成\n\n\n1.10 有关使用分表的注意事项\n// 根据uid 来判断写入哪个表\nfunc (t *Test) TableName() string {\n    return fmt.Sprintf(\"test_%d\", t.UID%10)\n}\n\n在使用 查询,更新 ,创建的时候,需要注意是否用到 分表\n\n// 使用 &Test{} 使用到了 分表\n//  &注意这个  没有& 的  就不适用了\n// 都是有deleted_at is null的\nModel(&Test{UID: 8}).Update(...)\n.Model(&User).Create(&Test{UID:8})  // 创建的是test ,与model指定的无关\n.Create(&Test{UID:8})  //走分表的\n.Create(Test{UID:8})  //没& 不走分表的\n\n// 因为使用Find 其实 不会去管Model里设置的是哪个表\n\n// 经过测试, 就是\na:=Test{}\nModel(&User{}).Find(&a) // 找的是test表,与 Model里的User表无关\n.Model(&Test{UID:8}).Find(&..)  // 不管model有没有& 都不走分表\n// 需要指定 .Table((&Test{UID:8}).TableName())\n.Model(&Test{UID:8}).Scan(&..)  //走分表   Model(没&)  不走分表\n\n// Scan 与 Find 的区别是,他必须指定table或者model\n// 所以上面我们的Scan 指定了model 是走分表的\n\n// 凡是用.Table 来指定表名的, 查询不会有 deleted_at is null\n// 更新也不会更新 updated_at\n\nFirst() 换成 Model(&).order limit .Scan(&obj)\n\n// model 不会管cp属性的值 来作为过滤条件,(除非是主键id有值,则会作为where条件)\n// 只会关心where里的 ,如果where里的用的是模型,那么 用& 才会指定tablename\n// 否则 出问题\n.Model(&cp).Where(&cp).Scan()\n\n\n// 注意如果这里Where(&cp), 然后后面update, 会先将\n// is_finished 属性true值 设置到模型cp中,然后作为where条件\n// 这样就导致问题了,\n// update is_finished=true where is_finished =true   XX\n// where 还是不用模型比较好\ncp := models.CourseProgress{UID: 1457341, LessonID: 97}\n    resource.GetDB().\n        //Where(\"uid = ?\", cp.UID).\n        //Where(\"lesson_id = ?\", cp.LessonID).\n        Where(&cp). \n        Model(&cp).\n        Update(\"is_finished\", true)\n// 这里不是指针\n    cp := CourseProgress{\n                Platform: 2,\n                UID:      121,\n                CourseID: 100,\n            }\n            //但是传递进去的是指针,所以里面会使用到 分表\n             cp.DeleteCourseProgress()\nfunc (cp *CourseProgress) DeleteCourseProgress() error {\n    fmt.Println(cp.LessonID)\n    cp.LessonID = 10\n    // Delete(cp) 是指针 才会使用模型中的TableName()\n    return resource.GetDB().Where(cp).Delete(cp).Error\n}\nfunc (c *User) Test() {\n    fmt.Println(c.ID)\n    c.ID = 123\n}\n\nfunc main() {\n    u := User{Name: \"xx\"}\n    u.Test()\n    fmt.Println(u) // 修改了id\n}"
  },
  {
    "objectID": "docs/go/pkg/gorm.html#其他技巧",
    "href": "docs/go/pkg/gorm.html#其他技巧",
    "title": "斯巴拉稀",
    "section": "2 其他技巧",
    "text": "2 其他技巧\n这样默认的表名不是+s 的, 可以不用 TableName()来具体指定了\ndb.SingularTable(true)\n\n修改默认表名\n您可以通过定义DefaultTableNameHandler对默认表名应用任何规则\ngorm.DefaultTableNameHandler = func (db *gorm.DB, defaultTableName string) string  {\n  return \"prefix_\" + defaultTableName;\n}\n\n*gorm.expr子查询\ndb.Where(\"amount &gt; ?\", DB.Table(\"orders\").Select(\"AVG(amount)\").Where(\"state = ?\", \"paid\").QueryExpr()).Find(&orders)\n\n\n// Cancel limit condition with -1\ndb.Limit(10).Find(&users1).Limit(-1).Find(&users2)\n\n// Cancel offset condition with -1\ndb.Offset(10).Find(&users1).Offset(-1).Find(&users2)\n\n2.1 Set 的使用\n\n我们在afterUpdate这种操作中,如果想要知道该update之前的某个字段的值的时候怎么办呢?\n\n// gorm 中的每次.Where啊什么的操作都是 db.clone() 一次的, 之后的clone都会带上你设置的值(set设置的)\ne = db.Where(&wher).Where(\"id = 111\").\n        Set(\"old\", 1). // 这个就是设置了一个临时的值,在afterupdate 可以使用\n        Update(map[string]interface{}{\"is_finished\": true, \"stars\": 11})\n\n// 所以你在afterUpdate 中可以\na, ok := scope.Get(\"old\")\nif ok {\n    fmt.Println(\"ss\", a)\n}\nfmt.Println(scope.DB().RowsAffected)\n\n\n// 这样我们就算是达到了,获取更新之前的old 值的要求了\n\n\n2.2 .Table()\n// 看下源码就知道了\n// 没有 deleted_at is null  需要手动添加\nresource.GetDB().Table((&Course{}).TableName()).Count() \n\n// 如果使用的是 Find 则\n//不需要 deleted_at is null 默认就有\n\nTable((&CourseProgress{UID: 2}).TableName()).\n  Find(&a)    // table 有效, Model 无效\n\n\n2.3 first & find\n\n意义上来说, 我们查询列表, 没有数据是完全正常的, 而当我们 查询某一条记录是否存在时,正常情况下,我们是需要这条记录的, 所以才查询. 所以系统设计上给你报err了\n\n//gorm  // callback_query.go / init()\n //查看实际调用的 查询方法.\n\nelse if scope.db.RowsAffected == 0 && !isSlice {\n    scope.Err(ErrRecordNotFound)\n   }\n\n//我们发现,Find(& xx   ) xx 使用切片的时候, \n//不会报ErrRecordNotFound, FIrst 使用的是单个 所以报ErrRecordNotFound"
  },
  {
    "objectID": "docs/go/pkg/gorm.html#子查询",
    "href": "docs/go/pkg/gorm.html#子查询",
    "title": "斯巴拉稀",
    "section": "3 子查询",
    "text": "3 子查询\n\nsubQuery 是会用() 包起来的\n\nresource.GetDB().Exec(\n    fmt.Sprintf(`insert into %s (a,b,c,d,created_at,updated_at,actived_at,e) select * from (?) tmp where not exists(?)`, cp.TableName()),\n    resource.GetDB().\n     Model(models.AB{}).\n     Select(\"?,b,c,d ,now(),now() ,now() ,'{}'\", cp.UID).\n     Where(\"id = ?\", c.ID).Order(\"id\").Limit(2).\n     SubQuery(),\n    resource.GetDB().Model(cp).Where(\"id=?\", ID).Where(\"id = tmp.id\").QueryExpr(),\n   )"
  },
  {
    "objectID": "docs/go/infrastructure/test.html",
    "href": "docs/go/infrastructure/test.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "\"go.testFlags\": [\n   \"-v\",\n   \"-gcflags=-l\",\n],",
    "crumbs": [
      "工程设计",
      "测试"
    ]
  },
  {
    "objectID": "docs/go/infrastructure/test.html#vscode-golang-相关配置",
    "href": "docs/go/infrastructure/test.html#vscode-golang-相关配置",
    "title": "斯巴拉稀",
    "section": "",
    "text": "\"go.testFlags\": [\n   \"-v\",\n   \"-gcflags=-l\",\n],",
    "crumbs": [
      "工程设计",
      "测试"
    ]
  },
  {
    "objectID": "docs/go/infrastructure/test.html#代码",
    "href": "docs/go/infrastructure/test.html#代码",
    "title": "斯巴拉稀",
    "section": "2 代码",
    "text": "2 代码\n\n\none_test.go 文件名必须以 _test 结尾\n\npackage test\n\nimport (\n    \"fmt\"\n    \"testing\"\n)\n// 函数名必须Test 开头\nfunc TestOne(t *testing.T) {\n    fmt.Println(1 == 1)\n}\n\n点击vscode 上看到的 run test 或 打断点后点击debug test 或者使用命令\n# -v 显示打印信息\ngo test -v # 执行当前目录下所有的 _test测试文件\ngo test -v target_dir/* # 指定目录\ngo test -v one_test.go # 指定文件\n# 执行指定测试方法\ngo test -v -run TestOne one_test.go",
    "crumbs": [
      "工程设计",
      "测试"
    ]
  },
  {
    "objectID": "docs/go/infrastructure/semver.html",
    "href": "docs/go/infrastructure/semver.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "语义化版本号管理"
  },
  {
    "objectID": "docs/go/infrastructure/semver.html#version",
    "href": "docs/go/infrastructure/semver.html#version",
    "title": "斯巴拉稀",
    "section": "",
    "text": "语义化版本号管理"
  },
  {
    "objectID": "docs/go/infrastructure/semver.html#commit-message",
    "href": "docs/go/infrastructure/semver.html#commit-message",
    "title": "斯巴拉稀",
    "section": "2 commit message",
    "text": "2 commit message\nangular commit"
  },
  {
    "objectID": "docs/go/concurrency/sync.html",
    "href": "docs/go/concurrency/sync.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "Back to top",
    "crumbs": [
      "并发",
      "sync"
    ]
  },
  {
    "objectID": "docs/go/concurrency/channel.html",
    "href": "docs/go/concurrency/channel.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "Tip\n\n\n\n\n无缓冲:假设快递, 在没有蜂巢的情况下, 快递员带着包裹来了, 你人不在, GG, 阻塞了,等待\n有缓冲:有蜂巢后, 包裹到了, 快递员直接将包裹放到蜂巢就行, 但是如果蜂巢满了, GG,阻塞了,等待\n\n当然如果 客户在的话, 那么直接交给客户就是了\n\n上面2点已经说明了,什么情况下是不阻塞的\n\n\n\nfunc TestChan(t *testing.T) {\n    //定义\n    var intChan chan int\n    // 指针,引用类型\n    intChan = make(chan int, 3)\n    fmt.Printf(\"intChar的值=%v intChan本身的地址=%p\\n\", intChan, &intChan)\n    go func() {\n        // 元素个数为空时读 会阻塞等待\n        fmt.Println(\"读取管道等待中...\")\n        num2 := &lt;-intChan\n        fmt.Println(\"读取完毕...\", num2)\n    }()\n    time.Sleep(2 * time.Second)\n    // 向管道写入数据\n    intChan &lt;- 1\n    intChan &lt;- 2\n    intChan &lt;- 3\n    // 打印管道的长度和容量\n    // 容量是不变的,长度根据管道里面存放着多少个数据\n    fmt.Printf(\"intChan len=%d cap=%d\\n\", len(intChan), cap(intChan))\n    intChan &lt;- 4\n    go func() {\n        // 数据写入,满了,再写 会阻塞等待\n        fmt.Println(\"写入管道等待中...\")\n        intChan &lt;- 5\n        fmt.Println(\"写入管道完毕...\")\n    }()\n\n    time.Sleep(3 * time.Second)\n    //读取管道数据\n    // 无变量接收\n    &lt;-intChan\n    // 有变量接收\n    num, ok := &lt;-intChan\n    fmt.Println(\"读取:\",ok, num)\n\n    time.Sleep(5 * time.Second)\n    // 关闭管道后,不能写入数据,但是可以读取\n    close(intChan)\n\n    num = &lt;-intChan\n    fmt.Println(num)\n    num = &lt;-intChan\n    fmt.Println(num)\n    // 已经没有元素了, 但是还是可以读取操作, 值是0\n    num, ok = &lt;-intChan\n    fmt.Println(num,ok) // 0 false\n}\nfunc main() {\n    // 无缓冲\n    ch := make(chan int)\n    // 没有消费者, 运行会直接报错\n    ch &lt;- 1\n}\nfunc main() {\n    ch := make(chan int)\n    // 启动一个goroutine将数据发送到通道中\n    go func() {\n        for i := 1; i &lt;= 5; i++ {\n            ch &lt;- i // 发送数据到通道\n            time.Sleep(time.Second)\n\n        }\n        close(ch) // 关闭通道\n    }()\n\n    // 使用for range迭代读取通道中的值\n    // 如果没有 close 会超时退出\n    for num := range ch {\n        fmt.Println(num)\n    }\n}\n\nselect",
    "crumbs": [
      "并发",
      "channel"
    ]
  },
  {
    "objectID": "docs/go/concurrency/channel.html#基本操作",
    "href": "docs/go/concurrency/channel.html#基本操作",
    "title": "斯巴拉稀",
    "section": "",
    "text": "Tip\n\n\n\n\n无缓冲:假设快递, 在没有蜂巢的情况下, 快递员带着包裹来了, 你人不在, GG, 阻塞了,等待\n有缓冲:有蜂巢后, 包裹到了, 快递员直接将包裹放到蜂巢就行, 但是如果蜂巢满了, GG,阻塞了,等待\n\n当然如果 客户在的话, 那么直接交给客户就是了\n\n上面2点已经说明了,什么情况下是不阻塞的\n\n\n\nfunc TestChan(t *testing.T) {\n    //定义\n    var intChan chan int\n    // 指针,引用类型\n    intChan = make(chan int, 3)\n    fmt.Printf(\"intChar的值=%v intChan本身的地址=%p\\n\", intChan, &intChan)\n    go func() {\n        // 元素个数为空时读 会阻塞等待\n        fmt.Println(\"读取管道等待中...\")\n        num2 := &lt;-intChan\n        fmt.Println(\"读取完毕...\", num2)\n    }()\n    time.Sleep(2 * time.Second)\n    // 向管道写入数据\n    intChan &lt;- 1\n    intChan &lt;- 2\n    intChan &lt;- 3\n    // 打印管道的长度和容量\n    // 容量是不变的,长度根据管道里面存放着多少个数据\n    fmt.Printf(\"intChan len=%d cap=%d\\n\", len(intChan), cap(intChan))\n    intChan &lt;- 4\n    go func() {\n        // 数据写入,满了,再写 会阻塞等待\n        fmt.Println(\"写入管道等待中...\")\n        intChan &lt;- 5\n        fmt.Println(\"写入管道完毕...\")\n    }()\n\n    time.Sleep(3 * time.Second)\n    //读取管道数据\n    // 无变量接收\n    &lt;-intChan\n    // 有变量接收\n    num, ok := &lt;-intChan\n    fmt.Println(\"读取:\",ok, num)\n\n    time.Sleep(5 * time.Second)\n    // 关闭管道后,不能写入数据,但是可以读取\n    close(intChan)\n\n    num = &lt;-intChan\n    fmt.Println(num)\n    num = &lt;-intChan\n    fmt.Println(num)\n    // 已经没有元素了, 但是还是可以读取操作, 值是0\n    num, ok = &lt;-intChan\n    fmt.Println(num,ok) // 0 false\n}\nfunc main() {\n    // 无缓冲\n    ch := make(chan int)\n    // 没有消费者, 运行会直接报错\n    ch &lt;- 1\n}\nfunc main() {\n    ch := make(chan int)\n    // 启动一个goroutine将数据发送到通道中\n    go func() {\n        for i := 1; i &lt;= 5; i++ {\n            ch &lt;- i // 发送数据到通道\n            time.Sleep(time.Second)\n\n        }\n        close(ch) // 关闭通道\n    }()\n\n    // 使用for range迭代读取通道中的值\n    // 如果没有 close 会超时退出\n    for num := range ch {\n        fmt.Println(num)\n    }\n}\n\nselect",
    "crumbs": [
      "并发",
      "channel"
    ]
  },
  {
    "objectID": "docs/go/concurrency/channel.html#底层原理",
    "href": "docs/go/concurrency/channel.html#底层原理",
    "title": "斯巴拉稀",
    "section": "2 底层原理",
    "text": "2 底层原理\n\n2.1 hchan数据结构\n\n\n\n\n\n\n思考 (以有缓冲为例)\n\n\n\n\nchannel 可能占用的内存空间比较大, 那么将实际数据存放在堆上\n操作上FIFO,那么 使用一个数组来存数据 ,环形的\n\n需要一个索引指出下一个读的下标位置\n需要一个索引指出下一个写的下标位置\n\n需要存储的元素的类型信息\n线程安全的, 那么肯定有锁这样的东西\n缓冲区为空时,在读这个chan的goroutine会阻塞, 当chan 有数据时,会开始读取数据,所以chan需要知道谁在等待读自己\n当缓冲区满了后,往chan写数据的goroutine 就会阻塞,等空出位置了, 之前阻塞的goroutine 会重新开始写数据,所以需要知道谁在等待写该chan\nclose 操作后, 不能写入数据了, 需要记录 是否close的信息\n\n\n\n\n\n查看汇编知道 runtime.makechan\n\ntype hchan struct {\n    qcount   uint           // 当前存放的元素个数\n    dataqsiz uint           // 数组的容量\n    buf      unsafe.Pointer // 数组的地址\n    elemsize uint16 \n    closed   uint32  // \n    elemtype *_type // element type\n    sendx    uint   // 下一个写的下标\n    recvx    uint   // 下一个读的下标\n    recvq    waitq  // 读等待队列\n    sendq    waitq  // 写等待队列\n    lock mutex  // 锁\n}\n\n\n\n2.2 recvq和sendq何时有数据\n\n\n\n\n\n\nTip\n\n\n\n\n有缓冲chan,缓冲区满了,还往里写的goroutine 会加入 sendq 队列\n有缓冲chan,缓冲区空的,从ch里读的goroutine 会加入 recvq 队列\n无缓冲chan,无人接收时,往里写的goroutine 会加入 sendq 队列\n无缓冲chan,无人写入时,从ch里读的goroutine 会加入 recvq 队列\n\n\n\n\n\n用于检验sendq和recvq的demo\n\npackage test\n\nimport (\n    \"bytes\"\n    \"fmt\"\n    \"runtime\"\n    \"strconv\"\n    \"testing\"\n    \"time\"\n    \"unsafe\"\n)\n\ntype hchan struct {\n    qcount   uint\n    dataqsiz uint\n    buf      unsafe.Pointer\n    elemsize uint16\n    closed   uint32\n    elemtype *int64\n    sendx    uint \n    recvx    uint\n    recvq    waitq \n    sendq    waitq\n}\ntype waitq struct {\n    first *sudog\n    last  *sudog\n}\ntype sudog struct {\n    g    *g\n    next *sudog\n    prev *sudog\n}\ntype g struct {\n    // 通过源码g 的结构, 前面字段占用的字节.\n    // 版本不一样可能 这里也会不一样.\n    tmp  [19]uint64\n    goid uint64\n}\n\n// 获取 goroutine 的id\nfunc GetGID() uint64 {\n    b := make([]byte, 64)\n    b = b[:runtime.Stack(b, false)]\n    b = bytes.TrimPrefix(b, []byte(\"goroutine \"))\n    b = b[:bytes.IndexByte(b, ' ')]\n    n, _ := strconv.ParseUint(string(b), 10, 64)\n    return n\n}\n\nfunc TestMain(t *testing.T) {\n    fmt.Println(\"主 goroutine:\", GetGID())\n    // ch := make(chan int) 无缓冲验证\n    ch := make(chan int, 5)\n    chAddr := *(*uintptr)(unsafe.Pointer(&ch))\n    go func() {\n\n        fmt.Println(\"这个goroutine A的 id:\", GetGID())\n        for i := 0; i &lt; 10; i++ {\n            time.Sleep(50 * time.Millisecond)\n            ch &lt;- i\n        }\n\n    }()\n    go func() {\n\n        time.Sleep(1 * time.Second)\n        fmt.Println(\"这个goroutine B的 id:\", GetGID())\n        for i := 11; i &lt; 20; i++ {\n            time.Sleep(50 * time.Millisecond)\n            ch &lt;- i\n        }\n    }()\n    go func() {\n\n        for {\n            hchanData := *(*hchan)(unsafe.Pointer(chAddr))\n            fmt.Println(hchanData)\n            if hchanData.sendq.first != nil {\n                fmt.Println(\"hchan结构里sendq存的 first goroutine id: \", hchanData.sendq.first.g.goid)\n                if hchanData.sendq.first.next != nil {\n                    fmt.Println(\"hchan结构里sendq存的first goroutine id -&gt;next: \", hchanData.sendq.first.next.g.goid)\n                }\n            }\n            if hchanData.sendq.last != nil {\n                fmt.Println(\"hchan结构里sendq存的last goroutine id: \", hchanData.sendq.last.g.goid)\n                if hchanData.sendq.last.prev != nil {\n                    fmt.Println(\"hchan结构里sendq存的last goroutine id -&gt;prev: \", hchanData.sendq.last.prev.g.goid)\n                }\n\n            }\n            // for select case 处读取chan, 到没有元素了,就会在recvq添加读取它goroutine\n            if hchanData.recvq.first != nil {\n                fmt.Println(\"当前ch 的元素个数:\", len(ch))\n                // 主协程 最后一直等待读取 chan\n                fmt.Println(\"hchan结构里 recvq 存的first goroutine id: \", hchanData.recvq.first.g.goid)\n                close(ch)\n            }\n            time.Sleep(1 * time.Second)\n        }\n    }()\n\n    time.Sleep(5 * time.Second)\n\nLoop:\n    for {\n        select {\n        case c, ok := &lt;-ch:\n            if !ok {\n                break Loop\n            }\n            fmt.Println(c)\n        }\n        time.Sleep(500 * time.Millisecond)\n    }\n}\n\n\n\n2.3 写 runtime.chansend1\nfunc chansend1(c *hchan, elem unsafe.Pointer) {\n    chansend(c, elem, true, getcallerpc())\n}\n\nfunc chansend(c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool {\n    if c == nil {\n        if !block {\n            return false\n        }\n\n        //chan是nil的情况, 直接 阻塞\n        gopark(nil, nil, waitReasonChanSendNilChan, traceEvGoStop, 2)\n        throw(\"unreachable\")\n    }\n\n    // ...\n\n    if !block && c.closed == 0 && full(c) {\n        return false\n    }\n\n    var t0 int64\n    if blockprofilerate &gt; 0 {\n        t0 = cputicks()\n    }\n    // 准备开始发送数据,先加锁\n    lock(&c.lock)\n\n    if c.closed != 0 {\n        unlock(&c.lock)\n        panic(plainError(\"send on closed channel\"))  // (1)\n    }\n    // 如果这个时候有接收者在等待数据,那么直接发给它,不用写入缓冲区\n    // 接收者在等待意味着缓冲区里本身是没数据的\n    if sg := c.recvq.dequeue(); sg != nil {\n        send(c, sg, ep, func() { unlock(&c.lock) }, 3)\n        return true\n    }\n    // 如果缓冲区有空余的情况\n    if c.qcount &lt; c.dataqsiz {\n        qp := chanbuf(c, c.sendx)\n        if raceenabled {\n            racenotify(c, c.sendx, nil)\n        }\n        typedmemmove(c.elemtype, qp, ep)\n        c.sendx++\n        if c.sendx == c.dataqsiz {\n            c.sendx = 0\n        }\n        c.qcount++\n        unlock(&c.lock)\n        return true\n    }\n\n    if !block {\n        unlock(&c.lock)\n        return false\n    }\n    // 走到这里的话, 意味着缓冲没空余且无接收者,这个时候就是 添加到sendq\n    gp := getg()\n    mysg := acquireSudog()\n    mysg.releasetime = 0\n    if t0 != 0 {\n        mysg.releasetime = -1\n    }\n    mysg.elem = ep\n    mysg.waitlink = nil\n    mysg.g = gp\n    mysg.isSelect = false\n    mysg.c = c\n    gp.waiting = mysg\n    gp.param = nil\n    c.sendq.enqueue(mysg)\n    gp.parkingOnChan.Store(true)\n    gopark(chanparkcommit, unsafe.Pointer(&c.lock), waitReasonChanSend, traceEvGoBlockSend, 2)\n    KeepAlive(ep)\n\n    // someone woke us up.\n    if mysg != gp.waiting {\n        throw(\"G waiting list is corrupted\")\n    }\n    gp.waiting = nil\n    gp.activeStackChans = false\n    closed := !mysg.success\n    gp.param = nil\n    if mysg.releasetime &gt; 0 {\n        blockevent(mysg.releasetime-t0, 2)\n    }\n    mysg.c = nil\n    releaseSudog(mysg)\n    if closed {\n        if c.closed == 0 {\n            throw(\"chansend: spurious wakeup\")\n        }\n        panic(plainError(\"send on closed channel\"))\n    }\n    return true\n}\n\n测试代码 go     // 执行会报错 panic: send on closed channel     func TestSendToCloseChan(t *testing.T) {         ch := make(chan int, 2)         ch &lt;- 1         close(ch)         ch &lt;- 2     }\n\n\n\n2.4 读 runtime.chanrecv1",
    "crumbs": [
      "并发",
      "channel"
    ]
  },
  {
    "objectID": "docs/go/concurrency/goroutine.html",
    "href": "docs/go/concurrency/goroutine.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "TODO ## goroutine与线程\n协程的底层结构 ```go title=“src/runtime2.go” type g struct { stack stack // (1) stackguard0 uintptr // offset known to liblink stackguard1 uintptr // offset known to liblink\n}",
    "crumbs": [
      "并发",
      "goroutine"
    ]
  },
  {
    "objectID": "docs/go/concurrency/goroutine.html#gpm",
    "href": "docs/go/concurrency/goroutine.html#gpm",
    "title": "斯巴拉稀",
    "section": "1 GPM",
    "text": "1 GPM\ngo build -o main -gcflags \"-N -l\" main.go\nobjdump -t  main|grep -v '.text'| grep -E 'g0|m0'",
    "crumbs": [
      "并发",
      "goroutine"
    ]
  },
  {
    "objectID": "docs/go/basic/unsafe.html",
    "href": "docs/go/basic/unsafe.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "Tip\n\n\n\nGo 1.17 新增 unsafe.Slice\n\n\n// 等价于  (*[len]ArbitraryType)(unsafe.Pointer(ptr))[:]\nfunc TestSlice(t *testing.T) {\n    st := struct {\n        a int8  // 内存对齐, 导致补一个字节\n        b int16 // 516 ==&gt; 高位字节是 2, 低位字节是4  0x204\n        c int32\n    }{1, 516, 3}\n    // unsafe.Slice  把任何指针变成一个切片\n    // 切片元素类型是 转递的参数指针的类型 , 这里就是 int8\n    // 比如 如果你传递  &st 虽然地址与&st.a 一样, 但是结果就不一样了.\n    slice := unsafe.Slice(&st.a, 5)\n    println(len(slice), cap(slice))\n    // 1 ?(不确定的污染数据) 4 2\n    println(slice[0], slice[1], slice[2], slice[3])\n\n}\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nGo 1.20 新增 unsafe.SliceData\n\n\nfunc TestSliceData(t *testing.T) {\n    slice := []int64{1, 2, 3, 4}\n    // unsafe.SliceData 返回指向 切片数据(数组)的指针\n    sliceDataPtr := unsafe.SliceData(slice)\n    reflSlice := *(*reflect.SliceHeader)(unsafe.Pointer(&slice))\n    println(sliceDataPtr, unsafe.Pointer(reflSlice.Data))\n}\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nuintptr的+ 的操作的简便方式\n\n\ntype MyStruct struct {\n    age    int16\n    height int16\n}\n\nfunc TestUnsafeAdd(t *testing.T) {\n    var ms MyStruct\n    ms.age = 32\n    ms.height = 182\n\n    ptr := unsafe.Pointer(&ms)\n    offset := unsafe.Offsetof(ms.height)\n    fmt.Println(offset)\n    newPtr := unsafe.Add(ptr, offset)\n\n    // 访问新的地址处的值\n    fmt.Println(*(*int16)(newPtr)) // 输出 182\n}\n\n\n\nfunc TestUnsafe(t *testing.T) {\n    slice := []byte{'h', 'e', 'l', 'l', 'o'}\n    // 参数1: 字符数组的地址, 参数2: 字符数组长度\n    // 是字符串的2个组成部分\n    s := unsafe.String(&slice[0], 3)\n    println(s)\n    ss := *(*reflect.StringHeader)(unsafe.Pointer(&s))\n    // 相同的, 所以是直接转为 字符串 (将字符串的字符数组地址设置为 上面切片的数组地址)\n    println(unsafe.Pointer(ss.Data), &slice[0])\n}",
    "crumbs": [
      "基础篇",
      "unsafe"
    ]
  },
  {
    "objectID": "docs/go/basic/unsafe.html#一些方法",
    "href": "docs/go/basic/unsafe.html#一些方法",
    "title": "斯巴拉稀",
    "section": "",
    "text": "Tip\n\n\n\nGo 1.17 新增 unsafe.Slice\n\n\n// 等价于  (*[len]ArbitraryType)(unsafe.Pointer(ptr))[:]\nfunc TestSlice(t *testing.T) {\n    st := struct {\n        a int8  // 内存对齐, 导致补一个字节\n        b int16 // 516 ==&gt; 高位字节是 2, 低位字节是4  0x204\n        c int32\n    }{1, 516, 3}\n    // unsafe.Slice  把任何指针变成一个切片\n    // 切片元素类型是 转递的参数指针的类型 , 这里就是 int8\n    // 比如 如果你传递  &st 虽然地址与&st.a 一样, 但是结果就不一样了.\n    slice := unsafe.Slice(&st.a, 5)\n    println(len(slice), cap(slice))\n    // 1 ?(不确定的污染数据) 4 2\n    println(slice[0], slice[1], slice[2], slice[3])\n\n}\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nGo 1.20 新增 unsafe.SliceData\n\n\nfunc TestSliceData(t *testing.T) {\n    slice := []int64{1, 2, 3, 4}\n    // unsafe.SliceData 返回指向 切片数据(数组)的指针\n    sliceDataPtr := unsafe.SliceData(slice)\n    reflSlice := *(*reflect.SliceHeader)(unsafe.Pointer(&slice))\n    println(sliceDataPtr, unsafe.Pointer(reflSlice.Data))\n}\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nuintptr的+ 的操作的简便方式\n\n\ntype MyStruct struct {\n    age    int16\n    height int16\n}\n\nfunc TestUnsafeAdd(t *testing.T) {\n    var ms MyStruct\n    ms.age = 32\n    ms.height = 182\n\n    ptr := unsafe.Pointer(&ms)\n    offset := unsafe.Offsetof(ms.height)\n    fmt.Println(offset)\n    newPtr := unsafe.Add(ptr, offset)\n\n    // 访问新的地址处的值\n    fmt.Println(*(*int16)(newPtr)) // 输出 182\n}\n\n\n\nfunc TestUnsafe(t *testing.T) {\n    slice := []byte{'h', 'e', 'l', 'l', 'o'}\n    // 参数1: 字符数组的地址, 参数2: 字符数组长度\n    // 是字符串的2个组成部分\n    s := unsafe.String(&slice[0], 3)\n    println(s)\n    ss := *(*reflect.StringHeader)(unsafe.Pointer(&s))\n    // 相同的, 所以是直接转为 字符串 (将字符串的字符数组地址设置为 上面切片的数组地址)\n    println(unsafe.Pointer(ss.Data), &slice[0])\n}",
    "crumbs": [
      "基础篇",
      "unsafe"
    ]
  },
  {
    "objectID": "docs/go/basic/unsafe.html#unsafe.pointer-uintptr",
    "href": "docs/go/basic/unsafe.html#unsafe.pointer-uintptr",
    "title": "斯巴拉稀",
    "section": "2 unsafe.Pointer & uintptr",
    "text": "2 unsafe.Pointer & uintptr\nGC 会管理 unsafe.Pointer uintptr 则不会",
    "crumbs": [
      "基础篇",
      "unsafe"
    ]
  },
  {
    "objectID": "docs/go/basic/slice.html",
    "href": "docs/go/basic/slice.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "type SliceHeader struct {\n    Data uintptr // 引用的数组的地址\n    Len  int     // 切片长度\n    Cap  int     // 引用的数组的长度\n}\n\nfunc TestSlice(t *testing.T) {\n    // 方式1\n    slice1 := []int{11, 22, 33, 44, 55}\n    b := (*reflect.SliceHeader)(unsafe.Pointer(&slice1))\n    fmt.Println(b.Cap, b.Len) // 5 5\n    fmt.Println(len(slice1), cap(slice1))\n    // 方式2\n    arr := [5]int{11, 22, 33, 44, 55}\n    slice2 := arr[1:3]\n    c := (*reflect.SliceHeader)(unsafe.Pointer(&slice2))\n    // 指向的数组是 arr 从1下标开始的. 所以cap 是4\n    fmt.Println(c.Cap, c.Len) // 4 2\n    // slice2[2]  越界了,len是可以访问的范围\n    // 方式3\n    slice3 := make([]int, 5)\n    d := (*reflect.SliceHeader)(unsafe.Pointer(&slice3))\n    // 5,5,824634322544   data 初始化了, 分配了内存,对应的字节数组元素都是0\n    fmt.Println(d.Cap, d.Len, d.Data)\n    slice33 := make([]int, 1, 5)\n    dd := (*reflect.SliceHeader)(unsafe.Pointer(&slice33))\n    // cap =5, len=1\n    fmt.Println(dd.Cap, dd.Len, slice33[0])\n    // 方式4\n    var slice4 []int\n    e := (*reflect.SliceHeader)(unsafe.Pointer(&slice4))\n    // data 还没有初始化的 ,相比 slice4:=[]int{} 初始化推荐这种\n    fmt.Println(e.Cap, e.Len, e.Data)\n\n    a := [10]int{1, 2, 3, 4, 5, 6, 7, 8, 9}\n    // 2个切片引用同一个底层数组\n    a1 := a[1:4]\n    a2 := a[2:5]\n    a1[1] = 111\n    fmt.Println(a) // 修改了底层数组元素\n    a2[0] = 222\n    fmt.Println(a, a1[1])\n    a1 = append(a1, 333)\n    fmt.Println(a) // 修改了底层数组元素\n\n}",
    "crumbs": [
      "基础篇",
      "切片"
    ]
  },
  {
    "objectID": "docs/go/basic/slice.html#数据结构",
    "href": "docs/go/basic/slice.html#数据结构",
    "title": "斯巴拉稀",
    "section": "",
    "text": "type SliceHeader struct {\n    Data uintptr // 引用的数组的地址\n    Len  int     // 切片长度\n    Cap  int     // 引用的数组的长度\n}\n\nfunc TestSlice(t *testing.T) {\n    // 方式1\n    slice1 := []int{11, 22, 33, 44, 55}\n    b := (*reflect.SliceHeader)(unsafe.Pointer(&slice1))\n    fmt.Println(b.Cap, b.Len) // 5 5\n    fmt.Println(len(slice1), cap(slice1))\n    // 方式2\n    arr := [5]int{11, 22, 33, 44, 55}\n    slice2 := arr[1:3]\n    c := (*reflect.SliceHeader)(unsafe.Pointer(&slice2))\n    // 指向的数组是 arr 从1下标开始的. 所以cap 是4\n    fmt.Println(c.Cap, c.Len) // 4 2\n    // slice2[2]  越界了,len是可以访问的范围\n    // 方式3\n    slice3 := make([]int, 5)\n    d := (*reflect.SliceHeader)(unsafe.Pointer(&slice3))\n    // 5,5,824634322544   data 初始化了, 分配了内存,对应的字节数组元素都是0\n    fmt.Println(d.Cap, d.Len, d.Data)\n    slice33 := make([]int, 1, 5)\n    dd := (*reflect.SliceHeader)(unsafe.Pointer(&slice33))\n    // cap =5, len=1\n    fmt.Println(dd.Cap, dd.Len, slice33[0])\n    // 方式4\n    var slice4 []int\n    e := (*reflect.SliceHeader)(unsafe.Pointer(&slice4))\n    // data 还没有初始化的 ,相比 slice4:=[]int{} 初始化推荐这种\n    fmt.Println(e.Cap, e.Len, e.Data)\n\n    a := [10]int{1, 2, 3, 4, 5, 6, 7, 8, 9}\n    // 2个切片引用同一个底层数组\n    a1 := a[1:4]\n    a2 := a[2:5]\n    a1[1] = 111\n    fmt.Println(a) // 修改了底层数组元素\n    a2[0] = 222\n    fmt.Println(a, a1[1])\n    a1 = append(a1, 333)\n    fmt.Println(a) // 修改了底层数组元素\n\n}",
    "crumbs": [
      "基础篇",
      "切片"
    ]
  },
  {
    "objectID": "docs/go/basic/slice.html#append",
    "href": "docs/go/basic/slice.html#append",
    "title": "斯巴拉稀",
    "section": "2 append",
    "text": "2 append\n\n\n\n\n\n\nTip\n\n\n\n\n由于真实的数据是通过引用数组,那么如果追加后长度超过了数组的cap,肯定需要重新分配一块内存,然后还需要将原来的数据复制到新的内存地址上\n新的内存要多大才好呢?\n\n\n\n\n\n哪个版本的go 已经忘记了. 后续更新最新版本的\n\nfunc growslice(et *_type, old slice, cap int) slice {\n    newcap := old.cap\n    doublecap := newcap + newcap\n    if cap &gt; doublecap {\n        //如果期望容量大于当前容量的两倍就会使用期望容量\n        newcap = cap\n    } else {\n        if old.len &lt; 1024 {\n            // 否则 如果当前切片的长度小于 1024 就会将容量设置为原先2倍大小\n            newcap = doublecap\n        } else {\n            //如果当前切片的长度大于 1024 就会每次增加 25% 的容量，直到新容量大于期望容量\n            for 0 &lt; newcap && newcap &lt; cap {\n                newcap += newcap / 4\n            }\n            if newcap &lt;= 0 {\n                newcap = cap\n            }\n        }\n    }\n}",
    "crumbs": [
      "基础篇",
      "切片"
    ]
  },
  {
    "objectID": "docs/go/basic/slice.html#遍历-for-range",
    "href": "docs/go/basic/slice.html#遍历-for-range",
    "title": "斯巴拉稀",
    "section": "3 遍历 for range",
    "text": "3 遍历 for range\nfunc TestSlice(t *testing.T) {\n    arr := []int{1, 2, 3}\n    var v2 *int\n    for _, v := range arr {\n        if v == 2 {\n            v2 = &v\n        }\n        fmt.Println(&v) // 同一个地址\n    }\n    fmt.Println(*v2) // 3\n}",
    "crumbs": [
      "基础篇",
      "切片"
    ]
  },
  {
    "objectID": "docs/go/basic/slice.html#增加排序",
    "href": "docs/go/basic/slice.html#增加排序",
    "title": "斯巴拉稀",
    "section": "4 增加排序",
    "text": "4 增加排序\npackage main\n\nimport (\n    \"fmt\"\n    \"math/rand\"\n    \"sort\"\n)\n\ntype Student struct {\n    Name string\n    Age  int\n    Id   string\n}\ntype StudentSlice []Student\n\n// 注意我们是给切片 排序,所以是让切片实现了接口\nfunc (p StudentSlice) Len() int {\n    return len(p)\n}\nfunc (p StudentSlice) Less(i, j int) bool {\n    return p[i].Name &gt; p[j].Name\n}\nfunc (p StudentSlice) Swap(i, j int) {\n    //这个彼此换,和python一样的写法\n    p[i], p[j] = p[j], p[i]\n}\nfunc main() {\n    var ss StudentSlice\n    for i := 0; i &lt; 10; i++ {\n        s := Student{\n            Name: fmt.Sprintf(\"stu%d\", rand.Intn(100)),\n            Id:   fmt.Sprintf(\"ID_%d\", rand.Intn(100)),\n            Age:  rand.Intn(100),\n        }\n        ss = append(ss, s)\n    }\n    for _, v := range ss {\n        fmt.Println(v)\n    }\n    sort.Sort(ss)\n    fmt.Println(\"=================\")\n    for _, v := range ss {\n        fmt.Println(v)\n    }\n}",
    "crumbs": [
      "基础篇",
      "切片"
    ]
  },
  {
    "objectID": "docs/go/basic/plan9.html",
    "href": "docs/go/basic/plan9.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "Important\n\n\n\n\n查看go底层执行的代码时, 可以通过查看汇编来找到源码位置\n下面几个查看的方式,结果格式略有不同\n\n\n\n\n\n方式一\n\n# -l 禁止内联优化\n# -N Disable optimizations.\n# 编译的二进制文件 禁止内联优化\ngo build -o main -gcflags \"-N -l\" main.go\n# -S Print assembly listing to standard output (code only).\n# 编译成二进制文件,并打印汇编代码\ngo build -o main -gcflags=\"-N -l -S\" main.go\n\n# 从可执行文件 反编译出汇编代码\n# 表示只输出 main 包中相关的汇编\ngo tool objdump -s \"main.\" main\n# 如果使用 \"main.main\" 则表示 只输出 main.main方法相关的汇编\ngo tool objdump -s \"main.main\" main\n#  -S   print Go code alongside assembly\n# 会打印对应的go代码\ngo tool objdump -s \"main.main\" -S main\n\n\n\n方式二\n\n#  会生成main.o 文件, -S 输出汇编代码\ngo tool compile -S -N -l main.go\n# 直接看代码的第几行的汇编代码\ngo tool compile -S -N -l main.go |grep \"main.go:8\"\n\n\n\n方式三\n\n# dlv  disassemble\n# 查看汇编代码\n(dlv) disassemble -l main.main",
    "crumbs": [
      "基础篇",
      "汇编"
    ]
  },
  {
    "objectID": "docs/go/basic/plan9.html#查看汇编代码1",
    "href": "docs/go/basic/plan9.html#查看汇编代码1",
    "title": "斯巴拉稀",
    "section": "",
    "text": "Important\n\n\n\n\n查看go底层执行的代码时, 可以通过查看汇编来找到源码位置\n下面几个查看的方式,结果格式略有不同\n\n\n\n\n\n方式一\n\n# -l 禁止内联优化\n# -N Disable optimizations.\n# 编译的二进制文件 禁止内联优化\ngo build -o main -gcflags \"-N -l\" main.go\n# -S Print assembly listing to standard output (code only).\n# 编译成二进制文件,并打印汇编代码\ngo build -o main -gcflags=\"-N -l -S\" main.go\n\n# 从可执行文件 反编译出汇编代码\n# 表示只输出 main 包中相关的汇编\ngo tool objdump -s \"main.\" main\n# 如果使用 \"main.main\" 则表示 只输出 main.main方法相关的汇编\ngo tool objdump -s \"main.main\" main\n#  -S   print Go code alongside assembly\n# 会打印对应的go代码\ngo tool objdump -s \"main.main\" -S main\n\n\n\n方式二\n\n#  会生成main.o 文件, -S 输出汇编代码\ngo tool compile -S -N -l main.go\n# 直接看代码的第几行的汇编代码\ngo tool compile -S -N -l main.go |grep \"main.go:8\"\n\n\n\n方式三\n\n# dlv  disassemble\n# 查看汇编代码\n(dlv) disassemble -l main.main",
    "crumbs": [
      "基础篇",
      "汇编"
    ]
  },
  {
    "objectID": "docs/go/basic/plan9.html#汇编分析go代码",
    "href": "docs/go/basic/plan9.html#汇编分析go代码",
    "title": "斯巴拉稀",
    "section": "2 汇编分析go代码",
    "text": "2 汇编分析go代码\n\n\n\n\n\n\nTip\n\n\n\n更详细的汇编说明后续会专门写教程,有些很多都忘记了…,得重新花时间再看看\n\n\n\n2.1 函数调用为啥使用栈\npackage main\n\nfunc C() {\n    println(4)\n}\nfunc B() {\n    C()\n    println(3)\n}\nfunc A() {\n    B()\n    println(2)\n}\n\nfunc main() {\n    A()\n    println(1)\n}\n\n\n\n\n\n\n思考\n\n\n\n\n函数的执行是后来的先执行,这个和栈的后进先出特征一致\n执行一个函数需要的一些内存: 参数, 返回值, 自己的局部变量\n\n参数和返回值 由调用者分配 (理由后面讲)\n局部变量所在的内存, 如果在函数执行完毕后,没有用了,那直接在函数栈上即可,返回时,弹出,移动栈顶指针即可,(就是内存释放)\n局部变量所在的内存, 如果在函数执行完毕后,还要用到,就不能在函数栈上分配了,在其他地方分配,然后返回值返回它地址即可\n\n这样函数自己分配的栈空间在调用完毕后可以完全释放了,符合入栈出栈, 可以用来管理函数\n还有一点可以得出,就是在栈上分配内存的变量它的大小是必须确定的\n\n比如定义一个局部变量 是字符串, 然后在后续代码的执行过程中, 字符串做了增加, 这说明你的字符串占用的内存大小不固定,你肯定不能将它完全直接分配在栈上了\n所以这类型的变量,必定需要在其他地方分配 (堆上分配, 栈上存它的指针,指针大小是确定的)\n\n\n\n\n\n\n2.2 要分析的go代码\npackage main\n\nfunc add(c, d int64) (sum int64) {\n    var add_local_var int64 = 3\n    sum = c + d + add_local_var\n    return sum\n}\n\nfunc main() {\n    var r int64\n    var a, b int64 = 1, 2\n    r = add(a, b)\n    println(r)\n}\n\n\n\n\n\n\n注意\n\n\n\ngo 的版本不一样看到的结果可能不一样\n\n\n\n\n\nOS\ngo version\n\n\n\n\nUbuntu 20.04.3 LTS\ngo1.20.4\n\n\n\ngo tool compile -S -N -l main.go\n\n\n2.3 main.main\n\n\n\n\n\n\n\nitem\ndescription\n\n\n\n\ncaller\n调用者\n\n\ncallee\n被调用者\n\n\nSP\n栈顶指针\n\n\n$数字\n立即数: 就是直接是指令来进行数据赋值,而不是从哪块内存读取数据的操作\n\n\n\n\nargs: 参数+返回值, main()的调用者传递给main的参数,没有,显示 0\nlocals: 包含如下\n\nmain函数本地使用的局部变量\n调用其他所有函数时传递的参数以及它的返回值 (=callee 所有 args之和) ,参数和返回值由caller负责分配\n\n\n\n\n\n\n\n\n为什么callee的参数和返回值要由caller分配内存呢?\n\n\n\n\n如果在 callee 栈中分配, 那么每次调用 callee 都要进行内存分配和释放的操作,比如你在 main函数里多次 调用 add(),每次调用都要分配一次内存和释放\n如果在 caller 栈中分配内存，caller 调用多次 callee, 也只需要一次内存分配操作\n局部变量 a和b 申请的栈空间直接作为 add 的参数(c ,d)不行吗?\n\n如果add 里对 参数做修改, 汇编代码怎么处理?\n\n直接修改 caller的a,b 所在的栈内存吗? 那肯定不行\n在 callee 中申请内存? 那又变成多次分配释放的问题了,也不行的\n\n处理方式就是在 caller 栈中申请参数 ! ==&gt;可以说明函数是值转递的\n\n返回值的额外理由\n\ncallee 的返回值, 肯定是 caller 需要用到,所以 在caller直接申请内存空间就行了,callee 直接将结果写入caller的函数栈内存即可\n如果你callee申请 ,最后函数返回会释放内存, 你可能还需要将返回值复制到 caller 的函数栈内,这样会导致额外的内存拷贝操作\n\n\n\n\nmain.main STEXT size=109 args=0x0 locals=0x30 funcid=0x0 align=0x0\n    # SB  伪寄存器，保存静态基地址(static-base) 指针，即我们程序地址空间的开始地址\n    0x0000 00000 (main.go:9)    TEXT    main.main(SB), ABIInternal, $48-0 \n    0x0000 00000 (main.go:9)    CMPQ    SP, 16(R14)\n    # PCDATA  垃圾回收相关, 由go 编译器加入\n    0x0004 00004 (main.go:9)    PCDATA  $0, $-2\n    0x0004 00004 (main.go:9)    JLS 102\n    0x0006 00006 (main.go:9)    PCDATA  $0, $-1\n    # \"main 申请的48个字节\"\n    # `SUBQ $48, SP`  SP=SP-48 ,栈顶指针往下移动48个字节, 就是main函数 申请 48个字节的栈空间\n    # main的局部变量 a b 共16个字节\n    # 调用add ,需要 传递的参数 16个字节, r 接收add返回值 占8个字节  共 24个字节 都由caller(即main) 分配\n    # 保存BP  占8个字节\n    # 调用println()  传参 直接使用的r,我估计是编译器明确知道println 不会修改参数的原因?\n    0x0006 00006 (main.go:9)    SUBQ    $48, SP \n    # BP 伪寄存器, 调用者(这里就是main的调用者)函数栈的起始位置 仅作为一个指示作用\n    # 保存BP 伪寄存器 到栈 SP+40 的位置\n    0x000a 00010 (main.go:9)    MOVQ    BP, 40(SP)\n    # 将 SP+40 这个地址 (栈地址)  设置给 BP寄存器\n    # 现在 BP寄存器指向的栈内存 存储的是 原来BP的值\n    0x000f 00015 (main.go:9)    LEAQ    40(SP), BP\n    # FUNCDATA  垃圾回收相关, 由go 编译器加入\n    0x0014 00020 (main.go:9)    FUNCDATA    $0, gclocals·g2BeySu+wFnoycgXfElmcg==(SB)\n    0x0014 00020 (main.go:9)    FUNCDATA    $1, gclocals·g2BeySu+wFnoycgXfElmcg==(SB)\n    # 将 SP+16 的栈内存 设置 立即数 0 ==&gt; r变量\n    0x0014 00020 (main.go:10)   MOVQ    $0, main.r+16(SP)\n    # 将 SP+32 的栈内存 设置 立即数 1 ==&gt; a变量\n    0x001d 00029 (main.go:11)   MOVQ    $1, main.a+32(SP)\n    # 将 SP+24 的栈内存 设置 立即数 2 ==&gt; b变量\n    0x0026 00038 (main.go:11)   MOVQ    $2, main.b+24(SP)\n    # 将 立即数 1 设置到 寄存器 AX\n    0x002f 00047 (main.go:12)   MOVL    $1, AX\n    # 将 立即数 2 设置到 寄存器 BX\n    0x0034 00052 (main.go:12)   MOVL    $2, BX\n    0x0039 00057 (main.go:12)   PCDATA  $1, $0\n\n调用 add 函数, 去看main.add\nCALL 指令\n\n将ip 压栈 就是将下一条指令(调用函数后的下一个要执行的指令)的地址 压栈\n压栈: 先将栈顶指针下移, SP=SP-8 (内存地址占8个字节), 然后将ip设置到SP指向的栈上\n调用的add 函数 最后会有一个RET 操作, 是弹栈. (call 和 ret)\n\n\n    0x0039 00057 (main.go:12)   CALL    main.add(SB)\n\nCALL 的add 最后的RET后, SP又重新变成一开始的 SP-48的位置了. 将AX寄存器里的值设置到 r的栈内存位置\n    0x003e 00062 (main.go:12)   MOVQ    AX, main.r+16(SP)\n\n    0x0043 00067 (main.go:13)   CALL    runtime.printlock(SB)\n    0x0048 00072 (main.go:13)   MOVQ    main.r+16(SP), AX\n    0x004d 00077 (main.go:13)   CALL    runtime.printint(SB)\n    0x0052 00082 (main.go:13)   CALL    runtime.printnl(SB)\n    0x0057 00087 (main.go:13)   CALL    runtime.printunlock(SB)\n复原BP,SP\n    0x005c 00092 (main.go:14)   MOVQ    40(SP), BP\n    0x0061 00097 (main.go:14)   ADDQ    $48, SP\n    0x0065 00101 (main.go:14)   RET\n\n\n2.4 main.add\n\nargs = 0x10=16, 使用了caller的栈内存 (参数+返回值)\n$24-16\n\n24表示add 申请的栈内存空间,\n16表示 用到了 caller的栈内存空间大小 = args\n 你可能会觉得 不应该是 参数+返回值= 24个字节吗?? 怎么是16,后面说 \n\n\nmain.add STEXT nosplit size=63 args=0x10 locals=0x18 funcid=0x0 align=0x0\n    0x0000 00000 (main.go:3)    TEXT    main.add(SB), NOSPLIT|ABIInternal, $24-16\n\nBP+局部变量(sum+add_local_var) 共24个字节?\n 你可能又会觉得 这个sum 不就是 main栈空间的r吗? 不直接使用它而在add栈内分配了内存呢? 后面解答\n\n    0x0000 00000 (main.go:3)    SUBQ    $24, SP\n    0x0004 00004 (main.go:3)    MOVQ    BP, 16(SP)\n    0x0009 00009 (main.go:3)    LEAQ    16(SP), BP\n    0x000e 00014 (main.go:3)    FUNCDATA    $0, gclocals·g2BeySu+wFnoycgXfElmcg==(SB)\n    0x000e 00014 (main.go:3)    FUNCDATA    $1, gclocals·g2BeySu+wFnoycgXfElmcg==(SB)\n    0x000e 00014 (main.go:3)    FUNCDATA    $5, main.add.arginfo1(SB)\n\n将AX( 即 1) 设置到 SP+32 =SP+24(add申请的栈空间)+8(call add 压栈) 这个位置就是 main一开始申请栈内存后的 sp的位置, 参数c\n将BX( 即 2) 参数d\n\n    0x000e 00014 (main.go:3)    MOVQ    AX, main.c+32(SP)\n    0x0013 00019 (main.go:3)    MOVQ    BX, main.d+40(SP)\n\n初始化 sum变量设置为0\n设置 局部变量 add_local_var =3\n\n    0x0018 00024 (main.go:3)    MOVQ    $0, main.sum(SP)\n    0x0020 00032 (main.go:4)    MOVQ    $3, main.add_local_var+8(SP)\n\n计算后将结果设置到AX 以及sum变量,我们发现这里并没有操作main的栈内存分配的返回值r\n所以 $24-16 写的是16\n\n\n\n\n\n\n\n$24-16的问题, 知道即可,无需太过在意\n\n\n\n\n我在看笔记的时候,发现以前的显示的args是24, 以前的看起来符合我们前面说的.\n为什么不一样 我估计是go 版本的问题, 下面是我试了几个go版本后,一个符合的\n\n\n\ngo1.15.4版本的汇编情况\n\n\"\".add STEXT nosplit size=60 args=0x18 locals=0x10\n0x0000 00000 (main.go:3)    TEXT    \"\".add(SB), NOSPLIT|ABIInternal, $16-24\n0x0000 00000 (main.go:3)    SUBQ    $16, SP\n0x0004 00004 (main.go:3)    MOVQ    BP, 8(SP)\n0x0009 00009 (main.go:3)    LEAQ    8(SP), BP\n0x000e 00014 (main.go:3)    FUNCDATA    $0, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)\n0x000e 00014 (main.go:3)    FUNCDATA    $1, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)\n0x000e 00014 (main.go:3)    MOVQ    $0, \"\".sum+40(SP)\n0x0017 00023 (main.go:4)    MOVQ    $3, \"\".add_local_var(SP)\n0x001f 00031 (main.go:5)    MOVQ    \"\".c+24(SP), AX\n0x0024 00036 (main.go:5)    ADDQ    \"\".d+32(SP), AX\n0x0029 00041 (main.go:5)    ADDQ    $3, AX\n0x002d 00045 (main.go:5)    MOVQ    AX, \"\".sum+40(SP)\n0x0032 00050 (main.go:6)    MOVQ    8(SP), BP\n0x0037 00055 (main.go:6)    ADDQ    $16, SP\n0x003b 00059 (main.go:6)    RET\n\n我们可以发现 8行和13行, add函数是直接使用main的栈内存作为sum的,所以add它申请的栈内存只有16,而使用的caller的栈内存是24个字节\n\n\n    0x0029 00041 (main.go:5)    LEAQ    (AX)(BX*1), AX\n    0x002d 00045 (main.go:5)    LEAQ    3(AX), AX\n    0x0031 00049 (main.go:5)    MOVQ    AX, main.sum(SP)\n\nBP和SP归位\n    0x0035 00053 (main.go:6)    MOVQ    16(SP), BP\n    0x003a 00058 (main.go:6)    ADDQ    $24, SP\n\nRET\n\n=POP IP, 将之前main call add的时候 压栈的ip,弹出 写入到 ip寄存器,这样 cpu就知道重新执行哪一条指令了\n先读取栈数据 写入ip寄存器, 然后 SP=SP+8 往上移动, 这样就回到了 call add 之前的 sp位置了.\n\n\n    0x003e 00062 (main.go:6)    RET",
    "crumbs": [
      "基础篇",
      "汇编"
    ]
  },
  {
    "objectID": "docs/go/basic/plan9.html#go调用汇编代码写的函数",
    "href": "docs/go/basic/plan9.html#go调用汇编代码写的函数",
    "title": "斯巴拉稀",
    "section": "3 go调用汇编代码写的函数",
    "text": "3 go调用汇编代码写的函数",
    "crumbs": [
      "基础篇",
      "汇编"
    ]
  },
  {
    "objectID": "docs/go/basic/plan9.html#footnotes",
    "href": "docs/go/basic/plan9.html#footnotes",
    "title": "斯巴拉稀",
    "section": "Footnotes",
    "text": "Footnotes\n\n\ntool compile↩︎",
    "crumbs": [
      "基础篇",
      "汇编"
    ]
  },
  {
    "objectID": "docs/go/basic/func-closure.html",
    "href": "docs/go/basic/func-closure.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "main.go\n\npackage main\n\nimport (\n    \"fmt\"\n    \"unsafe\"\n)\n\nfunc add(a, b int) int {\n    sum := 0\n    sum = a + b\n    return sum\n}\n\nfunc main() {\n    println(add)\n    addFuncVar := add\n    println(addFuncVar)\n    // 这里由于println() 和 fmt.Printf(\"%p\") 打印 函数名, 处理上不同, 为了看函数名所代表直接内容\n    addFuncVarVal := *(*uint64)(unsafe.Pointer(&addFuncVar))\n    // 我们得到addFunc变量的值 与上面 println(add) 相同\n    fmt.Printf(\"函数名所表示的值: 0x%x\\n\", addFuncVarVal)\n    // 我们将这个值 作为内存地址, 将它转换为指针,找到它指向的内容\n    addFuncCodeRealAddr := *(*uint64)(unsafe.Pointer(uintptr(addFuncVarVal)))\n    fmt.Printf(\"把函数名表示的值作为地址,它指向的那块内存的内容 (即代码地址): 0x%x\\n\", addFuncCodeRealAddr)\n    // fmt.Printf 打印 函数名 地址 结果是 真正代码的地址\n    fmt.Printf(\"fmt.Printf(\\\"%%p\\\")打印的值: %p\\n\", add)\n    add(1, 2)\n    println(9999)\n}\n\n\n\n编译\n\ngo build -o main -gcflags \"-N -l\" main.go\n\n\n\n./main  执行结果\n\n0x10b1790\n0x10b1790\n函数名所表示的值: 0x10b1790\n把函数名表示的值作为地址,它指向的那块内存的内容 (即代码地址): 0x108f600\nfmt.Printf(\"%p\")打印的值: 0x108f600\n9999\n\n\n\ndlv调试查看 add代码实际地址\n\n# 断点打到 add(1,2) 那里\n(dlv) s #进入函数add ,我们可以看到 PC的值, 这里是add代码指令的内存地址\n&gt; main.add() ./main.go:8 (PC: 0x108f600)\n     3: import (\n     4:         \"fmt\"\n     5:         \"unsafe\"\n     6: )\n     7:\n=&gt;   8: func add(a, b int) int {\n\n\n\n直接查看汇编代码来看add代码内存地址\n\ngo tool objdump -s \"main.add\" main\nTEXT main.add(SB) main.go\n  main.go:8             0x108f600               4883ec18                SUBQ $0x18, SP\n  main.go:8             0x108f604               48896c2410              MOVQ BP, 0x10(SP)\n  main.go:8             0x108f609               488d6c2410              LEAQ 0x10(SP), BP\n  main.go:8             0x108f60e               4889442420              MOVQ AX, 0x20(SP)\n  #....\n\n\n\n你可以继续用代码获取 add 编译后的指令,与上面的 4883ec18 是否一致 (注意左边是低地址的内容)\n\n    addFuncCode := *(*uint32)(unsafe.Pointer(uintptr(addFuncCodeRealAddr)))\n    fmt.Printf(\"0x%x\\n\", addFuncCode)\n\n上面的操作可以说用代码来实现获取”代码内容”\n\n\n\n\n\n\n结论\n\n\n\n\n函数名是个二级指针!\n带着为什么函数名是个二级指针的疑问,我们继续看闭包",
    "crumbs": [
      "基础篇",
      "函数和闭包"
    ]
  },
  {
    "objectID": "docs/go/basic/func-closure.html#函数名到底是个啥",
    "href": "docs/go/basic/func-closure.html#函数名到底是个啥",
    "title": "斯巴拉稀",
    "section": "",
    "text": "main.go\n\npackage main\n\nimport (\n    \"fmt\"\n    \"unsafe\"\n)\n\nfunc add(a, b int) int {\n    sum := 0\n    sum = a + b\n    return sum\n}\n\nfunc main() {\n    println(add)\n    addFuncVar := add\n    println(addFuncVar)\n    // 这里由于println() 和 fmt.Printf(\"%p\") 打印 函数名, 处理上不同, 为了看函数名所代表直接内容\n    addFuncVarVal := *(*uint64)(unsafe.Pointer(&addFuncVar))\n    // 我们得到addFunc变量的值 与上面 println(add) 相同\n    fmt.Printf(\"函数名所表示的值: 0x%x\\n\", addFuncVarVal)\n    // 我们将这个值 作为内存地址, 将它转换为指针,找到它指向的内容\n    addFuncCodeRealAddr := *(*uint64)(unsafe.Pointer(uintptr(addFuncVarVal)))\n    fmt.Printf(\"把函数名表示的值作为地址,它指向的那块内存的内容 (即代码地址): 0x%x\\n\", addFuncCodeRealAddr)\n    // fmt.Printf 打印 函数名 地址 结果是 真正代码的地址\n    fmt.Printf(\"fmt.Printf(\\\"%%p\\\")打印的值: %p\\n\", add)\n    add(1, 2)\n    println(9999)\n}\n\n\n\n编译\n\ngo build -o main -gcflags \"-N -l\" main.go\n\n\n\n./main  执行结果\n\n0x10b1790\n0x10b1790\n函数名所表示的值: 0x10b1790\n把函数名表示的值作为地址,它指向的那块内存的内容 (即代码地址): 0x108f600\nfmt.Printf(\"%p\")打印的值: 0x108f600\n9999\n\n\n\ndlv调试查看 add代码实际地址\n\n# 断点打到 add(1,2) 那里\n(dlv) s #进入函数add ,我们可以看到 PC的值, 这里是add代码指令的内存地址\n&gt; main.add() ./main.go:8 (PC: 0x108f600)\n     3: import (\n     4:         \"fmt\"\n     5:         \"unsafe\"\n     6: )\n     7:\n=&gt;   8: func add(a, b int) int {\n\n\n\n直接查看汇编代码来看add代码内存地址\n\ngo tool objdump -s \"main.add\" main\nTEXT main.add(SB) main.go\n  main.go:8             0x108f600               4883ec18                SUBQ $0x18, SP\n  main.go:8             0x108f604               48896c2410              MOVQ BP, 0x10(SP)\n  main.go:8             0x108f609               488d6c2410              LEAQ 0x10(SP), BP\n  main.go:8             0x108f60e               4889442420              MOVQ AX, 0x20(SP)\n  #....\n\n\n\n你可以继续用代码获取 add 编译后的指令,与上面的 4883ec18 是否一致 (注意左边是低地址的内容)\n\n    addFuncCode := *(*uint32)(unsafe.Pointer(uintptr(addFuncCodeRealAddr)))\n    fmt.Printf(\"0x%x\\n\", addFuncCode)\n\n上面的操作可以说用代码来实现获取”代码内容”\n\n\n\n\n\n\n结论\n\n\n\n\n函数名是个二级指针!\n带着为什么函数名是个二级指针的疑问,我们继续看闭包",
    "crumbs": [
      "基础篇",
      "函数和闭包"
    ]
  },
  {
    "objectID": "docs/go/basic/func-closure.html#闭包",
    "href": "docs/go/basic/func-closure.html#闭包",
    "title": "斯巴拉稀",
    "section": "2 闭包",
    "text": "2 闭包\n\n\n\n\n\n\nCaution\n\n\n\n闭包（closure）是一个函数以及其捆绑的周边环境状态（lexical environment，词法环境）的引用的组合.\n换而言之,闭包让开发者可以从内部函数访问外部函数的作用域\n\n\n\n\n请看高亮的注释的思考\n\npackage main\n\n// 外部函数\nfunc outerFunc() func() int {\n    var x int=1\n    // 内部函数\n    innerFunc := func() int {\n        // x 属于 outerFunc的\n        // 如果x在栈上,执行完 outerFunc ,x 那么作为它的局部变量会被释放,这肯定不行\n        // 因为 我们这个 return的 innerFunc 还会操作x,所以逃逸到堆上\n        x = x + 1\n        return x\n    }\n    // 既然 innerFunc 会操作到x\n    // 那么 innerFunc 这个东西所在的内存除了它自己函数的信息(函数体)外\n    // 还必定含有x 这个数据的相关信息\n    /*\n    问: 为什么不直接将x 这个外部变量的信息编译到函数体内呢?\n    答: 如果直接在函数体内, 那么堆上申请内存,初始化x 的操作都在函数内,\n        然而这样你调用完函数后,没有任何东西再引用这个x了,x必定释放了,这与闭包本身的目的不一致了.\n        而且你重新调用一次函数, 重新初始化了,不行\n    */\n    // 把x作为innerFunc的参数? 这不行,首先这不跟传参的一样吗, 还是值传递不成.\n    // 值传递? 搞成传递指针 好像行得通? (这里只是一种思考)\n    //   闭包的调用者堆上申请x的内存,(注:不同的闭包对外部变量的使用情况可能会有不同)\n    //   然后在自己的栈帧上存地址,将地址传递给闭包函数\n\n    return innerFunc\n}\n\nfunc main() {\n    // 创建一个闭包函数\n    closure := outerFunc()\n\n    // 调用闭包函数\n    closure()\n}\n\n通过汇编来看看实际的情况\ngo build -o main -gcflags \"-N -l -S\" main.go\n会看到当前这个闭包的结构\nruntime.newobject\nLEAQ    type:noalg.struct { F uintptr; main.x *int }(SB), AX\n\n\n代码验证结构\n\npackage main\n\nimport (\n    \"unsafe\"\n)\n\nfunc outerFunc() func() int {\n    var x int = 1\n    innerFunc := func() int {\n        x = x + 1\n        return x\n    }\n    return innerFunc\n}\n\n//go:linkname inheap runtime.inheap\nfunc inheap(arg uintptr) bool\n\nfunc inHeapOrStack(b uintptr) bool\nfunc main() {\n    type closureStruct struct {\n        F uintptr // 闭包的函数的地址\n        x *int    // 闭包的外部变量 这里是指针\n    }\n    // 创建一个闭包函数\n    closure := outerFunc()\n    closureVal := *(*uint64)(unsafe.Pointer(&closure))\n    println(inheap(uintptr(closureVal))) //堆上\n    println(closure, closureVal)         // 0xc000090000\n    closureCodeRealAddrAndVar := *(*closureStruct)(unsafe.Pointer(uintptr(closureVal)))\n    println(*closureCodeRealAddrAndVar.x) // 1\n    println(closureCodeRealAddrAndVar.x)  // 0xc00008e000  堆上\n    println(closureCodeRealAddrAndVar.F)  // 闭包函数的地址 0x1057820  只读\n    // 调用闭包函数\n    println(closure()) // 2\n    println(closure()) // 3\n\n    closure2 := outerFunc()\n    closureVal2 := *(*uint64)(unsafe.Pointer(&closure2))\n    closureCodeRealAddrAndVar2 := *(*closureStruct)(unsafe.Pointer(uintptr(closureVal2)))\n    // 函数地址一样\n    println(closureCodeRealAddrAndVar2.F == closureCodeRealAddrAndVar.F) // true\n\n}\n\n\n我们看看下面这个例子的结构\n\n\n验证一下闭包结构\n\npackage main\n\nimport (\n    \"fmt\"\n    \"unsafe\"\n)\n\nfunc outerFunc(x int) func() int {\n    innerFunc := func() int {\n        return x\n    }\n    return innerFunc\n}\n\nfunc main() {\n    // 创建一个闭包函数\n    closure := outerFunc(10)\n    // 这个是针对 上面的闭包结构\n    type closureStruct struct {\n        F uintptr\n        x int //直接存就行了. 因为没做修改等操作,就打印的需求\n    }\n    closureVal := *(*uint64)(unsafe.Pointer(&closure))\n    println(closureVal)\n    closureCodeRealAddrAndVar := *(*closureStruct)(unsafe.Pointer(uintptr(closureVal)))\n    println(closureCodeRealAddrAndVar.x) //10\n    println(closureCodeRealAddrAndVar.F) //闭包函数的地址\n    // 调用闭包函数\n    closure()\n\n}",
    "crumbs": [
      "基础篇",
      "函数和闭包"
    ]
  },
  {
    "objectID": "docs/go/basic/func-closure.html#println-fmt.print",
    "href": "docs/go/basic/func-closure.html#println-fmt.print",
    "title": "斯巴拉稀",
    "section": "3 println & fmt.Print",
    "text": "3 println & fmt.Print\n\n\n\n\n\n\nTip\n\n\n\ntodo",
    "crumbs": [
      "基础篇",
      "函数和闭包"
    ]
  },
  {
    "objectID": "docs/go/basic/variable-type.html",
    "href": "docs/go/basic/variable-type.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "一个变量就是一块内存(有的变量不占内存空间),变量的类型规定了你 如何从这块内存里读取数据和写入数据,且给这个类型的变量一些”操作方法”,比如 数组的下标操作",
    "crumbs": [
      "基础篇",
      "变量与类型的本质"
    ]
  },
  {
    "objectID": "docs/go/basic/variable-type.html#大小端",
    "href": "docs/go/basic/variable-type.html#大小端",
    "title": "斯巴拉稀",
    "section": "1 大小端",
    "text": "1 大小端",
    "crumbs": [
      "基础篇",
      "变量与类型的本质"
    ]
  },
  {
    "objectID": "docs/go/basic/variable-type.html#代码判断大小端",
    "href": "docs/go/basic/variable-type.html#代码判断大小端",
    "title": "斯巴拉稀",
    "section": "2 代码判断大小端",
    "text": "2 代码判断大小端\nvar val int32 = 1\nptr := unsafe.Pointer(&val)\nIsLittleEndian := *(*byte)(ptr) == 1\nprintln(IsLittleEndian) //true 就是小端模式",
    "crumbs": [
      "基础篇",
      "变量与类型的本质"
    ]
  },
  {
    "objectID": "docs/go/basic/variable-type.html#变量类型与类型转换",
    "href": "docs/go/basic/variable-type.html#变量类型与类型转换",
    "title": "斯巴拉稀",
    "section": "3 变量类型与类型转换",
    "text": "3 变量类型与类型转换\n变量的类型规定了你如何从这块内存里读取数据和写入数据 类型的转换无非就是你换了一种读写数据的方式而已\nfunc main() {\n    // 1000 0011\n    var a uint8 = 131\n    println(a)\n    // 变成有符号的, 那么它的数据的读取方式就变了\n    // 1000 0011 负数的补码\n    // 反码 1000 0010\n    // 原码 1111 1101 = -125\n    b := int8(a)\n    println(b) // -125\n}\n\n3.1 一块可读写的内存,是不是可以按照我任意的方式来读写呢?\n是的, 你想怎么读写,就怎么读写\npackage main\n\nimport (\n    \"unsafe\"\n)\n\ntype FF struct {\n    i int32\n    j int8\n    k int8\n}\n\nfunc main() {\n    // 我们这里假定 z和 a 变量之间是连续的 (因为可能不一定是连续的!)\n    var z int32 = 1800\n    var a, b, c, d int8 = 2, 4, 3, 1\n\n    ptr := unsafe.Pointer(&d)\n    // 格式化(类型转换)  理解为 你想这么去读写这块内存上的数据\n    // 这里当然你可以就用 (*int32)(ptr) 来格式化 读取4个字节的测试\n    ff := (*FF)(ptr)\n    //0xc00004c753 0xc00004c752 0xc00004c751 0xc00004c750\n    println(&a, &b, &c, &d)\n    // 0xc00004c754\n    println(&z)\n    // 0xc00004c750 0xc00004c754\n    println(&ff.i, &ff.j)\n    // 33817345 8 7\n    println(ff.i, ff.j, ff.k)\n    // 直接修改了z 原来那块内存上某个字节上的数据了.\n    // 当然如果要去改变量的某个字节上的数据, 可以用位运算..\n    ff.j = 9\n    // 1801\n    println(z)\n    ff.k = 1\n    // 265\n    println(z)\n\n}\n\n\n再举个例子\n\npackage main\n\nimport (\n    \"unsafe\"\n)\n\ntype dd struct {\n    i1  int8\n    arr [3]int8\n}\n\nfunc main() {\n    d := 33817345\n    // 想怎么格式化就怎么格式化\n    // 想怎么读写数据就怎么格式化它\n    d2 := (*dd)(unsafe.Pointer(&d))\n    println(d2.i1, d2.arr[0], d2.arr[1], d2.arr[2])\n    d2.arr[0] = 6\n    println(d)\n}\n理解了类型,使用起 (unsafe.Pointer) 会变得更容易",
    "crumbs": [
      "基础篇",
      "变量与类型的本质"
    ]
  },
  {
    "objectID": "docs/go/basic/variable-type.html#指针的类型",
    "href": "docs/go/basic/variable-type.html#指针的类型",
    "title": "斯巴拉稀",
    "section": "4 指针的类型",
    "text": "4 指针的类型\n\n\n\n\n\n\nTip\n\n\n\n\n指针: 它的值是一个地址, 一般说它指向一个内存地址\n指针类型: 说明了你用什么样的方式结构去读取它指向的那块内存\n\n\n\n// 新的结构= 新的内存读取方式\nnewPtr:=(*新的结构)(unsafe.Pointer(地址))",
    "crumbs": [
      "基础篇",
      "变量与类型的本质"
    ]
  },
  {
    "objectID": "docs/go/basic/struct.html",
    "href": "docs/go/basic/struct.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "结构体和方法是通过方法集（method set）联系起来的.方法集是一个特殊的函数指针,它指向结构体类型的方法. 当定义一个结构体类型时,Go语言会为这个类型生成一个方法集\n\n\n反射来打印对象的方法\n\ntype Dog struct {\n    Age  int\n    Name string\n}\n\nfunc (d Dog) SetName(name string) {\n    fmt.Println(\"input::\", name)\n    d.Name = name\n}\n\nfunc (d *Dog) GetName() string {\n    fmt.Printf(\"方法内的地址: %p\\n\", d)\n    return d.Name\n}\n\nfunc TestStruct(t *testing.T) {\n    fmt.Println(\"Dog 类型的 方法\")\n    d := Dog{Age: 2}\n    v := reflect.TypeOf(d)\n    for i := 0; i &lt; v.NumMethod(); i++ {\n        // SetName == func(test.Dog, string) == func\n        fmt.Println(v.Method(i).Name, \"==\", v.Method(i).Type, \"==\", v.Method(i).Type.Kind())\n    }\n    fmt.Println(\"*Dog 类型的方法\")\n    d2 := &Dog{}\n    v2 := reflect.TypeOf(d2)\n    for i := 0; i &lt; v2.NumMethod(); i++ {\n        // 注意有2个func, SetName(*Dog,string) 方法 自动生成了\n        // 虽然我们只定义了 func SetName(Dog,string) 方法\n        // GetName == func(*test.Dog) string == func\n        // SetName == func(*test.Dog, string) == func\n        fmt.Println(v2.Method(i).Name, \"==\", v2.Method(i).Type, \"==\", v2.Method(i).Type.Kind())\n    }\n}\n\n\n\n\n\n\n\n重要结论\n\n\n\n注意 编译器为 Dog 类型的 Shout方法 生成了 对应 *Dog类型 的Shout方法\n\n\n\n\n命令查看实现的方法\n\ngo tool compile -S -N -l main.go\n# 查看有哪些函数\ngo tool nm -type  main.o|grep ' T '",
    "crumbs": [
      "基础篇",
      "结构体"
    ]
  },
  {
    "objectID": "docs/go/basic/struct.html#结构体和方法是如何联系的",
    "href": "docs/go/basic/struct.html#结构体和方法是如何联系的",
    "title": "斯巴拉稀",
    "section": "",
    "text": "结构体和方法是通过方法集（method set）联系起来的.方法集是一个特殊的函数指针,它指向结构体类型的方法. 当定义一个结构体类型时,Go语言会为这个类型生成一个方法集\n\n\n反射来打印对象的方法\n\ntype Dog struct {\n    Age  int\n    Name string\n}\n\nfunc (d Dog) SetName(name string) {\n    fmt.Println(\"input::\", name)\n    d.Name = name\n}\n\nfunc (d *Dog) GetName() string {\n    fmt.Printf(\"方法内的地址: %p\\n\", d)\n    return d.Name\n}\n\nfunc TestStruct(t *testing.T) {\n    fmt.Println(\"Dog 类型的 方法\")\n    d := Dog{Age: 2}\n    v := reflect.TypeOf(d)\n    for i := 0; i &lt; v.NumMethod(); i++ {\n        // SetName == func(test.Dog, string) == func\n        fmt.Println(v.Method(i).Name, \"==\", v.Method(i).Type, \"==\", v.Method(i).Type.Kind())\n    }\n    fmt.Println(\"*Dog 类型的方法\")\n    d2 := &Dog{}\n    v2 := reflect.TypeOf(d2)\n    for i := 0; i &lt; v2.NumMethod(); i++ {\n        // 注意有2个func, SetName(*Dog,string) 方法 自动生成了\n        // 虽然我们只定义了 func SetName(Dog,string) 方法\n        // GetName == func(*test.Dog) string == func\n        // SetName == func(*test.Dog, string) == func\n        fmt.Println(v2.Method(i).Name, \"==\", v2.Method(i).Type, \"==\", v2.Method(i).Type.Kind())\n    }\n}\n\n\n\n\n\n\n\n重要结论\n\n\n\n注意 编译器为 Dog 类型的 Shout方法 生成了 对应 *Dog类型 的Shout方法\n\n\n\n\n命令查看实现的方法\n\ngo tool compile -S -N -l main.go\n# 查看有哪些函数\ngo tool nm -type  main.o|grep ' T '",
    "crumbs": [
      "基础篇",
      "结构体"
    ]
  },
  {
    "objectID": "docs/go/basic/struct.html#结构体方法的实质与参数",
    "href": "docs/go/basic/struct.html#结构体方法的实质与参数",
    "title": "斯巴拉稀",
    "section": "2 结构体方法的实质与参数",
    "text": "2 结构体方法的实质与参数\n\n\n\n\n\n\nTip\n\n\n\n结构体调用方法实际上是函数的第一个参数是结构体\n\n\ntype Dog struct {\n    Age  int\n    Name string\n}\n\nfunc (d *Dog) GetName() string {\n    // 与TestStruct2的 &d  地址一样\n    fmt.Printf(\"方法内的地址: %p\\n\", d)\n    return d.Name\n}\n\nfunc (d Dog) SetName(name string) {\n    fmt.Println(\"input::\", name)\n    d.Name = name\n}\n\n\n// 前面通过反射我们看到实际上的方法是这样的\n/*\nfunc SetName(d Dog,name string) {\n    d.Name = name\n}\n\nfunc GetName(d *Dog) string{\n    return d.Name\n}\n\n结构体方法会自动生成一个结构体指针的方法\nfunc SetName(d *Dog,name string) {\n    d.Name = name\n}\n*/\n\n结构体调用方法结构体指针调用方法\n\n\nfunc TestStruct2(t *testing.T) {\n    d := Dog{Age: 3, Name: \"hello\"}\n    fmt.Printf(\"外部的  地址:%p\\n\", &d)\n    // 实际是将 &d 传递 给 GetName(&d)  ==&gt; (*Dog).GetName(&d)\n    println(d.GetName()) // hello\n    // 等价于 执行   Dog.SetName(d, \"abc\")\n    d.SetName(\"abc\")     // SetName(d) , 由于go 是值传递的 ,所以没有改变d的Name属性\n    println(d.Name)      // hello\n}\n\n\nfunc TestStruct2(t *testing.T) {\n    f := &Dog{Age: 3, Name: \"hello\"}\n    // 实际调用了 SetName(*f ,abc)\n    // 按照前面说到的反射 应该有 SetName(*Dog,string) 方法\n    // 但这里的调用还是用的  SetName(Dog,string) 方法!!!\n    // 那么自动生成的 SetName(*Dog,string) 方法有什么用呢?\n    f.SetName(\"abc\")\n    println(f.Name) // 还是 hello\n}\n\n\n\n\n\n\n\n\n\nTip\n\n\n\n编译器自动生成的 SetName(*Dog,string) 方法 用于接口,我们后续再说",
    "crumbs": [
      "基础篇",
      "结构体"
    ]
  },
  {
    "objectID": "docs/go/basic/runtime.html",
    "href": "docs/go/basic/runtime.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "运行时, 程序的运行环境, 就是支撑你程序运行的东西 好比你的程序要想运行起来 是需要 操作系统\n一封信+ 人 =&gt; 文字变成了声音\n比如java 需要java虚拟机(JVM), 需要你环境中有这个东西\n磁带需要录音机才能播放出音乐\ngo 的runtime 不太一样了, 它实际上是一坨代码, 编译后,会将这些作为程序的一部分打包, 从我们编译go代码变成一个二进制文件,可以直接运行,可以放到其他没安装go的系统运行,可以看出这点 你写的代码+runtime =&gt; 编译成程序\ngo的运行时的功能 (到时候重新命名目录)\n比如 内存管理分配 垃圾回收GC 并发能力 协程 是runtime来弄\ngo的一些关键字实际上是在 runtime 下的函数\n\n\n\n关键字\n编译后转换成runtime下的函数名\n\n\n\n\ngo\nnewproc\n\n\nnew\nnewobject\n\n\nmake\nmakechan makeslice makemap\n\n\n&lt;-\nchansend1 chanrecv1\n\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "docs/go/basic/gc.html",
    "href": "docs/go/basic/gc.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "可以先看看汇编\n\n\n\n\n\n\nTip\n\n\n\ntodo\n\n\n\n\n\n\n Back to top",
    "crumbs": [
      "基础篇",
      "GC"
    ]
  },
  {
    "objectID": "docs/go/basic/env.html",
    "href": "docs/go/basic/env.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "go 一键安装脚本",
    "crumbs": [
      "基础篇",
      "环境准备"
    ]
  },
  {
    "objectID": "docs/go/basic/env.html#安装1",
    "href": "docs/go/basic/env.html#安装1",
    "title": "斯巴拉稀",
    "section": "",
    "text": "go 一键安装脚本",
    "crumbs": [
      "基础篇",
      "环境准备"
    ]
  },
  {
    "objectID": "docs/go/basic/env.html#配置",
    "href": "docs/go/basic/env.html#配置",
    "title": "斯巴拉稀",
    "section": "2 配置",
    "text": "2 配置\ngo env -w GOPROXY=https://goproxy.cn,http://mirrors.aliyun.com/goproxy/,https://goproxy.io,direct",
    "crumbs": [
      "基础篇",
      "环境准备"
    ]
  },
  {
    "objectID": "docs/go/basic/env.html#常用指令",
    "href": "docs/go/basic/env.html#常用指令",
    "title": "斯巴拉稀",
    "section": "3 常用指令",
    "text": "3 常用指令\n# 清理下载的mod, 一般情况下不会清理.  ~/go/pkg/mod\ngo clean -modcache\n\ngo mod tidy\n\ngo env\nGOPATH=\"/Users/your_name/go\"  # go install 安装的二进制文件放在 GOPATH/bin中\nGOMODCACHE=\"/Users/your_name/go/pkg/mod\"\nGOPRIVATE=\"\"\nGOPROXY=\"\"\nGOROOT=\"/usr/local/go\"",
    "crumbs": [
      "基础篇",
      "环境准备"
    ]
  },
  {
    "objectID": "docs/go/basic/env.html#gvm-版本管理工具",
    "href": "docs/go/basic/env.html#gvm-版本管理工具",
    "title": "斯巴拉稀",
    "section": "4 gvm 版本管理工具",
    "text": "4 gvm 版本管理工具",
    "crumbs": [
      "基础篇",
      "环境准备"
    ]
  },
  {
    "objectID": "docs/go/basic/env.html#环境问题排查",
    "href": "docs/go/basic/env.html#环境问题排查",
    "title": "斯巴拉稀",
    "section": "5 环境问题排查",
    "text": "5 环境问题排查",
    "crumbs": [
      "基础篇",
      "环境准备"
    ]
  },
  {
    "objectID": "docs/go/basic/env.html#footnotes",
    "href": "docs/go/basic/env.html#footnotes",
    "title": "斯巴拉稀",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nhttps://golang.google.cn/dl/↩︎",
    "crumbs": [
      "基础篇",
      "环境准备"
    ]
  },
  {
    "objectID": "docs/go/basic/interface.html",
    "href": "docs/go/basic/interface.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "接口是一种协议, 一种规则, 规定了一些功能,具体怎么实现不关心\n比如我们需要将数据进行存储读取,我们规定了读取保存功能,怎么实现不关心.\n在现实中其实可以说我们很多时候经常说的都是”接口”\n\n说打车, 车是一种实现了4个轮子能移动的接口, 不管是比亚迪还是宝马都行\n说吃饭, 饭是一种实现了可以吃饱功能的接口,具体吃什么,还不清楚\n…\n\n所以实际上在开发中我们应当 面向接口开发(实际在设计阶段,沟通中一直说的都是”接口”), 接口是一种抽象, 不关心具体怎么实现,这样以后更换具体实现就会比较方便 ## 基本操作\n\n\n\n\n\n\n\nTip\n\n\n\n当我们定义一个新的类型时, 只要保证其方法集合与某个接口相同即可隐式实现该接口\n\n\ntype Animal interface {\n    Shout()\n}\n\ntype Cat struct {\n    Age  int\n    Name string\n}\n\n// 隐式地实现了Animal 接口\n// 结构体实现接口\nfunc (c Cat) Shout() {\n    fmt.Println(\"miao\")\n}\ntype Dog struct {\n    Age  int\n}\n// 结构体指针实现接口\n// 将结构体指针 当成一个整体, 这个东西实现了 方法Shout\nfunc (d *Dog) Shout() {\n    fmt.Println(\"wang\")\n}\nfunc TestSlice(t *testing.T) {\n    // 实际会做 类型是否实现接口 的检查\n    // 注意这个实际上就是一种类型转换\n    var a Animal = Cat{Age: 2, Name: \"tom\"}\n    a.Shout()\n    // 这样也是ok的,前面我们在结构体那里知道,编译器会自动给 Cat的同名方法生成一个*Cat的同名方法\n    // 这个同名方式 的作用就在这里\n    // 所以*Cat 实现了 Shout 方法,实现了 Animal接口\n    var a2 Animal = &Cat{Age: 3, Name: \"jjj\"}\n    a2.Shout()\n\n    // 结构体指针 *Dog 实现了Shout方法, 所以可以\n    var d Animal = &Dog{Age: 1}\n    d.Shout()\n    // 报错, 因为 Dog{Age: 1} 没有实现Shout() 方法\n    // var d2 Animal = Dog{Age: 1}\n\n    // 类型断言 方式一\n    cat, ok := a.(Cat)\n    if ok {\n        fmt.Println(cat.Age)\n    }\n    // 类型断言 方式二\n    switch a.(type) {\n    case Cat:\n        cat := a.(Cat)\n        fmt.Println(cat.Name)\n    }\n}",
    "crumbs": [
      "基础篇",
      "接口"
    ]
  },
  {
    "objectID": "docs/go/basic/interface.html#什么是接口",
    "href": "docs/go/basic/interface.html#什么是接口",
    "title": "斯巴拉稀",
    "section": "",
    "text": "接口是一种协议, 一种规则, 规定了一些功能,具体怎么实现不关心\n比如我们需要将数据进行存储读取,我们规定了读取保存功能,怎么实现不关心.\n在现实中其实可以说我们很多时候经常说的都是”接口”\n\n说打车, 车是一种实现了4个轮子能移动的接口, 不管是比亚迪还是宝马都行\n说吃饭, 饭是一种实现了可以吃饱功能的接口,具体吃什么,还不清楚\n…\n\n所以实际上在开发中我们应当 面向接口开发(实际在设计阶段,沟通中一直说的都是”接口”), 接口是一种抽象, 不关心具体怎么实现,这样以后更换具体实现就会比较方便 ## 基本操作\n\n\n\n\n\n\n\nTip\n\n\n\n当我们定义一个新的类型时, 只要保证其方法集合与某个接口相同即可隐式实现该接口\n\n\ntype Animal interface {\n    Shout()\n}\n\ntype Cat struct {\n    Age  int\n    Name string\n}\n\n// 隐式地实现了Animal 接口\n// 结构体实现接口\nfunc (c Cat) Shout() {\n    fmt.Println(\"miao\")\n}\ntype Dog struct {\n    Age  int\n}\n// 结构体指针实现接口\n// 将结构体指针 当成一个整体, 这个东西实现了 方法Shout\nfunc (d *Dog) Shout() {\n    fmt.Println(\"wang\")\n}\nfunc TestSlice(t *testing.T) {\n    // 实际会做 类型是否实现接口 的检查\n    // 注意这个实际上就是一种类型转换\n    var a Animal = Cat{Age: 2, Name: \"tom\"}\n    a.Shout()\n    // 这样也是ok的,前面我们在结构体那里知道,编译器会自动给 Cat的同名方法生成一个*Cat的同名方法\n    // 这个同名方式 的作用就在这里\n    // 所以*Cat 实现了 Shout 方法,实现了 Animal接口\n    var a2 Animal = &Cat{Age: 3, Name: \"jjj\"}\n    a2.Shout()\n\n    // 结构体指针 *Dog 实现了Shout方法, 所以可以\n    var d Animal = &Dog{Age: 1}\n    d.Shout()\n    // 报错, 因为 Dog{Age: 1} 没有实现Shout() 方法\n    // var d2 Animal = Dog{Age: 1}\n\n    // 类型断言 方式一\n    cat, ok := a.(Cat)\n    if ok {\n        fmt.Println(cat.Age)\n    }\n    // 类型断言 方式二\n    switch a.(type) {\n    case Cat:\n        cat := a.(Cat)\n        fmt.Println(cat.Name)\n    }\n}",
    "crumbs": [
      "基础篇",
      "接口"
    ]
  },
  {
    "objectID": "docs/go/basic/interface.html#数据结构",
    "href": "docs/go/basic/interface.html#数据结构",
    "title": "斯巴拉稀",
    "section": "2 数据结构",
    "text": "2 数据结构\n\n2.1 接口与元数据\n\n\n\n\n\n\n关于接口的思考\n\n\n\n\nvar animal Animal = Cat{Age: 2, Name: \"tom\"}\n\nanimal是一个类型为Animal接口的变量\n这是一个类型转换的操作, 这句话看起来是个废话\n\nCat 能否转换为 接口Animal, 是如何判断的?\n\nCat 结构体是否实现了接口的方法\n\nanimal可以转换为Cat 对象, 也就是说 接口变量animal必定存储了Cat对象数据的信息,以及Cat的类型信息\n接口有方法, ==接口变量animal 必定存储了 接口定义的方法==\n\n\n\n\n\n\n\n\n\n关于元数据的思考\n\n\n\n\n我们知道 当我们定义 一个 int64 类型的变量时, 编译时编译器最终会根据代码定义的 int64的 “类型信息” 来分配多少内存的\n这些 “类型信息” 我们能否得到呢?\n\n在关于接口的思考中,因为 接口变量和结构体可以互相转换,所以接口变量必定存储了 结构体实际数据以及类型的信息\n这个不就是我们想要的吗? 那么我们将变量转换成接口类型不就可以了吗!!! 这波推理可以!\n\n编译后的可执行文件里会有这些信息吗?\n\n没有, 通过二进制 的汇编指令 ,我们可以根据最终的一条条指令,得出指令里是没有所谓这些类型的概念\n\n\n\n\n\n\n2.2 空接口 interface\n\n\n\n\n\n\nTip\n\n\n\n\n前面我们说道只要实现了接口定义的方法, 就算实现了接口.\n空接口 可以认为是没有方法的接口, 那么所有类型可以说都实现了该接口\n那么所有的类型都可以转换为 空接口类型\n\n\n\n\n\n空接口数据结构\n\ntype eface struct {\n    _type *_type // 类型信息\n    data  unsafe.Pointer // 数据信息\n}\n\ntype _type struct {\n    size       uintptr // 这个类型需要占用的内存大小\n    ptrdata    uintptr // size of memory prefix holding all pointers\n    hash       uint32  // 类型的hash值, 用来类型比较和查找\n    tflag      tflag  // (1)\n    align      uint8  // 类型的对齐边界\n    fieldAlign uint8  // 类型字段的对齐边界\n    kind       uint8  //类型的分类 (2)\n    // 比较2个当前类型的变量是否相等\n    equal func(unsafe.Pointer, unsafe.Pointer) bool\n    gcdata    *byte   // gc 相关\n    str       nameOff // 偏移, 可以通过这个得到 类型的名称等信息\n    ptrToThis typeOff // 同上, 得到对应指针类型的信息\n}\n\n\ntflag\n\ntype tflag uint8\n\nconst (\n    tflagUncommon      tflag = 1 &lt;&lt; 0\n    tflagExtraStar     tflag = 1 &lt;&lt; 1\n    tflagNamed         tflag = 1 &lt;&lt; 2\n    tflagRegularMemory tflag = 1 &lt;&lt; 3 \n)\n\nkind\n\nconst (\n    Invalid Kind = iota\n    Bool\n    Int\n    Int8\n    Int16\n    Int32\n    Int64\n    Uint\n    Uint8\n    Uint16\n    Uint32\n    Uint64\n    Uintptr\n    Float32\n    Float64\n    Complex64\n    Complex128\n    Array\n    Chan\n    Func\n    Interface\n    Map\n    Pointer\n    Slice\n    String\n    Struct\n    UnsafePointer\n)\n\n\n\n\n\n\nCaution\n\n\n\n更多细节等,后续有时间再弄吧…\n\n\n\n\n代码验证结构\n\npackage main\n\nimport (\n    //  _ \"test/pkg\"\n    \"fmt\"\n    \"unsafe\"\n)\n\ntype eface struct {\n    _type *_type         // 类型信息\n    data  unsafe.Pointer // 数据信息\n}\n\ntype _type struct {\n    size       uintptr // 这个类型需要占用的内存大小\n    ptrdata    uintptr // size of memory prefix holding all pointers\n    hash       uint32  // 类型的hash值, 用来类型比较和查找\n    tflag      uint8   //\n    align      uint8   // 类型的对齐边界\n    fieldAlign uint8   // 类型字段的对齐边界\n    kind       uint8   //类型的分类\n    // 比较2个当前类型的变量是否相等\n    equal     func(unsafe.Pointer, unsafe.Pointer) bool\n    gcdata    *byte   // gc 相关\n    str       nameOff // 偏移, 可以通过这个得到 类型的名称等信息\n    ptrToThis int32   // 同上, 得到对应指针类型的信息\n}\n\n//go:linkname resolveNameOff runtime.resolveNameOff\nfunc resolveNameOff(ptrInModule unsafe.Pointer, off nameOff) name\n\ntype Cat struct {\n    Age  int\n    Name string\n}\n\nfunc (c Cat) Show() {\n    fmt.Println(11)\n}\nfunc (c Cat) pp() {\n    fmt.Println(11)\n}\nfunc main() {\n    var a int64 = 66\n    var b interface{} = a\n    c := *(*eface)(unsafe.Pointer(&b))\n    fmt.Println(*(*int64)(c.data)) // 66\n    fmt.Println(*c._type)\n    d := resolveNameOff(unsafe.Pointer(c._type), c._type.str)\n    fmt.Println(d.name())\n\n    fmt.Println(\"--自定义类型 (结构体) 的情况 呢?----\")\n    cat := Cat{3, \"tom\"}\n    var catAny interface{} = cat\n    catEface := *(*eface)(unsafe.Pointer(&catAny))\n    fmt.Println(*catEface._type)\n    dd := resolveNameOff(unsafe.Pointer(catEface._type), catEface._type.str)\n    fmt.Println(dd.name())\n\n    // 结构体中字段的信息呢? 好像仅从eface 中没有.\n    // 我们看源码中的 这个方法\n    // func (t *_type) uncommon() *uncommontype\n    // 从中知道 struct 类型 有额外的信息存储在 *_type 指针指向的内存\n    catStructUncommon := *(*structUncommon)(unsafe.Pointer(catEface._type))\n    // 可自行验证\n    fmt.Println(catStructUncommon.fields[1].name.name())\n    fmt.Println(catStructUncommon.u)\n}\n\ntype structUncommon struct {\n    structtype\n    u uncommontype\n}\ntype defaultUncommon struct {\n    _type\n    u uncommontype\n}\ntype uncommontype struct {\n    pkgpath nameOff\n    mcount  uint16 // number of methods\n    xcount  uint16 // number of exported methods\n    moff    uint32 // offset from this uncommontype to [mcount]method\n    _       uint32 // unused\n}\ntype structtype struct {\n    typ     _type\n    pkgPath name\n    fields  []structfield\n}\ntype structfield struct {\n    name   name\n    typ    *_type\n    offset uintptr\n}\ntype name struct {\n    bytes *byte\n}\ntype nameOff int32\n\nfunc (n name) name() string {\n    if n.bytes == nil {\n        return \"\"\n    }\n    i, l := n.readVarint(1)\n    return unsafe.String(n.data(1+i, \"non-empty string\"), l)\n}\nfunc (n name) readVarint(off int) (int, int) {\n    v := 0\n    for i := 0; ; i++ {\n        x := *n.data(off+i, \"read varint\")\n        v += int(x&0x7f) &lt;&lt; (7 * i)\n        if x&0x80 == 0 {\n            return i + 1, v\n        }\n    }\n}\nfunc (n name) data(off int, whySafe string) *byte {\n    return (*byte)(add(unsafe.Pointer(n.bytes), uintptr(off), whySafe))\n}\nfunc add(p unsafe.Pointer, x uintptr, whySafe string) unsafe.Pointer {\n    return unsafe.Pointer(uintptr(p) + x)\n}\n\n\n\n2.3 非空接口\ntype iface struct {\n    tab  *itab\n    data unsafe.Pointer\n}\ntype itab struct {\n    inter *interfacetype  // 接口的元数据\n    _type *_type   // 实际类型的元数据\n    hash  uint32 //  _type.hash的复制用来方便做类型断言\n    _     [4]byte\n    fun   [1]uintptr // variable sized. fun[0]==0 means _type does not implement inter.\n}\n\n\ntype interfacetype struct {\n    typ     _type\n    pkgpath name\n    mhdr    []imethod  // 方法列表\n}\ntype _type struct {\n    size       uintptr\n    ptrdata    uintptr // size of memory prefix holding all pointers\n    hash       uint32\n    tflag      tflag\n    align      uint8\n    fieldAlign uint8\n    kind       uint8\n    // function for comparing objects of this type\n    // (ptr to object A, ptr to object B) -&gt; ==?\n    equal func(unsafe.Pointer, unsafe.Pointer) bool\n    // gcdata stores the GC type data for the garbage collector.\n    // If the KindGCProg bit is set in kind, gcdata is a GC program.\n    // Otherwise it is a ptrmask bitmap. See mbitmap.go for details.\n    gcdata    *byte\n    str       nameOff\n    ptrToThis typeOff\n}",
    "crumbs": [
      "基础篇",
      "接口"
    ]
  },
  {
    "objectID": "docs/devops/linux/service/nginx.html",
    "href": "docs/devops/linux/service/nginx.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "nginx -V | grep  abc  # 你发现grep 任何东西都会输出...\nnginx -V # 实际上这个是错误信息输出到终端\n\n\n可以看到配置文件的位置\n\nnginx -V 2&gt;&1 |grep nginx.conf\n\n\n\n配置相关信息输出重定向到文件\n\nnginx -V 2&gt;&1 1&gt;tmp.txt",
    "crumbs": [
      "service",
      "nginx"
    ]
  },
  {
    "objectID": "docs/devops/linux/service/nginx.html#查看配置",
    "href": "docs/devops/linux/service/nginx.html#查看配置",
    "title": "斯巴拉稀",
    "section": "",
    "text": "nginx -V | grep  abc  # 你发现grep 任何东西都会输出...\nnginx -V # 实际上这个是错误信息输出到终端\n\n\n可以看到配置文件的位置\n\nnginx -V 2&gt;&1 |grep nginx.conf\n\n\n\n配置相关信息输出重定向到文件\n\nnginx -V 2&gt;&1 1&gt;tmp.txt",
    "crumbs": [
      "service",
      "nginx"
    ]
  },
  {
    "objectID": "docs/devops/linux/bash/script.html",
    "href": "docs/devops/linux/bash/script.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "while true\ndo\n    echo 1\n    sleep 3\ndone\n# killall -0 docker-proxy 执行的结果 $? =0 的情况, 才会进入循环\nwhile killall -0 docker-proxy\ndo\n    echo 1\n    sleep 3\ndone",
    "crumbs": [
      "bash",
      "脚本"
    ]
  },
  {
    "objectID": "docs/devops/linux/bash/script.html#循环",
    "href": "docs/devops/linux/bash/script.html#循环",
    "title": "斯巴拉稀",
    "section": "",
    "text": "while true\ndo\n    echo 1\n    sleep 3\ndone\n# killall -0 docker-proxy 执行的结果 $? =0 的情况, 才会进入循环\nwhile killall -0 docker-proxy\ndo\n    echo 1\n    sleep 3\ndone",
    "crumbs": [
      "bash",
      "脚本"
    ]
  },
  {
    "objectID": "docs/devops/linux/bash/script.html#函数",
    "href": "docs/devops/linux/bash/script.html#函数",
    "title": "斯巴拉稀",
    "section": "2 函数",
    "text": "2 函数\n\n2.1 获取函数名称\n\n\n\n\n\n\nWarning\n\n\n\n不要用 sh fun.sh 来执行, 否则 没有 $FUNCNAME\n\n\n\n\nfun.sh\n\n#!/bin/bash\nshow(){\n    # FUNCNAME 实际是一个数组,包含了当前调用栈上所有函数的名称,先进后出\n    echo $FUNCNAME # 首个元素是当前函数名\n    # 可以发现实际有个main 函数, 先main,再调用了show2, 最后show\n    echo ${FUNCNAME[@]} # show show2 main.\n}\nshow2(){\n    show\n}\nshow2\n\nbash fun.sh\n# 或者\nchmod +x fun.sh\n./fun.sh",
    "crumbs": [
      "bash",
      "脚本"
    ]
  },
  {
    "objectID": "docs/devops/linux/bash/script.html#section",
    "href": "docs/devops/linux/bash/script.html#section",
    "title": "斯巴拉稀",
    "section": "3 ()",
    "text": "3 ()\n\n\n\n\n\n\nCaution\n\n\n\n\n实现执行脚本时,没有参数直接提示错误, 然后退出脚本\n() 里实际是在子shell里执行命令,它的exit退出,变量修改等操作都不影响当前shell,所以不对\n{} 里面的是在当前shell的, 一组命令作为一个整体执行.\n\n\n\n\n\n错的版本\n\n#!/bin/bash\ntest -z $1 && ( echo \"need arg\";exit; )\necho ok\n\n\n\n对的版本\n\n#!/bin/bash\ntest -z $1 && { echo \"need arg\";exit; }\necho ok\n\n\n\n\n\n\n\nWarning\n\n\n\n注意 需要{ } 两边空格, 最后 }前面的; 也是需要的",
    "crumbs": [
      "bash",
      "脚本"
    ]
  },
  {
    "objectID": "docs/devops/linux/bash/script.html#和",
    "href": "docs/devops/linux/bash/script.html#和",
    "title": "斯巴拉稀",
    "section": "4 `` 和 $()",
    "text": "4 `` 和 $()\n\n\n\n\n\n\nNote\n\n\n\n将命令执行的结果赋值给变量\n\n\nt=$(date +%Y) # t=`date +%Y`\necho $t # 2023",
    "crumbs": [
      "bash",
      "脚本"
    ]
  },
  {
    "objectID": "docs/devops/linux/bash/script.html#shift",
    "href": "docs/devops/linux/bash/script.html#shift",
    "title": "斯巴拉稀",
    "section": "5 shift",
    "text": "5 shift\n\n\nshift.sh\n\n#!/bin/bash\necho $*   # sh shift.sh a b c d e f\nshift  # 参数左移一位\necho $1 # 这个时候 第一个参数就是 b\nshift 1 # 同 shift\necho $1 #  c\nshift 3 # 参数左移3 位\necho $1 # 这个时候 $1 是f\n\nsh shift.sh a b c d e f",
    "crumbs": [
      "bash",
      "脚本"
    ]
  },
  {
    "objectID": "docs/devops/linux/bash/grep.html",
    "href": "docs/devops/linux/bash/grep.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "-E/egrep\n\n\n\n\n不带-E的时候 那么{} () | + ? 没有特别含义,就是它本身,如果想要变成特殊含义则前面加上\n\n带上-E与之相反\n等价与egrep",
    "crumbs": [
      "bash",
      "grep"
    ]
  },
  {
    "objectID": "docs/devops/linux/bash/grep.html#v-显示不匹配的行",
    "href": "docs/devops/linux/bash/grep.html#v-显示不匹配的行",
    "title": "斯巴拉稀",
    "section": "1 -v 显示不匹配的行",
    "text": "1 -v 显示不匹配的行\n\n1.txt不带 -v带-v\n\n\nhello world\npython hell\nabc hello efg\n\n\ngrep hello 1.txt\n# 结果\nhello world\nabc hello efg\n\n\ngrep hello -v 1.txt\n# 结果\npython hell",
    "crumbs": [
      "bash",
      "grep"
    ]
  },
  {
    "objectID": "docs/devops/linux/bash/grep.html#忽略大小写",
    "href": "docs/devops/linux/bash/grep.html#忽略大小写",
    "title": "斯巴拉稀",
    "section": "2 忽略大小写",
    "text": "2 忽略大小写\ngrep -i hello &lt;&lt;EOF\nhello world\npython hell\nabc HeLlo efg\nEOF\n# 结果\nhello world\nabc HeLlo efg",
    "crumbs": [
      "bash",
      "grep"
    ]
  },
  {
    "objectID": "docs/devops/linux/bash/grep.html#显示行号",
    "href": "docs/devops/linux/bash/grep.html#显示行号",
    "title": "斯巴拉稀",
    "section": "3 显示行号",
    "text": "3 显示行号\ngrep -n hello &lt;&lt;EOF\nhello world\npython hell\nabc hello efg\nEOF\n\n1:hello world\n3:abc hello efg",
    "crumbs": [
      "bash",
      "grep"
    ]
  },
  {
    "objectID": "docs/devops/linux/bash/grep.html#递归搜索",
    "href": "docs/devops/linux/bash/grep.html#递归搜索",
    "title": "斯巴拉稀",
    "section": "4 递归搜索",
    "text": "4 递归搜索\ntree\n.\n├── 1.txt \n└── a\n    ├── 1.txt\n    └── b\n        └── 1.txt\n# 会搜索当前目录下的所有文件\ngrep -r hello # 不能指定文件\n    a/b/1.txt:go hello\n    a/1.txt:python hello\n    1.txt:hello\n    1.txt:hello world\n\n# -l 只显示 匹配的文件名\ngrep -rl hello\n    a/b/1.txt\n    a/1.txt\n    1.txt",
    "crumbs": [
      "bash",
      "grep"
    ]
  },
  {
    "objectID": "docs/devops/linux/bash/grep.html#f-按字面意思找",
    "href": "docs/devops/linux/bash/grep.html#f-按字面意思找",
    "title": "斯巴拉稀",
    "section": "5 -F 按字面意思找",
    "text": "5 -F 按字面意思找\ngrep \"he.*\" 1.txt\n    hello\n    hello world\n    hell\n    he.*\ngrep \"he\\.\\*\" 1.txt\n    he.*\ngrep -F \"he.*\" 1.txt\n    he.*",
    "crumbs": [
      "bash",
      "grep"
    ]
  },
  {
    "objectID": "docs/devops/linux/bash/grep.html#查看匹配行的前后几行",
    "href": "docs/devops/linux/bash/grep.html#查看匹配行的前后几行",
    "title": "斯巴拉稀",
    "section": "6 查看匹配行的前后几行",
    "text": "6 查看匹配行的前后几行\n# -A  --after-context\n# -B  --before-context\ncat example.txt|grep \"hello\" -A 10 -B 2",
    "crumbs": [
      "bash",
      "grep"
    ]
  },
  {
    "objectID": "docs/devops/linux/bash/grep.html#c-只显示匹配了几行",
    "href": "docs/devops/linux/bash/grep.html#c-只显示匹配了几行",
    "title": "斯巴拉稀",
    "section": "7 -c 只显示匹配了几行",
    "text": "7 -c 只显示匹配了几行\ngrep -c hello 1.txt",
    "crumbs": [
      "bash",
      "grep"
    ]
  },
  {
    "objectID": "docs/devops/linux/bash/grep.html#w-匹配整词",
    "href": "docs/devops/linux/bash/grep.html#w-匹配整词",
    "title": "斯巴拉稀",
    "section": "8 -w 匹配整词",
    "text": "8 -w 匹配整词\ngrep -w hello &lt;&lt;EOF\nhelloworld\nhello world\nabchello xzy\nEOF",
    "crumbs": [
      "bash",
      "grep"
    ]
  },
  {
    "objectID": "docs/devops/linux/bash/grep.html#x-匹配到整行",
    "href": "docs/devops/linux/bash/grep.html#x-匹配到整行",
    "title": "斯巴拉稀",
    "section": "9 -x 匹配到整行",
    "text": "9 -x 匹配到整行\ngrep -x \"hello world\" &lt;&lt;EOF\nhello world \nhello world\nhello world ok\nEOF\n# 只会匹配到第二行, 第一行 后面有空格 也不行.",
    "crumbs": [
      "bash",
      "grep"
    ]
  },
  {
    "objectID": "docs/devops/linux/bash/var.html",
    "href": "docs/devops/linux/bash/var.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "env # 打印所有环境变量\nprintenv # 同上\necho $HOME # 打印某个变量的值\nprintenv HOME # 同上\n\n# 一些常用的环境变量\necho $PWD\necho $HOST # 当前主机名\necho $IFS # 词与词的分隔符, 默认为空格\necho $RANDOM #返回一个0到32767之间的随机数\necho $SHELL  # 当前使用的Shell  比如 /bin/bash 或/bin/zsh",
    "crumbs": [
      "bash",
      "变量"
    ]
  },
  {
    "objectID": "docs/devops/linux/bash/var.html#环境变量",
    "href": "docs/devops/linux/bash/var.html#环境变量",
    "title": "斯巴拉稀",
    "section": "",
    "text": "env # 打印所有环境变量\nprintenv # 同上\necho $HOME # 打印某个变量的值\nprintenv HOME # 同上\n\n# 一些常用的环境变量\necho $PWD\necho $HOST # 当前主机名\necho $IFS # 词与词的分隔符, 默认为空格\necho $RANDOM #返回一个0到32767之间的随机数\necho $SHELL  # 当前使用的Shell  比如 /bin/bash 或/bin/zsh",
    "crumbs": [
      "bash",
      "变量"
    ]
  },
  {
    "objectID": "docs/devops/linux/bash/var.html#自定义变量",
    "href": "docs/devops/linux/bash/var.html#自定义变量",
    "title": "斯巴拉稀",
    "section": "2 自定义变量",
    "text": "2 自定义变量\n\n增读删export设置默认值\n\n\necho $ff # 没有定义的变量名 ,默认是空\na=1 # 两边不能用空格\n# 这个相当于 \"a=\" 然后 执行1 这个命令\n# 提示 没有1 这个命令\na= 1\na =1 # 同样 ,会将a 作为命令 执行,提示没有该命令\n\nstr=\"hello world\" # 用空格 用\"\" 包起来\necho $str  # hello world, 默认会将多个空格合并成一个\nstr=\"hello     world\"\necho $str  # hello world\necho \"$str\"  # hello     world\n\n\npython_version=3.10\npython=snake\n# $ 会将后面的字符串视为变量名\necho $python_version # 3.10\n# 使用{} 将变量名包起来\necho ${python}_version # snake_version\n\n\n变量的值当成变量名\n\na=b\nc=a\necho $c # a\necho ${!c} # b\n\n\n\na=1\nunset a\n# 设置为空, 就是删除, 前面说到,不定义,默认就是空\na=''\na=\n\n\na=1 # 只能在当前shell可用,\nexport a # 这样 在当前shell创建的子shell都可以使用该变量\nexport b=2 # 直接赋值export\n\n\n# b 不为空,则返回b的值, 否则返回 123\na=${b:-123}\necho $a # 123 ,b还是空的\n# b 不为空,则返回b的值, 否则设置b为123,并且返回123\na=${b:=123}\necho $a,$b # 123,123\n# c 不为空,则返回1, 否则返回空\n# 可以用来判断c 是否为空,返回1 就是不为空了\necho ${c:+1} #\nc=2\necho ${c:+1} # 1\n\n# 如果d变量未定义,则报错退出 ,错误信息是你写的 undefined\n# 用来防止变量未定义\n${d:?undefined} # -bash: d: undefined\n\n\n脚本中应用\n\n# 使用 1 到 9 表示参数\n#!/bin/bash\n${1:?\"请带上参数\"}",
    "crumbs": [
      "bash",
      "变量"
    ]
  },
  {
    "objectID": "docs/devops/linux/bash/var.html#局部变量和全局变量",
    "href": "docs/devops/linux/bash/var.html#局部变量和全局变量",
    "title": "斯巴拉稀",
    "section": "3 局部变量和全局变量",
    "text": "3 局部变量和全局变量\n#!/bin/bash\na=1\nfoo(){\n    b=2 # 执行foo函数后, b是全局变量\n    local c=3 # 局部变量\n    local a=4 # 与外部的a 是不一样的变量\n}\nfoo\necho $a # 1\necho $b # 读取的到\necho $c # 读取不到\nbar(){\n    echo $b\n}\nbar # 会打印 b的值",
    "crumbs": [
      "bash",
      "变量"
    ]
  },
  {
    "objectID": "docs/devops/linux/bash/var.html#开头的特殊变量",
    "href": "docs/devops/linux/bash/var.html#开头的特殊变量",
    "title": "斯巴拉稀",
    "section": "4 $开头的特殊变量",
    "text": "4 $开头的特殊变量\n# 上一个命令的退出码,我们用来判断命令执行是否成功\nlss\necho $?  # &gt; 0 表示执行失败, 0 表示成功\n\n# $$为当前Shell的进程ID\necho $$\n\n#$_ 上一个命令的最后一个参数\nls tmp_install\necho $_ # tmp_install\n\n\n脚本a.sh\n\n#!/bin/bash\n\necho $0\necho $1\necho $2\necho $*\necho $@\necho $#\n# 看看$@ $* 之间的区别\nfor var in \"$*\"\ndo\n    echo \"$var\"\ndone\n\nfor var in \"$@\"\ndo\n    echo \"$var\"\ndone\n\n\n\n执行 ./a.sh a b c 的结果\n\n./a.sh  # $0 脚本本身\na       # $1 第一个参数\nb       # $2 第二个参数\na b c   # $* 所有参数\na b c   # $@ 所有参数\n3       # $# 参数个数\na b c   # \"$*\" 参数作为一个整体\na       # \"$@\" 还是会\nb\nc",
    "crumbs": [
      "bash",
      "变量"
    ]
  },
  {
    "objectID": "docs/devops/linux/bash/var.html#declare-typeset",
    "href": "docs/devops/linux/bash/var.html#declare-typeset",
    "title": "斯巴拉稀",
    "section": "5 declare / typeset",
    "text": "5 declare / typeset\n\n\n\n\n\n\nTip\n\n\n\ndeclare和typeset 等价\n\n\n\n5.1 打印当前环境所有变量\n# 不带参数\ndeclare\ntypeset\n\n\n5.2 申明为只读\n# 只读, 修改会报错\ndeclare -r a=1\na=2  # -bash: a: readonly variable\nunset a  # -bash: unset: a: cannot unset: readonly variable\n\n\n5.3 申明为整型\na1=1\na2=2\nc=b1+b2\necho $c  # 结果是  b1+b2\n# 我们计算是要这样的\na4=$((a1 + a2))  # 或a3=$(($a1 + $a2))\n# 申明为整型\ndeclare -i a1=1 a2=2\ndeclare -i res\nres=a1+a2\necho $res # 3\nres=a1+a2 # 3 这样其实就ok的, 只要 结果的变量设置为整型,a1和a2 不需要设置.\nres=a1+10 # 11\n\nd=1+2\necho d # 1+2\ndeclare -i d\nd=1+2\necho d # 3\n\n\n5.4 声明变量为大/小写字母\n# 申明为小写\ndeclare -l a\na=AbC\necho $a # abc\n# 申明为大写\ndeclare -u b\nb=abc\necho $b # ABC\n# 取消变量b 的大写申明\ndeclare +u b # - 变+ 都有类似效果\nb=abc\necho $b # abc 不再会变成ABC了\n\n\n5.5 申明为环境变量\na=1\ndeclare -x a # 同export a\n\n\n5.6 显示当前环境的所有函数\n# 打印当前环境的所有函数名 以及 定义\ndeclare -f\n# 只打印函数名\ndeclare -F",
    "crumbs": [
      "bash",
      "变量"
    ]
  },
  {
    "objectID": "docs/devops/linux/bash/var.html#字符串",
    "href": "docs/devops/linux/bash/var.html#字符串",
    "title": "斯巴拉稀",
    "section": "6 字符串",
    "text": "6 字符串\n\n6.1 拼接\nstr1=\"hello\"\nstr2=\"world\"\nresult=\"$str1 $str2\"\n\n\n6.2 长度\nstr=\"hello world\"\necho ${#str} # 输出 \"11\"\n\necho $(expr length \"$str\")\necho `expr length \"$str\"`\n\n\n6.3 截取\n\n截取获取字符在字符串中的索引获取子串的长度\n\n\nstr=\"hello world\"\n#  从第6个索引开始,包含索引位置的字符, 截取5个字符.\necho ${str:6:5} # 输出 \"world\"\n\necho ${str:2} # llo world\n# 同上\necho ${str:(2)}  # llo world\n\n# : 后面必须有空格. -2 表示从尾部开始找\necho ${str: -2} #ld\n# 同上\necho ${str:(-2)} #ld\necho ${str: -5:2} # wo\necho ${str:(-5):2} # wo\n\n\n\n\n\n\n\n\nCaution\n\n\n\n\nexpr index 命令只能查找单个字符或字符串中的第一个字符，不能查找多个字符组成的子串\n如果是子串,那会将子串里的每个字符全部找一遍, 然后显示最短的那个\n==这里的索引是从1 开始的, 而${str:1} 是从0开始的==\n\n\n\nstr=\"hello world\"\n# 不是7 而是3?  这是因为它会将你的字串里的每个字符全部找一遍, 然后显示最短的那个\n# w 是在 第7个位置, o在 5,  而l 是在3 最短\nexpr index \"$str\" \"world\" # 3\nexpr index \"$str\" \"worle\" # 2\n\n# 我们应该这样使用这个\nexpr index \"$str\" \"w\"  # 7\n\n\n\n\n\n\nTip\n\n\n\n所以这个的用法 就不该整子串, 而是用来找单个字符的操作\n\n\n\n\n\n\n\n\n\n\nWarning\n\n\n\n必须是从头开始找的\n\n\nstr=\"hello world\"\nexpr match \"$str\" world # 0\nexpr match \"$str\" hell # 4\nexpr match \"$str\" hellq # 0\n\n\n\n\n\n6.4 替换\n\n替换第一个匹配的替换全部匹配的\n\n\nstr=\"hello hello world\"\necho ${str/hello/goodbye} # 输出 \"goodbye hello world\"\n\n\nstr=\"hello hello world\"\necho ${str//hello/goodbye} # 输出 \"goodbye goodbye world\"\n\n\n\n\n\n6.5 删除(替换为空)\n\n从头删除从尾删除\n\n\n\n\n最短匹配\n\nstr=\"hello world hello python\"\necho ${str#*llo} # world hello python\n\n\n\n最长匹配\n\nstr=\"hello world hello python\"\necho ${str##*llo} # python\n\n\n\n\n\n最短匹配\n\nstr=\"hello world hello python\"\necho ${str%llo*} # hello world he\n\n\n\n最长匹配\n\nstr=\"hello world hello python\"\necho ${str%%llo*} # he\n\n\n\n\n\n\n6.6 大小写转换\n\n大写转小写小写转大写\n\n\nstr=\"Hello World\"\necho ${str,,} # 输出 \"hello world\"\n\n\nstr=\"hello world\"\necho ${str^^} # 输出 \"HELLO WORLD\"",
    "crumbs": [
      "bash",
      "变量"
    ]
  },
  {
    "objectID": "docs/devops/linux/bash/var.html#数组",
    "href": "docs/devops/linux/bash/var.html#数组",
    "title": "斯巴拉稀",
    "section": "7 数组",
    "text": "7 数组\n\n\n\n\n\n\nTip\n\n\n\n\n整型数组无需用declare -a arr 进行申明\n关联数组必须要declare -A arr 进行申明\n\n\n\n\n7.1 增\n\n方式一方式二方式三read -a追加元素\n\n\narr[0]=a\narr[1]=b\narr[2]=c\n\n\narr=(a b c) # 索引按顺序\narr=([0]=c [1]=a [2]=b) # 指定索引\n\n\ntouch a.txt b.txt c.txt\narr=(x *.txt)\necho ${arr[0]} # x\necho ${arr[1]} # a.txt\n\narr2=(x $(ls *.txt))\n\n\nread -a arr # 输入 a b c\necho ${arr[0]} # a\n\n\narr=(a b c)\narr+=(1 2 3)\necho ${arr[@]} # a b c 1 2 3 \n\n\n\n\n\n7.2 查\n\n单个元素所有元素元素个数元素的长度索引遍历截取\n\n\narr=(a b c)\necho ${arr[0]} # a\necho $arr  # 输出 首个元素的值\necho $arr[0] # 输出 a[0]  ,{} 是必须的.\n\n\narr=(a b c)\necho ${arr[@]} # a b c\necho ${arr[*]}\n\n\narr=([5]=1 [2]=4 [10]=1)\necho ${#arr[*]} #3\necho ${#arr[@]} #3\n\n\n\n\n索引0的元素的长度\n\narr=(abc e fg)\necho ${#arr[0]} #3\n\n\n\narr=([5]=1 [2]=4 [10]=1)\necho ${!arr[@]} # 打印索引 2 5 10\necho ${!arr[*]} # 同上\n\n\narr=(a b c)\nfor i in ${!arr[@]}\ndo\n    echo ${arr[i]}\ndone\n\n\n\n\n\n\n\n\nTip\n\n\n\n与字符串截取类似\n\n\narr=(a b c e f g)\n# ${arr[@]:position:length}\necho ${arr[@]:1:2} # b c\n# 省略 length\necho ${arr[@]:2} # c e f g\necho ${arr[@]: -2} # f g\necho ${arr[@]: -3:1} # e\n\n\n\n\n\n7.3 删\narr=(a b c)\necho ${!arr[@]} # 0 1 2\nunset arr[0]\necho ${arr[@]} # b c\necho ${!arr[@]} # 1 2, 索引0 没有了.\nunset arr # 全部删除\n\n\n7.4 关联数组\n\n\n\n\n\n\nCaution\n\n\n\n需要bash 4.0 以上版本\n\n\ndeclare -A it\nit[\"go\"]=\"1.19.0\"\nit[\"python\"]=\"3.10.0\"\nit[\"rust\"]=\"1.58.1\"",
    "crumbs": [
      "bash",
      "变量"
    ]
  },
  {
    "objectID": "docs/devops/docker/podman.html",
    "href": "docs/devops/docker/podman.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "podman machine init\n# podman machine set --rootful --storage-path /data/podman\npodman machine list\n\npodman system connection list\n\npodman machine start\npodman machine ssh # ssh到 podman 虚拟机\n# podman 默认是用的qemu 来创建虚拟机的\n/usr/local/bin/qemu-system-x86_64  --version\n\npodman machine stop\npodman machine rm podman-machine-default\n\npodman ps # 许多命令同docker, 略\n\n# 也是用 docker-compose.yaml 就可以\npodman compose up -d\npodman compose stop\npodman compose start\npodman run -it --rm --name alpine-podman alpine",
    "crumbs": [
      "基础",
      "podman"
    ]
  },
  {
    "objectID": "docs/devops/docker/podman.html#常用命令",
    "href": "docs/devops/docker/podman.html#常用命令",
    "title": "斯巴拉稀",
    "section": "",
    "text": "podman machine init\n# podman machine set --rootful --storage-path /data/podman\npodman machine list\n\npodman system connection list\n\npodman machine start\npodman machine ssh # ssh到 podman 虚拟机\n# podman 默认是用的qemu 来创建虚拟机的\n/usr/local/bin/qemu-system-x86_64  --version\n\npodman machine stop\npodman machine rm podman-machine-default\n\npodman ps # 许多命令同docker, 略\n\n# 也是用 docker-compose.yaml 就可以\npodman compose up -d\npodman compose stop\npodman compose start\npodman run -it --rm --name alpine-podman alpine",
    "crumbs": [
      "基础",
      "podman"
    ]
  },
  {
    "objectID": "docs/devops/docker/podman.html#配置",
    "href": "docs/devops/docker/podman.html#配置",
    "title": "斯巴拉稀",
    "section": "2 配置",
    "text": "2 配置\n\n\n设置国内源  ~/.config/containers/registries.conf\n\nunqualified-search-registries = [\"docker.io\"]\n\n[[registry]]\nprefix = \"docker.io\"\nlocation = \"registry.docker-cn.com\"\n\n[[registry.mirror]]\nlocation = \"hub-mirror.c.163.com\"\n[[registry.mirror]]\nlocation = \"docker.m.daocloud.io\"\n[[registry.mirror]]\nlocation = \"mirror.baidubce.com\"\n[[registry.mirror]]\nlocation = \"docker.nju.edu.cn\"\n[[registry.mirror]]\nlocation = \"hub-mirror.c.163.com\"",
    "crumbs": [
      "基础",
      "podman"
    ]
  },
  {
    "objectID": "docs/devops/docker/ip.html",
    "href": "docs/devops/docker/ip.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "0.1 启动容器\ndocker run -itd --name nginx -p 80:80 nginx\n\n\n0.2 打开iptables调试功能\n通过调试可以看 iptables 几个表 (raw mangle nat filter ) 的顺序,谁先谁后, 可以自己测试一下.\nmodprobe ipt_LOG #centos6\nmodprobe nf_log_ipv4 #centos7\n# 查看\nsysctl net.netfilter.nf_log.2\n   #centos 7\n     net.netfilter.nf_log.2 = nf_log_ipv4\n# raw 表 添加规则, 打开调试. \niptables -t raw -A PREROUTING -p tcp --dport 80 -j TRACE \niptables -t raw -A OUTPUT -p tcp --dport 80 -j TRACE\niptables -t raw -nL\n\n\n0.3 查看 NAT 表\niptables -t nat -nvL --line-numbers\n\n\n\n\n\n\n查看执行结果\n\n\n\n\n\nChain PREROUTING (policy ACCEPT 0 packets, 0 bytes)\nnum   pkts bytes target     prot opt in     out     source               destination\n1        0     0 DOCKER     all  --  *      *       0.0.0.0/0            0.0.0.0/0            ADDRTYPE match dst-type LOCAL\n\nChain INPUT (policy ACCEPT 0 packets, 0 bytes)\nnum   pkts bytes target     prot opt in     out     source               destination\n\nChain OUTPUT (policy ACCEPT 12 packets, 883 bytes)\nnum   pkts bytes target     prot opt in     out     source               destination\n1        0     0 DOCKER     all  --  *      *       0.0.0.0/0           !127.0.0.0/8          ADDRTYPE match dst-type LOCAL\n\nChain POSTROUTING (policy ACCEPT 12 packets, 883 bytes)\nnum   pkts bytes target     prot opt in     out     source               destination\n1        0     0 MASQUERADE  all  --  *      !docker0  172.17.0.0/16        0.0.0.0/0\n2        0     0 MASQUERADE  tcp  --  *      *       172.17.0.2           172.17.0.2           tcp dpt:80\n\nChain DOCKER (2 references)\nnum   pkts bytes target     prot opt in     out     source               destination\n1        0     0 RETURN     all  --  docker0 *       0.0.0.0/0            0.0.0.0/0\n2        0     0 DNAT       tcp  --  !docker0 *       0.0.0.0/0            0.0.0.0/0            tcp dpt:80 to:172.17.0.2:80\n\n\n\n\n\n0.4 查看 filter 表\niptables -t filter -nvL --line-numbers\n\n\n\n\n\n\n查看执行结果\n\n\n\n\n\nChain INPUT (policy ACCEPT 523 packets, 31567 bytes)\nnum   pkts bytes target     prot opt in     out     source               destination\n\nChain FORWARD (policy ACCEPT 0 packets, 0 bytes)\nnum   pkts bytes target     prot opt in     out     source               destination\n1       40  7071 DOCKER-USER  all  --  *      *       0.0.0.0/0            0.0.0.0/0\n2       40  7071 DOCKER-ISOLATION-STAGE-1  all  --  *      *       0.0.0.0/0            0.0.0.0/0\n3       15   833 ACCEPT     all  --  *      docker0  0.0.0.0/0            0.0.0.0/0            ctstate RELATED,ESTABLISHED\n4        3   156 DOCKER     all  --  *      docker0  0.0.0.0/0            0.0.0.0/0\n5       22  6082 ACCEPT     all  --  docker0 !docker0  0.0.0.0/0            0.0.0.0/0\n6        0     0 ACCEPT     all  --  docker0 docker0  0.0.0.0/0            0.0.0.0/0\n\nChain OUTPUT (policy ACCEPT 274 packets, 92208 bytes)\nnum   pkts bytes target     prot opt in     out     source               destination\n\nChain DOCKER (1 references)\nnum   pkts bytes target     prot opt in     out     source               destination\n1        3   156 ACCEPT     tcp  --  !docker0 docker0  0.0.0.0/0            172.17.0.2           tcp dpt:80\n\nChain DOCKER-ISOLATION-STAGE-1 (1 references)\nnum   pkts bytes target     prot opt in     out     source               destination\n1       22  6082 DOCKER-ISOLATION-STAGE-2  all  --  docker0 !docker0  0.0.0.0/0            0.0.0.0/0\n2       40  7071 RETURN     all  --  *      *       0.0.0.0/0            0.0.0.0/0\n\nChain DOCKER-ISOLATION-STAGE-2 (1 references)\nnum   pkts bytes target     prot opt in     out     source               destination\n1        0     0 DROP       all  --  *      docker0  0.0.0.0/0            0.0.0.0/0\n2       22  6082 RETURN     all  --  *      *       0.0.0.0/0            0.0.0.0/0\n\nChain DOCKER-USER (1 references)\nnum   pkts bytes target     prot opt in     out     source               destination\n1       40  7071 RETURN     all  --  *      *       0.0.0.0/0            0.0.0.0/\n\n\n\n\n\n0.5 watch 日志\n\ntail -f /var/log/kern.log\n# 或 ?\ntail -f /var/log/messages\n#或 ?\ndmesg --follow\n\n\n0.6 外部浏览器访问 nginx\n上面我的操作我是在虚拟机里的.\n\n\n0.7 观察日志\n流量进来先走 nat:PREROUTING -&gt; 如果有转发就走filter:FORWARD-&gt;nat:POSTROUTING\n\n\n\n\n\n\n查看执行结果\n\n\n\n\n\nTRACE: raw:PREROUTING:policy:2 IN=eth0 OUT=\n# nat:PREROUTING:rule:1 找 nat:PREROUTING 第一条规则, target 是 DOCKER\nTRACE: nat:PREROUTING:rule:1 IN=eth0 OUT=\n#  nat:DOCKER: 的第一条规则 in 不匹配, 所以 继续下一条规则. 第2条匹配了.\nTRACE: nat:DOCKER:rule:2 IN=eth0 OUT=\n# 走filter 的 forward(因为前面的规则里nat:DOCKER:rule:2  再根据路由)\n# 跳转到 DOCKER-USER\nTRACE: filter:FORWARD:rule:1 IN=eth0 OUT=docker0 \n# 跳这DOCKER-USER 第一条. 是个return (return的意思是,结束子chains,返回到原来的chains 继续它的下一条)\n# 可以理解为 main函数里 调用了 A 函数, A函数里面return了. 你到了main ,执行 A函数后面的语句.\nTRACE: filter:DOCKER-USER:return:1 IN=eth0 OUT=docker0\n# 回到forward的第二条 发现是跳 DOCKER-ISOLATION-STAGE-1\nTRACE: filter:FORWARD:rule:2 IN=eth0 OUT=docker0\n# DOCKER-ISOLATION-STAGE-1的第一条 没有符合规则, 继续第二条看是否匹配, 匹配了.\n# 第二条是个return \nTRACE: filter:DOCKER-ISOLATION-STAGE-1:return:2 IN=eth0 OUT=docker0\n# 继续回到forward.  (看第3条规则没匹配,因为是还没有建立连接)\nTRACE: filter:FORWARD:rule:4 IN=eth0 OUT=docker0\n# accept 了..\nTRACE: filter:DOCKER:rule:1 IN=eth0 OUT=docker0\nTRACE: nat:POSTROUTING:policy:3 IN= OUT=docker0\n# 后续\nTRACE: filter:FORWARD:rule:1 IN=eth0 OUT=docker0\nTRACE: filter:DOCKER-USER:return:1 IN=eth0 OUT=docker0\nTRACE: filter:FORWARD:rule:2 IN=eth0 OUT=docker0\nTRACE: filter:DOCKER-ISOLATION-STAGE-1:return:2 IN=eth0 OUT=docker0\n# 看 这个时候匹配上了. 因为已经建立连接了.\nTRACE: filter:FORWARD:rule:3 IN=eth0 OUT=docker0\n\n\n\n\n\n\n\n Back to top",
    "crumbs": [
      "基础",
      "流量走向分析"
    ]
  },
  {
    "objectID": "docs/devops/docker/network.html",
    "href": "docs/devops/docker/network.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "Back to top",
    "crumbs": [
      "底层原理(todo...)",
      "network"
    ]
  },
  {
    "objectID": "docs/devops/docker/cgroup.html",
    "href": "docs/devops/docker/cgroup.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "Back to top",
    "crumbs": [
      "底层原理(todo...)",
      "cgroup"
    ]
  },
  {
    "objectID": "docs/devops/docker/union-fs.html",
    "href": "docs/devops/docker/union-fs.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "Back to top",
    "crumbs": [
      "底层原理(todo...)",
      "union fs"
    ]
  },
  {
    "objectID": "docs/devops/docker/env.html",
    "href": "docs/devops/docker/env.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "docker.io 是debian/ubuntu 团队维护的. 基于社区源码封装的版本,采用apt的方式管理依赖 docker-ce 社区版,docker官方维护的. 用go的方式管理依赖, 会自己管理所有的依赖\n\n\n安装后,打开点击配置, 点击 advanced 配置, 选择 system 这样 docker命令会放到 /usr/local/bin 目录下, 方便全局使用.\n默认设置user, 可能需要你手动配置 path 才行",
    "crumbs": [
      "基础",
      "环境准备"
    ]
  },
  {
    "objectID": "docs/devops/docker/env.html#安装",
    "href": "docs/devops/docker/env.html#安装",
    "title": "斯巴拉稀",
    "section": "",
    "text": "docker.io 是debian/ubuntu 团队维护的. 基于社区源码封装的版本,采用apt的方式管理依赖 docker-ce 社区版,docker官方维护的. 用go的方式管理依赖, 会自己管理所有的依赖\n\n\n安装后,打开点击配置, 点击 advanced 配置, 选择 system 这样 docker命令会放到 /usr/local/bin 目录下, 方便全局使用.\n默认设置user, 可能需要你手动配置 path 才行",
    "crumbs": [
      "基础",
      "环境准备"
    ]
  },
  {
    "objectID": "docs/devops/docker/env.html#国内源配置",
    "href": "docs/devops/docker/env.html#国内源配置",
    "title": "斯巴拉稀",
    "section": "2 国内源配置",
    "text": "2 国内源配置\n\n\n\n/etc/docker/daemon.json\n\n{\n  \"registry-mirrors\": [\n    \"https://registry.docker-cn.com\",\n    \"http://hub-mirror.c.163.com\",\n    \"https://docker.mirrors.ustc.edu.cn\"\n  ]\n}\n\n\n\ncentos\n\n# 修改后,需要.\nsudo systemctl daemon-reload\nsudo systemctl restart docker\ndocker info # 能看到 Registry Mirrors 的配置\n\n\n\nubuntu\n\nservice docker restart\ndocker info",
    "crumbs": [
      "基础",
      "环境准备"
    ]
  },
  {
    "objectID": "docs/devops/docker/docker-file.html",
    "href": "docs/devops/docker/docker-file.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "未完待续",
    "crumbs": [
      "基础",
      "dockerfile"
    ]
  },
  {
    "objectID": "docs/devops/docker/docker-file.html#dockerfile-指令",
    "href": "docs/devops/docker/docker-file.html#dockerfile-指令",
    "title": "斯巴拉稀",
    "section": "1 dockerfile 指令",
    "text": "1 dockerfile 指令\n\n1.1 from\nFROM:选择基础镜像，推荐 alpine\nFROM [--platform=&lt;platform&gt;] &lt;image&gt;[@&lt;digest&gt;] [AS &lt;name&gt;]\n\n\n1.2 LABEL\nmaintainer 废弃\n按标签组织项目 (不用搞目录什么的.)\nLABEL multi.label1=\"value1\" multi.label2=\"value2\" other=\"value3\"\n配合 label filter 可过滤镜像查询结果\ndocker images -f label=multi.label1=\"value1\"\n查看镜像的label\n# -A 10 看 labels 后10行\ndocker inspect image_name |grep labels -A 10\n\n\n1.3 RUN\n!!! warning 这两条命令应该永远用&&连接，如果分开执行，RUN apt-get update 构建层被缓存，可能会导致新 package 无法安装\n执行命令,最常见的用法是\nRUN apt-get update && apt-get install\n\n\n1.4 CMD\n!!! tip 1. 运行的命令会被实际执行是指定的命令覆盖 2. 定义了多个,只有最后一个会执行 3. 当指定了 ENTRYPOINT 后，CMD 的含义就发生了改变，不再是直接的运行其命令，而是将 CMD 的内容作为参数传给 ENTRYPOINT 指令\nCMD [\"executableA\", \"param1\", \"param2\"...]\nCMD [\"executableB\", \"param1\", \"param2\"...]\n# 这个echo hello 会覆盖配置里的cmd, 配置里的cmd不会执行\n# 在没有 ENTRYPOINT的时候,我们运行容器, 想执行什么命令就执行什么命令\ndocker run image_name echo hello\n\n\n1.5 ENTRYPOINT\n!!! tips - 定义可以执行的容器镜像入口命令 ,必定会执行,不会被覆盖 - ==在不指定entrypoint的情况下,Docker 会为你提供一个隐含的 ENTRYPOINT，即:/bin/sh -c, 所以你的cmd 是这个的参数哦== - 不过docker run 时指定–entrypoint 可以覆盖\n# 我们一般 是不会这么做的...\ndocker run -it --entrypoint /bin/bash image_name \n# 注意覆盖的是 entrypoint 里的指令,\n# 设置的cmd 还是作为 entrypoint 的参数,这里可以指定参数 /usr/share/nginx/html\ndocker run -it --entrypoint ls nginx  /usr/share/nginx/html\n\n# 这个是进入容器执行, 不是说覆盖了原来的entrypoint..  别混淆了.\n# 任何运行的容器,都可以这样操作..\ndocker exec -it image_name bash\n#docker run –-entrypoint 可替换 Dockerfile 中定义的 ENTRYPOINT  \n#ENTRYPOINT 的最佳实践是用 ENTRYPOINT 定义镜像主命令，并通过 CMD 定义主要参数，如下所示\nENTRYPOINT [\"sed\"]\nCMD [\"--help\"]\n\n#可以这样, 这样的话, 就看你运行的时候指定啥了.\nCMD []\nFROM ubuntu\nRUN apt-get update && apt-get install  -y stress\nENTRYPOINT [\"/usr/bin/stress\"]\nCMD []\ndocker build -t stress .\n# 指定的参数-v会覆盖 dockerfile里配置的cmd\ndocker run --rm stress -v\n\n1.5.1 exec模式 与 shell模式\n!!! note “shell模式与exec模式的区别” shell 模式会忽略所有 CMD 命令的参数和 docker run 的命令行参数，ENTRYPOINT 要运行的命令会作为 /bin/sh -c 的子命令运行，而且 /bin/sh 不会传递信号，也就是说 ENTRYPOINT 要运行的命令不是 PID 为 1 的进程，且不会收到 Unix 信号，所以你要执行的命令不会收到 docker stop  发出的 SIGTERM 信号 (这里说的是,不会优雅退出, 就是直接停止了容器, 还没停止里面的程序, 可以写个程序测试) 一般情况下,我们停止一个服务, 是需要优雅退出的. 比如nginx ,会先让其处理已经发送过来的请求.\n=== “exec模式 (推荐)” dockerfile     # exec 模式     ENTRYPOINT [\"executable\", \"param1\", \"param2\"] dockerfile     FROM ubuntu     ENTRYPOINT [\"top\", \"-b\"]     CMD [\"-c\"] bash     docker build -t top .     docker run --rm --name top top     # 然后在另外一个会话执行 下面的, 可以看到, 执行的命令本身 pid =1     docker exec -it top ps -ef         UID        PID  PPID  C STIME TTY          TIME CMD         root         1     0  0 03:29 ?        00:00:00 top -b -c         root        16     0  0 03:30 pts/0    00:00:00 ps -ef     我们可以 ctrl+c 退出 === “shell模式”\n```dockerfile\nENTRYPOINT command param1 param2\n```\n\n```dockerfile\nFROM ubuntu\nENTRYPOINT top -b\nCMD -c\n```\n```bash\n# 是 pid=1 的shell 进程的 子进程\ndocker exec -it stest ps -ef\n    UID        PID  PPID  C STIME TTY          TIME CMD\n    root         1     0  0 03:36 ?        00:00:00 /bin/sh -c top -b /bin/sh -c -c\n    root         7     1  0 03:36 ?        00:00:00 top -b\n    root        17     0  0 03:36 pts/0    00:00:00 ps -ef\n#ctrl+c 没反应.. \n```\n=== “go程序测试” !!! warning 写的代码 测试信号接收.. 代码暂时没找到在哪…..\n\n\n\n1.6 EXPOSE\n暴露端口\n\n是镜像创建者和使用者的约定,告知用户你暴露了什么服务(端口)\n在 docker run –P 时，docker 会自动映射 expose 的端口到主机大端口，如0.0.0.0:32768-&gt;80/tcp\n-P 是将容器内所有暴露的端口(写了EXPOSE的) 映射到主机的随机端口上,如果没有写EXPOSE, 就不会映射任何端口\n-p 指定容器的端口({==无需 dockerfile 写 EXPOSE==})映射到主机\n从某种意义上看{==EXPOSE只是一种提醒/告知: 说我这个应用应该访问这个端口,这个端口提供服务==}\n\n--8&lt;-- \"devops/docker/code/go-web-simple/main.go\"\n--8&lt;-- \"devops/docker/code/go-web-simple/dockerfile\"\nEXPOSE &lt;port&gt; [&lt;port&gt;/&lt;protocol&gt;...]\n\n\n1.7 HEALTHCHECK\n健康检查\n--interval=&lt;duration&gt;：指定健康检查的时间间隔,默认为 30 秒.\n--timeout=&lt;duration&gt;：指定每次健康检查的超时时间,默认为 30 秒.\n--retries=&lt;number&gt;：指定在将容器标记为不健康之前尝试健康检查的次数,默认为 3 次.\nHEALTHCHECK --interval=5s --timeout=3s \\\n  CMD curl -f http://localhost/ || exit 1\n\n\n1.8 ENV\n设置环境变量, 就是进入容器后,你可以用env 看到这些\nENV &lt;key&gt;=&lt;value&gt; ...\n#或者MYSQL_VERSION=5.7\nENV MYSQL_VERSION 5.7\n# run 实际上是进入容器执行的. 所以用到的变量可以\nRUN agt-get install -y mysql-server=\"${MYSQL_VERSION}\"  \n\n\n1.9 ADD (不推荐)\n!!! note - 从源地址(文件，目录或者 URL)复制文件到目标路径 - 如果 src 是一个本地压缩文件,则在 ADD 的同时完整解压操作 - 如果 dest 不存在,则 ADD 指令会创建目标目录 - 如果 dest 结尾没有/,那么 dest 是目标文件名,如果 dest 结尾有/,那么 dest 是目标目录名 - 如果 src 是一个目录,则所有文件都会被复制至 dest - 如果 src 是一个本地压缩文件,则在 ADD 的同时完整解压操作 - ADD 支持通配符，如 ADD check* /testdir/\nADD [--chown=&lt;user&gt;:&lt;group&gt;] &lt;src&gt;... &lt;dest&gt;  \nADD [--chown=&lt;user&gt;:&lt;group&gt;] [\"&lt;src&gt;\",... \"&lt;dest&gt;\"] (路径中有空格时使用)\n\n\n1.10 COPY\n!!! note - COPY:从源地址(文件，目录)复制文件到目标路径 - 可以用于多阶段编译场景，可以用前一个临时镜像中拷贝文件 - COPY 不解压文件 - COPY 只支持本地文件的复制\nCOPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;src&gt;... &lt;dest&gt;\nCOPY [--chown=&lt;user&gt;:&lt;group&gt;] [\"&lt;src&gt;\",... \"&lt;dest&gt;\"] # 路径中有空格时使用\nCOPY --from=build /bin/project /bin/project\n```bash title=“src是目录时注意点” FROM ubuntu COPY tmp /root/\n. ├── dockerfile └── tmp ├── abc └── t2 └── 123\ndocker run –rm tmp ls /root abc t2 #没有 tmp 目录,, 所以写copy的时候 要 copy tmp /root/tmp\n\n\n\n###  VOLUME\n将指定目录定义为外挂存储卷，Dockerfile 中在该指令之后所有对同一目录的修改都无效 VOLUME [\"/data\"]\n等价于 docker run –v /data，可通过 docker inspect 查看主机的 mount point， /var/lib/docker/volumes//_data\n### WORKDIR\n切换工作目录\nWORKDIR，意思是在这一句之后，Dockerfile 后面的操作都以这一句指定的 WORKDIR 目录作为当前目录\n还有设置后,你`docker run -it xxx bash` 进入后, `pwd`看到的,就不会是默认的/ 而是这个了.\n\n\n```dockerfile\nWORKDIR /path/to/workdir\n\n\n1.11 USER\nUSER:切换运行镜像的用户和用户组, 容器默认会以root的用户去运行容器, 可以用user指定成其他 用户必须存在,没有的话先添加\n#RUN USERADD abc\nUSER &lt;user&gt;[:&lt;group&gt;] \n\n# 进去容器后,  whoami 能看到\n\n\n1.12 ARG\nfrom ubuntu\nARG FILE\n# 可以有默认值\nARG DIR=\"/root\"\n\nRUN cd $DIR && touch $FILE\n\n# 生成镜像的时候 --build-arg 然后 FILE=hello.txt 传递 参数\ndocker build --build-arg FILE=hello.txt -t yyy  .\n\n\n1.13 其他\n• ONBUILD  \n• STOPSIGNAL  \n• HEALTHCHECK \n• SHELL\n\n\n1.14 dockerfile 最佳实践\n\n每个镜像最好只有一个进程\n当无法避免同一镜像运行多进程时,应选择合理的初始化进程(init process)\n最小化层级数\n\n只有 RUN,COPY,ADD 会创建新层,其他指令创建临时层,不会增加镜像大小\n多条 RUN 命令可通过连接符连接成一条指令集以减少层数\n通过多段构建减少镜像层数\n\n把多行参数按字母排序，可以减少可能出现的重复参数，并且提高可读性\n编写 dockerfile 的时候,应该把变更频率低的编译指令优先构建以便放在镜像底层以有效利用 build cache\n复制文件时,每个文件应独立复制,这确保某个文件变更时,只影响改文件对应的缓存",
    "crumbs": [
      "基础",
      "dockerfile"
    ]
  },
  {
    "objectID": "docs/devops/docker/docker-file.html#多进程的容器镜像1",
    "href": "docs/devops/docker/docker-file.html#多进程的容器镜像1",
    "title": "斯巴拉稀",
    "section": "2 多进程的容器镜像1",
    "text": "2 多进程的容器镜像1\n\n选择适当的 init 进程\n需要捕获 SIGTERM 信号并完成子进程的优雅终止\n负责清理退出的子进程以避免僵尸进程",
    "crumbs": [
      "基础",
      "dockerfile"
    ]
  },
  {
    "objectID": "docs/devops/docker/docker-file.html#构建-build",
    "href": "docs/devops/docker/docker-file.html#构建-build",
    "title": "斯巴拉稀",
    "section": "3 构建 build",
    "text": "3 构建 build\n\n3.1 理解构建上下文(Build Context)\n!!! note - 当运行 docker build 命令时，当前工作目录被称为构建上下文 - 首先会把构建上下文传输给docker daemon,可能当前目录(构建上下文)里有很多没用的文件,这样就会导致传输时间长,所以当前目录要干净 - 可以通过 .dockerignore 文件从编译上下文排除某些文件 - 可以创建一个专门的目录放置 Dockerfile，并在目录中运行 docker build\n# .  就是你的构建目录,会将这个目录下的所有文件包含在构建上下文\n# 默认查找当前目录的 Dockerfile ,–f 指定 Dockerfile\ndocker build . –f ./Dockerfile\n\n\n3.2 Build Cache\n构建容器镜像时，Docker 依次读取 Dockerfile 中的指令，并按顺序依次执行构建指令。\nDocker 读取指令后，会先判断缓存中是否有可用的已存镜像，只有已存镜像不存在时才会重新构建。\n\n通常 Docker 简单判断 Dockerfile 中的指令与镜像。\n针对 ADD 和 COPY 指令，Docker 判断该镜像层每一个文件的内容并生成一个 checksum，与现存镜像比较时，Docker 比较的是二者的 checksum。\n其他指令，比如 RUN apt-get -y update，Docker 简单比较与现存镜像中的指令字串是否一致。\n当某一层 cache 失效以后，所有所有层级的 cache 均一并失效，后续指令都重新构建镜像。\n\n==所以构建的时候,不会变的东西放到最上面==\n\n\n\n\n3.3 多段构建(Multi-stage build)\nFROM golang:1.10-alpine3.8 AS multistage\n\nRUN apk add --no-cache --update git\n\nWORKDIR /go/src/api\nCOPY . .\n\nRUN go get -d -v \\\n  && go install -v \\\n  && go build\n\n##alpine 空的,啥也没有, 因为我们的go程序本身就是可执行文件.\n\nFROM alpine:3.8\nCOPY --from=multistage /go/bin/api /go/bin/\nEXPOSE 3000\nCMD [\"/go/bin/api\"]\n!!! tip 也可以使用--from=0 来表示从第一个阶段来\n\n3.3.1 使用最小的镜像\nfrom scratch # 空的, 里面基础命令都没有, 所以一般我们用 alpine\n\n#很多都有这种 -alpine\nfrom golang:1.17.2-alpine\n\nfrom openjdk:alpine",
    "crumbs": [
      "基础",
      "dockerfile"
    ]
  },
  {
    "objectID": "docs/devops/docker/docker-file.html#通过镜像逆向dockerfile",
    "href": "docs/devops/docker/docker-file.html#通过镜像逆向dockerfile",
    "title": "斯巴拉稀",
    "section": "4 通过镜像逆向dockerfile",
    "text": "4 通过镜像逆向dockerfile\ndocker run -v /var/run/docker.sock:/var/run/docker.sock alpine/dfimage nginx:alpine",
    "crumbs": [
      "基础",
      "dockerfile"
    ]
  },
  {
    "objectID": "docs/devops/docker/docker-file.html#dockerignore",
    "href": "docs/devops/docker/docker-file.html#dockerignore",
    "title": "斯巴拉稀",
    "section": "5 .dockerignore",
    "text": "5 .dockerignore",
    "crumbs": [
      "基础",
      "dockerfile"
    ]
  },
  {
    "objectID": "docs/devops/docker/docker-file.html#footnotes",
    "href": "docs/devops/docker/docker-file.html#footnotes",
    "title": "斯巴拉稀",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nhttps://github.com/krallin/tini↩︎",
    "crumbs": [
      "基础",
      "dockerfile"
    ]
  },
  {
    "objectID": "docs/devops/docker/docker-compose.html",
    "href": "docs/devops/docker/docker-compose.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "Caution\n\n\n\ntodo…\nhttps://docs.docker.com/compose/install/linux/",
    "crumbs": [
      "基础",
      "docker-compose"
    ]
  },
  {
    "objectID": "docs/devops/docker/docker-compose.html#一些简易的yml",
    "href": "docs/devops/docker/docker-compose.html#一些简易的yml",
    "title": "斯巴拉稀",
    "section": "1 一些简易的yml",
    "text": "1 一些简易的yml\n\n\nconsul\n\nversion: '3'\nservices:\n  consul:\n    image: consul\n    restart: always\n    container_name: consul_server\n    network_mode: bridge \n    volumes: \n      - ./consul:/tmp/consul\n    ports:\n      - 8300:8300\n      - 8301:8301\n      - 8301:8301/udp\n      - 8302:8302\n      - 8302:8302/udp\n      - 8400:8400\n      - 8500:8500\n      - 8600:8600/udp\n      - 53:53/udp\n    command: consul agent -data-dir=/tmp/consul -dev -client=0.0.0.0\n\n\n\ngrafana\n\nversion: \"3\"\n\nservices:\n  grafana:\n    image: grafana/grafana\n    ports:\n      - 3000:3000\n    environment:\n    #   GF_INSTALL_PLUGINS=grafana-clock-panel,grafana-simple-json-datasource\n    #   GF_SECURITY_ADMIN_PASSWORD=admin\n      GF_INSTALL_PLUGINS: grafana-clock-panel,grafana-simple-json-datasource \n      # 卡的话,使用url地址来;后面是别名 然后用,隔开表示另外一个插件 https://codeload.github.com/grafana/clock-panel/legacy.zip/bb466d0682d58af659b018748d53c0d3b69a8377;clock-panel,https://codeload.github.com/grafana/simple-json-datasource/legacy.zip/87ced44c4587eae39eeedcbd4b2936593724de16;simple-json-datasource\n      GF_SECURITY_ADMIN_PASSWORD: admin\n    volumes:\n      - ./grafana:/var/lib/grafana\n\n\n\nmysql\n\nversion: '3'\nservices:\n  db:\n    image: mysql:5.7\n    container_name: mysql\n    ports:\n      - 3306:3306\n    environment:\n      MYSQL_ALLOW_EMPTY_PASSWORD: 1\n    volumes:\n      - ./mysql/data:/var/lib/mysql\n    networks:\n      - my-bridge\nnetworks:\n  my-bridge:\n    driver: bridge\n\n\n\nrabbitmq\n\nversion: '3.1'\nservices:\n  rabbitmq:\n    image: rabbitmq:3.6.9-management\n    ports:\n      - \"4369:4369\"\n      - \"5671:5671\"\n      - \"5672:5672\"\n      - \"15672:15672\"\n      - \"25672:25672\"\n    hostname: rmq\n    container_name: rabbitmq\n    environment:\n      RABBITMQ_DEFAULT_VHOST: /\n      RABBITMQ_DEFAULT_USER: admin\n      RABBITMQ_DEFAULT_PASS: admin\n      RABBITMQ_LOGS: /var/lib/rabbitmq/rabbitmq.log\n      RABBITMQ_SASL_LOGS: /var/lib/rabbitmq/rabbitmq-sasl.log\n      RABBITMQ_ERLANG_COOKIE: LZJADKXKLULIXFKAALGX\n      TZ: Asia/Shanghai\n      #extra_hosts:\n#      - \"rmq_node1:172.16.11.106\"\n#- \"rmq_node2:172.16.11.156\"\n#      - \"rmq_node3:172.16.11.206\"\n    volumes:\n      - ./rabbitmq:/var/lib/rabbitmq\n#      - /etc/hosts:/etc/hosts\n    restart: always\n\n\n\nredis\n\nversion: '3'\nservices:\n  redis:\n    image: redis:alpine\n    container_name: redis\n      #    restart: always\n    volumes:\n      - ~/docker_data/redis/data:/data\n      - ~/docker_data/redis/logs:/logs\n        #- ./conf/redis.conf:/usr/local/etc/redis/redis.conf\n    ports:\n      - 6379:6379\n\n\n1.1 vscode go开发用\ngolang-vscode1\nnacos2",
    "crumbs": [
      "基础",
      "docker-compose"
    ]
  },
  {
    "objectID": "docs/devops/docker/docker-compose.html#footnotes",
    "href": "docs/devops/docker/docker-compose.html#footnotes",
    "title": "斯巴拉稀",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nhttps://github.com/microsoft/vscode-remote-try-go↩︎\nnacos-docker↩︎",
    "crumbs": [
      "基础",
      "docker-compose"
    ]
  },
  {
    "objectID": "docs/devops/docker/docker.html",
    "href": "docs/devops/docker/docker.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "待整理",
    "crumbs": [
      "基础",
      "常用命令"
    ]
  },
  {
    "objectID": "docs/devops/docker/docker.html#基础命令",
    "href": "docs/devops/docker/docker.html#基础命令",
    "title": "斯巴拉稀",
    "section": "1 基础命令",
    "text": "1 基础命令\n\n显示docker相关信息\n\ndocker info\nClient:\n Context:    default\n Debug Mode: false\n Plugins:\n  buildx: Docker Buildx (Docker Inc.)\n    Version:  v0.10.4\n    Path:     /usr/libexec/docker/cli-plugins/docker-buildx\n  compose: Docker Compose (Docker Inc.)\n    Version:  v2.17.2\n    Path:     /usr/libexec/docker/cli-plugins/docker-compose\n  scan: Docker Scan (Docker Inc.)\n    Version:  v0.23.0\n    Path:     /usr/libexec/docker/cli-plugins/docker-scan\n\nServer:\n Containers: 6\n  Running: 6\n  Paused: 0\n  Stopped: 0\n Images: 6\n Server Version: 23.0.2\n Storage Driver: overlay2\n  Backing Filesystem: extfs\n  Supports d_type: true\n  Using metacopy: false\n  Native Overlay Diff: true\n  userxattr: false\n Logging Driver: json-file # 表示存在本地, 是可以让他存放在远端的\n Cgroup Driver: cgroupfs # 限制与隔离的驱动\n Cgroup Version: 1\n Plugins:\n  Volume: local\n  Network: bridge host ipvlan macvlan null overlay\n  Log: awslogs fluentd gcplogs gelf journald json-file local logentries splunk syslog\n Swarm: inactive  # 编排工具, 不开启\n Runtimes: io.containerd.runc.v2 runc\n Default Runtime: runc\n Init Binary: docker-init\n containerd version: 2806fc1057397dbaeefbea0e4e17bddfbd388f38\n runc version: v1.1.5-0-gf19387a\n init version: de40ad0\n Security Options:\n  apparmor\n  seccomp\n   Profile: builtin\n Kernel Version: 5.4.0-146-generic\n Operating System: Ubuntu 20.04.6 LTS\n OSType: linux\n Architecture: x86_64\n CPUs: 2\n Total Memory: 3.84GiB\n Name: ubtest\n ID: fb514c1e-58bd-4be0-ad81-c8d7c4413f53\n Docker Root Dir: /var/lib/docker  # 数据存放的位置\n Debug Mode: false\n Registry: https://index.docker.io/v1/ \n Experimental: false\n Insecure Registries:\n  127.0.0.0/8\n Live Restore Enabled: false  #热更新 生产环境 设置为true ,表示重启docker ,容器不会重启\n\n查看版本\n\ndocker version\nServer: Docker Engine - Community\n Engine:\n  Version:          23.0.2\n  API version:      1.42 (minimum version 1.12)\n  Go version:       go1.19.7\n  Git commit:       219f21b\n  Built:            Mon Mar 27 16:16:18 2023\n  OS/Arch:          linux/amd64\n  Experimental:     false\n containerd:\n  Version:          1.6.20\n  GitCommit:        2806fc1057397dbaeefbea0e4e17bddfbd388f38\n runc:\n  Version:          1.1.5\n  GitCommit:        v1.1.5-0-gf19387a\n docker-init:\n  Version:          0.19.0\n  GitCommit:        de40ad0",
    "crumbs": [
      "基础",
      "常用命令"
    ]
  },
  {
    "objectID": "docs/devops/docker/docker.html#镜像操作",
    "href": "docs/devops/docker/docker.html#镜像操作",
    "title": "斯巴拉稀",
    "section": "2 镜像操作",
    "text": "2 镜像操作\n\n2.1 搜索\ndocker search nginx\n\n\n2.2 拉取\n# 默认拉取最新版\ndocker pull nginx\n# 等价于这个\ndocker pull nginx:latest\n# 拉取某个 sha256的版本\ndocker pull nginx@sha256:1195d1c1cd901058d1f059f2e31e17b559f51a03e093bf0a774c9304aebb5c36\n\n\n2.3 查看\n# 查看本地下载的所有镜像\ndocker images\n# 查看镜像有几层 (看dockerfile后就明白了)\ndocker history image_id\n\n\n2.4 标签\n# docker tag 镜像id或者镜像名:版本  新的...\ndocker images\n    REPOSITORY   TAG       IMAGE ID       CREATED      SIZE\n    nginx        latest    0e901e68141f   3 days ago   142MB\ndocker tag 0e901e68141f nginx:v1.0\n# 或\ndocker tag nginx:latest nginx:v1.0\n\n# 查看 ,原来的还在的, 另外一个并不会占用空间的.\ndocker images\n    REPOSITORY   TAG       IMAGE ID       CREATED      SIZE\n    nginx        v1.0      0e901e68141f   3 days ago   142MB\n    nginx        latest    0e901e68141f   3 days ago   142MB\n\ndocker rmi nginx:latest # 相当于删除标签\n\n\n2.5 登录和推送\ndocker login  #默认登录官方的 hub库\ndocker login hub.yy.com # 登录自己的镜像仓库. hub.yy.com 自己弄去\n# 登录你的aliyun 的 仓库. \ndocker login --username=...  register.cn-hz-aliyuncs.com\n# 将你的镜像tag 改成你的 仓库名. myhub是你的仓库名\ndocker tag 0e901e68141f myhub/nginx:latest\n\n# 推送镜像\ndocker image push myhub/nginx:latest\n#等价与\ndocker push myhub/nginx:latest\n\n\n2.6 删除\n# 如果镜像正在被容器使用, 是无法删除的\ndocker rmi image_id\n# 等价\ndocker image rm image_id\n\n# 删除所有的镜像\ndocker image prune\n\n\n2.7 编译打包\n# 根据dockerfile 打包镜像\n# -t 表示 镜像的tag, . 是dockerfile所在路径\ndocker build -t nginx:123 .\n\n\n2.8 save && load\n!!! tip 当你镜像不能通过仓库进行分享或传输, 我们本地保存然后给其他人.\ndocker save nginx -o nginx.tar\n# 其他人使用的时候\ndocker load &lt; nginx.tar",
    "crumbs": [
      "基础",
      "常用命令"
    ]
  },
  {
    "objectID": "docs/devops/docker/docker.html#容器操作",
    "href": "docs/devops/docker/docker.html#容器操作",
    "title": "斯巴拉稀",
    "section": "3 容器操作",
    "text": "3 容器操作\n\n3.1 创建,启动,停止\n# 创建\ndocker create -it --name nginx nginx:latest\ndocker ps # 没有看到, 只是创建了.\n# 启动容器, 使用容器名或容器id\ndocker start nginx\ndocker ps\n# 优雅停止, 使用容器名或容器id\ndocker stop nginx\n# 强制停止, 使用容器名或容器id\ndocker kill nginx\n# 停止容器里的进程\ndocker pause nginx\ndocker ps # 查看, 容器还是运行的, status 显示 pause\n  CONTAINER ID   IMAGE          COMMAND                  CREATED         STATUS                  PORTS     NAMES\n  316e566c99fa   nginx:latest   \"/docker-entrypoint.…\"   4 minutes ago   Up 7 seconds (Paused)   80/tcp    nginx\ndocker unpause nginx # 重新启动进程\n\n\n3.2 运行\n!!! tip 相比较前面的 create start 这个更常用, 直接就创建并且启动了容器\n\n#交互的,直接进入该容器,如果退出exit,该容器就退出了\n# -it  交互式 前台, 运行bash 命令 ,-i=--interactive -t=tty\n# nginx:latest 镜像名, 先会查看本地有没有这个镜像,如果没有则从 docker.io上拉取\n# --name 容器名\ndocker run -it --name abc nginx:latest bash\n# 后台 -d\ndocker run -itd nginx:latest\n# 端口映射,将容器里的80端口映射到本机的8080端口\ndocker run -itd -p 8080:80 nginx:latest\n\n# 退出会自动删除容器\ndocker run -it --rm nginx:latest\n\n\n3.3 commit\n\ndocker pull centos\ndocker run -it centos\n#这个时候已经直接进去该容器的bash了\nyum install vim -y #我们安装一个vim\n#exit #然后退出\n#可以查看一下该容器的信息\n#将该容器commit 成一个image 下面的:latest 是tag 可以不设置,默认就是latest\ndocker commit -m 'install vim' 容器名 自己设置的image名(test/centos-vim:latest)\n\n\n3.4 exec 执行指令\n# 执行容器里的bash , 这个实际就是进入了容器, 执行了bash ,前台\ndocker exec -it nginx bash\n# 进入容器运行指令后直接退出\ndocker exec -it nginx ls /var/log/nginx\n  # access.log  error.log\n\n\n3.5 查看容器进程信息\n# 查看容器里的运行的进程\ndocker top nginx\n# 查看容器里进程的资源使用情况, 会前台执行一直\ndocker stats nginx\n# 输出一次就退出\ndocker stats nginx --no-stream\n\n\n3.6 重命名\ndocker rename nginx nginx_new\n\n\n3.7 控制cpu的使用的运行\ndocker run -itd --name=nginx --cpu-period=100000 --cpu-quota=10000 nginx\n\n\n3.8 加入其他容器的net ns\ndocker run -it --net container:4ddf4638572d busybox ifconfig\n\n\n3.9 带上数据持久化的运行\n#将本地的/home/html目录映射到容器中的/usr/share/nginx/html\n#这样本地做什么修改，容器就修改，通过容器修改，本地也就修改了\ndocker run -d --name nginx01 -v /home/html:/usr/share/nginx/html nginx\n\ndocker volume ls\n\n\n3.10 查看运行的容器\n#显示当前正在运行的容器\ndocker ps\ndocker container ls #等价于上面的\n# 查看 状态是退出的容器\ndocker ps -f 'status=exited'\n# 比如你创建了一个名字为go-web 的容器, 你想要看这个容器 包含关系\ndocker ps -f name=go\ndocker ps -l # 最新创建的一个容器\n#显示所有的容器，包括已经退出的\ndocker ps -a\ndocker container ls -a\n# 查看运行的容器的id (简化输出)\ndocker ps -q\n# 所有容器的id\ndocker ps -aq\n\n\n3.11 删除\n# 这个默认就是删除容器\n# id 只要前面几位就行，能区别其他的容器就ok\n# 容器正在运行 这个命令会报错\ndocker rm 容器id\ndocker container rm 容器id\n# 强制删除, 不管是否在运行\ndocker rm -f 容器id\n\n# 删除所有的容器,强制的. 注意操作.\ndocker rm -f $(docker ps -aq)\n# 只删除已经退出的容器\ndocker rm $(docker ps -f 'status=exited' -q)\n# 删除已经退出的容器\ndocker container prune\n\n\n3.12 查看容器运行日志\n# 假如你的容器里的日志是写在文件里的, 那么这里就看不到 容器的日志了\n# 我们自己开发的镜像 运行后  应该将日志显示在前台. 控制台, 才能看到日志\ndocker logs -f  容器id\ndocker logs -f  容器id  --tail 1\n\n\n3.13 容器与主机的文件传输\n\n从容器复制到主机从主机复制到容器\n\n\n# nginx 是容器名  ~/ 是主机的目录\ndocker cp nginx:/app.c ~/\n\n\n# nginx: 表示容器名, text.txt 是主机的文件\ndocker cp text.txt nginx:/\n\n\n\n\n\n3.14 排查 容器的操作记录\n# 查看从昨天开始到现在的 docker的操作记录\ndocker events --since=$(date -d \"1 day ago\" +%s)\ndocker events --since=$(date -d \"2 day ago\" +%s) --until=$(date -d \"1 day ago\" +%s)",
    "crumbs": [
      "基础",
      "常用命令"
    ]
  },
  {
    "objectID": "docs/devops/docker/docker.html#inspect-获取容器镜像的元数据",
    "href": "docs/devops/docker/docker.html#inspect-获取容器镜像的元数据",
    "title": "斯巴拉稀",
    "section": "4 inspect 获取容器/镜像的元数据",
    "text": "4 inspect 获取容器/镜像的元数据\ndocker inspect 容器id/容器名/镜像名/镜像id",
    "crumbs": [
      "基础",
      "常用命令"
    ]
  },
  {
    "objectID": "docs/devops/docker/architecture.html",
    "href": "docs/devops/docker/architecture.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "todo…\nOCI Containerd RunC\n\n\n\n\n Back to top",
    "crumbs": [
      "基础",
      "架构"
    ]
  },
  {
    "objectID": "docs/devops/docker/namespace.html",
    "href": "docs/devops/docker/namespace.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "Back to top",
    "crumbs": [
      "底层原理(todo...)",
      "namespace"
    ]
  },
  {
    "objectID": "docs/devops/linux/bash/quick-start.html",
    "href": "docs/devops/linux/bash/quick-start.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "Warning\n\n\n\n待整理…",
    "crumbs": [
      "bash",
      "基础"
    ]
  },
  {
    "objectID": "docs/devops/linux/bash/quick-start.html#常用命令",
    "href": "docs/devops/linux/bash/quick-start.html#常用命令",
    "title": "斯巴拉稀",
    "section": "1 常用命令",
    "text": "1 常用命令\n\n帮助cdmkdirlscatdaterenamecphistory查看用户\n\n\n\n\n几个都试试\n\nman sed\nhelp cd\ncd --help\ncd -h\n\n\n\ncd   # 直接什么也不加 会cd 到 家目录\ncd ~ # 同上\ncd - # 返回上一次的目录\n\n\n关于cd建议设置一些这样的别名\n\ncat &gt;&gt; /etc/profile &lt;&lt;EOF\nalias ..=\"cd ..\"\nalias ...=\"cd ../..\"\nEOF\n\n\n\n# -v 显示创建信息\n# -p 多级目录可以自动创建\nmkdir -pv a/b/c\nmkdir -pv a/{a1,a2} #(1)\n    a\n    ├── a1\n    └── a2\n\n\n#如何只列出目录\nls -p #可以给文件夹后面加上/,其实实际上就是有/\nls -d */ #就可以说明 实际上有/ ,这样就只列出目录了\nls -p |egrep \"/$\"\n\n#给文件名加上引号\nls -Q\n#删除目录\nls -Qd */|xargs rm -fr\n\n# 查看文件的inode信息\nls -i\n# 查看文件的读取时间,默认是修改时间\nls --time=atime\nll -t # 按修改时间排序, 降序\nll -rt #反着.  新的在最后.\n\n#使用ll的话 前面多了一行 total\n# 比如在目录中是备份文件,  这里的命令便是删除旧的10个备份\nls -rt | head -10 |xargs rm\n\n\n# 显示行号\ncat -n a.txt\n\ncat &gt; 2.txt &lt;&lt;EOF\nhello world\nEOF\n\ncat &gt;&gt; 2.txt &lt;&lt;EOF\nhello shell\nEOF\n\n# 2.txt 的内容 加上  echo hello python 命令显示的内容\ncat 2.txt &lt;(echo hello python)\n# 结果输出\n    hello world\n    hello shell\n    hello python\n# 重定向到3.txt\ncat &gt;3.txt  2.txt &lt;(echo hello python)\n\ncat &gt;3.txt 2.txt &lt;(cat &lt;&lt;EOF\ngo to hell\ngood night\nEOF)\necho 111 &gt; 1.txt\ncat 1.txt &lt;(cat 2.txt &lt;(cat  &lt;&lt;EOF\nxyz\nabc\nEOF\n))\n\n\n# 时间戳\ndate +%s\n# 一天前的时间戳\ndate -d \"1 day ago\" +%s\n\ndate +\"%Y/%m/%d %H:%M:%S\"\n\n\n# 没有这个命令的话,需要安装\napt install rename\n# 如果后缀名匹配到, 也会修改\n# 不同的linux版本 可能使用的方式不一样\nrename txt mp3 `ls` #把文件名里的txt替换为mp3\nrename txt mp3 *\n# 这个是ubuntu的 与sed 一个德行..\nrename \"s/txt/mp3/g\" *\n\n\n\n\n\n\n\n\nWarning\n\n\n\n\n实际上cp默认是会覆盖的，出现你这种情况是因为cp被alias成cp -i了，可以通过alias命令查看。\n，直接执行原本的cp\n\n\n\n# 这个命令来查看一下\nalias\n\n\nhistory -c  # 清空history\nhistory -a  # 表示把当前session的history立即写入到history文件里去 ~/.bash_history\n#估计原来是过一段时间什么的 才写入文件\n#查看保存记录的文件\necho $HISTFILE\n\n#history配置\nvim /etc/profile\n\n# 空格+命令,不会写入到history中. 防止有人用方向键不小心 使用history 里的rm命令 误删除等等\necho \"export HISTCONTROL=ignorespace\" &gt;&gt; ~/.zshrc\n\n\nw\n# 简洁\nusers\n# 最后登录的用户情况\nlast\n\n\n\n\n关机与重启alias查找 findddseqsort,tactarEOF\n\n\nhalt\n#或者init 0 也是关机\nshutdown -h now # h=halt\n\n### 重启\nreboot\ninit 6 #也是重启\nshutdown -r now #重启 r=reboot\n\n\nvim /etc/profile\nalias cls='clear'\n\n#所有用户永久生效\nvim /etc/bashrc\n#当前用户生效\nvim ~/.bashrc\n#设置的别名可以使用 which 来找\n\n\nwhich cp\nwhereis rsync\nwhereis -b rsync\n#查找更多有关这个字符串在哪里有的\nlocate cp\nfind /tmp -type f -name '*.log' -mtime +7\n\n\n\n生成空文件\n\ndd if=/dev/zero of=test bs=10M count=1\n\n复制文件内容到另外一个文件\n\ndd if=abc.jpg of=test conv=notrunc\n\n跳过复制源多少字节\n\n# 跳过test,jpg的 10m内容, 后面的内容复制到my.mp4\ndd if=test.jpg of=my.mp4 bs=10M skip=1\n\n跳过输出的目标文件的多少字节\n\n# 如果of指定的文件是不存在的,那么也会在文件前面写入空的10m 大小的数据\n# 就是从指定文件的10M 大小位置开始写入if指定的文件\ndd if=a.mp4  of=testbak.jpg  bs=10M seek=1\n\n\n# 默认以回车符 为分隔符 输出 1 2 3 4 5\nseq 1 5\nseq 1 2 5 #中间的2是间隔 这里打出1 3 5\n# -s 指定分隔符 这里是空格\nseq -s \" \" 1 5\n\n\n-w 补零\n\n# 根据更宽的那个来补足其他\nseq -w 5 11\n\n\n\n执行结果\n\n05\n06\n07\n08\n09\n10\n11\n\n\n\n-f 指定格式输出数字\n\n# %g 默认\n# %2g表示 宽度是2位, 不够就补空格\nseq -f \"%2g\" 1 3\n\n\n\n执行结果\n\n1\n2\n3\n\n# 0表示宽度不足的话,补零,而不是空格\nseq -f \"%02g\" 1 3\n\n\n执行结果\n\n01\n02\n03\n\nseq -f \"file%02g\" 1 3\nfile01\nfile02\nfile03\n\n\nseq 10|sort -rn\n# 倒序打出\nseq 10|tac\n\n\n\n\n打包\n\n# --exclude 排除\ntar -zcvf my-web.tar --exclude=web/.git --exclude=web/node_modules web/\n\n\n\n解包\n\ntar -zxvf my-web.tar\n# tar xf helm-v3.12.2-linux-amd64.tar.gz 解压后 的文件结果是这样的\nlinux-amd64/\n├── helm\n├── LICENSE\n└── README.md\n# -C 指定解压到的目录\n# --strip-components=1 表示 剥离路径一级, 因为这里我们只有  linux-amd64/ 这样一级目录\n# 如果你有2级就 写 --strip-components=2\n# --strip-components=1  后面 要写上 tar包里的 你要解压的文件路径 linux-amd64/helm\n# 结果就是将helm 可执行文件 解压到 /usr/local/bin/\ntar -zxvf helm-v3.12.2-linux-amd64.tar.gz  -C /usr/local/bin/ --strip-components=1 linux-amd64/helm\n\n\n\n命令接收方 &lt;&lt;EOF\nyour content\nEOF\n\ncat &lt;&lt;EOF\nhello\nworld\nEOF\n\nsed -n '/hello/p' &lt;&lt;EOF\nhello\nworld\nEOF\n\n\n-EOF 没有效果...\n\ncat &gt;tmp.txt&lt;&lt;-EOF\n    hello world\n    cat dog\nEOF\n\n\n\n\n\n\n\n关于EOF一个难以察觉的错误\n\n\n\ncat &gt; abc.txt &lt;&lt;EOF\nabc\nEOF \n\ncat &gt; 2.txt &lt;&lt;EOF\n222\nEOF\n\n如果在第三行的EOF后面我们多加了一个空格,其他EOF后都没有\n上面的程序运行的结果是\n\n\n\n最后abc.txt里的内容\n\nabc\nEOF\n\ncat &gt; 2.txt &lt;&lt;EOF\n222\n\n\n\n\n\n\n\nkillwatchtree任务前后台命令bg fg ctrl+z\n\n\nkillall -0 nginx\necho $? # 0 表示 进程存在, 非0 表示不存在\nkillall -s 0 nginx # 同上\n\n\n# 每隔1s 查看一次\nwatch -n 1 tail /var/log/syslog\n\n\n# -I 忽略文件 文件夹\n# -L 2 显示层级\ntree -L 2 -I node_modules\n\n\n# 比如你正在vim 编辑一个文件\n#按下 该按键，则会将当前执行的进程暂停，放到后台,这个时候你可以做其他事情了\nctrl+z \njobs # 查看当前放到后台的任务 1 这种就是任务的编号\n    # suspended 可以知道后台任务的状态\n    [1]  + suspended  vim my.md\nsleep 600 & #直接一个后台的任务\nsleep 500\nctrl+z # 将 sleep 500 这个任务暂停放到后台\njobs \n    [1]  + suspended  vim my.md\n    [2]    running    sleep 600  # 可以看到running的状态的任务\n    [3]  - suspended  sleep 500\n# fg %编号 或 直接 %编号 将后台暂停的任务重新放回前台运行 \nfg %1  \nfg # 这样会直接将编号1的任务 放回前台运行\nbg %3 # 表示将后台暂停的任务 变成在后台执行",
    "crumbs": [
      "bash",
      "基础"
    ]
  },
  {
    "objectID": "docs/devops/linux/bash/quick-start.html#磁盘",
    "href": "docs/devops/linux/bash/quick-start.html#磁盘",
    "title": "斯巴拉稀",
    "section": "2 磁盘",
    "text": "2 磁盘\ndu -h -d 1 dir  #会显示dir目录里的子目录 一层\ndu -h -d 0 dir  #只会显示dir 的大小",
    "crumbs": [
      "bash",
      "基础"
    ]
  },
  {
    "objectID": "docs/devops/linux/bash/quick-start.html#网络命令",
    "href": "docs/devops/linux/bash/quick-start.html#网络命令",
    "title": "斯巴拉稀",
    "section": "3 网络命令",
    "text": "3 网络命令\n\nnccurlss netstatlsofwget\n\n\n\n\n\n# 指定CA 证书 或 自签名证书 ,这个需要你配置 /etc/hosts\ncurl --cacert server.crt https://example1.com/\n#  无需配置 /etc/hosts, 直接指定dns\ncurl --cacert server.crt --resolve example1.com:443:192.168.1.104  https://example1.com/\n\n\nss -tnl\n\n\nlsof -i:8080\n# 通过pid 找文件位置\nlsof -p pid\n\n\n# -O 保存为指定的文件名\n# -q quiet\nwget https://mirrors.163.com/.help/sources.list.jammy -qO /etc/apt/sources.list\n# -c 断点续传\nwget -c url",
    "crumbs": [
      "bash",
      "基础"
    ]
  },
  {
    "objectID": "docs/devops/linux/bash/综合例子.html",
    "href": "docs/devops/linux/bash/综合例子.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "看无注释的配置文件\n\n# 过滤掉空行和注释, 这里以# 作为注释符号的例子\n# [:blank:] 表示 空格和tab\n# 1. 首先以空格或tab开头的 (0个或多个,0就表示可以不是以这个为开头)\n# 2. [^#[:blank:]] 反向字符集 ,表示接着的字符是 不能是# 空格和tab, 就是说匹配非(#空格tab)的字符\n#    过滤了空行, 过滤了 #开头的行, 过滤了 空格/tab+# 的行\nsed -n '/^[[:blank:]]*[^#[:blank:]]/p' my.cnf\n\n\n\n修改配置文件并做备份\n\n# 修改文件 my.cnf, 并做将源文件生成一个备份,文件名是my.cnf.bak\nsed -i.bak 's/hello/world/g' my.cnf\n\n\n\n统计英语单词次数\n\n# (网上随便找到的例子基本都不太严谨.)\n# 这里我排除了 各种符号. 比如标点符号. &lt;&gt; 等等\n# 会将 don't 和 xxx's 这种 看成一个单词. (具体看实际的需求)\n# \\L 表示都转成小写\nsed -nE \"s/[^a-zA-Z]*([a-zA-Z]+'[a-zA-Z]|[a-zA-Z]+)[^a-zA-Z]*/\\L\\1\\n/gp\" book.txt \\\n |sed '/^$/d' \\\n |sort \\\n |uniq -c \\\n |sort -n -r -t \" \" -k 1 \\\n |head -10\n\n\n\n处理空行空格\n\n\n\n#删除行首的空格和行尾的空格\nsed 's/^ *//;s/ *$//' example.txt\n\n# 制表符 tab 转为空格\nsed 's/\\t/  /g' example.txt\n\n# 删除空行\nsed  '/^$/d' example.txt\n\n\n\n指定行号,正则匹配,区间,非!,最后一行$\n\n# 打印第5行\nsed -n '5p' example.txt\n# 打印5-10行\nsed -n '5,10p' example.txt\n# 删除 第2-4行, 7-10行\nseq 1 15 |sed '2,4d;7,+3d'\n# 打印不包含hello的行, I表示 忽略大小写, 要放到!的前面\nsed -En '/hello/I!p' example.txt\n# 首行不打印\nsed -n '1!p' example.txt\n# 打印最后一行\nsed -n '$p' example.txt\n\n# 匹配包含python的行到 包含java的行\n# macos和linux下的都会匹配上,2个区间\nsed -n '/python/,/java/p' &lt;&lt;EOF\nmacos\n    python url1\n    golang url2\n    java url3\nlinux\n    python url4\n    golang  url5\n    java url6\nEOF\n\n# 只打印macos下的 ,可以这样\nsed -n '/^macos/,/^linux/{/python/,/java/p}' &lt;&lt;EOF\nmacos\n    python url1\n    golang url2\n    java url3\nlinux\n    python url4\n    golang  url5\n    java url6\nEOF\n\n# 将第2行和第3行合成一行\nsed  '2N;s/\\n/ /' example.txt\n\n\n整理中...\n\n#将 文件里所有的换行符去掉. 这个命令不支持mac\n# :label 定位标签, 后面的b label 表示跳转到标签label\n# N 表示读取下一行, 然后追加到当前行\n# s/\\n//g 表示将所有的换行符替换为空\nsed -i ':label ;N;s/\\n//g;b label' b.txt\n# $!ba 表示如果还没有到文件末尾,就跳转到标签label\n# 这里的意思是,如果文件还有内容,就继续执行, 直到文件内容为空\nsed -i -e ':a;N;$!ba;s/\\n//g' b.txt\n\n# mac\nsed -n 'H;${x;s/\\n//g;p;}' b.txt\n\n\n\n批量重命名\n\n# 将后缀名 md改成qmd\nfor name in `ls *.md`; do  mv $name  ${name%.md}.qmd; done",
    "crumbs": [
      "bash",
      "综合例子"
    ]
  },
  {
    "objectID": "docs/devops/linux/bash/综合例子.html#实用脚本",
    "href": "docs/devops/linux/bash/综合例子.html#实用脚本",
    "title": "斯巴拉稀",
    "section": "",
    "text": "看无注释的配置文件\n\n# 过滤掉空行和注释, 这里以# 作为注释符号的例子\n# [:blank:] 表示 空格和tab\n# 1. 首先以空格或tab开头的 (0个或多个,0就表示可以不是以这个为开头)\n# 2. [^#[:blank:]] 反向字符集 ,表示接着的字符是 不能是# 空格和tab, 就是说匹配非(#空格tab)的字符\n#    过滤了空行, 过滤了 #开头的行, 过滤了 空格/tab+# 的行\nsed -n '/^[[:blank:]]*[^#[:blank:]]/p' my.cnf\n\n\n\n修改配置文件并做备份\n\n# 修改文件 my.cnf, 并做将源文件生成一个备份,文件名是my.cnf.bak\nsed -i.bak 's/hello/world/g' my.cnf\n\n\n\n统计英语单词次数\n\n# (网上随便找到的例子基本都不太严谨.)\n# 这里我排除了 各种符号. 比如标点符号. &lt;&gt; 等等\n# 会将 don't 和 xxx's 这种 看成一个单词. (具体看实际的需求)\n# \\L 表示都转成小写\nsed -nE \"s/[^a-zA-Z]*([a-zA-Z]+'[a-zA-Z]|[a-zA-Z]+)[^a-zA-Z]*/\\L\\1\\n/gp\" book.txt \\\n |sed '/^$/d' \\\n |sort \\\n |uniq -c \\\n |sort -n -r -t \" \" -k 1 \\\n |head -10\n\n\n\n处理空行空格\n\n\n\n#删除行首的空格和行尾的空格\nsed 's/^ *//;s/ *$//' example.txt\n\n# 制表符 tab 转为空格\nsed 's/\\t/  /g' example.txt\n\n# 删除空行\nsed  '/^$/d' example.txt\n\n\n\n指定行号,正则匹配,区间,非!,最后一行$\n\n# 打印第5行\nsed -n '5p' example.txt\n# 打印5-10行\nsed -n '5,10p' example.txt\n# 删除 第2-4行, 7-10行\nseq 1 15 |sed '2,4d;7,+3d'\n# 打印不包含hello的行, I表示 忽略大小写, 要放到!的前面\nsed -En '/hello/I!p' example.txt\n# 首行不打印\nsed -n '1!p' example.txt\n# 打印最后一行\nsed -n '$p' example.txt\n\n# 匹配包含python的行到 包含java的行\n# macos和linux下的都会匹配上,2个区间\nsed -n '/python/,/java/p' &lt;&lt;EOF\nmacos\n    python url1\n    golang url2\n    java url3\nlinux\n    python url4\n    golang  url5\n    java url6\nEOF\n\n# 只打印macos下的 ,可以这样\nsed -n '/^macos/,/^linux/{/python/,/java/p}' &lt;&lt;EOF\nmacos\n    python url1\n    golang url2\n    java url3\nlinux\n    python url4\n    golang  url5\n    java url6\nEOF\n\n# 将第2行和第3行合成一行\nsed  '2N;s/\\n/ /' example.txt\n\n\n整理中...\n\n#将 文件里所有的换行符去掉. 这个命令不支持mac\n# :label 定位标签, 后面的b label 表示跳转到标签label\n# N 表示读取下一行, 然后追加到当前行\n# s/\\n//g 表示将所有的换行符替换为空\nsed -i ':label ;N;s/\\n//g;b label' b.txt\n# $!ba 表示如果还没有到文件末尾,就跳转到标签label\n# 这里的意思是,如果文件还有内容,就继续执行, 直到文件内容为空\nsed -i -e ':a;N;$!ba;s/\\n//g' b.txt\n\n# mac\nsed -n 'H;${x;s/\\n//g;p;}' b.txt\n\n\n\n批量重命名\n\n# 将后缀名 md改成qmd\nfor name in `ls *.md`; do  mv $name  ${name%.md}.qmd; done",
    "crumbs": [
      "bash",
      "综合例子"
    ]
  },
  {
    "objectID": "docs/devops/linux/bash/综合例子.html#python-conda-一键安装脚本",
    "href": "docs/devops/linux/bash/综合例子.html#python-conda-一键安装脚本",
    "title": "斯巴拉稀",
    "section": "2 python conda 一键安装脚本",
    "text": "2 python conda 一键安装脚本\n\n\n\n\n\n\nCaution\n\n\n\n这里只支持ubuntu和mac, 我只暂时测试了 ubuntu 下的安装,后续会再优化测试.\n\n\nos=$(uname -s|tr '[:upper:]' '[:lower:]')\n\ninstall_python(){\n    #/Linux installers/,/Installing/ 表示找 这2个之间的文本\n    if [ $os == \"linux\" ];then\n        os_begin=\"Linux installers\"\n        os_end=\"Installing\"\n    else\n        os_begin=\"macOS installers\"\n        os_end=\"Linux installers\"\n    fi\n    pyversion=($(curl -Ss https://docs.conda.io/en/latest/miniconda.html | sed -n  '/'\"${os_begin}\"'/,/'\"${os_end}\"'/s#.*&lt;td&gt;Python \\([0-9.]*\\)&lt;/td&gt;#\\1#p'))\n    echo \"选择你的python版本\"\n    for j in ${!pyversion[@]}\n    do\n        echo $(expr $j + 1): ${pyversion[$j]}\n    done\n    echo -n \"请输入编号:\"\n    read python_version_no\n    # 将. 转义\n    python_version=${pyversion[$(expr $python_version_no-1)]/./\\\\.}\n    python_next_version=${pyversion[$python_version_no]/./\\\\.}\n    between_begin=\"Python \"${python_version}\n    between_end=\"Python \"${python_next_version}\n    if [ -z ${python_next_version} ];then\n        between_end=\"Installing\"\n    fi\n    # 使用//,//{//,//} 来范围内找范围\n    cpuverurl=($(curl -Ss https://docs.conda.io/en/latest/miniconda.html | sed -n '/'\"${os_begin}\"'/,/'\"${os_end}\"'/{/'\"${between_begin}\"'/,/'\"${between_end}\"'/s/.* class=\"reference external\" href=\"\\(.*Linux-\\(.*\\)\\.sh\\)\"&gt;.*/\\2 \\1/p}'))\n\n    declare conda_url\n    declare cpu_ver\n\n    echo \"选择你的cpu架构\"\n    for j in ${!cpuverurl[@]}\n    do\n        if [ $(($j%2)) == 0 ];then\n            i=$(expr $j / 2 + 1)\n            echo $i: ${cpuverurl[$j]}\n            cpu_ver[$i]=${cpuverurl[$j]}\n            conda_url[$i]=${cpuverurl[$(expr $j + 1)]}\n        fi\n    done\n    echo -n \"输入编号:\"\n    read chosen_cpu\n    echo \"你选择的是:\" ${cpu_ver[${chosen_cpu}]}\n    miniconda_url=${conda_url[${chosen_cpu}]}\n    execfile=${conda_url[${chosen_cpu}]##*/}\n    wget ${miniconda_url}\n    chmod +x $execfile\n    # -p 安装的目录.\n    bash $execfile -b -p $HOME/miniconda\n    $HOME/miniconda/bin/conda init zsh\n    . ~/.zshrc\n    # 如果你在bash 环境下 安装的. 想要用zsh\n    # conda init zsh \n    # 在zsh 环境下安装 默认就会修改.zshrc的. \n}\ninstall_python",
    "crumbs": [
      "bash",
      "综合例子"
    ]
  },
  {
    "objectID": "docs/devops/linux/bash/综合例子.html#go-一键安装脚本",
    "href": "docs/devops/linux/bash/综合例子.html#go-一键安装脚本",
    "title": "斯巴拉稀",
    "section": "3 go 一键安装脚本",
    "text": "3 go 一键安装脚本\nos=$(uname -s|tr '[:upper:]' '[:lower:]')\ninstall_go(){\n    echo  \"暂时只写了 amd64版本的下载.\"\n    echo \" 输入你要的go版本\"\n    curl -Ss https://golang.google.cn/dl/ | sed -n 's/.*class=\"toggle\" id=\"go\\([.0-9]*\\)\"&gt;/\\1/p'| head -20\n    read go_version\n    wget https://golang.google.cn/dl/go${go_version}.${os}-amd64.tar.gz\n    # 这里我直接删除了旧的, 后续再完善 , 可以用 软链接之类的.\n    rm -rf /usr/local/go && tar -C /usr/local -xzf go${go_version}.${os}-amd64.tar.gz\n    echo 'export PATH=$PATH:/usr/local/go/bin' &gt;&gt; ~/.zshrc\n    . ~/.zshrc\n    go env -w GOPROXY=https://goproxy.cn,http://mirrors.aliyun.com/goproxy/,https://goproxy.io,direct\n}\ninstall_go",
    "crumbs": [
      "bash",
      "综合例子"
    ]
  },
  {
    "objectID": "docs/devops/linux/bash/sed.html",
    "href": "docs/devops/linux/bash/sed.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "env\nversion\n\n\n\n\nsed\nsed (GNU sed) 4.7",
    "crumbs": [
      "bash",
      "sed"
    ]
  },
  {
    "objectID": "docs/devops/linux/bash/sed.html#工作原理",
    "href": "docs/devops/linux/bash/sed.html#工作原理",
    "title": "斯巴拉稀",
    "section": "1 工作原理",
    "text": "1 工作原理\n\nsed = stream editor 可以对标准输出和文件进行逐行处理 ### 命令结构\n\n\n\n1.1 流程图\n\n\n\n1.2 –debug 分析流程\n\n1.2.1 p 打印操作分析\n\nexample.txt”执行命令debug分析\n\n\nhello cat\nhello world\nhot dog\n\n\n# = 的行为是打印匹配的行的行号\nsed '/hello/=;p' example.txt\n\n\n执行结果\n\n1\nhello cat\nhello cat\n2\nhello world\nhello world\nhot dog\nhot dog\n\n\n\nsed --debug '/hello/=;p' example.txt\n\n\n执行结果\n\nSED PROGRAM:\n/hello/ =\np\nINPUT:   'example.txt' line 1\nPATTERN: hello cat\nCOMMAND: /hello/ =\n1\nCOMMAND: p\nhello cat\nEND-OF-CYCLE:\nhello cat\nINPUT:   'example.txt' line 2\nPATTERN: hello world\nCOMMAND: /hello/ =\n2\nCOMMAND: p\nhello world\nEND-OF-CYCLE:\nhello world\nINPUT:   'example.txt' line 3\nPATTERN: hot dog\nCOMMAND: /hello/ =\nCOMMAND: p\nhot dog\nEND-OF-CYCLE:\nhot dog\n\n\n第5行, 显示 pattern space buffer的内容,就是行内容\n显示结果里的第6行COMMAND: /hello/ = 判断pattern space是否包含hello,是的话就打印它的行号\n第8行 COMMAND: p [addr]是空,就是直接匹配了,直接p操作打印pattern space的内容.\n第11行是 不带-n的 默认行为 打印了pattern space的内容 hello cat\n\n\n\n\n\n\n1.2.2 s 替换操作分析\n\n执行命令debug分析\n\n\nsed  's/hello/xxxx/gp' example.txt\n\n\n执行结果\n\nxxxx cat\nxxxx cat\nxxxx world\nxxxx world\nhot dog\n\n\n\nsed --debug 's/hello/xxxx/gp' example.txt\n\n\n执行结果\n\nSED PROGRAM:\ns/hello/xxxx/gp\nINPUT:   'example.txt' line 1\nPATTERN: hello cat\nCOMMAND: s/hello/xxxx/gp\nMATCHED REGEX REGISTERS\nregex[0] = 0-5 'hello'\nxxxx cat\nPATTERN: xxxx cat\nEND-OF-CYCLE:\nxxxx cat\nINPUT:   'example.txt' line 2\nPATTERN: hello world\nCOMMAND: s/hello/xxxx/gp\nMATCHED REGEX REGISTERS\nregex[0] = 0-5 'hello'\nxxxx world\nPATTERN: xxxx world\nEND-OF-CYCLE:\nxxxx world\nINPUT:   'example.txt' line 3\nPATTERN: hot dog\nCOMMAND: s/hello/xxxx/gp\nPATTERN: hot dog\nEND-OF-CYCLE:\nhot dog\n\n\n第8行 是 s/hello/xxxx/gp中p这个s的flag的行为(打印pattern space). 注意它其实并不是X,s是X,这个p只是它的flag,只不过行为与身为X的p操作一样.后续再说\n第9行 显示变化后的 pattern space 的内容给我们看. 这个时候已经被替换了相关的字符串. 如果patttern space 内容有变化会在这里重新显示一次\n不带-n的默认操作, 打印 pattern space\n\n\n\n\n\n\n1.2.3 a 行后插入操作分析\n\n执行命令\n\n\nsed -n '/world/a python' example.txt\n\n\n执行结果\n\npython\n\n从执行结果看, a操作默认会打印你插入的内容 #### debug分析\n# 我们debug 一下不带 -n 参数的 流程.\nsed --debug '/world/a python' example.txt\n\n\n执行结果\n\nSED PROGRAM:\n/world/ a\\python\n\nINPUT:   'example.txt' line 1\nPATTERN: hello cat\nCOMMAND: /world/ a\\python\n\nEND-OF-CYCLE:\nhello cat\nINPUT:   'example.txt' line 2\nPATTERN: hello world\nCOMMAND: /world/ a\\python\n\nEND-OF-CYCLE:\nhello world\npython\nINPUT:   'example.txt' line 3\nPATTERN: hot dog\nCOMMAND: /world/ a\\python\n\nEND-OF-CYCLE:\nhot dog\n\n\n从11-16行可以看到 Pattern space并没有发生变化. (有变化会重新显示一次)\n15行是 没有-n 的默认行为, 打印Pattern space\n16行是a 的行为. 它发生在 默认打印pattern space行为的后面\na的行为: 不改变pattern space , 它会把在该命令后面的文本,在当前CYCLE结束或读取下一行时输出.\n注意上面的空行3,7,13,20这几行,这是COMMAND本身的一部分. 就是说我们a python后面实际跟着一个换行符,要不然也不会是插入一行了. 所以SED PROGRAM:后面显示的是2行,包含了一个换行符\n\n\n\n\n\n\n1.2.4 i 行前插入操作分析\n\n执行命令debug分析\n\n\nsed '/world/i python' example.txt\n\n\n执行结果\n\nhello cat\npython\nhello world\nhot dog\n\n\n\nsed  --debug '/world/i python' example.txt\n\n\n执行结果\n\nSED PROGRAM:\n/world/ i\\python\n\nINPUT:   'example.txt' line 1\nPATTERN: hello cat\nCOMMAND: /world/ i\\python\n\nEND-OF-CYCLE:\nhello cat\nINPUT:   'example.txt' line 2\nPATTERN: hello world\nCOMMAND: /world/ i\\python\n\npython\nEND-OF-CYCLE:\nhello world\nINPUT:   'example.txt' line 3\nPATTERN: hot dog\nCOMMAND: /world/ i\\python\n\nEND-OF-CYCLE:\nhot dog\n\n\n第14行直接打印了, 可以与a操作 做个对比\n官方原话: Immediately output the lines of text which follow this command\n\n\n\n\n\n\n1.2.5 H和x操作 与hold space\n\ninput.txt执行指令分析\n\n\n官方例子, 我内容稍微变下\njs\nvue\nreact\n\npython\nphp\n\njava\ngolang\nrust\n\n\nsed '/./{H;$!d} ; x ; s/^/\\nSTART--&gt;/ ; s/$/\\n&lt;--END/' input.txt\n# 上面的命令会在最开头增加一个空行. 这里这个将这个去掉了.\n# sed '/./{H;$!d} ; x ; s/^/START--&gt;/; $!s/$/\\n&lt;--END\\n/;$s/$/\\n&lt;--END/' input.txt\n\n\n执行结果\n\n                    \nSTART--&gt;\njs\nvue\nreact\n&lt;--END\n\nSTART--&gt;\npython\nphp\n&lt;--END\n\nSTART--&gt;\njava\ngolang\nrust\n&lt;--END\n\n\n\n\n\n\nX\nDescription\n\n\n\n\nH1\n添加一个换行符到hold space,然后将pattern space 的内容追加到hold space\n\n\nx2\n互相hold space和pattern space的内容\n\n\nd\n删除 pattern space的内容,立刻开始下一次cycle,后续的命令不再执行哦\n\n\n\nsed --debug '/./{H;$!d} ; x ; s/^/\\nSTART--&gt;/ ; s/$/\\n&lt;--END/' input.txt\n\n\n执行结果\n\nSED PROGRAM:\n/./ {\n    H\n    $! d\n}\nx\ns/^/\nSTART--&gt;/\ns/$/\n&lt;--END/\nINPUT:   'input.txt' line 1\nPATTERN: js\nCOMMAND: /./ {\nCOMMAND:   H\nHOLD:    \\njs\nCOMMAND:   $! d\nEND-OF-CYCLE:\nINPUT:   'input.txt' line 2\nPATTERN: vue\nCOMMAND:   /./ {\nCOMMAND:     H\nHOLD:    \\njs\\nvue\nCOMMAND:     $! d\nEND-OF-CYCLE:\nINPUT:   'input.txt' line 3\nPATTERN: react\nCOMMAND:     /./ {\nCOMMAND:       H\nHOLD:    \\njs\\nvue\\nreact\nCOMMAND:       $! d\nEND-OF-CYCLE:\nINPUT:   'input.txt' line 4\nPATTERN:\nCOMMAND:       /./ {\nCOMMAND:       }\nCOMMAND:       x\nPATTERN: \\njs\\nvue\\nreact\nHOLD:\nCOMMAND:       s/^/\nSTART--&gt;/\nMATCHED REGEX REGISTERS\nregex[0] = 0-0 ''\nPATTERN: \\nSTART--&gt;\\njs\\nvue\\nreact\nCOMMAND:       s/$/\n&lt;--END/\nMATCHED REGEX REGISTERS\nregex[0] = 22-22 ''\nPATTERN: \\nSTART--&gt;\\njs\\nvue\\nreact\\n&lt;--END\nEND-OF-CYCLE:\n\nSTART--&gt;\njs\nvue\nreact\n&lt;--END\nINPUT:   'input.txt' line 5\nPATTERN: python\nCOMMAND:       /./ {\nCOMMAND:         H\nHOLD:    \\npython\nCOMMAND:         $! d\nEND-OF-CYCLE:\nINPUT:   'input.txt' line 6\nPATTERN: php\nCOMMAND:         /./ {\nCOMMAND:           H\nHOLD:    \\npython\\nphp\nCOMMAND:           $! d\nEND-OF-CYCLE:\nINPUT:   'input.txt' line 7\nPATTERN:\nCOMMAND:           /./ {\nCOMMAND:           }\nCOMMAND:           x\nPATTERN: \\npython\\nphp\nHOLD:\nCOMMAND:           s/^/\nSTART--&gt;/\nMATCHED REGEX REGISTERS\nregex[0] = 0-0 ''\nPATTERN: \\nSTART--&gt;\\npython\\nphp\nCOMMAND:           s/$/\n&lt;--END/\nMATCHED REGEX REGISTERS\nregex[0] = 20-20 ''\nPATTERN: \\nSTART--&gt;\\npython\\nphp\\n&lt;--END\nEND-OF-CYCLE:\n\nSTART--&gt;\npython\nphp\n&lt;--END\nINPUT:   'input.txt' line 8\nPATTERN: java\nCOMMAND:           /./ {\nCOMMAND:             H\nHOLD:    \\njava\nCOMMAND:             $! d\nEND-OF-CYCLE:\nINPUT:   'input.txt' line 9\nPATTERN: golang\nCOMMAND:             /./ {\nCOMMAND:               H\nHOLD:    \\njava\\ngolang\nCOMMAND:               $! d\nEND-OF-CYCLE:\nINPUT:   'input.txt' line 10\nPATTERN: rust\nCOMMAND:               /./ {\nCOMMAND:                 H\nHOLD:    \\njava\\ngolang\\nrust\nCOMMAND:                 $! d\nCOMMAND:               }\nCOMMAND:               x\nPATTERN: \\njava\\ngolang\\nrust\nHOLD:    rust\nCOMMAND:               s/^/\nSTART--&gt;/\nMATCHED REGEX REGISTERS\nregex[0] = 0-0 ''\nPATTERN: \\nSTART--&gt;\\njava\\ngolang\\nrust\nCOMMAND:               s/$/\n&lt;--END/\nMATCHED REGEX REGISTERS\nregex[0] = 26-26 ''\nPATTERN: \\nSTART--&gt;\\njava\\ngolang\\nrust\\n&lt;--END\nEND-OF-CYCLE:\n\nSTART--&gt;\njava\ngolang\nrust\n&lt;--END\n\n\n第13行, /./匹配非空行\n第14行, H指令, 将换行符+pattern space追加到 hold space\n第15行, 可以看到hold space的内容\n第16行, d 操作 ,然后17行直接 去下一次 cycle,后续 命令不再执行.\n第32行, input.txt 第4行是空行, 所以/./ 不匹配, 没有做{}里面的d操作, 则继续后面的指令 x,将hold space和pattern space 互换了.\n后面是s 替换操作. 最后 不带-n的默认 打印pattern space 操作.",
    "crumbs": [
      "bash",
      "sed"
    ]
  },
  {
    "objectID": "docs/devops/linux/bash/sed.html#option-参数",
    "href": "docs/devops/linux/bash/sed.html#option-参数",
    "title": "斯巴拉稀",
    "section": "2 OPTION 参数",
    "text": "2 OPTION 参数\n\n\n\n\n\n\n\nOPTION\nDescription\n\n\n\n\n-n\n 仅显示 script 处理后的结果\n\n\n-e\n 以指定的 script 来处理输入的文本文件,默认就有这个参数\n\n\n-f\n: 以指定的文件的内容来作为 script 来处理 input-file\n\n\n-E/-r\n 支持扩展正则 (推荐用-E 可移植性)  带-E与不带-E的区别 1. 不带的时候 那么{} () | + ? 没有特别含义,就是它本身,如果想要变成特殊含义则前面加上\\2. 带上-E与之相反\n\n\n-i\n 直接修改 input-file 的内容\n\n\n-s\n 放到input-file章节说明\n\n\n--debug\n 显示 sed 的执行过程,低版本的sed可能没有\n\n\n\n\n example.txt -n -e -f -E/-r -i\n\n\nhello cat\nhello world\nhot dog\n\n\n\n不带-n带 -n\n\n\n下面这个,匹配则打印处理后的行(/hello/p的行为),然后不管匹配与否再打印处理后的行(不带-n的默认行为).\nsed '/hello/p' example.txt\n\n\n执行结果\n\nhello cat\nhello cat\nhello world\nhello world\nhot dog\n\n\n\n只打印匹配的行\nsed -n '/hello/p' example.txt\n\n\n执行结果\n\nhello cat\nhello world\n\n\n\n\n\n\n指定多个-e, 就是对读取的行,按顺序进行 script1,然后script2 操作\nsed -n -e '/hello/p' -e '/world/p' example.txt\n\n\n执行结果\n\nhello cat\nhello world\nhello world\n\n\n\n将 /hello/p 这样的 script 写到文件中去,执行如下命令\nsed -n -f script.sed example.txt\n\n\n|无特殊含义,就是它本身,所以没有找到匹配的行.\nsed  -n '/hello|world/p' example.txt\n这里的|表示特殊含义或 ,所以可以正确匹配.\nsed  -n -E '/hello|world/p' example.txt\n\n\nsed -n 's/cat/dog/g;p' example.txt\n# 直接修改源文件了, 注意这里就不能再加上;p了. 否则你文件里就重复行了.\nsed -i 's/cat/dog/g' example.txt\n\n==使用-i后面直接带上.bak 来修改文件的同时进行备份.==\n\n# 会先将example.txt 做个备份, 文件名是\nsed -i.bak 's/cat/dog/g' example.txt.bak\n# 所以 写-i 和其他 -E这种参数时要注意, 不要放在i的后面 , \n# 写成 -Ei而不是-iE 后者是做了备份了.E成了备份文件的后缀名\n\n\n\n\n\n\n关于-i的底层逻辑\n\n\n\n\n实际是创建了一个临时文件, 将输出写入到该临时文件而不是终端.\n等到文件读完,会将临时文件rename 为 我们 原本的文件名\n\n# 我们使用strace来跟踪我们的sed操作里与文件有关的系统调用\nstrace -e trace=file sed -i 's/cat/dog/g' example.txt\n\n\n执行结果\n\n...\n...\nopenat(AT_FDCWD, \"example.txt\", O_RDONLY)  = 3\nopenat(AT_FDCWD, \"./sedE5aURA\", O_RDWR|O_CREAT|O_EXCL, 0600) = 4\nrename(\"./sedE5aURA\", \"example.txt\")       = 0",
    "crumbs": [
      "bash",
      "sed"
    ]
  },
  {
    "objectID": "docs/devops/linux/bash/sed.html#input-file",
    "href": "docs/devops/linux/bash/sed.html#input-file",
    "title": "斯巴拉稀",
    "section": "3 input-file",
    "text": "3 input-file\n\n text.txt 指定多个文件 -s\n\n\ntomcat\nhello cat\ngoogle\n\n\nsed  -n '/cat/{p;=}' example.txt text.txt\n\n\n执行结果\n\nhello cat\n1\ntomcat\n4\nhello cat\n5\n\n\n看行号,我们可以知道sed是将2个文件当成一个文件来处理\n使用 -s 参数, 会将每个文件作为一个单独的来处理\n\n\n\nsed  -ns '/cat/{p;=}' example.txt text.txt\n\n\n执行结果\n\nhello cat\n1\ntomcat\n1\nhello cat\n2",
    "crumbs": [
      "bash",
      "sed"
    ]
  },
  {
    "objectID": "docs/devops/linux/bash/sed.html#script",
    "href": "docs/devops/linux/bash/sed.html#script",
    "title": "斯巴拉稀",
    "section": "4 script",
    "text": "4 script\n\n4.1 [addr] 匹配行\n\n example.txt 所有行: 指定行号” : 正则3 区间 取反 最后一行\n\n\nhello one\nhello two\ntree\nfour\nfive\nspace\nblank\nworld one\nxxx two\nyyy\nworld five\nzzz\n\n\n# 会打印所有行 这个时候 [addr] 可以说是空的.\nsed -n \"p\" example.txt\nsed -n \"s/hello/world/g\" example.txt\n\n\n# 匹配到第二行\nsed -n '2p' example.txt\n\n\n执行结果\n\nhello two\n\n\n\n# 包含hello的行\nsed -n '/hello/p' example.txt\n# 大写的I 表示忽略大小写, 如果写成 i ,是 行前插入的操作. 是X类别\nsed -n '/hello/Ip' example.txt\n\n\n\n行号指定区间,多行\n\n# 匹配到第2到4行\nsed -n '2,4p' example.txt\n# 第2行, 再加2行, 也就是2-4行, 一共3行\nsed -n '2,+2p' example.txt\n\n\n执行结果\n\nhello two\ntree\nfour\n\n\n正则区间 /pattern1/,/pattern2/\n\n\n匹配到pattern1的行开始到匹配到pattern2的行结束\n如果开始的行没有匹配到,那么就没有匹配到行\n而到哪一行为止呢? 稍微思考下, 可以得出这样的结论 :\n\n如果到哪行为止没有匹配到, 就意味着一直匹配到最后一行\n到哪行为止 有多行都能匹配到, 肯定是首先匹配的那一行.\n\n\n# 含有two的行到  含有five的行\nsed -n '/two/,/five/p' example.txt\n多个符合的区间, 就会都匹配上的\n\n\n执行结果\n\nhello two\ntree\nfour\nfive\nxxx two\nyyy\nworld five\n\n# 第一个区间匹配到了. 第二个区间只匹配到开始的行. 那么第二个区间就是匹配行到最后一行\nsed -n '/two/,/four/p' example.txt\n\n\n执行结果\n\nhello two\ntree\nfour\nxxx two\nyyy\nworld five\nzzz\n\n\n行号正则混合使用\n\n#/four/ 如果没匹配到行,那么从第 1 行一直匹配到最后,会都打印.\nsed -n '1,/four/p' example.txt\n#如果匹配到行号大于 后面的具体行数, 那么就只会显示 /four/ 匹配到的行\nsed -n '/four/,6p' example.txt\n\n\n# 排除1-2 行,其他行进行s操作\nsed -n '1,2!s/one/111/p' example.txt\n# 打印不保护hello的行\nsed -n '/hello/!p' example.txt\n\n\n# 打印最后一行\nsed -n '$p'  text.txt example.txt\n# 打印各自文件的最后一行.\nsed -ns '$p'  text.txt example.txt\n\n\n\n\n\n4.2 X 指令\n\n4.2.1 查 (p)\n\n\n\n\n\n\n\nX\nDescription\n\n\n\n\np\n 打印处理后的匹配行 (打印pattern space + 换行符)\n\n\n=\n 打印匹配行的行号 + 换行符\n\n\n\n\np\n\nseq 3|sed -n '2p'\n\n=\n\n# 显示匹配到的行的行号\nsed -n '/hello/=' example.txt\n\nseq -f \"line%g\" 1 3|sed '='\n\n\n执行结果\n\n1\nline1\n2\nline2\n3\nline3\n\n\n\n4.2.2 增 (a i r w)\n\n\n\n\n\n\n\nX\nDescription\n\n\n\n\na\n 行后追加\n\n\ni\n 行前追加\n\n\nr\n 外部文件读入, 行后追加\n\n\nw\n 匹配行写入外部文件\n\n\n\n\n# 在匹配到的hello 行下一行 ,添加 NIHAO 这样一行\n# a后面 空格 再跟上你要添加的内容\nsed -i '/hello/a NIHAO' example.txt\n# 匹配到的每一个行 后都添加一行 内容是hi\nsed -i '/hello/,/world/a hi'\n# 插入多行.\nsed -i '/hello/a\\\nhi\\\nhow are your' example.txt\n\n# 行前\nsed -i '/hello/i NIHAO' example.txt\n# 将new.txt 里的内容添加到 包含hello 的行后\nsed -i '/hello/r new.txt' example.txt\nsed -n '/hello/w new.txt' out.txt\n\n\n4.2.3 删 (d)\n\n\n\n\n\n\n\nX\nDescription\n\n\n\n\nd\n 删除 pattern space的内容,立刻开始下一次cycle,后续的命令不再执行且默认不带-n时的打印处理后的行(pattern space+换行符) 的行为也不会执行. 如果这个默认行为没有取消,那么你不带-n时每次d,都会打印一行空行了 \n\n\n\nseq -f \"line%g\" 1 3 | sed '2d;='\n\n\n执行结果\n\n1\nline1\n3\nline3\n\n# 删除包含hello的行到包含world的行, 有多个就执行删除多个区间\nsed '/hello/,/world/d' example.txt\n\n\n4.2.4 改 (s)\n\n\n\n\n\n\n\n\nX\nDescription\n\n\n\n\ns\n: 替换操作\n\n\n\n\n\n\nflags\nDescription\n\n\n\n\ni/I\n匹配时忽略大小写\n\n\n\n\nexample.txt例子”反向引用 &与&\n\n\nHEllo cat\nxx hello yyy hello\nhot dog HELLO\n\n\n#每一行的第一个 hello 替换为 world\nsed 's/hello/world/' example.txt\n# 全部hello替换为world\nsed 's/hello/world/g' example.txt \n#忽略大小写,全部替换 i/I 大写的I也是一个意思\nsed 's/hello/world/ig' example.txt \n# 将行内第 2 个匹配的 hello 到后面所有匹配到的 hello 替换为 world\nsed 's/hello/world/2g' example.txt\n\n\nsed 's/hello/world/2g' example.txt 执行结果\n\nHEllo cat\nxx hello yyy world\nhot dog HELLO\n\n# \\U 将匹配到的内容 转为大写 (\\u 是第一个字符大写)\nsed 's/hello/\\U&/g' example.txt\n# 将xx转为大写, yyy转为大写 \\E表示停止前面\\U 的行为,就是\\E后面的不会继续转大写了.\nsed -E 's/(xx)\\shello\\s(yyy)/\\U\\1\\E hello \\U\\2/g' example.txt\n# 同理 \\L 是将匹配到的内容 转为小写, \\l 是将第一个字符转小写\nsed -E 's/hello/\\L&/ig' example.txt\n\n\n\n\n\nregex\nDescription\n\n\n\n\n&\n正则表达式匹配到的所有内容\n\n\n\\n (n值为1-9)\n正则表达式里\\(\\)里匹配到的内容\n\n\n\n\n\n# 将两行的eat/EAT 改成==&gt; don't eat/EAT\n# & 表示/eat/正则匹配到的具体内容\nsed \"s/eat/don't &/i\" &lt;&lt;EOF\ncats eat fish\ndogs EAT fish\nEOF\n\n\n执行结果\n\ncats don't eat fish\ndogs don't EAT fish\n\n\n\n# \\S 非空白字符\n# 按顺序 第一个() 就是 \\1...\nsed -E \"s/(\\S+)\\s(eat)\\s(\\S+)/\\3 \\2 \\1/i\" &lt;&lt;EOF\ncats eat fish\ndogs EAT fish\nEOF\n\n\n执行结果\n\nfish eat cats\nfish EAT dogs\n\n\n\n\n\n\n4.2.5 n/N\n\n\n\n\n\n\n\nX\nDescription\n\n\n\n\nn\n如果没有使用参数-n, 则立刻打印处理后的行(pattern space+换行符),然后不管是否使用-n,都将pattern space 替换为下一行的内容,如果没有下一行了,则立刻结束,后续指令不操作.\n\n\nN\n追加换行符到pattern space,继续追加下一行的内容 ,如果没有下一行了,则立刻结束,后续指令不操作.\n\n\n\n\nn”N\n\n\nseq 1 3 | sed  'n;p'\n\n\n执行结果\n\n1\n2\n2\n3\n\n\n\ndebug\n\nSED PROGRAM:\nn\np\nINPUT:   'STDIN' line 1\nPATTERN: 1\nCOMMAND: n\n1\nPATTERN: 2\nCOMMAND: p\n2\nEND-OF-CYCLE:\n2\nINPUT:   'STDIN' line 3\nPATTERN: 3\nCOMMAND: n\n3\nEND-OF-CYCLE:\n\n\n第6-7行,由于这里 不带-n,则立刻打印 pattern space,然后 将pattern space 替换为下一行\n第8行显示为替换后的 pattern space\n第9-10行 是p的操作, 打印了 pattern space\n第13行说明直接读取了文件的第3行, 第15行的n 操作 发现没有下一行了.立刻结束了. 不做后续的p操作.\n\n#  比如偶数行 做些操作\nseq 6 | sed -n 'n;p'\n# 匹配到的行后面第2行\nseq 7 |sed -n '/3/{n;n;p}' # 显示5\n\n\n# 将第3行和第3行 合成一行.\nsed  '2N;s/\\n/--/' example.txt\n\n\n执行结果\n\nHEllo cat\nxx hello yyy hello--hot dog HELLO\n\n\n\ndebug\n\nSED PROGRAM:\n2 N\ns/\\n/--/\nINPUT:   '2.txt' line 1\nPATTERN: HEllo cat\nCOMMAND: 2 N\nCOMMAND: s/\\n/--/\nPATTERN: HEllo cat\nEND-OF-CYCLE:\nHEllo cat\nINPUT:   '2.txt' line 2\nPATTERN: xx hello yyy hello\nCOMMAND: 2 N\nPATTERN: xx hello yyy hello\\nhot dog HELLO\nCOMMAND: s/\\n/--/\nMATCHED REGEX REGISTERS\nregex[0] = 18-19 '\n'\nPATTERN: xx hello yyy hello--hot dog HELLO\nEND-OF-CYCLE:\nxx hello yyy hello--hot dog HELLO\n\n\n\n\n\n\n4.2.6 ; 和 {;}\n;可以有多个\n=={}里还可以有{}== ::: {.panel-tabset}\n\n\n4.2.7 ;\n# = 表示打印匹配的行的行号\nsed -n  '/hello/=;p' &lt;&lt;EOF\nhello cat\nhot dog\nworld hello\nEOF\n\n\n执行结果\n\n1\nhello cat\nhot dog\n3\nworld hello\n\n/hello/=;p 对与匹配到hello的行执行=指令, p与前面的无关, 它会重新看该行是否匹配它自己的规则. #### {;}”\nsed -n  '/hello/{=;p}' &lt;&lt;EOF\nhello cat\nhot dog\nworld hello\nEOF\n\n\n执行结果\n\n1\nhello cat\n3\nworld hello\n\n/hello/{=;p} 对于匹配到hello的行 执行 =指令,再执行p指令. {}里的指令是一个整体\n# 多个操作 可以这样写 ,不用;号\nsed  '/hello/{\n/world/a  python\n=\n}' &lt;&lt;EOF\nhello xx\nhello world\ngolang\nEOF\n:::\n\n\n4.2.8 使用变量\npattern=\"he..o\"\n# 这样. pattern里的. 在下面还是表示 任意字符哦.\n# 使用双引号\nsed -n \"s/$pattern/world/g\" example.txt\n#或者 单引号\nsed -n 's/'$pattern'/world/g' example.txt",
    "crumbs": [
      "bash",
      "sed"
    ]
  },
  {
    "objectID": "docs/devops/linux/bash/sed.html#footnotes",
    "href": "docs/devops/linux/bash/sed.html#footnotes",
    "title": "斯巴拉稀",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nhttps://www.gnu.org/software/sed/manual/sed.html#Multiline-techniques↩︎\nhttps://www.gnu.org/software/sed/manual/sed.html#Other-Commands↩︎\nhttps://www.gnu.org/software/sed/manual/sed.html#Regular-Expressions-Overview↩︎",
    "crumbs": [
      "bash",
      "sed"
    ]
  },
  {
    "objectID": "docs/go/basic/start-go.html",
    "href": "docs/go/basic/start-go.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "Tip\n\n\n\nTODO中…. 勿看",
    "crumbs": [
      "基础篇",
      "go程序的启动过程"
    ]
  },
  {
    "objectID": "docs/go/basic/start-go.html#找到程序入口函数",
    "href": "docs/go/basic/start-go.html#找到程序入口函数",
    "title": "斯巴拉稀",
    "section": "1 找到程序入口函数",
    "text": "1 找到程序入口函数\ngo build -o main main.go\nreadelf -h main\n\n\n查看 Entry point address\n\nELF Header:\n  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00\n  Class:                             ELF64\n  Data:                              2's complement, little endian\n  Version:                           1 (current)\n  OS/ABI:                            UNIX - System V\n  ABI Version:                       0\n  Type:                              EXEC (Executable file)\n  Machine:                           Advanced Micro Devices X86-64\n  Version:                           0x1\n  Entry point address:               0x456ca0\n  Start of program headers:          64 (bytes into file)\n  Start of section headers:          456 (bytes into file)\n  Flags:                             0x0\n  Size of this header:               64 (bytes)\n  Size of program headers:           56 (bytes)\n  Number of program headers:         7\n  Size of section headers:           64 (bytes)\n  Number of section headers:         23\n  Section header string table index: 3\n\n# 查看go 程序执行的入口\nreadelf -s main|grep 456ca0\n    1034: 0000000000456ca0     5 FUNC    GLOBAL DEFAULT    1 _rt0_amd64_linux\n\n\n\nitem\ndescription\n\n\n\n\nrt0\nruntime0\n\n\n\n\n\ngo/src/runtime/rt0_linux_amd64.s\n\n// Copyright 2009 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n#include \"textflag.h\"\n\nTEXT _rt0_amd64_linux(SB),NOSPLIT,$-8\n    JMP _rt0_amd64(SB)\n\nTEXT _rt0_amd64_linux_lib(SB),NOSPLIT,$0\n    JMP _rt0_amd64_lib(SB)\n\n\n\n我们可以用dlv调试看到入口\n\ndlv exec main\n(dlv) l\n&gt; _rt0_amd64_linux() /usr/local/go/src/runtime/rt0_linux_amd64.s:8 (PC: 0x4567c0)\nWarning: debugging optimized function\n     3: // license that can be found in the LICENSE file.\n     4:\n     5: #include \"textflag.h\"\n     6:\n     7: TEXT _rt0_amd64_linux(SB),NOSPLIT,$-8\n=&gt;   8:     JMP _rt0_amd64(SB)\n     9:\n    10: TEXT _rt0_amd64_linux_lib(SB),NOSPLIT,$0\n    11:     JMP _rt0_amd64_lib(SB)\n\n\n\ngo/src/runtime/asm_amd64.s\n\n// _rt0_amd64 is common startup code for most amd64 systems when using\n// internal linking. This is the entry point for the program from the\n// kernel for an ordinary -buildmode=exe program. The stack holds the\n// number of arguments and the C-style argv.\nTEXT _rt0_amd64(SB),NOSPLIT,$-8\n    MOVQ    0(SP), DI   // argc  参数个数\n    LEAQ    8(SP), SI   // argv  调用命令时的参数\n    JMP runtime·rt0_go(SB)\n\nTEXT runtime·rt0_go(SB),NOSPLIT|TOPFRAME,$0\n    // 将参数复制到栈上\n    MOVQ    DI, AX      // argc\n    MOVQ    SI, BX      // argv\n    SUBQ    $(5*8), SP      // 3args 2auto\n    ANDQ    $~15, SP\n    MOVQ    AX, 24(SP)\n    MOVQ    BX, 32(SP)\n\n    // 创建go程序的第一个协程 g0,用来调度其他协程\n    MOVQ    $runtime·g0(SB), DI\n    LEAQ    (-64*1024+104)(SP), BX\n    MOVQ    BX, g_stackguard0(DI)\n    MOVQ    BX, g_stackguard1(DI)\n    MOVQ    BX, (g_stack+stack_lo)(DI)\n    MOVQ    SP, (g_stack+stack_hi)(DI)\n    // ...\n    // ...\n    // ...\n    // 运行时 检查\n    CALL    runtime·check(SB)\n\n    MOVL    24(SP), AX      // copy argc\n    MOVL    AX, 0(SP)\n    MOVQ    32(SP), AX      // copy argv\n    MOVQ    AX, 8(SP)\n    CALL    runtime·args(SB) // 设置参数\n    CALL    runtime·osinit(SB) // cpu 核心等\n    CALL    runtime·schedinit(SB) // 初始化调度器\n\n    MOVQ    $runtime·mainPC(SB), AX     // runtime.main 函数地址\n    PUSHQ   AX\n    CALL    runtime·newproc(SB) // 启动一个协程\n    POPQ    AX\n\n    // start this M\n    CALL    runtime·mstart(SB)  // GMP中的M\n\n    CALL    runtime·abort(SB)   // mstart should never return\n    RET\n\n// mainPC is a function value for runtime.main, to be passed to newproc.\n// The reference to runtime.main is made via ABIInternal, since the\n// actual function (not the ABI0 wrapper) is needed by newproc.\nDATA    runtime·mainPC+0(SB)/8,$runtime·main&lt;ABIInternal&gt;(SB)",
    "crumbs": [
      "基础篇",
      "go程序的启动过程"
    ]
  },
  {
    "objectID": "docs/go/basic/start-go.html#验证一下参数",
    "href": "docs/go/basic/start-go.html#验证一下参数",
    "title": "斯巴拉稀",
    "section": "2 验证一下参数",
    "text": "2 验证一下参数\ndlv exec main a b\n# 打断点到JMP   runtime·rt0_go(SB), 路径看自己的改改\nb /usr/local/go/src/runtime/asm_amd64.s:18 # 在18行, 看自己的代码实际情况\n# 用si 可以一个指令一个指令的执行\nc # 运行\nregs # 查看寄存器\n    Rsi = 0x00007ffcde282508 # 是参数 ( 存的是字符数组的地址)\n    Rdi = 0x0000000000000003 # 参数个数, ok的\np unsafe.Pointer(*(*uintptr)(0x00007ffcde282508))\n    unsafe.Pointer(0x7ffcde2827dc)\np *(*uint8)(0x00007FFCDE2827DC)\np *(*uint8)(0x00007FFCDE2827DD)\n# 这里我一个字节一个字节的打 ,结果是\n47 114 111 111 116 47 116 109 112 47 116 101 115 116 50 47 116 116 51 47 109 97 105 110 0 97 0 98\n# ===&gt; 路径有点哈哈.. 徒增自己的麻烦...\n# ascii 0 表示空字符,在c 语言中 作为字符串的结尾\n/root/tmp/test2/tt3/main[NUL]a[NUL]b[NUL]",
    "crumbs": [
      "基础篇",
      "go程序的启动过程"
    ]
  },
  {
    "objectID": "docs/go/basic/start-go.html#runtime.check",
    "href": "docs/go/basic/start-go.html#runtime.check",
    "title": "斯巴拉稀",
    "section": "3 runtime.check",
    "text": "3 runtime.check\n\n\nsrc/runtime1.go#runtime.check()\n\nfunc check() {\n    var (\n        a     int8\n        b     uint8\n        c     int16\n        d     uint16\n        e     int32\n        f     uint32\n        g     int64\n        h     uint64\n        i, i1 float32\n        j, j1 float64\n        k     unsafe.Pointer\n        l     *uint16\n        m     [4]byte\n    )\n    type x1t struct {\n        x uint8\n    }\n    type y1t struct {\n        x1 x1t\n        y  uint8\n    }\n    var x1 x1t\n    var y1 y1t\n    // 各种类型长度检查\n    if unsafe.Sizeof(a) != 1 {\n        throw(\"bad a\")\n    }\n    if unsafe.Sizeof(b) != 1 {\n        throw(\"bad b\")\n    }\n    if unsafe.Sizeof(c) != 2 {\n        throw(\"bad c\")\n    }\n    if unsafe.Sizeof(d) != 2 {\n        throw(\"bad d\")\n    }\n    if unsafe.Sizeof(e) != 4 {\n        throw(\"bad e\")\n    }\n    if unsafe.Sizeof(f) != 4 {\n        throw(\"bad f\")\n    }\n    if unsafe.Sizeof(g) != 8 {\n        throw(\"bad g\")\n    }\n    if unsafe.Sizeof(h) != 8 {\n        throw(\"bad h\")\n    }\n    if unsafe.Sizeof(i) != 4 {\n        throw(\"bad i\")\n    }\n    if unsafe.Sizeof(j) != 8 {\n        throw(\"bad j\")\n    }\n    if unsafe.Sizeof(k) != goarch.PtrSize {\n        throw(\"bad k\")\n    }\n    if unsafe.Sizeof(l) != goarch.PtrSize {\n        throw(\"bad l\")\n    }\n    if unsafe.Sizeof(x1) != 1 {\n        throw(\"bad unsafe.Sizeof x1\")\n    }\n    // 结构体偏移量和长度检查\n    if unsafe.Offsetof(y1.y) != 1 {\n        throw(\"bad offsetof y1.y\")\n    }\n    if unsafe.Sizeof(y1) != 2 {\n        throw(\"bad unsafe.Sizeof y1\")\n    }\n\n    if timediv(12345*1000000000+54321, 1000000000, &e) != 12345 || e != 54321 {\n        throw(\"bad timediv\")\n    }\n\n    // cas ,atomic操作 检查\n    var z uint32\n    z = 1\n    if !atomic.Cas(&z, 1, 2) {\n        throw(\"cas1\")\n    }\n    if z != 2 {\n        throw(\"cas2\")\n    }\n\n    z = 4\n    if atomic.Cas(&z, 5, 6) {\n        throw(\"cas3\")\n    }\n    if z != 4 {\n        throw(\"cas4\")\n    }\n\n    z = 0xffffffff\n    if !atomic.Cas(&z, 0xffffffff, 0xfffffffe) {\n        throw(\"cas5\")\n    }\n    if z != 0xfffffffe {\n        throw(\"cas6\")\n    }\n\n    m = [4]byte{1, 1, 1, 1}\n    atomic.Or8(&m[1], 0xf0)\n    if m[0] != 1 || m[1] != 0xf1 || m[2] != 1 || m[3] != 1 {\n        throw(\"atomicor8\")\n    }\n\n    m = [4]byte{0xff, 0xff, 0xff, 0xff}\n    atomic.And8(&m[1], 0x1)\n    if m[0] != 0xff || m[1] != 0x1 || m[2] != 0xff || m[3] != 0xff {\n        throw(\"atomicand8\")\n    }\n\n    //指针操作检查\n    *(*uint64)(unsafe.Pointer(&j)) = ^uint64(0)\n    if j == j {\n        throw(\"float64nan\")\n    }\n    if !(j != j) {\n        throw(\"float64nan1\")\n    }\n\n    *(*uint64)(unsafe.Pointer(&j1)) = ^uint64(1)\n    if j == j1 {\n        throw(\"float64nan2\")\n    }\n    if !(j != j1) {\n        throw(\"float64nan3\")\n    }\n\n    *(*uint32)(unsafe.Pointer(&i)) = ^uint32(0)\n    if i == i {\n        throw(\"float32nan\")\n    }\n    if i == i {\n        throw(\"float32nan1\")\n    }\n\n    *(*uint32)(unsafe.Pointer(&i1)) = ^uint32(1)\n    if i == i1 {\n        throw(\"float32nan2\")\n    }\n    if i == i1 {\n        throw(\"float32nan3\")\n    }\n\n    testAtomic64()\n    // 栈大小是否是2的幂次方\n    if _FixedStack != round2(_FixedStack) {\n        throw(\"FixedStack is not power-of-2\")\n    }\n\n    if !checkASM() {\n        throw(\"assembly checks failed\")\n    }\n}",
    "crumbs": [
      "基础篇",
      "go程序的启动过程"
    ]
  },
  {
    "objectID": "docs/go/basic/start-go.html#runtime.args",
    "href": "docs/go/basic/start-go.html#runtime.args",
    "title": "斯巴拉稀",
    "section": "4 runtime.args()",
    "text": "4 runtime.args()\n\n\n设置参数\n\nfunc args(c int32, v **byte) {\n    argc = c\n    argv = v\n    sysargs(c, v)\n}",
    "crumbs": [
      "基础篇",
      "go程序的启动过程"
    ]
  },
  {
    "objectID": "docs/go/basic/start-go.html#runtime.osinit",
    "href": "docs/go/basic/start-go.html#runtime.osinit",
    "title": "斯巴拉稀",
    "section": "5 runtime.osinit()",
    "text": "5 runtime.osinit()\n\n\n获取cpu核心数\n\nfunc osinit() {\n    ncpu = getncpu()\n    physPageSize = getPageSize()\n    osinit_hack()\n}",
    "crumbs": [
      "基础篇",
      "go程序的启动过程"
    ]
  },
  {
    "objectID": "docs/go/basic/start-go.html#runtimeschedinit",
    "href": "docs/go/basic/start-go.html#runtimeschedinit",
    "title": "斯巴拉稀",
    "section": "6 runtime·schedinit",
    "text": "6 runtime·schedinit\nfunc schedinit() {\n    lockInit(&sched.lock, lockRankSched)\n    lockInit(&sched.sysmonlock, lockRankSysmon)\n    lockInit(&sched.deferlock, lockRankDefer)\n    lockInit(&sched.sudoglock, lockRankSudog)\n    lockInit(&deadlock, lockRankDeadlock)\n    lockInit(&paniclk, lockRankPanic)\n    lockInit(&allglock, lockRankAllg)\n    lockInit(&allpLock, lockRankAllp)\n    lockInit(&reflectOffs.lock, lockRankReflectOffs)\n    lockInit(&finlock, lockRankFin)\n    lockInit(&trace.bufLock, lockRankTraceBuf)\n    lockInit(&trace.stringsLock, lockRankTraceStrings)\n    lockInit(&trace.lock, lockRankTrace)\n    lockInit(&cpuprof.lock, lockRankCpuprof)\n    lockInit(&trace.stackTab.lock, lockRankTraceStackTab)\n    // Enforce that this lock is always a leaf lock.\n    // All of this lock's critical sections should be\n    // extremely short.\n    lockInit(&memstats.heapStats.noPLock, lockRankLeafRank)\n\n    // raceinit must be the first call to race detector.\n    // In particular, it must be done before mallocinit below calls racemapshadow.\n    gp := getg()\n    if raceenabled {\n        gp.racectx, raceprocctx0 = raceinit()\n    }\n    // 系统M线程的最大数量\n    sched.maxmcount = 10000\n\n    // The world starts stopped.\n    worldStopped()\n\n    moduledataverify()\n    stackinit()  //栈初始化\n    mallocinit()  // 内存分配器初始化\n    godebug := getGodebugEarly()\n    initPageTrace(godebug) // must run after mallocinit but before anything allocates\n    cpuinit(godebug)       // must run before alginit\n    // 算法初始化\n    alginit()              // maps, hash, fastrand must not be used before this call\n    fastrandinit()         // must run before mcommoninit\n    mcommoninit(gp.m, -1)\n    modulesinit()   // provides activeModules\n    typelinksinit() // uses maps, activeModules\n    itabsinit()     // uses activeModules\n    stkobjinit()    // must run before GC starts\n\n    sigsave(&gp.m.sigmask)\n    initSigmask = gp.m.sigmask\n\n    goargs() // 加载参数\n    goenvs() // 加载环境变量\n    secure()\n    parsedebugvars()\n    gcinit()\n\n    // if disableMemoryProfiling is set, update MemProfileRate to 0 to turn off memprofile.\n    // Note: parsedebugvars may update MemProfileRate, but when disableMemoryProfiling is\n    // set to true by the linker, it means that nothing is consuming the profile, it is\n    // safe to set MemProfileRate to 0.\n    if disableMemoryProfiling {\n        MemProfileRate = 0\n    }\n\n    lock(&sched.lock)\n    sched.lastpoll.Store(nanotime())\n    procs := ncpu\n    if n, ok := atoi32(gogetenv(\"GOMAXPROCS\")); ok && n &gt; 0 {\n        procs = n\n    }\n    if procresize(procs) != nil {\n        throw(\"unknown runnable goroutine during bootstrap\")\n    }\n    unlock(&sched.lock)\n\n    // World is effectively started now, as P's can run.\n    worldStarted()\n\n    // For cgocheck &gt; 1, we turn on the write barrier at all times\n    // and check all pointer writes. We can't do this until after\n    // procresize because the write barrier needs a P.\n    if debug.cgocheck &gt; 1 {\n        writeBarrier.cgo = true\n        writeBarrier.enabled = true\n        for _, pp := range allp {\n            pp.wbBuf.reset()\n        }\n    }\n\n    if buildVersion == \"\" {\n        // Condition should never trigger. This code just serves\n        // to ensure runtime·buildVersion is kept in the resulting binary.\n        buildVersion = \"unknown\"\n    }\n    if len(modinfo) == 1 {\n        // Condition should never trigger. This code just serves\n        // to ensure runtime·modinfo is kept in the resulting binary.\n        modinfo = \"\"\n    }\n}",
    "crumbs": [
      "基础篇",
      "go程序的启动过程"
    ]
  },
  {
    "objectID": "docs/go/basic/start-go.html#newproc",
    "href": "docs/go/basic/start-go.html#newproc",
    "title": "斯巴拉稀",
    "section": "7 newproc",
    "text": "7 newproc\n// Create a new g running fn.\n// Put it on the queue of g's waiting to run.\n// The compiler turns a go statement into a call to this.\nfunc newproc(fn *funcval) {\n    gp := getg()\n    pc := getcallerpc()\n    systemstack(func() {\n        newg := newproc1(fn, gp, pc)\n\n        pp := getg().m.p.ptr()\n        runqput(pp, newg, true)\n\n        if mainStarted {\n            wakep()\n        }\n    })\n}\n// Create a new g in state _Grunnable, starting at fn. callerpc is the\n// address of the go statement that created this. The caller is responsible\n// for adding the new g to the scheduler.\nfunc newproc1(fn *funcval, callergp *g, callerpc uintptr) *g {\n    if fn == nil {\n        fatal(\"go of nil func value\")\n    }\n\n    mp := acquirem() // disable preemption because we hold M and P in local vars.\n    pp := mp.p.ptr()\n    newg := gfget(pp)\n    if newg == nil {\n        newg = malg(_StackMin)\n        casgstatus(newg, _Gidle, _Gdead)\n        allgadd(newg) // publishes with a g-&gt;status of Gdead so GC scanner doesn't look at uninitialized stack.\n    }\n    if newg.stack.hi == 0 {\n        throw(\"newproc1: newg missing stack\")\n    }\n\n    if readgstatus(newg) != _Gdead {\n        throw(\"newproc1: new g is not Gdead\")\n    }\n\n    totalSize := uintptr(4*goarch.PtrSize + sys.MinFrameSize) // extra space in case of reads slightly beyond frame\n    totalSize = alignUp(totalSize, sys.StackAlign)\n    sp := newg.stack.hi - totalSize\n    spArg := sp\n    if usesLR {\n        // caller's LR\n        *(*uintptr)(unsafe.Pointer(sp)) = 0\n        prepGoExitFrame(sp)\n        spArg += sys.MinFrameSize\n    }\n\n    memclrNoHeapPointers(unsafe.Pointer(&newg.sched), unsafe.Sizeof(newg.sched))\n    newg.sched.sp = sp\n    newg.stktopsp = sp\n    newg.sched.pc = abi.FuncPCABI0(goexit) + sys.PCQuantum // +PCQuantum so that previous instruction is in same function\n    newg.sched.g = guintptr(unsafe.Pointer(newg))\n    gostartcallfn(&newg.sched, fn)\n    newg.gopc = callerpc\n    newg.ancestors = saveAncestors(callergp)\n    newg.startpc = fn.fn\n    if isSystemGoroutine(newg, false) {\n        sched.ngsys.Add(1)\n    } else {\n        // Only user goroutines inherit pprof labels.\n        if mp.curg != nil {\n            newg.labels = mp.curg.labels\n        }\n        if goroutineProfile.active {\n            // A concurrent goroutine profile is running. It should include\n            // exactly the set of goroutines that were alive when the goroutine\n            // profiler first stopped the world. That does not include newg, so\n            // mark it as not needing a profile before transitioning it from\n            // _Gdead.\n            newg.goroutineProfiled.Store(goroutineProfileSatisfied)\n        }\n    }\n    // Track initial transition?\n    newg.trackingSeq = uint8(fastrand())\n    if newg.trackingSeq%gTrackingPeriod == 0 {\n        newg.tracking = true\n    }\n    casgstatus(newg, _Gdead, _Grunnable)\n    gcController.addScannableStack(pp, int64(newg.stack.hi-newg.stack.lo))\n\n    if pp.goidcache == pp.goidcacheend {\n        // Sched.goidgen is the last allocated id,\n        // this batch must be [sched.goidgen+1, sched.goidgen+GoidCacheBatch].\n        // At startup sched.goidgen=0, so main goroutine receives goid=1.\n        pp.goidcache = sched.goidgen.Add(_GoidCacheBatch)\n        pp.goidcache -= _GoidCacheBatch - 1\n        pp.goidcacheend = pp.goidcache + _GoidCacheBatch\n    }\n    newg.goid = pp.goidcache\n    pp.goidcache++\n    if raceenabled {\n        newg.racectx = racegostart(callerpc)\n        newg.raceignore = 0\n        if newg.labels != nil {\n            // See note in proflabel.go on labelSync's role in synchronizing\n            // with the reads in the signal handler.\n            racereleasemergeg(newg, unsafe.Pointer(&labelSync))\n        }\n    }\n    if trace.enabled {\n        traceGoCreate(newg, newg.startpc)\n    }\n    releasem(mp)\n\n    return newg\n}",
    "crumbs": [
      "基础篇",
      "go程序的启动过程"
    ]
  },
  {
    "objectID": "docs/go/basic/start-go.html#runtime.main",
    "href": "docs/go/basic/start-go.html#runtime.main",
    "title": "斯巴拉稀",
    "section": "8 runtime.main",
    "text": "8 runtime.main\n\n\nsrc/runtime/proc.go\n\n// The main goroutine.\nfunc main() {\n    mp := getg().m\n\n    // Racectx of m0-&gt;g0 is used only as the parent of the main goroutine.\n    // It must not be used for anything else.\n    mp.g0.racectx = 0\n\n    // Max stack size is 1 GB on 64-bit, 250 MB on 32-bit.\n    if goarch.PtrSize == 8 {\n        maxstacksize = 1000000000\n    } else {\n        maxstacksize = 250000000\n    }\n\n    // An upper limit for max stack size. Used to avoid random crashes\n    // after calling SetMaxStack and trying to allocate a stack that is too big,\n    // since stackalloc works with 32-bit sizes.\n    maxstackceiling = 2 * maxstacksize\n\n    // Allow newproc to start new Ms.\n    mainStarted = true\n\n    if GOARCH != \"wasm\" { // no threads on wasm yet, so no sysmon\n        systemstack(func() {\n            newm(sysmon, nil, -1)\n        })\n    }\n\n    // Lock the main goroutine onto this, the main OS thread,\n    // during initialization. Most programs won't care, but a few\n    // do require certain calls to be made by the main thread.\n    // Those can arrange for main.main to run in the main thread\n    // by calling runtime.LockOSThread during initialization\n    // to preserve the lock.\n    lockOSThread()\n\n    if mp != &m0 {\n        throw(\"runtime.main not on m0\")\n    }\n\n    // Record when the world started.\n    // Must be before doInit for tracing init.\n    runtimeInitTime = nanotime()\n    if runtimeInitTime == 0 {\n        throw(\"nanotime returning zero\")\n    }\n\n    if debug.inittrace != 0 {\n        inittrace.id = getg().goid\n        inittrace.active = true\n    }\n\n    doInit(&runtime_inittask) // Must be before defer.\n\n    // Defer unlock so that runtime.Goexit during init does the unlock too.\n    needUnlock := true\n    defer func() {\n        if needUnlock {\n            unlockOSThread()\n        }\n    }()\n\n    gcenable()\n\n    main_init_done = make(chan bool)\n    if iscgo {\n        if _cgo_thread_start == nil {\n            throw(\"_cgo_thread_start missing\")\n        }\n        if GOOS != \"windows\" {\n            if _cgo_setenv == nil {\n                throw(\"_cgo_setenv missing\")\n            }\n            if _cgo_unsetenv == nil {\n                throw(\"_cgo_unsetenv missing\")\n            }\n        }\n        if _cgo_notify_runtime_init_done == nil {\n            throw(\"_cgo_notify_runtime_init_done missing\")\n        }\n        // Start the template thread in case we enter Go from\n        // a C-created thread and need to create a new thread.\n        startTemplateThread()\n        cgocall(_cgo_notify_runtime_init_done, nil)\n    }\n\n    doInit(&main_inittask)\n\n    // Disable init tracing after main init done to avoid overhead\n    // of collecting statistics in malloc and newproc\n    inittrace.active = false\n\n    close(main_init_done)\n\n    needUnlock = false\n    unlockOSThread()\n\n    if isarchive || islibrary {\n        // A program compiled with -buildmode=c-archive or c-shared\n        // has a main, but it is not executed.\n        return\n    }\n    fn := main_main\n    fn()  // 调用我们代码写的main函数了.\n    if raceenabled {\n        runExitHooks(0) // run hooks now, since racefini does not return\n        racefini()\n    }\n\n    // Make racy client program work: if panicking on\n    // another goroutine at the same time as main returns,\n    // let the other goroutine finish printing the panic trace.\n    // Once it does, it will exit. See issues 3934 and 20018.\n    if runningPanicDefers.Load() != 0 {\n        // Running deferred functions should not take long.\n        for c := 0; c &lt; 1000; c++ {\n            if runningPanicDefers.Load() == 0 {\n                break\n            }\n            Gosched()\n        }\n    }\n    if panicking.Load() != 0 {\n        gopark(nil, nil, waitReasonPanicWait, traceEvGoStop, 1)\n    }\n    runExitHooks(0)\n\n    exit(0)\n    for {\n        var x *int32\n        *x = 0\n    }\n}\n\n\n\nfn := main_main 编译指示中说过\n\n// main.main main包的main函数\n//\n//go:linkname main_main main.main\nfunc main_main()",
    "crumbs": [
      "基础篇",
      "go程序的启动过程"
    ]
  },
  {
    "objectID": "docs/go/basic/start-go.html#mstart",
    "href": "docs/go/basic/start-go.html#mstart",
    "title": "斯巴拉稀",
    "section": "9 mstart",
    "text": "9 mstart\n// mstart is the entry-point for new Ms.\n// It is written in assembly, uses ABI0, is marked TOPFRAME, and calls mstart0.\nfunc mstart()\n\n// mstart0 is the Go entry-point for new Ms.\n// This must not split the stack because we may not even have stack\n// bounds set up yet.\n//\n// May run during STW (because it doesn't have a P yet), so write\n// barriers are not allowed.\n//\n//go:nosplit\n//go:nowritebarrierrec\nfunc mstart0() {\n    gp := getg()\n\n    osStack := gp.stack.lo == 0\n    if osStack {\n        // Initialize stack bounds from system stack.\n        // Cgo may have left stack size in stack.hi.\n        // minit may update the stack bounds.\n        //\n        // Note: these bounds may not be very accurate.\n        // We set hi to &size, but there are things above\n        // it. The 1024 is supposed to compensate this,\n        // but is somewhat arbitrary.\n        size := gp.stack.hi\n        if size == 0 {\n            size = 8192 * sys.StackGuardMultiplier\n        }\n        gp.stack.hi = uintptr(noescape(unsafe.Pointer(&size)))\n        gp.stack.lo = gp.stack.hi - size + 1024\n    }\n    // Initialize stack guard so that we can start calling regular\n    // Go code.\n    gp.stackguard0 = gp.stack.lo + _StackGuard\n    // This is the g0, so we can also call go:systemstack\n    // functions, which check stackguard1.\n    gp.stackguard1 = gp.stackguard0\n    mstart1()\n\n    // Exit this thread.\n    if mStackIsSystemAllocated() {\n        // Windows, Solaris, illumos, Darwin, AIX and Plan 9 always system-allocate\n        // the stack, but put it in gp.stack before mstart,\n        // so the logic above hasn't set osStack yet.\n        osStack = true\n    }\n    mexit(osStack)\n}\n// The go:noinline is to guarantee the getcallerpc/getcallersp below are safe,\n// so that we can set up g0.sched to return to the call of mstart1 above.\n//\n//go:noinline\nfunc mstart1() {\n    gp := getg()\n\n    if gp != gp.m.g0 {\n        throw(\"bad runtime·mstart\")\n    }\n\n    // Set up m.g0.sched as a label returning to just\n    // after the mstart1 call in mstart0 above, for use by goexit0 and mcall.\n    // We're never coming back to mstart1 after we call schedule,\n    // so other calls can reuse the current frame.\n    // And goexit0 does a gogo that needs to return from mstart1\n    // and let mstart0 exit the thread.\n    gp.sched.g = guintptr(unsafe.Pointer(gp))\n    gp.sched.pc = getcallerpc()\n    gp.sched.sp = getcallersp()\n\n    asminit()\n    minit()\n\n    // Install signal handlers; after minit so that minit can\n    // prepare the thread to be able to handle the signals.\n    if gp.m == &m0 {\n        mstartm0()\n    }\n\n    if fn := gp.m.mstartfn; fn != nil {\n        fn()\n    }\n\n    if gp.m != &m0 {\n        acquirep(gp.m.nextp.ptr())\n        gp.m.nextp = 0\n    }\n    schedule()\n}",
    "crumbs": [
      "基础篇",
      "go程序的启动过程"
    ]
  },
  {
    "objectID": "docs/go/basic/start-go.html#schedule",
    "href": "docs/go/basic/start-go.html#schedule",
    "title": "斯巴拉稀",
    "section": "10 schedule()",
    "text": "10 schedule()\n// One round of scheduler: 找到一个可运行的goroutine并运行它\n// Never returns.\nfunc schedule() {\n    mp := getg().m\n\n    if mp.locks != 0 {\n        throw(\"schedule: holding locks\")\n    }\n\n    if mp.lockedg != 0 {\n        stoplockedm()\n        execute(mp.lockedg.ptr(), false) // Never returns.\n    }\n\n    // We should not schedule away from a g that is executing a cgo call,\n    // since the cgo call is using the m's g0 stack.\n    if mp.incgo {\n        throw(\"schedule: in cgo\")\n    }\n\ntop:\n    pp := mp.p.ptr()\n    pp.preempt = false\n\n    // Safety check: if we are spinning, the run queue should be empty.\n    // Check this before calling checkTimers, as that might call\n    // goready to put a ready goroutine on the local run queue.\n    if mp.spinning && (pp.runnext != 0 || pp.runqhead != pp.runqtail) {\n        throw(\"schedule: spinning with local work\")\n    }\n    // 找到一个可运行的goroutine\n    gp, inheritTime, tryWakeP := findRunnable() // blocks until work is available\n\n    // This thread is going to run a goroutine and is not spinning anymore,\n    // so if it was marked as spinning we need to reset it now and potentially\n    // start a new spinning M.\n    if mp.spinning {\n        resetspinning()\n    }\n\n    if sched.disable.user && !schedEnabled(gp) {\n        // Scheduling of this goroutine is disabled. Put it on\n        // the list of pending runnable goroutines for when we\n        // re-enable user scheduling and look again.\n        lock(&sched.lock)\n        if schedEnabled(gp) {\n            // Something re-enabled scheduling while we\n            // were acquiring the lock.\n            unlock(&sched.lock)\n        } else {\n            sched.disable.runnable.pushBack(gp)\n            sched.disable.n++\n            unlock(&sched.lock)\n            goto top\n        }\n    }\n\n    // If about to schedule a not-normal goroutine (a GCworker or tracereader),\n    // wake a P if there is one.\n    if tryWakeP {\n        wakep()\n    }\n    if gp.lockedm != 0 {\n        // Hands off own p to the locked m,\n        // then blocks waiting for a new p.\n        startlockedm(gp)\n        goto top\n    }\n    // 执行\n    execute(gp, inheritTime)\n}",
    "crumbs": [
      "基础篇",
      "go程序的启动过程"
    ]
  },
  {
    "objectID": "docs/go/basic/start-go.html#execute",
    "href": "docs/go/basic/start-go.html#execute",
    "title": "斯巴拉稀",
    "section": "11 execute",
    "text": "11 execute\n// Schedules gp to run on the current M.\n// If inheritTime is true, gp inherits the remaining time in the\n// current time slice. Otherwise, it starts a new time slice.\n// Never returns.\n//\n// Write barriers are allowed because this is called immediately after\n// acquiring a P in several places.\n//\n//go:yeswritebarrierrec\nfunc execute(gp *g, inheritTime bool) {\n    mp := getg().m\n\n    if goroutineProfile.active {\n        // Make sure that gp has had its stack written out to the goroutine\n        // profile, exactly as it was when the goroutine profiler first stopped\n        // the world.\n        tryRecordGoroutineProfile(gp, osyield)\n    }\n\n    // Assign gp.m before entering _Grunning so running Gs have an\n    // M.\n    mp.curg = gp\n    gp.m = mp\n    casgstatus(gp, _Grunnable, _Grunning)\n    gp.waitsince = 0\n    gp.preempt = false\n    gp.stackguard0 = gp.stack.lo + _StackGuard\n    if !inheritTime {\n        mp.p.ptr().schedtick++\n    }\n\n    // Check whether the profiler needs to be turned on or off.\n    hz := sched.profilehz\n    if mp.profilehz != hz {\n        setThreadCPUProfiler(hz)\n    }\n\n    if trace.enabled {\n        // GoSysExit has to happen when we have a P, but before GoStart.\n        // So we emit it here.\n        if gp.syscallsp != 0 && gp.sysblocktraced {\n            traceGoSysExit(gp.sysexitticks)\n        }\n        traceGoStart()\n    }\n\n    gogo(&gp.sched)\n}",
    "crumbs": [
      "基础篇",
      "go程序的启动过程"
    ]
  },
  {
    "objectID": "docs/go/basic/start-go.html#gogo",
    "href": "docs/go/basic/start-go.html#gogo",
    "title": "斯巴拉稀",
    "section": "12 gogo",
    "text": "12 gogo\n\n\nsrc/runtime/asm_amd64.s\n\n/*\n *  go-routine\n */\n\n// func gogo(buf *gobuf)\n// restore state from Gobuf; longjmp\nTEXT runtime·gogo(SB), NOSPLIT, $0-8\n    MOVQ    buf+0(FP), BX       // gobuf\n    MOVQ    gobuf_g(BX), DX\n    MOVQ    0(DX), CX       // make sure g != nil\n    JMP gogo&lt;&gt;(SB)\n\nTEXT gogo&lt;&gt;(SB), NOSPLIT, $0\n    get_tls(CX)\n    MOVQ    DX, g(CX)\n    MOVQ    DX, R14     // set the g register\n    MOVQ    gobuf_sp(BX), SP    // 将goroutine 结构中存的 自己的栈指针 设置到sp\n    MOVQ    gobuf_ret(BX), AX\n    MOVQ    gobuf_ctxt(BX), DX\n    MOVQ    gobuf_bp(BX), BP\n    MOVQ    $0, gobuf_sp(BX)    // clear to help garbage collector\n    MOVQ    $0, gobuf_ret(BX)\n    MOVQ    $0, gobuf_ctxt(BX)\n    MOVQ    $0, gobuf_bp(BX)\n    // 这个pc, 就是如果你cpu执行一段时间这个goroutine的代码后,切出, 后来又拿到cpu执行,可以知道执行到哪里了\n    MOVQ    gobuf_pc(BX), BX // goroutine中 下一个指令的地址\n    JMP BX  // 执行这个指令",
    "crumbs": [
      "基础篇",
      "go程序的启动过程"
    ]
  },
  {
    "objectID": "docs/go/basic/start-go.html#goexit",
    "href": "docs/go/basic/start-go.html#goexit",
    "title": "斯巴拉稀",
    "section": "13 goexit",
    "text": "13 goexit\n\n\nsrc/runtime/asm_amd64.s\n\n// The top-most function running on a goroutine\n// returns to goexit+PCQuantum.\nTEXT runtime·goexit(SB),NOSPLIT|TOPFRAME,$0-0\n    BYTE    $0x90   // NOP\n    CALL    runtime·goexit1(SB) // does not return\n    // traceback from goexit1 must hit code range of goexit\n    BYTE    $0x90   // NOP\n\n\n\nruntime/proc.go\n\n\nfunc goexit1() {\n    if raceenabled {\n        racegoend()\n    }\n    if trace.enabled {\n        traceGoEnd()\n    }\n    // 从当前的g 切换到g0的 栈, 然后执行该 goexit0 方法\n    mcall(goexit0)\n}\n\n// goexit continuation on g0.\n// 传递的是goroutine, goroutine运行完毕做哪些补充清理工作,修改状态等\nfunc goexit0(gp *g) {\n    mp := getg().m\n    pp := mp.p.ptr()\n\n    casgstatus(gp, _Grunning, _Gdead)\n    gcController.addScannableStack(pp, -int64(gp.stack.hi-gp.stack.lo))\n    if isSystemGoroutine(gp, false) {\n        sched.ngsys.Add(-1)\n    }\n    gp.m = nil\n    locked := gp.lockedm != 0\n    gp.lockedm = 0\n    mp.lockedg = 0\n    gp.preemptStop = false\n    gp.paniconfault = false\n    gp._defer = nil // should be true already but just in case.\n    gp._panic = nil // non-nil for Goexit during panic. points at stack-allocated data.\n    gp.writebuf = nil\n    gp.waitreason = waitReasonZero\n    gp.param = nil\n    gp.labels = nil\n    gp.timer = nil\n\n    if gcBlackenEnabled != 0 && gp.gcAssistBytes &gt; 0 {\n        // Flush assist credit to the global pool. This gives\n        // better information to pacing if the application is\n        // rapidly creating an exiting goroutines.\n        assistWorkPerByte := gcController.assistWorkPerByte.Load()\n        scanCredit := int64(assistWorkPerByte * float64(gp.gcAssistBytes))\n        gcController.bgScanCredit.Add(scanCredit)\n        gp.gcAssistBytes = 0\n    }\n\n    dropg()\n\n    if GOARCH == \"wasm\" { // no threads yet on wasm\n        gfput(pp, gp)\n        schedule() // never returns\n    }\n\n    if mp.lockedInt != 0 {\n        print(\"invalid m-&gt;lockedInt = \", mp.lockedInt, \"\\n\")\n        throw(\"internal lockOSThread error\")\n    }\n    gfput(pp, gp)\n    if locked {\n        // The goroutine may have locked this thread because\n        // it put it in an unusual kernel state. Kill it\n        // rather than returning it to the thread pool.\n\n        // Return to mstart, which will release the P and exit\n        // the thread.\n        if GOOS != \"plan9\" { // See golang.org/issue/22227.\n            gogo(&mp.g0.sched)\n        } else {\n            // Clear lockedExt on plan9 since we may end up re-using\n            // this thread.\n            mp.lockedExt = 0\n        }\n    }\n    // 最后重新开始调度, 选一个goroutine 来执行\n    schedule()\n}",
    "crumbs": [
      "基础篇",
      "go程序的启动过程"
    ]
  },
  {
    "objectID": "docs/go/basic/map.html",
    "href": "docs/go/basic/map.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "Caution\n\n\n\n源码方面看的是不支持泛型的版本. 未完待续…",
    "crumbs": [
      "基础篇",
      "Map"
    ]
  },
  {
    "objectID": "docs/go/basic/map.html#图书馆与map",
    "href": "docs/go/basic/map.html#图书馆与map",
    "title": "斯巴拉稀",
    "section": "1 图书馆与map",
    "text": "1 图书馆与map\n\n\n\n\n\n\n\n\nmap\n图书馆对应\n\n\n\n\n桶\n一个个分类不同的书架\n\n\n哈希算法\n你根据书名进行判断的判断方法,知道是哪个分类, 放到哪个书架上\n\n\n哈希冲突\n多本书,根据书名进行判断,都在同一个分类书架上,就依次放到书架上的空余位置即可  如果该书架满了,则需要新的同分类名的书架,将书放到这个新的书架上.\n\n\n读取数据\n你根据书名进行判断,知道是哪个分类书架,然后到该书架上 从左到右比对过去,比对书名(ISBN),找到并拿走\n\n\n写入数据\n你根据书名进行判断,知道是哪个分类书架,然后到该书架上 从左到右比对过去,比对书名(ISBN),如果有,则更换书,没有就放入最右边空余位置\n\n\n装载因子(元素个数/桶数量&lt;=6.5)\n很显然书架上的书越多,你找书就越慢, 如果每个书架上都只有一个本书, 那么你一定非常快就找到了.",
    "crumbs": [
      "基础篇",
      "Map"
    ]
  },
  {
    "objectID": "docs/go/basic/map.html#源码分析",
    "href": "docs/go/basic/map.html#源码分析",
    "title": "斯巴拉稀",
    "section": "2 源码分析",
    "text": "2 源码分析\n\n2.1 数据结构\nfunc main() {\n    a := make(map[int]string, 10)\n    fmt.Println(a)\n}\n\n\n\n\n\n\nTip\n\n\n\ngo tool compile -S main.go 查看汇编代码可以看到 runtime.makemap  容量小的话,可以看到runtime.makemap_small\n\n\nfunc makemap(t *maptype, hint int, h *hmap) *hmap {\n    mem, overflow := math.MulUintptr(uintptr(hint), t.bucket.size)\n    if overflow || mem &gt; maxAlloc {\n        hint = 0\n    }\n    if h == nil {\n        h = new(hmap)\n    }\n    h.hash0 = fastrand()\n    B := uint8(0)\n    for overLoadFactor(hint, B) {\n        B++\n    }\n    h.B = B\n\n    if h.B != 0 {\n        var nextOverflow *bmap\n        h.buckets, nextOverflow = makeBucketArray(t, h.B, nil)\n        if nextOverflow != nil {\n            h.extra = new(mapextra)\n            h.extra.nextOverflow = nextOverflow\n        }\n    }\n    return h\n}\n\nmap结构桶结构\n\n\n\n\nsrc/runtime/map.go\n\ntype hmap struct {\n    // map 中的元素个数，必须放在 struct 的第一个位置，\n    // 因为内置的 len 函数会通过unsafe.Pointer会从这里读取\n    count     int\n    flags     uint8\n    // bucket的数量是2^B, 最多可以放 loadFactor * 2^B 个元素，再多就要 hashGrow 了\n    // 装载因子 loadFactor= 元素个数/桶数量&lt;=6.5\n    B         uint8\n    //overflow 的 bucket 近似数\n    noverflow uint16\n    hash0     uint32 // hash seed\n    //2^B 大小的数组指针，如果 count == 0 的话，可能是 nil\n    buckets    unsafe.Pointer\n    // 扩容的时候，buckets 长度会是 oldbuckets 的两倍,只有在 growing 时候为空。\n    oldbuckets unsafe.Pointer\n    // 指示扩容进度，小于此地址的 buckets 迁移完成\n    nevacuate  uintptr // progress counter for evacuation (buckets less than this have been evacuated)\n    // 当 key 和 value 都可以 inline 的时候，就会用这个字段\n    extra *mapextra // optional fields\n}\n\n\n\n\n\nsrc/runtime/map.go\n\ntype bmap struct {\n    // 存储了键的哈希的高 8 位\n    tophash [bucketCnt]uint8\n}\n\n上面这个数据结构并不是 golang runtime 时的结构，在编译时候编译器会给它动态创建一个新的结构 因为哈希表中可能存储不同类型的键值对，而且 Go 语言也不支持泛型，所以键值对占据的内存空间大小只能在编译时进行推导\n// 每个 bucket 里面最多存储 8 个 key\ntype bmap struct {\n    topbits  [8]uint8 //key 计算出来的 hash 值的高 8 位\n    keys     [8]keytype\n    values   [8]valuetype\n    pad      uintptr\n    overflow uintptr\n}\n\n\n\n\n\n为什么 桶内的key和value 要这样设计? 我们以 map[int64]int8 为例来说明\n\n如果按照 key/value/key/value/… 这样的模式存储，由于内存对齐,在每一个 key/value 之后都要额外需要7个字节\nint64 8个字节 int8一个字节, 剩下的7个字节就浪费了. 因为接下来的key 8个字节你放不下\n而将所有的 key，value 分别绑定到一起，这种形式 key/key/…/value/value/…，则只需要在最后添加 pad\n\n每个 bucket 设计成最多只能放 8 个 key-value 对，如果有第 9 个 key-value 落入当前的 bucket，那就需要再构建一个 bucket ，通过 overflow 指针连接起来\n\n\n\n2.2 B值的计算\n\n2.2.1 源码解析\n\n\n这里我们创建10个容量的map\n\nfunc main() {\n    a := make(map[int]string, 10)\n    fmt.Println(a)\n}\n\n\nmakemap()中B值相关overLoadFactor()bucketShift()\n\n\nB := uint8(0)\n// hint 就是 10\n// 如果当前元素/桶数 超过了装载因子6.5 则说明桶数不够,需要增加,B++\nfor overLoadFactor(hint, B) {\n    B++\n}\n\n\n// 判断是否超过了装载因子\nfunc overLoadFactor(count int, B uint8) bool {\n    // bucketCntBits = 3\n    // bucketCnt     = 1 &lt;&lt; bucketCntBits  //1 左移3位 = 8\n    // 得出 bucketCnt = 8\n    // loadFactorNum = 13\n    // loadFactorDen = 2\n    // count&gt;bucketCnt 如果容量&gt; 一个桶能放的元素数\n    // 且 第一次循环, B=0, 10&gt;13*(1/2) 一个桶最多6.5 ,我们装载因为是6.5,超过了,说明需要扩容桶\n    // 则第二循环, B=1, bucketShift(B)= 1&lt;&lt;1=2 , 10&gt;13*(2/2) 不城里,退出循环了, 结果是B=1\n    return count &gt; bucketCnt && uintptr(count) &gt; loadFactorNum*(bucketShift(B)/loadFactorDen)\n}\n\n\nfunc bucketShift(b uint8) uintptr {\n    // Masking the shift amount allows overflow checks to be elided.\n    return uintptr(1) &lt;&lt; (b & (8*8 - 1))\n}\n\n\n\n\n\n2.2.2 代码验证\npackage main\nimport (\n    \"fmt\"\n    \"unsafe\"\n)\ntype MapStruct struct {\n    count int\n    flags uint8\n    B     uint8\n    noverflow  uint16\n    hash0      uint32\n    buckets    uintptr //unsafe.Pointer\n    oldbuckets unsafe.Pointer\n    nevacuate  uintptr\n    extra      uintptr\n}\nfunc main() {\n    m := make(map[int32]int32, 10)\n    // m 实际是个指针, 指向了真正的hmap\n    m[1] = 22\n    m[2] = 33\n    fmt.Println(len(m)) //2\n    hmapReal := *(**MapStruct)(unsafe.Pointer(&m))\n    fmt.Println(hmapReal.count, hmapReal.B) // 2 1\n    bks := hmapReal.buckets\n    for i := 0; i &lt; (1 &lt;&lt; hmapReal.B); i++ {\n        // bmap的size=88\n        kbase := bks + uintptr(i*88)\n        for j := 0; j &lt; 8; j++ {\n            fmt.Println(\"key=\", *(*int32)((unsafe.Pointer)(kbase + uintptr(8+j*4))))\n            fmt.Println(\"val=\", *(*int32)((unsafe.Pointer)(kbase + uintptr(8+8*4+j*4))))\n        }\n\n    }\n}\n\n\n\n2.3 访问\n\n2.3.1 for range 为啥是随机的\npackage main\n\nimport (\n    \"fmt\"\n)\nfunc main() {\n    m := make(map[int32]int32, 10)\n    m[1] = 22\n    m[2] = 33\n    m[3] = 44\n    m[4] = 55\n    m[5] = 66\n    for k, v := range m {\n        fmt.Println(k, v)\n    }\n}\n查看汇编 可以看到 写入map 的相关函数runtime.mapassign_fast32 range 的相关函数 runtime.mapiterinit\n\n\nmapiterinit()\n\nfunc mapiterinit(t *maptype, h *hmap, it *hiter) {\n    ...\n    ...\n    // decide where to start\n    r := uintptr(fastrand())\n    if h.B &gt; 31-bucketCntBits {\n        r += uintptr(fastrand()) &lt;&lt; 31\n    }\n    it.startBucket = r & bucketMask(h.B)\n    it.offset = uint8(r &gt;&gt; h.B & (bucketCnt - 1))\n\n    // iterator state\n    it.bucket = it.startBucket\n}\n\n\n\n\n2.4 扩容\n\n2.4.1 为什么需要扩容\n桶里key 多起来了,8个满了, 再overflow 整个几个. 你查询起来就慢了. 需要遍历桶里的元素, 这就是有装载因子的判断\n\n\n2.4.2 渐进式扩容",
    "crumbs": [
      "基础篇",
      "Map"
    ]
  },
  {
    "objectID": "docs/go/basic/quick-start.html",
    "href": "docs/go/basic/quick-start.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "Tip\n\n\n\n将github上的一个仓库作为你go项目的一个包来使用\n\n\n\n\n初始化go.mod\n\n# go1.16之前需要\ngo env -w GO111MODULE=on\n# 执行这个命令, 会在当前目录下生成一个 go.mod 文件\ngo mod init test\n\n\n\n查看go.mod\n\nmodule test\n\ngo 1.20\n\n\n\n添加一个包\n\ngo get github.com/pkg/errors\n\n在 go get 的时候如果不手动指定版本信息,会自动拉取最新的版本的包\n如果想要拉取指定版本可以通过 go get github.com/pkg/errors@v0.9.0 的方式\n\n@版本号 例如 @v0.9.0\n@分支名 例如 @master\n@commit tag 例如 @6cff360233dc4457f1536e4f3df4e4e740fd3410\n\n\n\n再看go.mod文件\n\nmodule test\n\ngo 1.20\n\nrequire (\n    github.com/pkg/errors v0.9.1 // indirect\n)\n\n// indirect 表示 这个包我们没有在代码中直接import 使用它, 大概是间接依赖的包, 比如 import A, 然后A里有import B, B就是我们间接依赖的包\npackage main\n\nimport \"github.com/pkg/errors\"\n\nfunc main() {\n    err := errors.New(\"abc\")\n    println(err)\n}\n当你在main.go 里使用了我们前面go get的包errors, 再去看下 go.mod 会看到提示说 should be  direct\n# 会下载依赖的包,并清理哪些不再需要的依赖,整理go.mod,\n# 这里会将 // indirect 取消掉了,意思就是直接\ngo mod tidy # 你应该每次下载包,用这个命令来\n# 将包缓存到本地 (你项目目录下会生成一个vendor 目录)\ngo mod vendor\n# 使用本地的包来编译, 这样不会去远程拉取\ngo build -mod vendor\n# 仓库作者修改了地址, 你可以修改\n# 这样你代码中 import \"github.com/Sirupsen/logrus\" 实际会使用替换后的\ngo mod edit -replace  github.com/Sirupsen/logrus@v1.4.1=github.com/sirupsen/logrus@v1.4.1",
    "crumbs": [
      "基础篇",
      "快速入门"
    ]
  },
  {
    "objectID": "docs/go/basic/quick-start.html#go-mod包管理工具",
    "href": "docs/go/basic/quick-start.html#go-mod包管理工具",
    "title": "斯巴拉稀",
    "section": "",
    "text": "Tip\n\n\n\n将github上的一个仓库作为你go项目的一个包来使用\n\n\n\n\n初始化go.mod\n\n# go1.16之前需要\ngo env -w GO111MODULE=on\n# 执行这个命令, 会在当前目录下生成一个 go.mod 文件\ngo mod init test\n\n\n\n查看go.mod\n\nmodule test\n\ngo 1.20\n\n\n\n添加一个包\n\ngo get github.com/pkg/errors\n\n在 go get 的时候如果不手动指定版本信息,会自动拉取最新的版本的包\n如果想要拉取指定版本可以通过 go get github.com/pkg/errors@v0.9.0 的方式\n\n@版本号 例如 @v0.9.0\n@分支名 例如 @master\n@commit tag 例如 @6cff360233dc4457f1536e4f3df4e4e740fd3410\n\n\n\n再看go.mod文件\n\nmodule test\n\ngo 1.20\n\nrequire (\n    github.com/pkg/errors v0.9.1 // indirect\n)\n\n// indirect 表示 这个包我们没有在代码中直接import 使用它, 大概是间接依赖的包, 比如 import A, 然后A里有import B, B就是我们间接依赖的包\npackage main\n\nimport \"github.com/pkg/errors\"\n\nfunc main() {\n    err := errors.New(\"abc\")\n    println(err)\n}\n当你在main.go 里使用了我们前面go get的包errors, 再去看下 go.mod 会看到提示说 should be  direct\n# 会下载依赖的包,并清理哪些不再需要的依赖,整理go.mod,\n# 这里会将 // indirect 取消掉了,意思就是直接\ngo mod tidy # 你应该每次下载包,用这个命令来\n# 将包缓存到本地 (你项目目录下会生成一个vendor 目录)\ngo mod vendor\n# 使用本地的包来编译, 这样不会去远程拉取\ngo build -mod vendor\n# 仓库作者修改了地址, 你可以修改\n# 这样你代码中 import \"github.com/Sirupsen/logrus\" 实际会使用替换后的\ngo mod edit -replace  github.com/Sirupsen/logrus@v1.4.1=github.com/sirupsen/logrus@v1.4.1",
    "crumbs": [
      "基础篇",
      "快速入门"
    ]
  },
  {
    "objectID": "docs/go/basic/quick-start.html#编译运行",
    "href": "docs/go/basic/quick-start.html#编译运行",
    "title": "斯巴拉稀",
    "section": "2 编译运行",
    "text": "2 编译运行\n\n\nmain.go\n\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    fmt.Println(\"hello\")\n}\n\n\n\n简单运行\n\ngo run main.go\n\n\n\n查看编译过程\n\ngo mod init test\ngo build -n\n\n    # import config\n    packagefile fmt=...\n    # 一个go程序会将runtime 编译进去.\n    packagefile runtime=...\n    # 编译\n    /usr/local/go/pkg/tool/linux_amd64/compile -o\n    # 要link 的文件清单\n    cat &gt;$WORK/b001/importcfg.link ...\n    # link 操作\n    /usr/local/go/pkg/tool/linux_amd64/link -o $WORK/b001/exe/a.out\n    /usr/local/go/pkg/tool/linux_amd64/buildid -w $WORK/b001/exe/a.out\n    # 重命名\n    mv $WORK/b001/exe/a.out test",
    "crumbs": [
      "基础篇",
      "快速入门"
    ]
  },
  {
    "objectID": "docs/go/basic/quick-start.html#基本数据类型",
    "href": "docs/go/basic/quick-start.html#基本数据类型",
    "title": "斯巴拉稀",
    "section": "3 基本数据类型",
    "text": "3 基本数据类型\n\n常量生成器iota\n\n\n// 每当遇到const, 就会重置为0\nconst c1 = iota // 0\nconst (\n    // const() 中每增加一行声明就会将iota计数 +1\n    a  = \"hello\" // hello\n    b            // hello\n    c  = 9\n    d         // 9  使用与它最近的表达式 这里是上面的 9\n    e         // 9\n    a1 = iota // 5  前面a 那里是0\n    a2        //6\n    _         //7\n    a4        //8\n    b1 = iota //9\n    b2        // 10\n)\n\nconst (\n    d1 = iota * 2 // 0\n    d2            //2\n    d3 = iota * 3 // 6\n    d4            //9  使用最近的 表达式 iota*3\n)\n\nconst (\n    e1 = 1 &lt;&lt; iota //1\n    e2             //2  左移 iota=1 位\n    e3             //4  左移 iota=2 位\n)\nconst pi=3.14\nfunc main() {\n    // # 常量是无法做 取址操作的,会报错\n    println(&pi)\n}\n\n\n\n\n\n\nTip\n\n\n\nconst申明的常量,是在编译期间就已经确定的固定值,你无法修改,所以你取址操作无意义",
    "crumbs": [
      "基础篇",
      "快速入门"
    ]
  },
  {
    "objectID": "docs/go/basic/quick-start.html#空结构体struct",
    "href": "docs/go/basic/quick-start.html#空结构体struct",
    "title": "斯巴拉稀",
    "section": "4 空结构体struct",
    "text": "4 空结构体struct\n\n\n\n\n\n\nImportant\n\n\n\n不占用内存, 经常用, 用来节约内存\n\n\n\npackage main\n\nimport (\n    \"fmt\"\n    \"unsafe\"\n)\n\nfunc main() {\n    a := struct{}{}\n    b := struct{}{}\n    fmt.Println(unsafe.Sizeof(a), unsafe.Sizeof(b)) //0\n    // 相同\n    fmt.Printf(\"%p,%p\\n\", &a, &b)\n    d := uintptr(unsafe.Pointer(&a))\n    fmt.Println(d)\n\n    cat := Cat{\n        Name:   \"abc\",\n        Ag:     struct{}{},\n        Age:    11,\n        Weight: 110,\n    }\n    // 我们发现 结果是32 , 在结构体里成员类型是空 struct{} ,也是不占用空间的\n    fmt.Println(unsafe.Sizeof(cat))\n    // 但是 和上面的 a, b 的 空结构体地址不一样.\n    // &cat.Ag, &cat.Age 地址一样\n    fmt.Printf(\"%p,%p,%p,%p\\n\", &cat.Name, &cat.Ag, &cat.Age, &cat.Weight)\n    dog := Dog{\n        Ag:     struct{}{},\n        Name:   \"abc\",\n        Age:    11,\n        Weight: 110,\n    }\n    fmt.Println(unsafe.Sizeof(dog)) // 32 不占用空间\n    // &dog.Ag, &dog.Name 地址一样\n    fmt.Printf(\"%p,%p,%p,%p\\n\", &dog.Ag, &dog.Name, &dog.Age, &dog.Weight)\n    // 放在结构体最后\n    h1 := struct {\n        b byte\n        s struct{}\n    }{}\n    fmt.Printf(\"%p,%p\\n\", &h1.b, &h1.s)\n    // 2 个字节, 也就是说填充了一个字节\n    // 试着 将 b 弄成 int16 int32 int64 看看\n    fmt.Println(unsafe.Sizeof(h1))\n}\ntype Cat struct {\n    Name   string //16 byte\n    Ag     struct{}\n    Age    int64 // 8\n    Weight int64 // 8\n}\ntype Dog struct {\n    Ag     struct{}\n    Name   string //16 byte\n    Age    int64  // 8\n    Weight int64  // 8\n}\n\n\n\n底层原理\n\nfunc mallocgc(size uintptr, typ *_type, needzero bool) unsafe.Pointer {\n    // ....\n    if size == 0 {\n        // 统一返回全局变量 zerobase 的地址\n        return unsafe.Pointer(&zerobase)\n    }\n}\n// base address for all 0-byte allocations\nvar zerobase uintptr\n\n\n\ndlv调试看看\n\nb main.main\nc\nb 16\nc\np d\np uintptr(&runtime.zerobase) # 与上面值一样",
    "crumbs": [
      "基础篇",
      "快速入门"
    ]
  },
  {
    "objectID": "docs/go/basic/quick-start.html#nil",
    "href": "docs/go/basic/quick-start.html#nil",
    "title": "斯巴拉稀",
    "section": "5 nil",
    "text": "5 nil\n\n\n\n\n\n\nTip\n\n\n\nnil 是一个变量\n\n\n\n\n\n源码中,请看看注释\n\n// nil is zero value for a pointer, channel, func, interface, map, or slice type.\n// Type must be a pointer, channel, func, interface, map, or slice type\nvar nil Type\n\n    var a *int\n    println(a == nil) //true\n    var b chan int\n    println(b == nil) //true\n    var c func() int\n    println(c == nil) //true\n    var d interface{}\n    println(d == nil) //true\n    d = b             // 看看接口的数据结构就知道了\n    println(d == nil) //false\n    var e map[string]int\n    println(e == nil) //true\n    var f []int\n    println(f == nil) //true",
    "crumbs": [
      "基础篇",
      "快速入门"
    ]
  },
  {
    "objectID": "docs/go/basic/quick-start.html#make-new",
    "href": "docs/go/basic/quick-start.html#make-new",
    "title": "斯巴拉稀",
    "section": "6 make && new",
    "text": "6 make && new\n// 只用来创建slice，map和channel\nfunc make(t Type, size ...IntegerType) Type\n\n// 返回的是指针, 指针指向的地址可能在栈上也可能在堆上\nfunc new(Type) *Type",
    "crumbs": [
      "基础篇",
      "快速入门"
    ]
  },
  {
    "objectID": "docs/go/basic/panic-recover.html",
    "href": "docs/go/basic/panic-recover.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "Tip\n\n\n\npanic后会执行当前协程(main也是协程)的defer",
    "crumbs": [
      "基础篇",
      "panic-recover"
    ]
  },
  {
    "objectID": "docs/go/basic/panic-recover.html#底层原理",
    "href": "docs/go/basic/panic-recover.html#底层原理",
    "title": "斯巴拉稀",
    "section": "1 底层原理",
    "text": "1 底层原理\nfunc gopanic(e any) {\n    gp := getg()  // 获取当前协程\n    // ...\n    for {\n        d := gp._defer\n        if d == nil {\n            break\n        }\n        // ...\n        if p.recovered {\n            // ...\n        }\n    }",
    "crumbs": [
      "基础篇",
      "panic-recover"
    ]
  },
  {
    "objectID": "docs/go/basic/mem.html",
    "href": "docs/go/basic/mem.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "package main\n\nvar global_init_xyz int64 = 3\nvar global_noinit_xyz int64\nvar global_init_strxyz string = \"hello\"\nvar global_noinit_strxyz string\n\nconst global_xyz int64 = 314  // 常量\nfunc main() {\n    var local_xyz int64 = 2\n    println(&local_xyz)\n    println(&global_init_xyz)\n    println(&global_noinit_xyz)\n    println(&global_init_strxyz)\n    println(&global_noinit_strxyz)\n    println(global_xyz)\n}\n\nobjdump查看各个段go tool compile\n\n\ngo build -o main -gcflags \"-N -l\" main.go\n# size 可执行文件\n# 查看程序内存的代码段 数据段等\n# 最好使用c程序来 看各个变量在哪个段\nsize main\n# dec = text+data+bss\n# hex 是dec的16进制数\n    text       data     bss     dec     hex filename\n    774543    13424  202000  989967   f1b0f main\nobjdump -t main|grep xyz\n    00000000004c0170 g     O .noptrdata 0000000000000008 main.global_init_xyz\n    00000000004f10a0 g     O .noptrbss  0000000000000008 main.global_noinit_xyz\n    00000000004c12e0 g     O .data  0000000000000010 main.global_init_strxyz\n    00000000004c35b0 g     O .bss   0000000000000010 main.global_noinit_strxyz\nobjdump -t main|grep string\n    0000000000466220 l     O .rodata    0000000000000000 go:string.*\n\n\n\n\ngo tool compile -S -N -l main.go 查看\n\ngo:string.\"hello\" SRODATA dupok size=5\n0x0000 68 65 6c 6c 6f                                   hello\n\nmain.global_init_xyz SNOPTRDATA size=8\nmain.global_noinit_xyz SNOPTRBSS size=8\nmain.global_init_strxyz SDATA size=16\nmain.global_noinit_strxyz SBSS size=16\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\n字符串 字面量 hello这种是在只读的内存区的. 定义的常量 global_xyz ,在汇编中可能是以 MOVL    $314, AX 这种形式来操作的,并不存在只读区,具体情况具体分析 可以关注到go里有 noptrdata noptrbss这种 无指针的 这种区\n\n\n\n\n\n Back to top",
    "crumbs": [
      "基础篇",
      "程序的内存分布"
    ]
  },
  {
    "objectID": "docs/go/basic/reflect.html",
    "href": "docs/go/basic/reflect.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "Tip\n\n\n\n建议先看下接口章节",
    "crumbs": [
      "基础篇",
      "反射"
    ]
  },
  {
    "objectID": "docs/go/basic/reflect.html#元数据",
    "href": "docs/go/basic/reflect.html#元数据",
    "title": "斯巴拉稀",
    "section": "1 元数据",
    "text": "1 元数据\n\n\n\n\n\n\n什么是元数据?\n\n\n\n是描述数据的数据 比如一个结构体对象是个数据, 它是什么类型,这个类型就是用来描述这个它自己的一种数据 这个结构体对象的值,比如 Dog{Name:“tom”} tom 这种就是它的值, 它显然也是描述该结构体的一种数据 我们只要有了一个数据的类型和值, 那么我们就知道了该数据的全部信息",
    "crumbs": [
      "基础篇",
      "反射"
    ]
  },
  {
    "objectID": "docs/go/basic/reflect.html#三定律",
    "href": "docs/go/basic/reflect.html#三定律",
    "title": "斯巴拉稀",
    "section": "2 三定律",
    "text": "2 三定律\n\n2.1 接口类型变量转换为反射对象\n\n2.1.1 类型 reflect.Type\n\n\n\n\n\n\nTip\n\n\n\n\n是接口,用于获取元数据 : “类型”信息\nreflect.TypeOf() 对象转换为Type接口的方法\n\n\n\n\n\nTypeOf()结构体和结构体指针的反射\n\n\n\n\n\n\n\n\n重要\n\n\n\n\n从源码看, 刚好和我们之前讲到的接口与元数据将变量转为接口类型,就可以获取它的元数据的推断一致\n后面比如.Field(0) 这类操作的底层与 接口章节的代码验证结构 原理一致\n\n\n\nfunc TypeOf(i any) Type {\n    eface := *(*emptyInterface)(unsafe.Pointer(&i))\n    return toType(eface.typ)\n}\n\n\npackage test\n\nimport (\n    \"fmt\"\n    \"reflect\"\n    \"testing\"\n)\ntype Dog struct {\n    Age  int\n    name string\n}\n\nfunc (d Dog) shout() {\n    println(\"wang ...\")\n}\nfunc (d Dog) Show() {\n    println(\"show ...\")\n}\nfunc (d *Dog) SetName(name string) {\n    d.name = name\n}\n\n结构体 反射结构体指针 反射\n\n\nfunc TestA(t *testing.T) {\n    d := Dog{11, \"tom\"}\n    typ := reflect.TypeOf(d)\n    fmt.Println(typ.Name(), typ.Kind())\n    if typ.Kind() == reflect.Struct {\n        // 字段\n        numField := typ.NumField()\n        for i := 0; i &lt; numField; i++ {\n            // 可以获取 private 字段 信息\n            fmt.Println(typ.Field(i).Name, \"是否公开:\", typ.Field(i).IsExported())\n        }\n        // 方法\n        numMethod := typ.NumMethod()\n        fmt.Println(\"方法个数:\", numMethod) //1\n        for i := 0; i &lt; numMethod; i++ {\n            // 只能获取public 方法 ,Show\n            fmt.Println(typ.Method(i).Name)\n        }\n    }\n}\n\n\nfunc TestA(t *testing.T) {\n    ptrD := &Dog{11, \"tom\"}\n    ptrTyp := reflect.TypeOf(ptrD)\n    // kind 是ptr指针\n    fmt.Println(ptrTyp.Name(), ptrTyp.Kind())\n    // 方法\n    numMethod := ptrTyp.NumMethod()\n    fmt.Println(\"方法个数:\", numMethod) // 2\n    for i := 0; i &lt; numMethod; i++ {\n        // SetName  Show (前面说过编译器会默认生成一个对应的 *Dog 为接受者的方法)\n        fmt.Println(ptrTyp.Method(i).Name)\n    }\n    fmt.Println(ptrTyp.Elem().Kind()) // struct\n}\n\n\n\n\n\n\n\n\n2.1.2 值 reflect.Value\n\n\n\n\n\n\nTip\n\n\n\n\n是结构体,用于获取元数据: “值”信息\nreflect.ValueOf() 对象转换为Value结构体的方法\n\n\n\n\n\n结构体与结构体指针 值的反射\n\n\npackage test\n\nimport (\n    \"fmt\"\n    \"reflect\"\n    \"testing\"\n)\ntype Dog struct {\n    Age  int\n    name string\n}\n\nfunc (d Dog) shout() {\n    println(\"wang ...\")\n}\nfunc (d Dog) Show() {\n    println(\"show ...\")\n}\nfunc (d *Dog) SetName(name string) {\n    d.name = name\n}\n\n结构体反射结构体指针\n\n\nfunc TestA(t *testing.T) {\n    d := Dog{11, \"tom\"}\n    val := reflect.ValueOf(d)\n    typFromVal := val.Type()\n    numField := val.NumField()\n    for i := 0; i &lt; numField; i++ {\n        field := val.Field(i)\n        typField := typFromVal.Field(i)\n        if typField.IsExported() {\n            // 私有的字段无法 获取它的值的\n            // 值无法修改 ,因为 方法是值转递,无意义,指针的话就可以了\n            fmt.Println(field.Interface(), field.CanSet())\n\n        } else {\n            fmt.Println(typField.Name)\n        }\n    }\n}\n\n\nfunc TestA(t *testing.T) {\n    ptrD := &Dog{11, \"tom\"}\n    ptrVal := reflect.ValueOf(ptrD)\n    val = ptrVal.Elem()\n    typFromVal = val.Type()\n    numField = val.NumField()\n    for i := 0; i &lt; numField; i++ {\n        field := val.Field(i)\n        typField := typFromVal.Field(i)\n        if typField.IsExported() {\n            fmt.Println(field.Interface(), field.CanSet())\n            field.SetInt(3)\n            fmt.Println(ptrD.Age)\n            // 或\n            field.Set(reflect.ValueOf(5))\n            fmt.Println(ptrD.Age)\n        } else {\n            fmt.Println(typField.Name)\n        }\n    }\n    fmt.Println(ptrD.Age)\n}\n\n\n\n\n\n\n\n\n\n2.2 反射对象转换为接口类型变量\n\n\n\n\n\n\nreflect.Interface()\n\n\n\n转为接口类型的变量, 然后可通过类型断言等转为原来的类型\n\n\n\n\n2.3 可变性",
    "crumbs": [
      "基础篇",
      "反射"
    ]
  },
  {
    "objectID": "docs/go/basic/reflect.html#基础操作",
    "href": "docs/go/basic/reflect.html#基础操作",
    "title": "斯巴拉稀",
    "section": "3 基础操作",
    "text": "3 基础操作\ntype Dog struct {\n    Age  int\n    Name string\n}\nfunc (d Dog) SetName(name string) {\n    d.Name = name\n}\nfunc TestReflect(t *testing.T) {\n    d := &Dog{Age: 2, Name: \"ff\"}\n    dT := reflect.TypeOf(d)\n    for i := 0; i &lt; dT.NumMethod(); i++ {\n        // 打印方法\n        fmt.Println(dT.Method(i).Name, \"==\", dT.Method(i).Type, \"==\", dT.Method(i).Type.Kind())\n    }\n\n    vv := reflect.ValueOf(d)\n    args := []reflect.Value{reflect.ValueOf(\"tom\")}\n    // 调用方法\n    vv.MethodByName(dT.Method(0).Name).Call(args)\n    fmt.Println(d.Name)\n}",
    "crumbs": [
      "基础篇",
      "反射"
    ]
  },
  {
    "objectID": "docs/go/basic/defer.html",
    "href": "docs/go/basic/defer.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "Tip\n\n\n\n常用于关闭资源,先进后执行",
    "crumbs": [
      "基础篇",
      "defer"
    ]
  },
  {
    "objectID": "docs/go/basic/defer.html#例子分析",
    "href": "docs/go/basic/defer.html#例子分析",
    "title": "斯巴拉稀",
    "section": "1 例子分析",
    "text": "1 例子分析\n\n1.1 例子1\nfunc TestDefer(t *testing.T) {\n    fmt.Println(111)\n    // 先进后执行\n    defer func() {\n        fmt.Println(333)\n    }()\n    {\n        // 代码块中的defer 也是在函数返回前执行\n        defer func() {\n            fmt.Println(\"代码块中的defer\")\n        }()\n        fmt.Println(\"代码块执行完毕\")\n    }\n\n    defer func() {\n        fmt.Println(444)\n    }()\n    fmt.Println(222)\n}\n\n\n执行结果\n\n111\n代码块执行完毕\n222\n444\n代码块中的defer\n333\n\n\n\n1.2 例子2\n\n\n\nOS\ngo version\n\n\n\n\nUbuntu 20.04.3 LTS\ngo1.20.4\n\n\n\n\n匿名返回值有名返回值\n\n\npackage main\n\nfunc defer1() int {\n    i := 2\n    defer func() {\n        i = 3\n    }()\n    return i\n}\nfunc main() {\n    ret := defer1()\n    // 结果是2\n    println(ret)\n}\n\n\npackage main\n\nfunc defer1() (i int) {\n    i = 2\n    defer func() {\n        i = 3\n    }()\n    return i\n}\nfunc main() {\n    ret := defer1()\n    // 结果是3\n    println(ret)\n}\n\n\n\ngo tool compile -S -N -l main.go\n\n汇编代码使用的是go 1.15.4生成的, 省略部分.\n\n匿名返回值有名返回值\n\n\n\n\"\".defer1 STEXT size=155 args=0x8 locals=0x68\n    0x0000 00000 (main.go:3)    TEXT    \"\".defer1(SB), ABIInternal, $104-8\n    0x0013 00019 (main.go:3)    SUBQ    $104, SP\n    0x0017 00023 (main.go:3)    MOVQ    BP, 96(SP)\n    0x001c 00028 (main.go:3)    LEAQ    96(SP), BP\n    # 返回值 r0\n    0x0021 00033 (main.go:3)    MOVQ    $0, \"\".~r0+112(SP)\n    # i\n    0x002a 00042 (main.go:4)    MOVQ    $2, \"\".i+8(SP)\n    0x0033 00051 (main.go:5)    MOVL    $8, \"\"..autotmp_3+16(SP)\n    0x003b 00059 (main.go:5)    LEAQ    \"\".defer1.func1·f(SB), AX\n    0x0042 00066 (main.go:5)    MOVQ    AX, \"\"..autotmp_3+40(SP)\n    0x0047 00071 (main.go:5)    LEAQ    \"\".i+8(SP), AX\n    0x004c 00076 (main.go:5)    MOVQ    AX, \"\"..autotmp_3+88(SP)\n    0x0051 00081 (main.go:5)    LEAQ    \"\"..autotmp_3+16(SP), AX\n    0x0056 00086 (main.go:5)    MOVQ    AX, (SP)\n    0x005a 00090 (main.go:5)    CALL    runtime.deferprocStack(SB)\n    0x005f 00095 (main.go:5)    NOP\n    0x0060 00096 (main.go:5)    TESTL   AX, AX\n    0x0062 00098 (main.go:5)    JNE 129\n    0x0064 00100 (main.go:5)    JMP 102\n    0x0066 00102 (main.go:9)    MOVQ    \"\".i+8(SP), AX\n    # i 附给 返回值\n    0x006b 00107 (main.go:9)    MOVQ    AX, \"\".~r0+112(SP)\n    0x0070 00112 (main.go:9)    XCHGL   AX, AX\n    0x0071 00113 (main.go:9)    CALL    runtime.deferreturn(SB)\n\"\".defer1.func1 STEXT nosplit size=13 args=0x8 locals=0x0\n    0x0000 00000 (main.go:5)    TEXT    \"\".defer1.func1(SB), NOSPLIT|ABIInternal, $0-8\n    # i的地址 给AX\n    0x0000 00000 (main.go:6)    MOVQ    \"\".&i+8(SP), AX\n    # 赋值3 给 i\n    0x0005 00005 (main.go:6)    MOVQ    $3, (AX)\n\"\".main STEXT size=98 args=0x0 locals=0x18\n    0x0000 00000 (main.go:11)   TEXT    \"\".main(SB), ABIInternal, $24-0\n    0x000f 00015 (main.go:11)   SUBQ    $24, SP\n    0x0013 00019 (main.go:11)   MOVQ    BP, 16(SP)\n    0x0018 00024 (main.go:11)   LEAQ    16(SP), BP\n    0x0020 00032 (main.go:12)   CALL    \"\".defer1(SB)\n    # (SP) 就是 r0\n    0x0025 00037 (main.go:12)   MOVQ    (SP), AX\n    # 赋值给 ret\n    0x0029 00041 (main.go:12)   MOVQ    AX, \"\".ret+8(SP)\n    0x002e 00046 (main.go:13)   CALL    runtime.printlock(SB)\n    0x0033 00051 (main.go:13)   MOVQ    \"\".ret+8(SP), AX\n    0x0038 00056 (main.go:13)   MOVQ    AX, (SP)\n\n\n\n\"\".defer1 STEXT size=140 args=0x8 locals=0x60\n    0x0000 00000 (main.go:3)    TEXT    \"\".defer1(SB), ABIInternal, $96-8\n    0x000f 00015 (main.go:3)    SUBQ    $96, SP\n    0x0013 00019 (main.go:3)    MOVQ    BP, 88(SP)\n    0x0018 00024 (main.go:3)    LEAQ    88(SP), BP\n    # i 赋值\n    0x001d 00029 (main.go:3)    MOVQ    $0, \"\".i+104(SP)\n    0x0026 00038 (main.go:4)    MOVQ    $2, \"\".i+104(SP)\n    0x002f 00047 (main.go:5)    MOVL    $8, \"\"..autotmp_2+8(SP)\n    0x0037 00055 (main.go:5)    LEAQ    \"\".defer1.func1·f(SB), AX\n    0x003e 00062 (main.go:5)    MOVQ    AX, \"\"..autotmp_2+32(SP)\n    0x0043 00067 (main.go:5)    LEAQ    \"\".i+104(SP), AX\n    0x0048 00072 (main.go:5)    MOVQ    AX, \"\"..autotmp_2+80(SP)\n    0x004d 00077 (main.go:5)    LEAQ    \"\"..autotmp_2+8(SP), AX\n    0x0052 00082 (main.go:5)    MOVQ    AX, (SP)\n    0x0056 00086 (main.go:5)    PCDATA  $1, $0\n    0x0056 00086 (main.go:5)    CALL    runtime.deferprocStack(SB)\n    0x005b 00091 (main.go:5)    TESTL   AX, AX\n    0x005d 00093 (main.go:5)    JNE 114\n    0x005f 00095 (main.go:5)    NOP\n    0x0060 00096 (main.go:5)    JMP 98\n    0x0062 00098 (main.go:9)    XCHGL   AX, AX\n    0x0063 00099 (main.go:9)    CALL    runtime.deferreturn(SB)\n\"\".defer1.func1 STEXT nosplit size=13 args=0x8 locals=0x0\n    0x0000 00000 (main.go:5)    TEXT    \"\".defer1.func1(SB), NOSPLIT|ABIInternal, $0-8\n    # i的地址 给AX\n    0x0000 00000 (main.go:6)    MOVQ    \"\".&i+8(SP), AX\n    # 赋值3 给 i\n    0x0005 00005 (main.go:6)    MOVQ    $3, (AX)\n\"\".main STEXT size=98 args=0x0 locals=0x18\n    0x0000 00000 (main.go:11)   TEXT    \"\".main(SB), ABIInternal, $24-0\n    0x000f 00015 (main.go:11)   SUBQ    $24, SP\n    0x0013 00019 (main.go:11)   MOVQ    BP, 16(SP)\n    0x0018 00024 (main.go:11)   LEAQ    16(SP), BP\n    0x0020 00032 (main.go:12)   CALL    \"\".defer1(SB)\n    # (SP) 就是 返回值也是 i\n    0x0025 00037 (main.go:12)   MOVQ    (SP), AX\n    # 赋值给 ret\n    0x0029 00041 (main.go:12)   MOVQ    AX, \"\".ret+8(SP)\n    0x002e 00046 (main.go:13)   CALL    runtime.printlock(SB)\n    0x0033 00051 (main.go:13)   MOVQ    \"\".ret+8(SP), AX\n    0x0038 00056 (main.go:13)   MOVQ    AX, (SP)\n\n\n\n先设置返回值,然后执行defer ,最后将返回值复制给ret\n有名返回值的情况是 返回值与i变量是同一个内存位置, defer会修改这个i,就是修改了返回值,最后复制给ret,这样结果就是3了\n匿名返回值的情况是 会有一个临时变量(一块在main栈帧中的内存作为返回值),先设置返回值=2,接着执行defer,修改的是defer1函数栈帧中的 i变量,对返回值无影响\n\n\n1.3 例子3\npackage main\n\nfunc defer1() (i int) {\n    i = 2\n    defer func() {\n        // 之前例子的汇编可以看到,defer 里会用到 &i\n        // 实际上变成一个闭包了.\n        // 是1\n        println(\"defer1\", i)\n        i = 3\n    }()\n    // 设置返回值, i就是, 所以i=1\n    return 1\n}\nfunc main() {\n    // 3\n    println(defer1())\n}\n\n\n1.4 例子4\npackage main\n\nfunc add(i *int) int {\n    println(*i)\n    *i = *i + 1\n    return *i\n}\n\nfunc main() {\n    var i int = 1\n    // 会执行它的参数 i变成2\n    defer println(\"defer:\", add(&i))\n    defer func() {\n        // 闭包了\n        // 使用了外部变量 打印5\n        println(i)\n    }()\n    // 2\n    println(\"before return: \", i)\n    i = 5\n    println(\"return\")\n}",
    "crumbs": [
      "基础篇",
      "defer"
    ]
  },
  {
    "objectID": "docs/go/basic/defer.html#底层原理",
    "href": "docs/go/basic/defer.html#底层原理",
    "title": "斯巴拉稀",
    "section": "2 底层原理",
    "text": "2 底层原理",
    "crumbs": [
      "基础篇",
      "defer"
    ]
  },
  {
    "objectID": "docs/go/basic/pragma-directives.html",
    "href": "docs/go/basic/pragma-directives.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "Tip\n\n\n\n\n编译指示一种语言结构,它指示编译器应该如何处理其输入\ngo中这样的注释 //go:(注释//与go没有空格) 就是 Go 语言编译指示的实现方式",
    "crumbs": [
      "基础篇",
      "编译指示"
    ]
  },
  {
    "objectID": "docs/go/basic/pragma-directives.html#gonoinline",
    "href": "docs/go/basic/pragma-directives.html#gonoinline",
    "title": "斯巴拉稀",
    "section": "1 //go:noinline",
    "text": "1 //go:noinline\n\n\n\n\n\n\n什么是inline内联优化?\n\n\n\n\n函数调用需要将相关寄存器中的数据入栈来保存现场,函数调用完毕又需要弹栈来恢复现场,频繁的这样消耗时间,影响执行效率\n内联就是将调用的函数直接复制到调用处.这样就不用频繁入栈出栈,减少了开销,执行速度快了.\n内联的问题\n\n增加了代码的重复\n如果函数被很多很多其他地方调用,都内联优化了,如果本来一个地方被缓存,读取指令快,现在可能缓存没有命中,得重新读取再缓存,慢了\n\n\n\n\n\n\n内联优化对比\n\nfunc show(){\n    fmt.Println(\"hello\")\n}\nfunc test(){\n    show()\n}\n// ==&gt; 内联优化后\nfunc show(){\n    fmt.Println(\"hello\")\n}\nfunc test(){\n    // 直接复制到调用处\n    fmt.Println(\"hello\")\n}\n\n\n\n\n\n\n\nTip\n\n\n\n\n//go:noinline 顾名思义就是禁止内联优化,通常我们需要调式的时候用\n后面必须跟着 func 的申明\n\n\n\npackage main\n\n// 哪个func 不想被内联优化, 就在哪个上面写\n//go:noinline\nfunc p() {\n    println(2)\n}\n\nfunc main() {\n    a := 1\n    println(a)\n    p()\n}\n# 代码中 写了 禁止内联, 查看汇编就可以不需要 -l\ngo tool compile -S  main.go |grep \"main.go:11\"",
    "crumbs": [
      "基础篇",
      "编译指示"
    ]
  },
  {
    "objectID": "docs/go/basic/pragma-directives.html#golinkname",
    "href": "docs/go/basic/pragma-directives.html#golinkname",
    "title": "斯巴拉稀",
    "section": "2 //go:linkname",
    "text": "2 //go:linkname\n\n\n\n\n\n\nTip\n\n\n\n\n当你想要使用别的包(自己写的包或者go源码的包都行)没有导出(私有)的变量和方法时\n//go:linkname localname [importpath.name]\n调试代码时可能会用到这类技术\n\n\n\n\n使用go源码中的包\n\nruntime.inheap 这个方法正常情况下我们是没法调用的\npackage main\n\nimport (\n    //  如果没有使用  也需要import \n    // _ \"unsafe\"\n    \"unsafe\"\n)\n\n// 表示 inheap 的真正实现是 runtime.inheap\n//\n//go:linkname inheap runtime.inheap\nfunc inheap(arg uintptr) bool  // 方法申明,去看 runtime.inheap 复制过来\nfunc main() {\n    var a int = 1\n    // false 表示在栈上\n    println(inheap(uintptr(unsafe.Pointer(&a))))\n}\n\n自己的包中的私有方法\n\n\n代码目录show.gomain.go\n\n\n.\n├── go.mod  # mod name  是test\n├── main.go\n├── pkg\n│   └── show.go\n\n\npackage pkg\n\nimport \"fmt\"\n\nfunc s() {\n    fmt.Println(11)\n}\n\n\npackage main\n\nimport (\n    _ \"test/pkg\"\n    _ \"unsafe\"\n)\n\nfunc main() {\n    show()\n}\n// 真正实现是test/pkg.s 函数\n//\n//go:linkname show test/pkg.s\nfunc show()",
    "crumbs": [
      "基础篇",
      "编译指示"
    ]
  },
  {
    "objectID": "docs/go/basic/escape.html",
    "href": "docs/go/basic/escape.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "Tip\n\n\n\n看过汇编后, 我们知道,在栈上的局部变量在函数返回后,会被释放,如果变量还会被引用到,那么就不能在栈上分配,编译器会将它设置为在堆上分配内存",
    "crumbs": [
      "基础篇",
      "逃逸分析"
    ]
  },
  {
    "objectID": "docs/go/basic/escape.html#分析方法",
    "href": "docs/go/basic/escape.html#分析方法",
    "title": "斯巴拉稀",
    "section": "1 分析方法",
    "text": "1 分析方法\n\n\n\n\n\n\n\nitem\ndescription\n\n\n\n\n-m\n打印逃逸分析信息\n\n\nxxx escapes to heap\n当前变量的一个副本拷贝在堆上进行分配\n\n\nmoved to heap: xxx\n表示变量自身在堆上进行分配\n\n\nleaking param content: xxx\n表示如果这个变量为指针的话，则是其指向的内容在堆上分配\n\n\n\npackage main\n\nimport (\n    \"unsafe\"\n)\n// 是否在堆中\n//\n//go:linkname inheap runtime.inheap\nfunc inheap(arg uintptr) bool\n\n// 是否在栈或堆中\n//\n//go:linkname inHeapOrStack runtime.inHeapOrStack\nfunc inHeapOrStack(b uintptr) bool\nfunc main() {\n    var a int = 1\n    // false 表示在栈上\n    println(inheap(uintptr(unsafe.Pointer(&a))))\n}\ngo run -gcflags \"-m -l\" main.go",
    "crumbs": [
      "基础篇",
      "逃逸分析"
    ]
  },
  {
    "objectID": "docs/go/basic/escape.html#例子",
    "href": "docs/go/basic/escape.html#例子",
    "title": "斯巴拉稀",
    "section": "2 例子",
    "text": "2 例子\n\n2.1 返回指针\npackage main\n\nfunc test() *int {\n    a := 66 // 逃逸到堆上\n    return &a\n}\n\nfunc main() {\n    println(test())\n}\ngo run -gcflags \"-m -l\" main.go\n    ./main.go:4:2: moved to heap: a\n    0xc00001c1a8",
    "crumbs": [
      "基础篇",
      "逃逸分析"
    ]
  },
  {
    "objectID": "docs/go/basic/string.html",
    "href": "docs/go/basic/string.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "首先我们知道在编译型语言中一个变量所占的内存必须是确定的\n\n\n编程语言中字符串都可以有类似这样的操作\n\nstr:=\"abc\"\nstr=\"hello\"\n\n从上面的代码我们做一些思考\n\n字符串变量指向的实际字符的内存内容是可变的\n如何知道字符串的长度\n\n实际存放字符的地方, 遇 “\\0” 截止?\n或设计上直接写明字符的字节长度\n\n实际字符串所在内存是否可以直接修改内容\n\n这个基于实际字符串放在内存的什么区域?\n\n字符串增长时(比如拼接)是怎么处理的\n\nstr:=\"abc\" 实际字符串所在位置是就分配3个字节\n增长时, 就需要重新分配内存,需要copy原先的字符串到新位置的操作\n如果你有很多次拼接,那么需要考虑性能, 用一些好的方式来拼接",
    "crumbs": [
      "基础篇",
      "字符串"
    ]
  },
  {
    "objectID": "docs/go/basic/string.html#如何设计字符串",
    "href": "docs/go/basic/string.html#如何设计字符串",
    "title": "斯巴拉稀",
    "section": "",
    "text": "首先我们知道在编译型语言中一个变量所占的内存必须是确定的\n\n\n编程语言中字符串都可以有类似这样的操作\n\nstr:=\"abc\"\nstr=\"hello\"\n\n从上面的代码我们做一些思考\n\n字符串变量指向的实际字符的内存内容是可变的\n如何知道字符串的长度\n\n实际存放字符的地方, 遇 “\\0” 截止?\n或设计上直接写明字符的字节长度\n\n实际字符串所在内存是否可以直接修改内容\n\n这个基于实际字符串放在内存的什么区域?\n\n字符串增长时(比如拼接)是怎么处理的\n\nstr:=\"abc\" 实际字符串所在位置是就分配3个字节\n增长时, 就需要重新分配内存,需要copy原先的字符串到新位置的操作\n如果你有很多次拼接,那么需要考虑性能, 用一些好的方式来拼接",
    "crumbs": [
      "基础篇",
      "字符串"
    ]
  },
  {
    "objectID": "docs/go/basic/string.html#数据结构",
    "href": "docs/go/basic/string.html#数据结构",
    "title": "斯巴拉稀",
    "section": "2 数据结构",
    "text": "2 数据结构\n\n\ngo的字符串的设计\n\ntype StringHeader struct {\n    // 指向实际字符串的地址 8字节\n    // 这个地址上是连续的内容空间来存放字符: 字节数组\n    Data uintptr\n    // 字符串的字节长度 8字节\n    Len  int\n}",
    "crumbs": [
      "基础篇",
      "字符串"
    ]
  },
  {
    "objectID": "docs/go/basic/string.html#字符串的定义",
    "href": "docs/go/basic/string.html#字符串的定义",
    "title": "斯巴拉稀",
    "section": "3 字符串的定义",
    "text": "3 字符串的定义\n可以先看看程序内存分布情况\n\n\n\n\n\n\nTip\n\n\n\n\n\n\n\nX=栈,Y=常量x=全局,y=常量X=栈,Y=堆X=堆,Y=常量x=栈,y=栈\n\n\nfunc TestString(t *testing.T) {\n    cd := 1\n    println(&cd)\n    a := \"abc我们\"\n    b := (*reflect.StringHeader)(unsafe.Pointer(&a))\n    // 字节大小16,  字符长度是9, 1个汉字占3个字节\n    println(unsafe.Sizeof(a), b.Len, b.Data)\n    println(&a, &b.Len, &b.Data)\n    fmt.Printf(\"0x%x\\n\", b.Data)\n    c := (*[3]int8)(unsafe.Pointer(b.Data))\n    // 97 98 99\n    println(c[0], c[1], c[2])\n    // c[0] = 'd' // 无法修改的,实际字符在内存的只读区\n\n    a2 := \"abc我们\"\n    b2 := (*reflect.StringHeader)(unsafe.Pointer(&a2))\n    // 我们发现, 实际字符串 和上面的变量a 的字符串 存放的位置是一样的\n    // 字符串字面量在常量区会重复使用, 因为是只读的,所以可以这样\n    println(b2.Data) // = b.Data\n}\n\n\nvar global_init_strxyz string = \"hello\"\n\nfunc TestString2(t *testing.T) {\n    b := (*reflect.StringHeader)(unsafe.Pointer(&global_init_strxyz))\n    // 0x1209c70 0x1209c78 0x1209c70\n    println(&global_init_strxyz, &b.Len, &b.Data)\n    fmt.Printf(\"0x%x\\n\", b.Data) //0x11293bd\n    c := (*[3]int8)(unsafe.Pointer(b.Data))\n    // 104 101 108\n    println(c[0], c[1], c[2])\n    // c[0] = 'd' // 无法修改的,实际字符在内存的只读区\n}\n\n\n//go:linkname inheap runtime.inheap\nfunc inheap(arg uintptr) bool\n\nfunc TestString4(t *testing.T) {\n    arr := [5]byte{'h', 'e', 'l', 'l', 'o'}\n    slc := arr[:]\n    fmt.Println(slc) // arr 逃逸到 堆中了\n    println(inheap(uintptr(unsafe.Pointer(&arr))))\n    // 直接将切片转为 字符串\n    b := *(*string)(unsafe.Pointer(&slc))\n    fmt.Println(b) // hello\n    slc[0] = 'w'\n    fmt.Println(b) // wello\n}\n\n\n//go:linkname inheap runtime.inheap\nfunc inheap(arg uintptr) bool\n\nfunc getString() *string {\n    r := \"hello\"\n    b := (*reflect.StringHeader)(unsafe.Pointer(&r))\n    println(b.Data)          // 0x1129A7D  常量区\n    println(&b.Len, &b.Data) //0xc00005e6a0  堆区\n    return &r\n}\nfunc TestString5(t *testing.T) {\n    s := getString()\n    println(s)\n    println(inheap(uintptr(unsafe.Pointer(s))))\n}\n\n\npackage main\n\nimport (\n    \"reflect\"\n    \"unsafe\"\n)\n\nfunc A(ptrArr *[5]byte) {\n    s := \"world\"\n    sStruct := (*reflect.StringHeader)(unsafe.Pointer(&s))\n    b := uintptr(unsafe.Pointer(ptrArr))\n    sStruct.Data = b\n    println(s)\n    ptrArr[0] = 'f'\n    println(s)\n}\n\nfunc main() {\n    arr := [5]byte{'h', 'e', 'l', 'l', 'o'}\n    x := 2\n    println(&arr, &x)\n    A(&arr)\n}\n汇编代码, 只列出一点,其他自行查看\n\n\nmain\n\nTEXT main.main(SB)\nfunc main() {\n0x105c906             4883ec30                SUBQ $0x30, SP\n0x105c90a             48896c2428              MOVQ BP, 0x28(SP)\n0x105c90f             488d6c2428              LEAQ 0x28(SP), BP\n        arr := [5]byte{'h', 'e', 'l', 'l', 'o'}\n0x105c914             c744240b68656c6c        MOVL $0x6c6c6568, 0xb(SP)\n0x105c91c             c644240f6f              MOVB $0x6f, 0xf(SP)\n        x := 2\n0x105c921             48c744241002000000      MOVQ $0x2, 0x10(SP)",
    "crumbs": [
      "基础篇",
      "字符串"
    ]
  },
  {
    "objectID": "docs/go/basic/string.html#字符串与字符切片的转换",
    "href": "docs/go/basic/string.html#字符串与字符切片的转换",
    "title": "斯巴拉稀",
    "section": "4 字符串与字符切片的转换",
    "text": "4 字符串与字符切片的转换\n前面代码验证字符串数据结构,知道 a := \"abc我们\" 这样定义的字符串是无法修改指向的内存的内容\n\n\n字符切片转字符串-方式一\n\nfunc main() {\n    a := []byte{'a', 'b', 'c'}\n    b := string(a)\n    println(b)\n}\n\n查看汇编可以看到使用的是runtime.slicebytetostring()\nfunc slicebytetostring(buf *tmpBuf, ptr *byte, n int) string {\n     // ...\n\n    var p unsafe.Pointer\n    if buf != nil && n &lt;= len(buf) {\n        p = unsafe.Pointer(buf)\n    } else {\n        p = mallocgc(uintptr(n), nil, false)\n    }\n    // 会复制切片的内容\n    memmove(p, unsafe.Pointer(ptr), uintptr(n))\n    return unsafe.String((*byte)(p), n)\n}\n\n\n字符切片转字符串-方式二\n\nfunc TestA(t *testing.T) {\n    a := []byte{'a', 'b', 'c'}\n    b := *(*string)(unsafe.Pointer(&a))\n    fmt.Println(b) // abc\n    a[0] = 'd'\n    fmt.Println(b) // dbc\n}\n\n\n切片的内存结构\n\n\n\n字符串的内存结构\n\n\n我们知道类型转换就是换一种方式来读写内存,根据切片和字符串的内存结构,发现他们刚好可以很方便的进行转换,切片data指向的字符数组成了字符串data的指向,这个转换是高效率的.\n\n\n稍微看下汇编\n\n0x006b 00107 (main.go:15) MOVQ    AX, main.a+48(SP) # 字符数组地址\n0x0070 00112 (main.go:15) MOVQ    $3, main.a+56(SP) # 切片长度 设置=3\n0x0079 00121 (main.go:15) MOVQ    $3, main.a+64(SP) # 切片cap 设置=3\n0x0082 00130 (main.go:16) LEAQ    main.a+48(SP), AX\n0x0087 00135 (main.go:16) TESTB   AL, (AX)\n0x0089 00137 (main.go:16) MOVQ    main.a+48(SP), AX\n0x008e 00142 (main.go:16) MOVQ    AX, main.b+32(SP) # 字符数组地址\n0x0093 00147 (main.go:16) MOVQ    $3, main.b+40(SP)  # 字符串的len 设置=3",
    "crumbs": [
      "基础篇",
      "字符串"
    ]
  },
  {
    "objectID": "docs/go/basic/string.html#字符串拼接",
    "href": "docs/go/basic/string.html#字符串拼接",
    "title": "斯巴拉稀",
    "section": "5 字符串拼接",
    "text": "5 字符串拼接\n\n\n\n\n\n\n思考\n\n\n\n前面在如何设计字符串中提到的如果多次拼接考虑性能,在字符串与字符切片的转换中提到的转换方法,我们不难想到一个高效拼接字符串的思路\n\n\n\n5.1 strings.Builder(推荐)\n\n\n\n\n\n\nTip\n\n\n\n推荐 事先看具体情况 Grow 一下\n\n\nfunc TestString6(t *testing.T) {\n    var builder strings.Builder\n    builder.WriteString(\"hello\")\n    res := builder.String()\n    fmt.Println(res)\n}\n\n\nstrings.Builder源码相关\n\ntype Builder struct {\n    addr *Builder\n    // 存放字符的切片, var builder strings.Builder 这个时候 切片的 cap ,len ,data 都是0\n    // WriteString 时,才会分配, 容量由 切片自己看情况扩容\n    // 基于这一点, 应该有 事先?就进行 字符切片容量分配的操作   ==&gt; Grow\n    buf  []byte\n}\nfunc (b *Builder) WriteString(s string) (int, error) {\n    b.copyCheck()\n    b.buf = append(b.buf, s...)\n    return len(s), nil\n}\nfunc (b *Builder) Grow(n int) {\n    b.copyCheck()\n    if n &lt; 0 {\n        panic(\"strings.Builder.Grow: negative count\")\n    }\n    if cap(b.buf)-len(b.buf) &lt; n {\n        b.grow(n)\n    }\n}\nfunc (b *Builder) grow(n int) {\n    buf := make([]byte, len(b.buf), 2*cap(b.buf)+n)\n    copy(buf, b.buf)\n    b.buf = buf\n}\n\nfunc (b *Builder) String() string {\n    return unsafe.String(unsafe.SliceData(b.buf), len(b.buf))\n}\n\n\n\n5.2 strings.Join\n\n\n\n\n\n\nTip\n\n\n\n底层原理是用的strings.builder\n\n\nfunc TestStringJoin(t *testing.T) {\n    baseSlice := []string{\"hello\", \"world\"}\n    s := strings.Join(baseSlice, \" \")\n    println(s)\n}",
    "crumbs": [
      "基础篇",
      "字符串"
    ]
  },
  {
    "objectID": "docs/go/basic/string.html#其他操作",
    "href": "docs/go/basic/string.html#其他操作",
    "title": "斯巴拉稀",
    "section": "6 其他操作",
    "text": "6 其他操作\n\n遍历字节长度转成utf-8字符数组截取\n\n\na := \"abc我们\"\nfor _, c := range a {\n    // 打印每个字符\n    fmt.Printf(\"%c\\n\", c)\n}\n\n\na := \"abc我们\"\nfmt.Println(len(a)) // 9 字节数\n\n\na := \"abc我们\"\ns := []rune(a) // 转成 utf-8字符 数组\nfmt.Println(s[0], s[1], s[2], string(s[3]), string(s[4]))\n\n\na := \"abc我们\"\n// 转成utf-8数组,切片后转成字符串\ns := string([]rune(a)[3:])\nfmt.Println(s) //我们",
    "crumbs": [
      "基础篇",
      "字符串"
    ]
  },
  {
    "objectID": "docs/go/basic/string.html#字符集",
    "href": "docs/go/basic/string.html#字符集",
    "title": "斯巴拉稀",
    "section": "7 字符集",
    "text": "7 字符集\n\n\n\n\n\n\nCaution\n\n\n\n有时间再详细写写\n\n\n\n\n\n\n\n\nCaution\n\n\n\n中英文混合的情况, 计算机是如何知道用一个字节或三个字节来区分是什么字符的呢? 是如何断字的?\n\n\n\n\n\n\n\n\nUTF-8的编码规则 go语言默认的编码方式\n\n\n\n\n1个字节的字符: 0xxxxxxx, 0开头表示一个字节的\n2个字节的字符: 110xxxxx 10xxxxxx\n\n110 开头表示2个字节的\n10开头表示一个字符的中间字节\n\n3个字节的字符: 1110xxxx 10xxxxxx 10xxxxxx\n4个字节的字符: 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n\n\n\nfunc TestString(t *testing.T) {\n    a := \"我\"\n    // 0xE6 1110  0110\n    // 0x88 10 001000\n    // 0x91 10 010001\n    fmt.Println(a[0], a[1], a[2])\n}\n\n\n\n\n\n\n结果\n\n\n\n我们将上面 “我” 汉字的每个字节的 “前缀” 去掉得到 0110 001000 010001 ==&gt; 01100010 00010001 =&gt; 0x6211 我的unicode 码就是 0x6211",
    "crumbs": [
      "基础篇",
      "字符串"
    ]
  },
  {
    "objectID": "docs/go/concurrency/lock.html",
    "href": "docs/go/concurrency/lock.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "Back to top",
    "crumbs": [
      "并发",
      "lock"
    ]
  },
  {
    "objectID": "docs/go/concurrency/context.html#background-todo",
    "href": "docs/go/concurrency/context.html#background-todo",
    "title": "斯巴拉稀",
    "section": "1 Background & TODO",
    "text": "1 Background & TODO\nvar (\n    background = new(emptyCtx)\n    todo       = new(emptyCtx)\n)\n\n// Background returns a non-nil, empty Context. It is never canceled, has no\n// values, and has no deadline. It is typically used by the main function,\n// initialization, and tests, and as the top-level Context for incoming\n// requests.\n// 作为初始的ctx,是起点时使用这个来实例化,然后传递给后续的\nfunc Background() Context {\n    return background\n}\n\n// TODO returns a non-nil, empty Context. Code should use context.TODO when\n// it's unclear which Context to use or it is not yet available (because the\n// surrounding function has not yet been extended to accept a Context\n// parameter).\n// 不是起点时,然后你暂时不知道使用哪个context,代码里就暂时写上,\n// 把TODO作为方法 可以说其实就表明了之后逻辑弄完后,你应该再来看看具体是使用什么\nfunc TODO() Context {\n    return todo\n}",
    "crumbs": [
      "并发",
      "context"
    ]
  },
  {
    "objectID": "docs/go/concurrency/context.html#withvalue",
    "href": "docs/go/concurrency/context.html#withvalue",
    "title": "斯巴拉稀",
    "section": "2 WithValue",
    "text": "2 WithValue\npackage test\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"testing\"\n    \"time\"\n)\n\nfunc TestWithValue(t *testing.T) {\n    ctx := context.Background()\n    parent := context.WithValue(ctx, \"name\", \"tom\")\n    son := context.WithValue(parent, \"age\", \"11\")\n    fmt.Println(parent.Value(\"name\"))\n    fmt.Println(parent.Value(\"age\")) // nil 无法获取子ctx 设置的key\n    fmt.Println(son.Value(\"name\"))\n}\n// 我们一般是不会这么做的\nfunc TestWithValueMap(t *testing.T) {\n    ctx := context.Background()\n    parent := context.WithValue(ctx, \"m\", map[string]string{\"name\": \"tom\"})\n    m := parent.Value(\"m\").(map[string]string)\n    m[\"age\"] = \"11\"\n    son := context.WithValue(parent, \"m\", m)\n    fmt.Println(parent.Value(\"m\").(map[string]string)[\"name\"])\n    // 父 ctx 获取 子 ctx 设置的key\n    fmt.Println(parent.Value(\"m\").(map[string]string)[\"age\"])\n    fmt.Println(son.Value(\"m\").(map[string]string)[\"name\"])\n}",
    "crumbs": [
      "并发",
      "context"
    ]
  },
  {
    "objectID": "docs/go/concurrency/context.html#withcancel",
    "href": "docs/go/concurrency/context.html#withcancel",
    "title": "斯巴拉稀",
    "section": "3 WithCancel",
    "text": "3 WithCancel\n\n\n\n\n\n\nTip\n\n\n\n父ctx cancel或超时, 所有子孙ctx都会cancel或超时\n\n\npackage test\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"testing\"\n    \"time\"\n)\n\n// 前面timeout 可以说是到期会自动cancel\n// 这里是需要我们主动 cancel ,用来控制链路流程,比如控制子goroutine 退出\nfunc TestWithCancel(t *testing.T) {\n    ctx, cancel := context.WithCancel(context.Background())\n    go func(context.Context) {\n        go func(context.Context) {\n            c, cancelSon := context.WithCancel(ctx)\n            defer cancelSon()\n        Loop:\n            for {\n                select {\n                case &lt;-c.Done(): // 父ctx cancel 会导致子ctx 也cancel\n                    fmt.Println(\"gorouting2 is done\")\n                    // context canceled ,很明星, cancelSon() 是没执行的. 但是err 信息是\n                    fmt.Println(c.Err())\n                    break Loop\n                default:\n                }\n                fmt.Println(\"gorouting2 is running\")\n                time.Sleep(time.Second)\n            }\n        }(ctx)\n    Loop:\n        for {\n            select {\n            case &lt;-ctx.Done():\n                fmt.Println(\"gorouting1 is done\")\n                break Loop\n            default:\n            }\n            fmt.Println(\"gorouting1 is running\")\n            time.Sleep(time.Second)\n        }\n    }(ctx)\n\n    time.Sleep(3 * time.Second)\n    // 主动取消\n    cancel()\n    fmt.Println(\"cancel...\")\n    time.Sleep(3 * time.Second)\n}\n// A cancelCtx can be canceled. When canceled, it also cancels any children\n// that implement canceler.\ntype cancelCtx struct {\n    Context\n\n    mu       sync.Mutex            // protects following fields\n    done     atomic.Value          // of chan struct{}, created lazily, closed by first cancel call\n    children map[canceler]struct{} // set to nil by the first cancel call\n    err      error                 // set to non-nil by the first cancel call\n    cause    error                 // set to non-nil by the first cancel call\n}\n\nfunc withCancel(parent Context) *cancelCtx {\n    if parent == nil {\n        panic(\"cannot create context from nil parent\")\n    }\n    c := newCancelCtx(parent)\n    propagateCancel(parent, c)\n    return c\n}\n\nfunc newCancelCtx(parent Context) *cancelCtx {\n    return &cancelCtx{Context: parent}\n}\n\n// 父 cancel后, 将cancel 传递给子孙 (子孙也cancel)\nfunc propagateCancel(parent Context, child canceler) {\n    done := parent.Done()\n    if done == nil {\n        // WithValue 的done() 是nil\n        return\n    }\n\n    select {\n    case &lt;-done:\n        // 如果这个时候父 ctx cancel 了\n        // 则调用子孙的cancel, 将 父ctx的Err,以及谁引发的传递\n        child.cancel(false, parent.Err(), Cause(parent))\n        return\n    default: // 因为有default 所以如果 &lt;-done 没有数据,就会立马结束,走后面的代码\n    }\n\n    if p, ok := parentCancelCtx(parent); ok {\n        // 如果找到最近一个是cancelCtx 的祖先context\n        p.mu.Lock()\n        if p.err != nil {\n            // 再次判断\n            // 如果父ctx 这个时候cancel后, 那么直接cancel 子ctx\n            child.cancel(false, p.err, p.cause)\n        } else {\n            if p.children == nil {\n                p.children = make(map[canceler]struct{})\n            }\n            // 设置children ,子 ctx, 内容是 空结构体省内存\n            // 后面我们只需要key ctx 就行\n            // 后续 父cancel时,需要cancel 所有children 用到\n            p.children[child] = struct{}{}\n        }\n        p.mu.Unlock()\n    } else {\n        // \n        goroutines.Add(1)\n        go func() {\n            select {\n            case &lt;-parent.Done(): // \n                child.cancel(false, parent.Err(), Cause(parent))\n            case &lt;-child.Done(): // 关心自己\n            }\n        }()\n    }\n}\nfor child := range c.children {\n    child.cancel(false, err, cause)\n}\n// 如果parent是cancelCtx,则返回parent ctx的指针\n// 如果不是cancelCtx (比如WithValue 返回的ctx),则继续往前找,找到最近的祖先cancelCtx\nfunc parentCancelCtx(parent Context) (*cancelCtx, bool) {\n    done := parent.Done()\n    if done == closedchan || done == nil {\n        return nil, false\n    }\n    p, ok := parent.Value(&cancelCtxKey).(*cancelCtx)\n    if !ok {\n        return nil, false\n    }\n    pdone, _ := p.done.Load().(chan struct{})\n    if pdone != done {\n        return nil, false\n    }\n    return p, true\n}\nfunc (c *valueCtx) Value(key any) any {\n    if c.key == key {\n        return c.val\n    }\n    return value(c.Context, key)\n}\nfunc (c *cancelCtx) Value(key any) any {\n    if key == &cancelCtxKey {\n        return c\n    }\n    return value(c.Context, key)\n}",
    "crumbs": [
      "并发",
      "context"
    ]
  },
  {
    "objectID": "docs/go/concurrency/context.html#withdeadlinetimeout",
    "href": "docs/go/concurrency/context.html#withdeadlinetimeout",
    "title": "斯巴拉稀",
    "section": "4 WithDeadline/Timeout",
    "text": "4 WithDeadline/Timeout\n// A timerCtx carries a timer and a deadline. It embeds a cancelCtx to\n// implement Done and Err. It implements cancel by stopping its timer then\n// delegating to cancelCtx.cancel.\ntype timerCtx struct {\n    *cancelCtx\n    timer *time.Timer // Under cancelCtx.mu.\n\n    deadline time.Time\n}\n\n// WithTimeout 里面直接调用了 WithDeadline , 和它没啥区别\nfunc WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc) {\n    return WithDeadline(parent, time.Now().Add(timeout))\n}\n\nfunc WithDeadline(parent Context, d time.Time) (Context, CancelFunc) {\n    if parent == nil {\n        panic(\"cannot create context from nil parent\")\n    }\n    if cur, ok := parent.Deadline(); ok && cur.Before(d) {\n        // The current deadline is already sooner than the new one.\n        return WithCancel(parent)\n    }\n    c := &timerCtx{\n        cancelCtx: newCancelCtx(parent),\n        deadline:  d,\n    }\n    propagateCancel(parent, c)\n    dur := time.Until(d)\n    if dur &lt;= 0 {\n        c.cancel(true, DeadlineExceeded, nil) // deadline has already passed\n        return c, func() { c.cancel(false, Canceled, nil) }\n    }\n    c.mu.Lock()\n    defer c.mu.Unlock()\n    if c.err == nil {\n        c.timer = time.AfterFunc(dur, func() {\n            c.cancel(true, DeadlineExceeded, nil)\n        })\n    }\n    return c, func() { c.cancel(true, Canceled, nil) }\n}\npackage test\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"testing\"\n    \"time\"\n)\nfunc TestWithTimeout(t *testing.T) {\n    ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)\n    defer cancel()\n    dl, isSetDl := ctx.Deadline()\n    fmt.Printf(\"预计的过期时间: %s \\n是否设置了过期时间:%t\\n\", dl, isSetDl) // 预计的过期时间\n    _, isSetDl2 := context.Background().Deadline()\n    fmt.Println(isSetDl2) // false\n    now := time.Now()\n    go func() {\n        // 到期后, Done() 管道会有数据\n        &lt;-ctx.Done()\n        // 到期的情况时 错误信息\n        fmt.Println(\"err\", ctx.Err()) // err context deadline exceeded\n        fmt.Println(\"经过\", time.Since(now), time.Now())\n\n    }()\n\n    time.Sleep(4 * time.Second)\n}\n\nfunc TestWithTimeout2(t *testing.T) {\n    ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)\n    defer cancel()\n    // 超时 设置无效的,父ctx超时了, 子孙也超时了.\n    s, c := context.WithTimeout(ctx, 5*time.Second)\n    defer c()\n    go func() {\n        &lt;-s.Done()\n        fmt.Println(\"s:\", s.Err())\n    }()\n    go func() {\n        // 到期后, Done() 管道会有数据\n        &lt;-ctx.Done()\n        // 到期的情况时 错误信息\n        fmt.Println(\"err\", ctx.Err()) // err context deadline exceeded\n\n    }()\n\n    time.Sleep(7 * time.Second)\n}\nfunc TestWithTimeoutCancel(t *testing.T) {\n    ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)\n    now := time.Now()\n    go func() {\n        // 主动执行cancel()后, Done() 管道会有数据\n        &lt;-ctx.Done()\n        err := ctx.Err()\n        fmt.Println(\"err\", err) // err context canceled\n        switch err {\n        // 判断错误类型\n        case context.Canceled:\n        case context.DeadlineExceeded:\n        }\n        fmt.Println(\"经过\", time.Since(now))\n    }()\n\n    time.Sleep(1 * time.Second)\n    cancel()\n    time.Sleep(3 * time.Second)\n}\nfunc TestWithDeadline(t *testing.T) {\n    ctx, cancel := context.WithDeadline(context.Background(), time.Now().Add(3*time.Second))\n    defer cancel()\n    fmt.Println(ctx)\n}",
    "crumbs": [
      "并发",
      "context"
    ]
  },
  {
    "objectID": "docs/go/infrastructure/clean-code.html",
    "href": "docs/go/infrastructure/clean-code.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "待整理…",
    "crumbs": [
      "工程设计",
      "编码规范"
    ]
  },
  {
    "objectID": "docs/go/infrastructure/clean-code.html#注释",
    "href": "docs/go/infrastructure/clean-code.html#注释",
    "title": "斯巴拉稀",
    "section": "1 注释",
    "text": "1 注释\n对象声明的注释应该是完整的句子,即使这看起来有点多余. 当提取到doc文档中时,这种方式可以使它们格式化良好. 注释应以所描述事物的名称开头,并以句点结尾\n// Request represents a request to run a command.\ntype Request struct { ...\n\n// Encode writes the JSON encoding of req to w.\nfunc Encode(w io.Writer, req *Request) { ...",
    "crumbs": [
      "工程设计",
      "编码规范"
    ]
  },
  {
    "objectID": "docs/go/infrastructure/clean-code.html#context",
    "href": "docs/go/infrastructure/clean-code.html#context",
    "title": "斯巴拉稀",
    "section": "2 Context",
    "text": "2 Context\n\n\n\n\n\n\nWarning\n\n\n\n大多数使用Context的函数都应将其作为第一个参数 不要将Context成员添加到结构类型, 应该将ctx参数添加到该类型需要传递的每个方法上\n\n\nfunc F(ctx context.Context, /* other arguments */) {}",
    "crumbs": [
      "工程设计",
      "编码规范"
    ]
  },
  {
    "objectID": "docs/go/infrastructure/clean-code.html#crypto-rand",
    "href": "docs/go/infrastructure/clean-code.html#crypto-rand",
    "title": "斯巴拉稀",
    "section": "3 Crypto Rand",
    "text": "3 Crypto Rand\n不要使用软件包 math/rand 生成密钥，即使是一次性密钥也是如此。 在没有种子情况下，生成器是完全可预测的。 将time.Nanoseconds()的作为随机生成器的种子，只有几熵（应该是消耗很少的意思）。 相反，请使用 crypto/rand’s Reader，如果需要文本，请打印为十六进制或base64\nimport (\n    \"crypto/rand\"\n    // \"encoding/base64\"\n    // \"encoding/hex\"\n    \"fmt\"\n)\n\nfunc Key() string {\n    buf := make([]byte, 16)\n    _, err := rand.Read(buf)\n    if err != nil {\n        panic(err)  // out of randomness, should never happen\n    }\n    return fmt.Sprintf(\"%x\", buf)\n    // or hex.EncodeToString(buf)\n    // or base64.StdEncoding.EncodeToString(buf)\n}",
    "crumbs": [
      "工程设计",
      "编码规范"
    ]
  },
  {
    "objectID": "docs/go/infrastructure/clean-code.html#声明空切片",
    "href": "docs/go/infrastructure/clean-code.html#声明空切片",
    "title": "斯巴拉稀",
    "section": "4 声明空切片",
    "text": "4 声明空切片\n声明空切片时，首选\nvar t []string \n其次\nt := []string{}\n前者声明nil slice值，而后者声明非nil但长度为零。 它们在功能上等同，他们 len和 cap均为零，而零切片是首选的风格。",
    "crumbs": [
      "工程设计",
      "编码规范"
    ]
  },
  {
    "objectID": "docs/go/infrastructure/clean-code.html#错误字符串",
    "href": "docs/go/infrastructure/clean-code.html#错误字符串",
    "title": "斯巴拉稀",
    "section": "5 错误字符串",
    "text": "5 错误字符串\n错误字符串不应大写（除非以专有名词或缩写开头）或标点符号结束，因为它们通常是在其他上下文之后打印的。 也就是说，请使用 fmt.Errorf(“something bad”)，不要使用 fmt.Errorf(“Something bad”)，这样 log.Printf(“Reading %s: %v”, filename, err)格式就不会出现虚假的大写字母中间消息。 这不适用于日志记录，后者是隐式面向行的，并且未在其他消息中合并。",
    "crumbs": [
      "工程设计",
      "编码规范"
    ]
  },
  {
    "objectID": "docs/go/infrastructure/clean-code.html#goroutine生命周期",
    "href": "docs/go/infrastructure/clean-code.html#goroutine生命周期",
    "title": "斯巴拉稀",
    "section": "6 Goroutine生命周期",
    "text": "6 Goroutine生命周期\n当您生成goroutine时，请清楚何时或是否退出。 Goroutine可以通过阻塞通道的发送或接收来泄漏：即使goroutine的阻塞通道不可访问，垃圾收集器也不会终止goroutine。 即使goroutine不会泄漏，在不再需要它们时仍在飞行中也会导致其他细微且难以诊断的问题。 在关闭的通道上发送紧急消息。 “在不需要结果之后”修改仍在使用的输入仍然会导致数据争用。 将goroutine进行任意长时间的飞行可能会导致不可预测的内存使用情况。 尝试使并发代码足够简单，以使goroutine生存期显而易见。 如果那不可行，请记录goroutine何时以及为何退出。 ## Imports 除避免名称冲突外，避免重命名导入； 好的软件包名称不需要重命名。 发生名称冲突时，最好重命名本地的或特定于项目的导入。 导入包是按组组织排序的，组之间有空白行。标准库软件包始终在第一组中\ngo imports 将为您做到这一点\n\n6.1 Import Blank\n仅出于辅助作用而导入的软件包（使用语法import _“pkg”）应仅在程序的主软件包或需要它们的测试中导入。 ### Import . 由于循环依赖关系，导入 . 形式不能用于要测试的程序包，因此在测试中很有用\npackage foo_test\n\nimport (\n    \"bar/testutil\" // also imports \"foo\"\n    . \"foo\"\n)",
    "crumbs": [
      "工程设计",
      "编码规范"
    ]
  },
  {
    "objectID": "docs/go/infrastructure/clean-code.html#in-band-errors",
    "href": "docs/go/infrastructure/clean-code.html#in-band-errors",
    "title": "斯巴拉稀",
    "section": "7 In-Band Errors",
    "text": "7 In-Band Errors\n在C和类似语言中，函数通常返回-1这样的值或null来表示错误或没有结果\n// Lookup returns the value for key or \"\" if there is no mapping for key.\nfunc Lookup(key string) string\n\n// Failing to check a for an in-band error value can lead to bugs:\nParse(Lookup(key))  // returns \"parse failure for value\" instead of \"no value for key\"\nGo对多个返回值的支持提供了更好的解决方案。 函数应该返回一个附加值以指示其其他返回值是否有效，而不是要求客户端检查带内错误值。 该返回值可以是错误，也可以是布尔值（不需要说明时）。 它应该是最终的返回值\n// Lookup returns the value for key or ok=false if there is no mapping for key.\nfunc Lookup(key string) (value string, ok bool)\n鼓励使用更健壮和易读的代码：\nvalue, ok := Lookup(key)\nif !ok {\n    return fmt.Errorf(\"no value for %q\", key)\n}\nreturn Parse(value)",
    "crumbs": [
      "工程设计",
      "编码规范"
    ]
  },
  {
    "objectID": "docs/go/infrastructure/clean-code.html#缩进错误流",
    "href": "docs/go/infrastructure/clean-code.html#缩进错误流",
    "title": "斯巴拉稀",
    "section": "8 缩进错误流",
    "text": "8 缩进错误流\n尝试使普通代码路径保持最小缩进，并缩进错误处理，并首先对其进行处理。 通过允许在视觉上快速扫描正常路径，可以提高代码的可读性。 例如，不要写\nif err != nil {\n    // error handling\n} else {\n    // normal code\n}\n应该写：\nif err != nil {\n    // error handling\n    return // or continue, etc.\n}\n// normal code\n如果该 if语句具有初始化语句，例如：\nif x, err := f(); err != nil {\n    // error handling\n    return\n} else {\n    // use x\n}\n那么这可能需要将short变量声明移至其自己的行： ==这样的目的是让业务代码能够直接清晰的看到==\nx, err := f()\nif err != nil {\n    // error handling\n    return\n}\n// use x",
    "crumbs": [
      "工程设计",
      "编码规范"
    ]
  },
  {
    "objectID": "docs/go/infrastructure/clean-code.html#首字母缩写",
    "href": "docs/go/infrastructure/clean-code.html#首字母缩写",
    "title": "斯巴拉稀",
    "section": "9 首字母缩写",
    "text": "9 首字母缩写\n名称中的缩写词或首字母缩写词（例如“ URL”或“ NATO”）具有一致的大小写。 例如，“ URL”应显示为“ URL”或“ url”（如在“ urlPony”或“ URLPony”中一样），而从不显示为“ Url”。 例如：ServeHTTP而不是ServeHttp。 对于具有多个已初始化“单词”的标识符，请使用“ xmlHTTPRequest”或“ XMLHTTPRequest”。 当“ ID”是“ identifier”的缩写时，该规则也适用于“ ID”（这在几乎所有情况下都不是“ ego”，“ superego”中的“ id”），因此请写上“ appID”而不是“ appId”。 协议缓冲区编译器生成的代码不受此规则约束。 人工编写的代码要比机器编写的代码具有更高的标准。",
    "crumbs": [
      "工程设计",
      "编码规范"
    ]
  },
  {
    "objectID": "docs/go/infrastructure/clean-code.html#接口interfaces",
    "href": "docs/go/infrastructure/clean-code.html#接口interfaces",
    "title": "斯巴拉稀",
    "section": "10 接口（Interfaces）",
    "text": "10 接口（Interfaces）\nGo接口通常属于使用接口类型的值的包中，而不是实现这些值的包中。 实现包应返回具体的（通常是指针或结构）类型：这样，可以将新方法添加到实现中，而无需进行大量重构。 不要在“用于模拟”的API的实现方定义接口； 而是设计API，以便可以使用实际实现的公共API对其进行测试。 在使用接口之前，不要先定义它们：如果没有实际的用法示例，很难知道接口是否是必需的，更不用说它应该包含什么方法了。 ### 接口命名 根据命名规则，一种方法的接口，需要在名称后面加上 -er 的后缀，或者通过代理名词的方式来进行修饰：Reader, Writer,Formatter,CloseNotifier 等\n这里最麻烦的是，你的一个接口有多个方法的时候，按照这个方式命名，就不总是很清晰明了。那是否要把结构拆分，变成一个接口对应一个方法呢？我觉得这个取决具体的使用场景了。 接口我的理解: 按理解来说应该名字倾向于一种功能的名字, 当然也可以是一种东西的名字. 一种类型一样的感觉\n\n命名规则基本和上面的结构体类型\n单个函数的结构名以 “er” 作为后缀，例如 Reader , Writer\n\ntype Reader interface {\n        Read(p []byte) (n int, err error)\n}\n\n两个函数的接口名综合两个函数名\n\ntype WriteFlusher interface {\n    Write([]byte) (int, error)\n    Flush() error\n}\n\n三个以上函数的接口名，类似于结构体名\n\ntype Car interface {\n    Start([]byte) \n    Stop() error\n    Recover()\n}",
    "crumbs": [
      "工程设计",
      "编码规范"
    ]
  },
  {
    "objectID": "docs/go/infrastructure/clean-code.html#bool-类型变量命名",
    "href": "docs/go/infrastructure/clean-code.html#bool-类型变量命名",
    "title": "斯巴拉稀",
    "section": "11 bool 类型变量命名",
    "text": "11 bool 类型变量命名\n名称应以 Has, Is, Can 或 Allow 开头\nvar isExist bool\nvar hasConflict bool\nvar canManage bool\nvar allowGitHook bool",
    "crumbs": [
      "工程设计",
      "编码规范"
    ]
  },
  {
    "objectID": "docs/go/infrastructure/clean-code.html#常量命名",
    "href": "docs/go/infrastructure/clean-code.html#常量命名",
    "title": "斯巴拉稀",
    "section": "12 常量命名",
    "text": "12 常量命名\n常量均需使用全部大写字母组成，并使用下划线分词\nconst APP_VER = \"1.0\"",
    "crumbs": [
      "工程设计",
      "编码规范"
    ]
  },
  {
    "objectID": "docs/go/infrastructure/clean-code.html#行长度",
    "href": "docs/go/infrastructure/clean-code.html#行长度",
    "title": "斯巴拉稀",
    "section": "13 行长度",
    "text": "13 行长度\nGo代码中没有严格的行长度限制，但要避免行太长。 同样，请勿添加换行符以使行在可读性更强的情况下保持较短（例如，如果它们是重复的）。 在大多数情况下，人们“不自然地”换行（在函数调用或函数声明的中间，或多或少，例如，尽管周围有一些例外情况），如果参数和简短的变量名数量合理，则不需要换行。长行似乎包含长名，而摆脱长名会很有帮助。 换句话说，换行是因为您所写内容的语义（作为一般规则），而不是因为行长。 如果发现行太长，则更改名称或语义，可能会得到不错的结果。 实际上，这和关于功能应该写多长的建议是完全相同的。 没有强制的规则“一个函数的长度不能超过N行”，但是肯定存在这样一个问题，即函数太长或者小函数过于频繁，解决方案是重新划分函数的功能，而不是开始数行数。 ## Named Result Parameters (命名返回值参数)\n考虑一下godoc中的表现。命名结果参数如下：\nfunc (n *Node) Parent1() (node *Node) {}\nfunc (n *Node) Parent2() (node *Node, err error) {}\n会在godoc中显得繁杂；更好的表现如下：\nfunc (n *Node) Parent1() *Node {}\nfunc (n *Node) Parent2() (*Node, error) {}\n\n例外 另一方面，在某些情况下,如果函数返回两个或三个相同类型的参数， 或者如果从上下文中不清楚结果的含义，则添加名称可能很有用。不要仅仅为了避免在内部声明var而命名结果参数; 这就以不必要的API冗长为代价，牺牲了实现的简短性。\n\nfunc (f *Foo) Location() (float64, float64, error)\n\n// 不如用下面的好点\n// Location returns f's latitude and longitude.\n// Negative values mean south and west, respectively.\nfunc (f *Foo) Location() (lat, long float64, err error)\n如果函数只有几行，则可以使用裸返回。 一旦成为通用的函数，请明确说明您的返回值。 结论：为了使您可以使用裸返回而命名结果参数是不值得的。文档的清晰性始终比在函数中保存一两行更为重要",
    "crumbs": [
      "工程设计",
      "编码规范"
    ]
  },
  {
    "objectID": "docs/go/infrastructure/clean-code.html#包注释",
    "href": "docs/go/infrastructure/clean-code.html#包注释",
    "title": "斯巴拉稀",
    "section": "14 包注释",
    "text": "14 包注释\n像godoc提出的所有注释一样，包注释必须出现在package子句的旁边，且不能有空行\n// Package math provides basic constants and mathematical functions.\npackage math\n\n/*\nPackage template implements data-driven templates for generating textual\noutput such as HTML.\n....\n*/\npackage template\n对于“ package main”注释，在二进制名称之后可以使用其他样式的注释（如果使用二进制格式，则可以大写），例如，对于在seedgen包中的package main包，您可以编写\n// Binary seedgen ...\npackage main\n\n// Command seedgen ...\npackage main\n\n// Program seedgen ...\npackage main\n\n// The seedgen program ...\npackage main\n\n\n// 都是可以的\n这些示例，以及这些的明智的变体是可以接受的。 请注意，包注释以小写单词开头的句子是不可可接受的，因为它们是公开可见的 应该用适当的英语写成，包括首字母大写的句子。当二进制名称是第一个单词时，将其大写即使它与拼写不完全匹配命令行调用也是必需的 ## 包名 您对包中所有名称的引用都将使用包名完成，因此您可以从标识符中省略该名称。例如，如果您在庞大的包中，您不需要输入ChubbyFile，客户端将其输入为 chubby.ChubbyFile。 而是命名类型 File，客户端将其写为 chubby.File。 避免使用无意义的程序包名称，例如util，common，misc，api，types 和interfaces。 请参阅 http://golang.org/doc/effective_go.html#package-names 和 http://blog.golang.org/package-names 以获得更多信息。\n保持package的名字和目录保持一致，尽量采取有意义的包名，简短，有意义，尽量和标准库不要冲突。包名应该为小写单词，不要使用下划线或者混合大小写 ## 文件命名 尽量采取有意义的文件名，简短，有意义，应该为小写单词，使用下划线分隔各个单词 ## 结构体命名\n\n采用驼峰命名法，首字母根据访问控制大写或者小写 ## 传递值 不要为了节省一些字节，将指针作为函数参数传递。 如果函数整个过程中都将 x 仅作为 x 使用，则自变量不应是指针。常见的实例包括传递指向字符串（ string的指针 ）或指向接口值的指针（ *io.Reader）。在这两种情况下，值本身都是固定大小，可以直接传递。这个建议不适用于大型结构，甚至不适用于可能增长的小型结构。",
    "crumbs": [
      "工程设计",
      "编码规范"
    ]
  },
  {
    "objectID": "docs/go/infrastructure/clean-code.html#方法接收者命名",
    "href": "docs/go/infrastructure/clean-code.html#方法接收者命名",
    "title": "斯巴拉稀",
    "section": "15 方法接收者命名",
    "text": "15 方法接收者命名\n方法的接收者的名称应反映其身份。 通常，其类型的一个或两个字母缩写就足够了（例如，“客户”是“ c”或“ cl”）。 不要使用通用名称，例如“ me”，“ this”或“ self”，这是面向对象语言的典型标识符，这些标识符赋予该方法特殊的含义。 在Go中，方法的接收者只是另一个参数，因此应相应地命名。 该名称不必像方法参数那样具有描述性，因为它的作用是显而易见的，没有任何文档目的。 它可能很短，因为它将出现在该类型的每种方法的几乎每一行上；熟悉承认简洁。也要保持一致：如果在一种方法中将接收器称为“ c”，则在另一种方法中请勿将其称为“ cl”。\n\n使用一个字母或2个字母即可\n\ntype T struct{} \n    \nfunc (t *T)Get(){}",
    "crumbs": [
      "工程设计",
      "编码规范"
    ]
  },
  {
    "objectID": "docs/go/infrastructure/clean-code.html#方法接收者类型",
    "href": "docs/go/infrastructure/clean-code.html#方法接收者类型",
    "title": "斯巴拉稀",
    "section": "16 方法接收者类型",
    "text": "16 方法接收者类型\n对于go初学者，接受者的类型如果不清楚，统一采用指针型\nfunc (t *T)Get(){}\n选择在方法上使用值接收器还是指针接收器可能很困难，特别是对于新的Go程序员而言。 如果有疑问，请使用指针，但是有时出于效率的原因（例如，小的不变结构或基本类型的值），值接收器才有意义。 一些有用的准则：\n\n如果接收方是map，func或channel，请不要使用指向它们的指针。 如果接收方是切片，并且该方法未重新切片或重新分配切片，请不要使用指向该切片的指针。\n\npackage main\n\nimport (\n    \"fmt\"\n)\n\ntype mp map[string]string\n\nfunc (m mp) Set(k, v string) {\n    m[k] = v\n}\n\nfunc main() {\n    m := make(mp)\n    m.Set(\"k\", \"v\")\n    fmt.Println(m)\n}\n//Channel\npackage main\n\nimport (\n    \"fmt\"\n)\n\ntype ch chan interface{}\n\nfunc (c ch) Push(i interface{}) {\n    c &lt;- i\n}\n\nfunc (c ch) Pop() interface{} {\n    return &lt;-c\n}\n\nfunc main() {\n    c := make(ch, 1)\n    c.Push(\"i\")\n    fmt.Println(c.Pop())\n}\n\n如果需要对slice进行修改，通过返回值的方式重新赋值\n\n//Slice\npackage main\n\nimport (\n    \"fmt\"\n)\n\ntype slice []byte\n\nfunc main() {\n    s := make(slice, 0)\n    s = s.addOne(42)\n    fmt.Println(s)\n}\n\nfunc (s slice) addOne(b byte) []byte {\n    return append(s, b)\n}\n\n如果该方法需要更改接收者，则接收者必须是指针。\n如果接收者是包含sync.Mutex或类似同步字段的结构，则接收者必须是一个指针以避免复制。\n\npackage main\n\nimport (\n    \"sync\"\n)\n\ntype T struct {\n    m sync.Mutex\n}\n\nfunc (t *T) lock() {\n    t.m.Lock()\n}\n\n如果接收者是大型结构或数组，则指针接收者效率更高。多大是大型？假设这等效于将其所有元素作为参数传递给方法。如果感觉太大，则对于接收者来说也太大。\n\n如果接收者是大的结构体或者数组，使用指针传递会更有效率\n\npackage main\n\nimport (\n    \"fmt\"\n)\n\ntype T struct {\n    data [1024]byte\n}\n\nfunc (t *T) Get() byte {\n    return t.data[0]\n}\n\nfunc main() {\n    t := new(T)\n    fmt.Println(t.Get())\n}\n\n函数或方法（同时执行或从该方法调用时）是否会使接收者发生变化？ 值类型在调用方法时创建接收者的副本，因此外部更新将不会应用于该接收者。 如果更改必须在原始接收者中可见，则接收者必须是指针。\n如果接收者是结构体，数组或切片，并且其任何元素都是指向可能正在修改的对象的指针，则最好使用指针接收者，因为它会使读者更加清楚意图。\n如果接收者是一个很小的数组或结构，自然是一个值类型（例如，诸如time.Time类型），没有可变字段且没有指针，或者仅仅是一个简单的基本类型（如int或string），值接收者是合理的。 值接收者可以减少可以生成的垃圾数量； 如果将值传递给值方法，则可以使用堆栈上的副本而不是在堆上分配。 （编译器会尽量避免这种分配，但是它不可能总是成功。）由于这个原因，请勿在没有进行概要分析的情况下选择值类型接收者。\n最后，如有疑问，请使用指针接收者。 ## 变量名 Go中的变量名应该简短而不是冗长。 对于范围有限的局部变量尤其如此。 比起 lineCount 更倾向于 c。比起 sliceIndex 更倾向于 i。",
    "crumbs": [
      "工程设计",
      "编码规范"
    ]
  },
  {
    "objectID": "docs/go/infrastructure/clean-code.html#代码分析",
    "href": "docs/go/infrastructure/clean-code.html#代码分析",
    "title": "斯巴拉稀",
    "section": "17 代码分析",
    "text": "17 代码分析\n\n静态分析我们的源码存在的各种问题，例如多余的代码，提前return的逻辑，struct的tag是否符合标准等。\n\ngo vet .",
    "crumbs": [
      "工程设计",
      "编码规范"
    ]
  },
  {
    "objectID": "docs/go/infrastructure/error.html",
    "href": "docs/go/infrastructure/error.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "Back to top",
    "crumbs": [
      "工程设计",
      "错误处理"
    ]
  },
  {
    "objectID": "docs/go/infrastructure/directory.html",
    "href": "docs/go/infrastructure/directory.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "Back to top",
    "crumbs": [
      "工程设计",
      "目录结构"
    ]
  },
  {
    "objectID": "docs/go/pkg/go-generate.html",
    "href": "docs/go/pkg/go-generate.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "todo…",
    "crumbs": [
      "工具与实用库",
      "generate"
    ]
  },
  {
    "objectID": "docs/go/pkg/go-generate.html#介绍",
    "href": "docs/go/pkg/go-generate.html#介绍",
    "title": "斯巴拉稀",
    "section": "1 介绍",
    "text": "1 介绍\n\n\n\n\n\n\nTip\n\n\n\n\nGo 语言的标准库中的 cmd/go/internal/generate\ngo generate 命令会遍历指定的包路径下的所有 Go 源文件,并解析这些源文件中的 //go:generate 注释,这些注释包含了代码生成指令\n//go:generate 后面就是会执行的命令,比如 //go:generate echo hello 执行go generate 会显示 hello",
    "crumbs": [
      "工具与实用库",
      "generate"
    ]
  },
  {
    "objectID": "docs/go/pkg/go-generate.html#例子",
    "href": "docs/go/pkg/go-generate.html#例子",
    "title": "斯巴拉稀",
    "section": "2 例子",
    "text": "2 例子\n\n\n\n\n\n\n提醒\n\n\n\n早期笔记, 下面的例子粗糙,{==给struct类型生成getset方法==}, 等整理了ast后, 我会再完善一下.  建议去学习 ==stringer==\n\n\ntree\n.\n├── abc.go\n├── codegen\n│   └── gen.go\n├── go.mod\n└── pkg\n    └── cat.go\n//go:generate echo 123\n\n// goto hell\n\n// xyz\npackage main\n\n//go:generate go run codegen/gen.go\n//go:generate echo hello--world\n\n//helloworld33\ntype Person struct { // this is person\n    Name string // this is name\n    Age  int32\n}\n\n//go:generate echo 99\ntype Cup struct {\n    Price  float64\n    Origin string\n}\n\n\ncodegen/gen.go\n\npackage main\n\nimport (\n    \"fmt\"\n    \"go/ast\"\n    \"go/parser\"\n    \"go/printer\"\n    \"go/token\"\n    \"os\"\n    \"strings\"\n    \"text/template\"\n)\n\ntype Field struct {\n    Name string\n    Type string\n}\n\ntype StructInfo struct {\n    Name        string\n    Fields      []Field\n    PackageName string\n}\n\nfunc generateCode() {\n    fset := token.NewFileSet()\n\n    // 解析当前目录下所有的 Go 源文件,不会递归解析子目录里的文件的.\n    pkgs, err := parser.ParseDir(fset, \".\", nil, parser.ParseComments)\n    if err != nil {\n        fmt.Fprintf(os.Stderr, \"Failed to parse directory: %v\\n\", err)\n        os.Exit(1)\n    }\n\n    for _, pkg := range pkgs {\n        for _, file := range pkg.Files {\n            packageName := file.Name.Name\n            // for _, l := range file.Doc.List {\n            //  fmt.Println(\"file-doc\", l.Text)\n            // }\n            // fmt.Println(\"---\", packageName, file.Doc.Text(), \"===\")\n            // for _, c := range file.Comments {\n            //  // 挨在一起的2行注释算一个file的Comment\n            //  fmt.Print(\"[\")\n            //  for _, l := range c.List {\n            //      fmt.Println(\"cc\", l.Text)\n            //  }\n            //  fmt.Println(\"]\")\n            // }\n            // for _, d := range file.Decls {\n            //  x := d.(*ast.GenDecl)\n            //  if x.Doc != nil {\n            //      fmt.Println(len(x.Doc.List))\n            //      for _, l := range x.Doc.List {\n            //          fmt.Println(\"ooo\", l.Text)\n            //      }\n            //      fmt.Println(\"gg\", x.Doc.Text(), \"--\")\n            //  }\n            //  ts := x.Specs[0].(*ast.TypeSpec)\n            //  fmt.Println(ts.Name)\n\n            // }\n            // continue\n            ast.Inspect(file, func(n ast.Node) bool {\n\n                switch x := n.(type) {\n                // 注释写在type struct 上面的注释 是算一个节点. 不是属于type struct的内部东西\n                case *ast.GenDecl:\n                    // fmt.Println(\"注释内容2:\", x.Doc.Text())\n                case *ast.CommentGroup:\n                    // fmt.Println(\"注释内容:\", x.Text())\n                case *ast.TypeSpec:\n                    if structType, ok := x.Type.(*ast.StructType); ok {\n                        fmt.Println(\"结构体名称:\", x.Name.Name)\n                        structInfo := StructInfo{\n                            Name:        x.Name.Name,\n                            PackageName: packageName,\n                        }\n\n                        // 提取结构体字段信息\n                        for _, field := range structType.Fields.List {\n                            for _, ident := range field.Names {\n                                structInfo.Fields = append(structInfo.Fields, Field{\n                                    Name: ident.Name,\n                                    Type: fileSetToString(fset, field.Type),\n                                })\n                            }\n                        }\n\n                        // 生成 Get 和 Set 方法的代码\n                        generateGetSetMethods(structInfo)\n\n                    }\n                }\n                // ast.Print(fset, n)\n                return true\n            })\n        }\n    }\n}\n\nfunc generateGetSetMethods(structInfo StructInfo) {\n    tmpl := template.Must(template.New(\"\").Parse(getSetMethodsTemplate))\n\n    fileName := structInfo.Name + \"_getset.go\"\n    fmt.Println(fileName)\n    file, err := os.Create(fileName)\n    if err != nil {\n        fmt.Fprintf(os.Stderr, \"Failed to create file: %v\\n\", err)\n        os.Exit(1)\n    }\n    defer file.Close()\n\n    err = tmpl.Execute(file, structInfo)\n    if err != nil {\n        fmt.Fprintf(os.Stderr, \"Failed to generate code: %v\\n\", err)\n        os.Exit(1)\n    }\n\n    fmt.Printf(\"生成的文件 %s\\n\", fileName)\n}\n\nfunc fileSetToString(fset *token.FileSet, node ast.Node) string {\n    var buf strings.Builder\n    if err := printer.Fprint(&buf, fset, node); err != nil {\n        return \"\"\n    }\n    return buf.String()\n}\n\nconst getSetMethodsTemplate = `\n// Code generated by go generate; DO NOT EDIT.\n\npackage {{.PackageName}}\n\n{{range .Fields}}\nfunc (s *{{$.Name}}) Get{{.Name}}() {{.Type}} {\n    return s.{{.Name}}\n}\n\nfunc (s *{{$.Name}}) Set{{.Name}}(value {{.Type}}) {\n    s.{{.Name}} = value\n}\n{{end}}\n`\n\nfunc main() {\n    fmt.Println(111)\n    generateCode()\n}\n\n# 只会解析当前目录下的所有go文件\ngo generate # 会创建struct类型的 getset 方法 的go文件\n\n# 或者\ncd codegen\ngo build .\nmv codegen /usr/local/bin\n然后在注释中 这样写 也是ok的\n//go:generate codegen\n\n# 解析子目录 pkg 需要进去目录?\ncd pkg\ngo generate",
    "crumbs": [
      "工具与实用库",
      "generate"
    ]
  },
  {
    "objectID": "docs/go/pkg/go-generate.html#stringer",
    "href": "docs/go/pkg/go-generate.html#stringer",
    "title": "斯巴拉稀",
    "section": "3 stringer",
    "text": "3 stringer",
    "crumbs": [
      "工具与实用库",
      "generate"
    ]
  },
  {
    "objectID": "docs/go/pkg/gocron.html",
    "href": "docs/go/pkg/gocron.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "0.1 gocron\nimport \"github.com/go-co-op/gocron\"\nfunc sync() {\n    fmt.Println(1111)\n}\nfunc main() {\n\n    s := gocron.NewScheduler(time.Local)\n\n    s.Every(1).Seconds().Do(sync)\n    s.StartBlocking()\n    s.StartAsync()\n    test()\n\n}\n\n\n\n\n Back to top"
  },
  {
    "objectID": "docs/go/pkg/go-cache.html",
    "href": "docs/go/pkg/go-cache.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "import  \"github.com/patrickmn/go-cache\"\n\nfunc main() {\n    //c的items (map结构) 过期key清理时间 = DefaultExpiration + CleanupInterval\n    c := cache.New(time.Duration(100)*time.Second, time.Duration(10)*time.Second)\n    fmt.Println(c)\n    // 某个key过期被删除的时候会触发\n    c.OnEvicted(func(a string, b interface{}) {\n        fmt.Println(a, b)\n    })\n    // 这个key x的过期时间是 5+ cache.New里设置的cleanupInterval 时间\n    // 如果key 设置的 过期时间 =0 , 则使用默认的New里设置的过期时间\n    // -1的话 ,永不过期\n    c.Set(\"x\", \"y\", 0*time.Second)\n    select {}\n}\n\n\n\n Back to top"
  },
  {
    "objectID": "docs/go/pkg/cobra.html",
    "href": "docs/go/pkg/cobra.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "例子说明\n\n# server 是 command(action),  'port' 是 一个flag,改变暴露的端口,对行为的修饰\n# hugo 是 应用程序的名称\nhugo server --port=1313\n# git 是应用程序, clone 是command(action), URL 是Args, --bare是 flag\ngit clone URL --bare",
    "crumbs": [
      "工具与实用库",
      "cobra"
    ]
  },
  {
    "objectID": "docs/go/pkg/cobra.html#概念",
    "href": "docs/go/pkg/cobra.html#概念",
    "title": "斯巴拉稀",
    "section": "",
    "text": "例子说明\n\n# server 是 command(action),  'port' 是 一个flag,改变暴露的端口,对行为的修饰\n# hugo 是 应用程序的名称\nhugo server --port=1313\n# git 是应用程序, clone 是command(action), URL 是Args, --bare是 flag\ngit clone URL --bare",
    "crumbs": [
      "工具与实用库",
      "cobra"
    ]
  },
  {
    "objectID": "docs/go/pkg/cobra.html#实战",
    "href": "docs/go/pkg/cobra.html#实战",
    "title": "斯巴拉稀",
    "section": "2 实战",
    "text": "2 实战\ncobra github 文档 cobra-cli\n# 安装cobra-cli 用于代码生成\ngo install github.com/spf13/cobra-cli@latest\n\nmkdir my-app && cd my-app && cobra-cli init\n# 或者\ncobra-cli init my-app && cd my-app\ntree\n.\n├── LICENSE\n├── cmd\n│   └── root.go\n├── go.mod\n├── go.sum\n└── main.go\n\n2.1 根命令\n\n\ncmd/root.go\n\n--8&lt;-- \"go/.code/cobra/cmd/root.go\"\n\ngo build .\n./my-app -h\n\n\n2.2 添加命令\n# 接下来添加一个命令\ncobra-cli add serve\n# 会在 cmd目录下创建一个 serve.go 文件\n\n\ncmd/serve.go 做相关修改\n\n/*\nCopyright © 2023 NAME HERE &lt;EMAIL ADDRESS&gt;\n\n*/\npackage cmd\n\nimport (\n    \"errors\"\n    \"fmt\"\n\n    \"github.com/spf13/cobra\"\n)\n\nvar serveCmd = &cobra.Command{\n    Use:     \"serve\",                //  ./my-app -h 帮助信息显示的命令名\n    Short:   \"short serve\",          //  ./my-app -h 会看到\n    Long:    `A longer description`, //  ./my-app serve -h 会看到\n    Aliases: []string{\"s\"},          //   命令别名 ./my-app s 等同于 ./my-app serve\n    // 如果有错误, 就不要再显示 使用帮助了.\n    // 默认没设置是 false , 命令执行有错误, 会显示帮助\n    SilenceUsage: true,\n    PersistentPreRun: func(cmd *cobra.Command, args []string) {\n        fmt.Printf(\"serve PersistentPreRun run运行前 执行, 这个会被子命令继承,除非子命令自己写了自己的: %v\\n\", args)\n    },\n    PreRun: func(cmd *cobra.Command, args []string) {\n        fmt.Printf(\"run 运行前执行, 不会被子命令继承: %v\\n\", args)\n    },\n\n    Run: func(cmd *cobra.Command, args []string) {\n        fmt.Println(\"执行了 serve  子命令\")\n        // rootCmd 里设置的 全局config\n        config := cmd.Flags().Lookup(\"config\").Value\n        // cmd.Flags() 包含所有的flag\n        dirtyReload0 := cmd.Flags().Lookup(\"dirtyreload\").Value\n        // 获取 local flags\n        dirtyReload := cmd.LocalFlags().Lookup(\"dirtyreload\").Value\n        fmt.Println(dirtyReload0, dirtyReload)\n        // cmd.PersistentFlags()\n        fmt.Println(config)\n        // 参数\n        fmt.Println(\"args:\", args)\n    },\n    PostRun: func(cmd *cobra.Command, args []string) {\n        fmt.Printf(\"run 运行后执行, 不会被子命令继承: %v\\n\", args)\n    },\n    PersistentPostRun: func(cmd *cobra.Command, args []string) {\n        fmt.Printf(\"serve PersistentPostRun run运行后执行, 这个会被子命令继承,除非子命令自己写了自己的: %v\\n\", args)\n    },\n    // 如果不写这个 ,表示接收任意参数\n    Args: func(cmd *cobra.Command, args []string) error {\n        fmt.Println(\"所有 pre post run 之前执行\")\n        // 参数自定义验证\n        if len(args) &lt; 1 {\n            return errors.New(\"至少一个参数\")\n        }\n        fmt.Println(\"args:\", args)\n        // 返回nil 才会执行后续的run方法\n        return nil\n    },\n}\n\nfunc init() {\n    rootCmd.AddCommand(serveCmd)\n    serveCmd.Flags().Bool(\"dirtyreload\", false, \"Help message for dirty\")\n}\n\ngo build .\n./my-app s\n\n\n执行结果\n\n执行了 serve  命令\nfalse\n~/.my-app.yaml\n\n# 代码里 bool 类型的, 这里执行是 只要带上 就表示true\n# 当然也可以 --dirtyreload=true\n./my-app s --dirtyreload --config=./debug.yaml\n\n\n2.3 命令添加子命令\n\n\n给命令添加子命令\n\n# 默认 没有-p 指明的话, 就是给rootCmd添加命令\ncobra-cli add image -p 'serveCmd'\n\n\n\ncmd/image.go\n\n/*\nCopyright © 2023 NAME HERE &lt;EMAIL ADDRESS&gt;\n\n*/\npackage cmd\n\nimport (\n    \"fmt\"\n\n    \"github.com/spf13/cobra\"\n)\n\n// imageCmd represents the image command\nvar imageCmd = &cobra.Command{\n    Use:   \"image\",\n    Short: \"image A brief \",\n    Long:  `image A longer description.`,\n    RunE: func(cmd *cobra.Command, args []string) error {\n        fmt.Println(\"image called\")\n        // return errors.New(\"eeee\")\n        return nil\n\n    },\n    PersistentPostRun: func(cmd *cobra.Command, args []string) {\n        fmt.Printf(\"image PersistentPostRun: %v\\n\", args)\n    },\n    // 用cobra 提供的方法, 之前我们在serve 命令中用的自定义\n    Args: cobra.ExactArgs(1),\n\n    /*\n        这里的表示 只接收 这样的参数\n        Args:      cobra.OnlyValidArgs,\n        ValidArgs: []string{\"abc\", \"efg\"},\n    */\n}\n\nfunc init() {\n    serveCmd.AddCommand(imageCmd)\n}\n\ngo build .\n./my-app s image # 报错\n./my-app s image abc",
    "crumbs": [
      "工具与实用库",
      "cobra"
    ]
  },
  {
    "objectID": "docs/go/pkg/net.html",
    "href": "docs/go/pkg/net.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "0.1 获取ip地址\nfunc TestA(t *testing.T) {\n    netInterfaces, err := net.Interfaces()\n    if err != nil {\n        panic(err.Error())\n    }\n\n    for i := 0; i &lt; len(netInterfaces); i++ {\n        if (netInterfaces[i].Flags & net.FlagUp) != 0 {\n            addrs, _ := netInterfaces[i].Addrs()\n            for _, address := range addrs {\n                if ipNet, ok := address.(*net.IPNet); ok && !ipNet.IP.IsLoopback() {\n                    //获取IPv6\n                    /*if ipNet.IP.To16() != nil {\n                        fmt.Println(ipNet.IP.String())\n\n                    }*/\n                    //获取IPv4\n                    if ipNet.IP.To4() != nil {\n                        fmt.Println(ipNet.IP.String())\n\n                    }\n                }\n            }\n        }\n    }\n\n}\n\n\n\n\n Back to top"
  },
  {
    "objectID": "docs/rust/advanced/02.type.html#dst",
    "href": "docs/rust/advanced/02.type.html#dst",
    "title": "斯巴拉稀",
    "section": "1 DST",
    "text": "1 DST\nuse std::mem;\ntrait Summary {\n    fn summarize(&self) -&gt; String;\n    fn hello(&self) {\n        println!(\"hello\");\n    }\n}\nfn main() {\n    // 报错, 无法获取大小\n    println!(\"{}\", mem::size_of::&lt;Summary&gt;());\n}",
    "crumbs": [
      "进阶",
      "奇异的类型"
    ]
  },
  {
    "objectID": "docs/rust/advanced/02.type.html#zst",
    "href": "docs/rust/advanced/02.type.html#zst",
    "title": "斯巴拉稀",
    "section": "2 ZST",
    "text": "2 ZST\nuse std::mem;\nstruct Nothing; // No fields = no size\n                // All fields have no size = no size\nstruct LotsOfNothing {\n    foo: Nothing,\n    qux: (),      // empty tuple has no size\n    baz: [u8; 0], // empty array has no size\n}\n\nfn main() {\n    println!(\"{}\", mem::size_of::&lt;Nothing&gt;());\n    println!(\"{}\", mem::size_of::&lt;LotsOfNothing&gt;());\n    let a = Nothing {};\n    let b = &a;\n    println!(\"{}\", mem::size_of_val(&a)); // 0\n    println!(\"{:p}\", &a); // 0x7ff7b1bacf4f\n    println!(\"{:p}\", &b); // 0x7ff7b1bacf50\n    println!(\"{}\", mem::size_of_val(&b)); // 8\n}",
    "crumbs": [
      "进阶",
      "奇异的类型"
    ]
  },
  {
    "objectID": "docs/rust/advanced/02.type.html#空类型",
    "href": "docs/rust/advanced/02.type.html#空类型",
    "title": "斯巴拉稀",
    "section": "3 空类型",
    "text": "3 空类型\nuse std::mem;\nenum NoVariants {} // No variants = no size\nfn main() {\n    // 无法实例化\n    // let a = NoVariants;\n    println!(\"{}\", mem::size_of::&lt;NoVariants&gt;());\n}",
    "crumbs": [
      "进阶",
      "奇异的类型"
    ]
  },
  {
    "objectID": "docs/rust/advanced/02.type.html#repr",
    "href": "docs/rust/advanced/02.type.html#repr",
    "title": "斯巴拉稀",
    "section": "4 repr",
    "text": "4 repr\n\n4.1 repr(C)\n它的目的很简单, 就是和 C 保持一致. 数据的顺序,大小,对齐方式都和你在C 或C++中见到的一摸一样.\n我们前面在内存对齐看对Struct A的对齐方式和它的大小,这里我们使用repr(C)来定义Struct A\n#[repr(C)]\nstruct A {\n    a: u8,\n    b: u32,\n    c: u16,\n}\n\nuse std::mem;\nfn main() {\n    let x = A { a: 1, b: 2, c: 3 };\n    // 12\n    println!(\"{}\", mem::size_of_val(&x));\n    println!(\"0x{:p}-0x{:p}-0x{:p}\", &x.a, &x.b, &x.c);\n}\nTODO 特殊情况\n\nZSTs are still zero-sized …\n…\n\n\n\n4.2 repr(transparent)\n\n\n4.3 repr(u) repr(i)\n\n\n4.4 repr(packed)",
    "crumbs": [
      "进阶",
      "奇异的类型"
    ]
  },
  {
    "objectID": "docs/rust/web/axum/index.html",
    "href": "docs/rust/web/axum/index.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "TODO"
  },
  {
    "objectID": "docs/rust/web/axum/index.html#环境准备",
    "href": "docs/rust/web/axum/index.html#环境准备",
    "title": "斯巴拉稀",
    "section": "1 环境准备",
    "text": "1 环境准备\ncargo add axum\n# cargo add tokio --features macros,rt-multi-thread\ncargo add tokio  --features full\ncargo add serde_json"
  },
  {
    "objectID": "docs/rust/web/axum/index.html#样例",
    "href": "docs/rust/web/axum/index.html#样例",
    "title": "斯巴拉稀",
    "section": "2 样例",
    "text": "2 样例\nuse axum::{response::Html, routing::get, Json, Router};\nuse serde_json::{json, Value};\n#[tokio::main]\nasync fn main() {\n    // build our application with a single route\n    // get 请求\n    let app = Router::new().route(\"/\", get(index_handler)).route(\n        \"/foo\",\n        // get post 2个请求都设置\n        get(|| async { \"Hello, Foo!\" }).post(json_handler),\n    );\n\n    // run our app with hyper, listening globally on port 3000\n    let listener = tokio::net::TcpListener::bind(\"0.0.0.0:3000\").await.unwrap();\n    axum::serve(listener, app).await.unwrap();\n}\nasync fn index_handler() -&gt; Html&lt;&'static str&gt; {\n    Html(\"&lt;h1&gt;Hello, World!&lt;/h1&gt;\")\n}\n\n// `&'static str` becomes a `200 OK` with `content-type: text/plain;charset=utf-8`\nasync fn plain_text() -&gt; &'static str {\n    \"foo\"\n}\n// `Json` gives a content-type of `application/json` and works with any type\n// that implements `serde::Serialize`\nasync fn json_handler() -&gt; Json&lt;Value&gt; {\n    Json(json!({ \"data\": 42 }))\n}\ngithub1 github2"
  },
  {
    "objectID": "docs/rust/web/axum/index.html#footnotes",
    "href": "docs/rust/web/axum/index.html#footnotes",
    "title": "斯巴拉稀",
    "section": "Footnotes",
    "text": "Footnotes\n\n\naxum: https://github.com/tokio-rs/axum↩︎\naxum生态: https://github.com/tokio-rs/axum/blob/main/ECOSYSTEM.md#tutorials↩︎"
  },
  {
    "objectID": "docs/rust/web/net.html",
    "href": "docs/rust/web/net.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "hello.html\n\n&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n  &lt;head&gt;\n    &lt;meta charset=\"utf-8\"&gt;\n    &lt;title&gt;Hello!&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;h1&gt;Hello!&lt;/h1&gt;\n    &lt;p&gt;Hi from Rust&lt;/p&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n\n\n\nsrc/main.rs\n\nuse std::{\n    fs,\n    io::{prelude::*, BufReader},\n    net::{TcpListener, TcpStream},\n};\nfn main() {\n    let listener = TcpListener::bind(\"127.0.0.1:7878\").unwrap();\n\n    for stream in listener.incoming() {\n        // 每一个stream 表示 客户端和服务端之间的链接\n        // 包含客户端发送来的数据\n        let stream = stream.unwrap();\n\n        handle_connection(stream);\n    }\n}\n\nfn handle_connection(mut stream: TcpStream) {\n    let buf_reader = BufReader::new(&mut stream);\n    let http_request: Vec&lt;_&gt; = buf_reader\n        .lines()\n        .map(|result| result.unwrap())\n        .take_while(|line| !line.is_empty())\n        .collect();\n\n    println!(\"Request: {:#?}\", http_request);\n\n    // response\n    let status_line = \"HTTP/1.1 200 OK\";\n    let contents = fs::read_to_string(\"hello.html\").unwrap();\n    let length = contents.len();\n\n    let response = format!(\"{status_line}\\r\\nContent-Length: {length}\\r\\n\\r\\n{contents}\");\n\n    stream.write_all(response.as_bytes()).unwrap();\n}\n\nfn handle_connection2(mut stream: TcpStream) {\n    let buf_reader = BufReader::new(&mut stream);\n    let request_line = buf_reader.lines().next().unwrap().unwrap();\n\n    if request_line == \"GET / HTTP/1.1\" {\n        let status_line = \"HTTP/1.1 200 OK\";\n        let contents = fs::read_to_string(\"hello.html\").unwrap();\n        let length = contents.len();\n\n        let response = format!(\n            \"{status_line}\\r\\nContent-Length: {length}\\r\\n\\r\\n{contents}\"\n        );\n\n        stream.write_all(response.as_bytes()).unwrap();\n    } else {\n        let status_line = \"HTTP/1.1 404 NOT FOUND\";\n        // 再弄个 404.html \n        let contents = fs::read_to_string(\"404.html\").unwrap();\n        let length = contents.len();\n\n        let response = format!(\n            \"{status_line}\\r\\nContent-Length: {length}\\r\\n\\r\\n{contents}\"\n        );\n\n        stream.write_all(response.as_bytes()).unwrap();\n    }\n}\n\n运行后,"
  },
  {
    "objectID": "docs/rust/web/net.html#单线程",
    "href": "docs/rust/web/net.html#单线程",
    "title": "斯巴拉稀",
    "section": "",
    "text": "hello.html\n\n&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n  &lt;head&gt;\n    &lt;meta charset=\"utf-8\"&gt;\n    &lt;title&gt;Hello!&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;h1&gt;Hello!&lt;/h1&gt;\n    &lt;p&gt;Hi from Rust&lt;/p&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n\n\n\nsrc/main.rs\n\nuse std::{\n    fs,\n    io::{prelude::*, BufReader},\n    net::{TcpListener, TcpStream},\n};\nfn main() {\n    let listener = TcpListener::bind(\"127.0.0.1:7878\").unwrap();\n\n    for stream in listener.incoming() {\n        // 每一个stream 表示 客户端和服务端之间的链接\n        // 包含客户端发送来的数据\n        let stream = stream.unwrap();\n\n        handle_connection(stream);\n    }\n}\n\nfn handle_connection(mut stream: TcpStream) {\n    let buf_reader = BufReader::new(&mut stream);\n    let http_request: Vec&lt;_&gt; = buf_reader\n        .lines()\n        .map(|result| result.unwrap())\n        .take_while(|line| !line.is_empty())\n        .collect();\n\n    println!(\"Request: {:#?}\", http_request);\n\n    // response\n    let status_line = \"HTTP/1.1 200 OK\";\n    let contents = fs::read_to_string(\"hello.html\").unwrap();\n    let length = contents.len();\n\n    let response = format!(\"{status_line}\\r\\nContent-Length: {length}\\r\\n\\r\\n{contents}\");\n\n    stream.write_all(response.as_bytes()).unwrap();\n}\n\nfn handle_connection2(mut stream: TcpStream) {\n    let buf_reader = BufReader::new(&mut stream);\n    let request_line = buf_reader.lines().next().unwrap().unwrap();\n\n    if request_line == \"GET / HTTP/1.1\" {\n        let status_line = \"HTTP/1.1 200 OK\";\n        let contents = fs::read_to_string(\"hello.html\").unwrap();\n        let length = contents.len();\n\n        let response = format!(\n            \"{status_line}\\r\\nContent-Length: {length}\\r\\n\\r\\n{contents}\"\n        );\n\n        stream.write_all(response.as_bytes()).unwrap();\n    } else {\n        let status_line = \"HTTP/1.1 404 NOT FOUND\";\n        // 再弄个 404.html \n        let contents = fs::read_to_string(\"404.html\").unwrap();\n        let length = contents.len();\n\n        let response = format!(\n            \"{status_line}\\r\\nContent-Length: {length}\\r\\n\\r\\n{contents}\"\n        );\n\n        stream.write_all(response.as_bytes()).unwrap();\n    }\n}\n\n运行后,"
  },
  {
    "objectID": "docs/rust/web/net.html#多线程版本",
    "href": "docs/rust/web/net.html#多线程版本",
    "title": "斯巴拉稀",
    "section": "2 多线程版本",
    "text": "2 多线程版本\n这个版本, 每一个请求, 都会开启一个线程,没有限制了, 不断访问,可就产生很多的线程,服务器要完\nuse std::net::{TcpListener, TcpStream};\nuse std::thread;\nfn main() {\n    let listener = TcpListener::bind(\"127.0.0.1:7878\").unwrap();\n\n    for stream in listener.incoming() {\n        let stream = stream.unwrap();\n\n        thread::spawn(|| {\n            handle_connection(stream);\n        });\n    }\n}\n\nfn handle_connection(mut stream: TcpStream) {}\n使用线程池,设计了一个线程池\n\n\nsrc/main.rs\n\nuse hello::ThreadPool;\nuse std::fs;\nuse std::io::prelude::*;\nuse std::net::TcpListener;\nuse std::net::TcpStream;\nuse std::thread;\nuse std::time::Duration;\n\nfn main() {\n    let listener = TcpListener::bind(\"127.0.0.1:7878\").unwrap();\n    let pool = ThreadPool::new(4);\n\n    for stream in listener.incoming().take(2) {\n        let stream = stream.unwrap();\n\n        pool.execute(|| {\n            handle_connection(stream);\n        });\n    }\n\n    println!(\"Shutting down.\");\n}\n\nfn handle_connection(mut stream: TcpStream) {\n    let mut buffer = [0; 1024];\n    stream.read(&mut buffer).unwrap();\n\n    let get = b\"GET / HTTP/1.1\\r\\n\";\n    let sleep = b\"GET /sleep HTTP/1.1\\r\\n\";\n\n    let (status_line, filename) = if buffer.starts_with(get) {\n        (\"HTTP/1.1 200 OK\", \"hello.html\")\n    } else if buffer.starts_with(sleep) {\n        thread::sleep(Duration::from_secs(5));\n        (\"HTTP/1.1 200 OK\", \"hello.html\")\n    } else {\n        (\"HTTP/1.1 404 NOT FOUND\", \"404.html\")\n    };\n\n    let contents = fs::read_to_string(filename).unwrap();\n\n    let response = format!(\n        \"{}\\r\\nContent-Length: {}\\r\\n\\r\\n{}\",\n        status_line,\n        contents.len(),\n        contents\n    );\n\n    stream.write_all(response.as_bytes()).unwrap();\n    stream.flush().unwrap();\n}\n\n\n\nsrc/lib.rs\n\nuse std::{\n    sync::{mpsc, Arc, Mutex},\n    thread,\n};\n\npub struct ThreadPool {\n    workers: Vec&lt;Worker&gt;,\n    sender: Option&lt;mpsc::Sender&lt;Job&gt;&gt;,\n}\n\ntype Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;\n\nimpl ThreadPool {\n    /// Create a new ThreadPool.\n    ///\n    /// The size is the number of threads in the pool.\n    ///\n    /// # Panics\n    ///\n    /// The `new` function will panic if the size is zero.\n    pub fn new(size: usize) -&gt; ThreadPool {\n        assert!(size &gt; 0);\n\n        let (sender, receiver) = mpsc::channel();\n\n        let receiver = Arc::new(Mutex::new(receiver));\n\n        let mut workers = Vec::with_capacity(size);\n\n        for id in 0..size {\n            workers.push(Worker::new(id, Arc::clone(&receiver)));\n        }\n\n        ThreadPool {\n            workers,\n            sender: Some(sender),\n        }\n    }\n    // 模拟 thread spawn\n    pub fn execute&lt;F&gt;(&self, f: F)\n    where\n        F: FnOnce() + Send + 'static,\n    {\n        let job = Box::new(f);\n\n        self.sender.as_ref().unwrap().send(job).unwrap();\n    }\n}\n// 优雅退出\nimpl Drop for ThreadPool {\n    fn drop(&mut self) {\n        drop(self.sender.take());\n\n        for worker in &mut self.workers {\n            println!(\"Shutting down worker {}\", worker.id);\n\n            if let Some(thread) = worker.thread.take() {\n                thread.join().unwrap();\n            }\n        }\n    }\n}\n\nstruct Worker {\n    id: usize,\n    thread: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,\n}\n\nimpl Worker {\n    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {\n        let thread = thread::spawn(move || loop {\n            let message = receiver.lock().unwrap().recv();\n\n            match message {\n                Ok(job) =&gt; {\n                    println!(\"Worker {id} got a job; executing.\");\n\n                    job();\n                }\n                Err(_) =&gt; {\n                    println!(\"Worker {id} disconnected; shutting down.\");\n                    break;\n                }\n            }\n        });\n\n        Worker {\n            id,\n            thread: Some(thread),\n        }\n    }\n}"
  },
  {
    "objectID": "docs/rust/basic/09.lifetime.html",
    "href": "docs/rust/basic/09.lifetime.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "fn main() {\n    let r;\n\n    {\n        let x = 5;\n        r = &x;\n    }    // x 离开作用域，其值被丢弃\n\n    println!(\"r: {}\", r);\n}\ncargo run \n --&gt; src/main.rs:6:13\n  |\n5 |         let x = 5;\n  |             - binding `x` declared here\n6 |         r = &x;\n  |             ^^ borrowed value does not live long enough\n7 |     }\n  |     - `x` dropped here while still borrowed\n8 |\n9 |     println!(\"r: {}\", r);\n  |                       - borrow later used here\nrust编译器 如何发现问题的呢?",
    "crumbs": [
      "基础篇",
      "生命周期"
    ]
  },
  {
    "objectID": "docs/rust/basic/09.lifetime.html#先看个例子",
    "href": "docs/rust/basic/09.lifetime.html#先看个例子",
    "title": "斯巴拉稀",
    "section": "",
    "text": "fn main() {\n    let r;\n\n    {\n        let x = 5;\n        r = &x;\n    }    // x 离开作用域，其值被丢弃\n\n    println!(\"r: {}\", r);\n}\ncargo run \n --&gt; src/main.rs:6:13\n  |\n5 |         let x = 5;\n  |             - binding `x` declared here\n6 |         r = &x;\n  |             ^^ borrowed value does not live long enough\n7 |     }\n  |     - `x` dropped here while still borrowed\n8 |\n9 |     println!(\"r: {}\", r);\n  |                       - borrow later used here\nrust编译器 如何发现问题的呢?",
    "crumbs": [
      "基础篇",
      "生命周期"
    ]
  },
  {
    "objectID": "docs/rust/basic/09.lifetime.html#借用检查器",
    "href": "docs/rust/basic/09.lifetime.html#借用检查器",
    "title": "斯巴拉稀",
    "section": "2 借用检查器",
    "text": "2 借用检查器\nThe Borrow Checker\nrust编译器 有一个 borrow checker 它会比较作用域来判断所有借用是否合法\n标注上变量的生命周期,我们看看\nfn main() {\n    let r;                // ---------+-- 'a\n                          //          |\n    {                     //          |\n        let x = 5;        // -+-- 'b  |\n        r = &x;           //  |       |\n    }                     // -+       |\n                          //          |\n    println!(\"r: {}\", r); //          |\n}                         // ---------+\n这里用 ’a 表示 变量r 的生命周期, ’b 表示变量x 的生命周期 变量r的生命周期 ’a 比 ’b 长 , 但是使用了’b 生命周期中的 x, 而这个时候’b 已经结束了,x不可用了\n将上面的代码修改成如下,就ok了\nfn main() {\n    let x = 5;            // ----------+-- 'b\n                          //           |\n    let r = &x;           // --+-- 'a  |\n                          //   |       |\n    println!(\"r: {}\", r); //   |       |\n                          // --+       |\n}                         // ----------+",
    "crumbs": [
      "基础篇",
      "生命周期"
    ]
  },
  {
    "objectID": "docs/rust/basic/09.lifetime.html#函数参数的生命周期",
    "href": "docs/rust/basic/09.lifetime.html#函数参数的生命周期",
    "title": "斯巴拉稀",
    "section": "3 函数参数的生命周期",
    "text": "3 函数参数的生命周期\n每个引用都有生命周期, 就是他的有效的作用域. 标注生命周期不会改变原来变量的生命周期,因为有些时候 编译器在运行时会发生什么事, 标注只是为了帮助编译器理解其中的生命周期(借用之间的相互关系),如果违反实际生命周期，编译器也是会拒绝编译的.\n\n// 编译器无法通过观察静态代码分析出返回的到底是x, 还是y\nfn longest(x: &str, y: &str) -&gt; &str {\n    if x.len() &gt; y.len() {\n        x\n    } else {\n        y\n    }\n}\nfn main() {\n    let string1 = String::from(\"abcd\");\n    let string2 = \"xyz\";\n\n    let result = longest(string1.as_str(), string2);\n    println!(\"The longest string is {}\", result);\n}",
    "crumbs": [
      "基础篇",
      "生命周期"
    ]
  },
  {
    "objectID": "docs/rust/basic/09.lifetime.html#生命周期的标注",
    "href": "docs/rust/basic/09.lifetime.html#生命周期的标注",
    "title": "斯巴拉稀",
    "section": "4 生命周期的标注",
    "text": "4 生命周期的标注\n使用 ’a ’b 这种 单个简单字母, 放在 &后面\n&i32        // 一个借用\n&'a i32     // 一个带有显式生命周期的借用\n&'a mut i32 //\n\n\n\n\n\n\nTip\n\n\n\nThe function signature now\n\ntells Rust that for some lifetime ’a\ntells Rust two parameters that the function takes will live at least as long as lifetime ’a.\ntells Rust that the string slice returned from the function will live at least as long as lifetime ’a\n\n\n\n// 我们将前面的代码加上生命周期标注\nfn longest&lt;'a&gt;(x: &'a str, y: &'a str) -&gt; &'a str {\n    if x.len() &gt; y.len() {\n        x\n    } else {\n        y\n    }\n}\n//it means that the lifetime of the reference returned by the longest function is the same as the smaller of the lifetimes of the values referred to by the function arguments\n正确的例子\nfn longest&lt;'a&gt;(x: &'a str, y: &'a str) -&gt; &'a str {\n    if x.len() &gt; y.len() {\n        x\n    } else {\n        y\n    }\n}\nfn main() {\n    let string1 = String::from(\"long string is long\");\n    let result;\n    {\n        let string2 = \"xyz\";\n        result = longest(string1.as_str(), string2);\n    } // string2 所借用的 xyz 这个数据实际是在 静态内存中分配的,所以到这里, 没有被free掉\n      // println!(\"{}\", string2); 注意这个还是会报错的, 因为变量string2 已经不可用了\n      // OK,\n    println!(\"The longest string is {}\", result);\n}\n错误的例子\nfn longest&lt;'a&gt;(x: &'a str, y: &'a str) -&gt; &'a str {\n    if x.len() &gt; y.len() {\n        x\n    } else {\n        y\n    }\n}\nfn main() {\n    let string1 = String::from(\"long string is long\");\n    let result;\n    {\n        let string2 = String::from(\"xyz\");\n        result = longest(string1.as_str(), string2.as_str());\n    } // 这个时候 string2 指向的 xyz (在堆上) 已经被free了\n    println!(\"The longest string is {}\", result);\n}\ny不需要标注, 因为与x和返回值 没有任何关系\nfn longest&lt;'a&gt;(x: &'a str, y: &str) -&gt; &'a str {\n    x\n}",
    "crumbs": [
      "基础篇",
      "生命周期"
    ]
  },
  {
    "objectID": "docs/rust/basic/09.lifetime.html#结构体中的生命周期",
    "href": "docs/rust/basic/09.lifetime.html#结构体中的生命周期",
    "title": "斯巴拉稀",
    "section": "5 结构体中的生命周期",
    "text": "5 结构体中的生命周期\nstruct Book&lt;'a&gt; {\n    title: &'a str,\n    author: &'a str,\n}\n\nfn main() {\n    let title = \"The Rust Programming Language\";\n    let author = \"Steve Klabnik and Carol Nichols\";\n    let book = Book { title, author };\n\n    println!(\"Book title: {}\", book.title);\n    println!(\"Book author: {}\", book.author);\n}\n生命周期标注 ’a 表明这两个字段的生命周期是相同的，并且它们至少活得和 Book 实例一样久\n如果没有生命周期标注，Rust 编译器就无法确定 title 和 author 引用的数据是否会在 Book 实例之前被释放。生命周期标注提供了一种方式，让编译器能够检查引用是否在有效范围内，从而确保内存安全",
    "crumbs": [
      "基础篇",
      "生命周期"
    ]
  },
  {
    "objectID": "docs/rust/basic/09.lifetime.html#生命周期的省略",
    "href": "docs/rust/basic/09.lifetime.html#生命周期的省略",
    "title": "斯巴拉稀",
    "section": "6 生命周期的省略",
    "text": "6 生命周期的省略\n// 早期像这样的,都是需要 进行生命周期标注的\n// fn first_word(s: &str) -&gt; &str {\nfn first_word&lt;'a&gt;(s: &'a str) -&gt; &'a str {\n    let bytes = s.as_bytes();\n\n    for (i, &item) in bytes.iter().enumerate() {\n        if item == b' ' {\n            return &s[0..i];\n        }\n    }\n    &s[..]\n}\n\n6.1 三个规则\n\n\n\n\n\n\nNote\n\n\n\n\nrust的开发人员注意到, 每次都要写很多这种标注, 很麻烦, 于是总结了一些规则,让编译器自动处理\n生命周期在函数的参数时,被称为输入生命周期\n生命周期在函数的返回值时,被称为输出生命周期\n\n\n\n\n每个引用参数都有自己的生命周期参数\n如果只有一个输入生命周期参数，那么它被赋予所有输出生命周期参数\n如果有多个输入生命周期参数, 且其中一个是&self 或 &mut self(是方法), 则self的生命周期会被赋予所有的输出生命周期参数\n\n如果编译器应用完这3个规则,还有无法确定生命周期的借用,那么就报错\n// 我们写的代码\nfn first_word(s: &str) -&gt; &str {}\n// 1. 编译器应用第一条规则后\nfn first_word&lt;'a&gt;(s: &'a str) -&gt; &str {}\n// 2. 编译器应用第二条规则后\nfn first_word&lt;'a&gt;(s: &'a str) -&gt; &'a str {}\n\n// 我们写的代码\nfn longest(x: &str, y: &str) -&gt; &str {}\n// 1. 编译器应用第一条规则后\nfn longest&lt;'a, 'b&gt;(x: &'a str, y: &'b str) -&gt; &str {\n// 2. 编译器应用第二条规则,发现有多个输入参数,pass\n// 3. 编译器应用第三条规则,发现是个函数,不是方法,pass\n//  结果, 返回值的生命周期 还是不确定, 所以报错了\n\n\n结构体方法生命周期\n// 需要在 impl后面申明,这个生命周期是结构体类型的一部分\nimpl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {\n    fn level(&self) -&gt; i32 {\n        3\n    }\n}\n// 1. 编译器应用第一条规则, &'a self, 所以我们不用标注了\n\n// 我们来看看方法中多个参数的情况,\nimpl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {\n    fn announce_and_return_part(&self, announcement: &str) -&gt; &str {\n        println!(\"Attention please: {}\", announcement);\n        self.part\n    }\n}\n// 1. 编译器应用第一条规则后,\n    fn announce_and_return_part(&'a self, announcement: &'a str) -&gt; &str {}\n// 2. 编译器应用第三条规则后,\n    fn announce_and_return_part&lt;'a&gt;(&'a self, announcement: &'a str) -&gt; &'a str {}",
    "crumbs": [
      "基础篇",
      "生命周期"
    ]
  },
  {
    "objectID": "docs/rust/basic/09.lifetime.html#静态生命周期",
    "href": "docs/rust/basic/09.lifetime.html#静态生命周期",
    "title": "斯巴拉稀",
    "section": "7 静态生命周期",
    "text": "7 静态生命周期\n\n\n\n\n\n\nTip\n\n\n\n整个程序的持续时间就是静态生命周期\n\n\nlet s: &'static str = \"I have a static lifetime.\";",
    "crumbs": [
      "基础篇",
      "生命周期"
    ]
  },
  {
    "objectID": "docs/rust/basic/09.lifetime.html#泛型trait约束中使用",
    "href": "docs/rust/basic/09.lifetime.html#泛型trait约束中使用",
    "title": "斯巴拉稀",
    "section": "8 泛型,trait约束中使用",
    "text": "8 泛型,trait约束中使用\n\n\n\n\n\n\nImportant\n\n\n\nlifetimes are a type of generic,所以会将它和泛型T的申明放在一起\n\n\nuse std::fmt::Display;\n\nfn longest_with_an_announcement&lt;'a, T&gt;(\n    x: &'a str,\n    y: &'a str,\n    ann: T,\n) -&gt; &'a str\nwhere\n    T: Display,\n{\n    println!(\"Announcement! {}\", ann);\n    if x.len() &gt; y.len() {\n        x\n    } else {\n        y\n    }\n}",
    "crumbs": [
      "基础篇",
      "生命周期"
    ]
  },
  {
    "objectID": "docs/rust/basic/13.cargo.html",
    "href": "docs/rust/basic/13.cargo.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "发布的配置信息, 是预定义好的,可自定义\n\ncargo build\n    Finished dev [unoptimized + debuginfo] target(s) in 0.0s\ncargo build --release\n    Finished release [optimized] target(s) in 0.0s\n我们运行2个命令看看, 看到 dev 和 release, 实际就是使用了不同的默认配置 dev默认的一些配置\n[profile.dev]\nopt-level = 0\ndebug = true\nsplit-debuginfo = '...'  # Platform-specific.\nstrip = \"none\"\ndebug-assertions = true\noverflow-checks = true\nlto = false\npanic = 'unwind'\nincremental = true\ncodegen-units = 256\nrpath = false\n我们可以通过修改Cargo.toml来覆盖一些默认配置\n[package]\nname = \"world\"\nversion = \"0.1.0\"\nedition = \"2021\"\n[dependencies]\nrand = \"0.8.5\"\n[profile.dev] # dev 配置\nopt-level = 1\n[profile.release] # release 配置\nopt-level = 3\n修改完后, 我们再次编译可以看到 optimized\ncargo build\n    Finished dev [optimized + debuginfo] target(s) in 3.14s\ndependencies的三种方式\n[dependencies]\nclap = \"2.27.1\" # from crates.io\nrand = { git = \"https://github.com/rust-lang-nursery/rand\" } # from online repo\nbar = { path = \"../bar\" } # from a path in the local filesystem",
    "crumbs": [
      "基础篇",
      "cargo"
    ]
  },
  {
    "objectID": "docs/rust/basic/13.cargo.html#配置文件",
    "href": "docs/rust/basic/13.cargo.html#配置文件",
    "title": "斯巴拉稀",
    "section": "",
    "text": "发布的配置信息, 是预定义好的,可自定义\n\ncargo build\n    Finished dev [unoptimized + debuginfo] target(s) in 0.0s\ncargo build --release\n    Finished release [optimized] target(s) in 0.0s\n我们运行2个命令看看, 看到 dev 和 release, 实际就是使用了不同的默认配置 dev默认的一些配置\n[profile.dev]\nopt-level = 0\ndebug = true\nsplit-debuginfo = '...'  # Platform-specific.\nstrip = \"none\"\ndebug-assertions = true\noverflow-checks = true\nlto = false\npanic = 'unwind'\nincremental = true\ncodegen-units = 256\nrpath = false\n我们可以通过修改Cargo.toml来覆盖一些默认配置\n[package]\nname = \"world\"\nversion = \"0.1.0\"\nedition = \"2021\"\n[dependencies]\nrand = \"0.8.5\"\n[profile.dev] # dev 配置\nopt-level = 1\n[profile.release] # release 配置\nopt-level = 3\n修改完后, 我们再次编译可以看到 optimized\ncargo build\n    Finished dev [optimized + debuginfo] target(s) in 3.14s\ndependencies的三种方式\n[dependencies]\nclap = \"2.27.1\" # from crates.io\nrand = { git = \"https://github.com/rust-lang-nursery/rand\" } # from online repo\nbar = { path = \"../bar\" } # from a path in the local filesystem",
    "crumbs": [
      "基础篇",
      "cargo"
    ]
  },
  {
    "objectID": "docs/rust/basic/13.cargo.html#文档",
    "href": "docs/rust/basic/13.cargo.html#文档",
    "title": "斯巴拉稀",
    "section": "2 文档",
    "text": "2 文档\n\n2.1 注释\n生成HTML文档,显示如何使用API\n我们 在src/lib.rs中添加一些文档注释\n\n\nsrc/lib.rs\n\n1//! # My Crate\n//!\n//! `my_crate` is a collection of utilities to make performing certain\n//! calculations more convenient.\n\n/// Adds one to the number given.\n///\n2/// # Examples\n///\n/// ```\n3/// let arg = 5;\n/// let answer = my_crate::add_one(arg);\n///\n/// assert_eq!(6, answer);\n/// ```\npub fn add_one(x: i32) -&gt; i32 {\n    x + 1\n}\n\n\n1\n\n描述 我们要发布的 整个crate, 使用 //!\n\n2\n\n使用 ///,可以用markdown 语法  Example 是一个常见的我们要去写的区域,后面写上示例Panics: 描述可能发生panic的场景 Errors: 如何函数返回Result,描述可能的错误种类,以及导致错误的条件Safty: 如果函数处于unsafe调用, 那么就描述使用unsafe的原因和使用的前提\n\n3\n\n使用cargo test 会测试这里的代码, 注意 需要将 示例代码里使用的 my_crate改成 Cargo.toml中 [package] 的 name\n\n\n# --open 会直接打开 生成的 html\ncargo doc --open\n# 会测试 文档注释中的代码\ncargo test\n   Doc-tests ....\n\n\n2.2 pub use\n\nsrc/lib.rssrc/main.rs\n\n\n//! # Art\n//!\n//! A library for modeling artistic concepts.\n\n// --加上这些--\n1pub use self::kinds::PrimaryColor;\npub use self::kinds::SecondaryColor;\npub use self::utils::mix;\n//  -----\n\npub mod kinds {\n    /// The primary colors according to the RYB color model.\n    pub enum PrimaryColor {\n        Red,\n        Yellow,\n        Blue,\n    }\n\n    /// The secondary colors according to the RYB color model.\n    pub enum SecondaryColor {\n        Orange,\n        Green,\n        Purple,\n    }\n}\n\npub mod utils {\n    use crate::kinds::*;\n\n    /// Combines two primary colors in equal amounts to create\n    /// a secondary color.\n    pub fn mix(c1: PrimaryColor, c2: PrimaryColor) -&gt; SecondaryColor {\n        SecondaryColor::Orange\n    }\n}\n\n1\n\n这样生成的文档方便用户查看,不需要点击多次才能看到\n\n\n\n\n// use art::kinds::PrimaryColor;\n// use art::utils::mix;\n\n// 在lib.rs 添加 pub use 后, 这里可以这样了,生成的文档也方便用户使用\nuse art::mix;\nuse art::PrimaryColor;\n\nfn main() {\n    let red = PrimaryColor::Red;\n    let yellow = PrimaryColor::Yellow;\n    mix(red, yellow);\n}\n\n\n\ncargo doc --open # 查看一下",
    "crumbs": [
      "基础篇",
      "cargo"
    ]
  },
  {
    "objectID": "docs/rust/basic/13.cargo.html#发布crate到crate.io",
    "href": "docs/rust/basic/13.cargo.html#发布crate到crate.io",
    "title": "斯巴拉稀",
    "section": "3 发布crate到crate.io",
    "text": "3 发布crate到crate.io\n\n3.1 登录crate.io获取token\n登录crate.io后,进入settings页面, 生成一个token\n# 该命令会将token 存储在 ~/.cargo/credentials\ncargo login abcdefghijklmnopqrstuvwxyz012345\n\n\n3.2 修改Cargo.toml\n[package]\n1name = \"guessing_game\"\nversion = \"0.1.0\"\nedition = \"2021\"\n2description = \"该描述会显示在crate.io的搜索结果里\"\n3license = \"MIT OR Apache-2.0\"\n[dependencies]\n\n1\n\n名字在crate.io中必须是独一无二的\n\n2\n\n必填项\n\n3\n\n必填项,许可标识值可在spdx上查找\n\n\n\n\n3.3 发布\ncargo publish\n发布已存在crate的新版本, 需要修改 toml文件中的 version 参考 http://semver.org/, 再执行cargo publish 即可\n\n\n3.4 cargo yank 撤回\n\n首先 crate.io 是不能让你删除已经发布的版本的,因为如果已经有人用了怎么办\n但是可以让你撤回,它的意思是, 防止新的用户使用这个可能不太好的版本,cargo add xxxx 后不会使用到这个撤回的版本, 如果是已经使用了这个版本的人(Cargo.lock里指定了版本了), 还是可以下载使用的\n\ncargo yank --vers 1.0.1\n    Updating crates.io index\n        Yank guessing_game@1.0.1\n# 取消 yank\ncargo yank --vers 1.0.1 --undo\n    Updating crates.io index\n      Unyank guessing_game@1.0.1",
    "crumbs": [
      "基础篇",
      "cargo"
    ]
  },
  {
    "objectID": "docs/rust/basic/13.cargo.html#工作空间",
    "href": "docs/rust/basic/13.cargo.html#工作空间",
    "title": "斯巴拉稀",
    "section": "4 工作空间",
    "text": "4 工作空间\n\n4.1 创建\nmkdir add\ncd add \ntouch Cargo.toml\nresolver-versions\n\n\nCargo.toml\n\n[workspace]\n\nmembers = [\n    \"adder\",\n]\nresolver = \"2\"\n\n# 添加 binary crate\ncargo new adder\ncargo build\ntree -L 2\n    .\n    ├── Cargo.lock\n    ├── Cargo.toml\n    ├── adder\n    │   ├── Cargo.toml\n    │   └── src\n    └── target # 存放所有members 编译后的东西\n        ├── CACHEDIR.TAG\n        └── debug\ncd adder\n# 我们没有看到在这个adder目录下生成target目录\n# 还是会在 外层的 target 目录下生成\ncargo build\n\n# 添加一个 lib crate\n# 该命令会在 Cargo.toml的 members 里自动添加\ncargo new add_one --lib\ntree -L 2\n    ├── Cargo.lock\n    ├── Cargo.toml\n    ├── add_one\n    │   ├── Cargo.toml\n    │   └── src\n    │       └── lib.rs\n    ├── adder\n    │   ├── Cargo.toml\n    │   └── src\n    │       └── main.rs\n    └── target\n\n\n在add_one/src/lib.rs添加一个方法\n\npub fn add_one(x: i32) -&gt; i32 {\n    x + 1\n}\n\n现在我们要在adder 中依赖add_one这个库,需要在adder/Cargo.toml中添加\n\n\nadder/Cargo.toml\n\n[package]\nname = \"adder\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[dependencies]\nadd_one = { path = \"../add_one\" }\n\n\n\nadder/src/main.rs\n\nuse add_one;\n\nfn main() {\n    let num = 10;\n    println!(\"Hello, world! {num} plus one is {}!\", add_one::add_one(num));\n}\n\n# 运行指定 binary crate\ncargo run  -p adder\n\n\n4.2 使用外部crate\nadder/Cargo.toml[dependencies]中添加rand = \"0.8.1\",然后在add_one/Cargo.toml[dependencies]中添加rand = \"0.8.5\"后, cargo build 只会在外层Cargo.lock中生成一个rand版本.这样工作空间中的crate 都会使用同一个版本的rand\n\n\n4.3 测试\n# 在add目录下\n# 会test 工作空间中所有的crate\ncargo test\n# 指定\ncargo test -p adder",
    "crumbs": [
      "基础篇",
      "cargo"
    ]
  },
  {
    "objectID": "docs/rust/basic/13.cargo.html#安装二进制crate",
    "href": "docs/rust/basic/13.cargo.html#安装二进制crate",
    "title": "斯巴拉稀",
    "section": "5 安装二进制crate",
    "text": "5 安装二进制crate\n只能安装具有 binary target的 crate (binary crate)\n# 会安装到 $HOME/.cargo/bin 目录\ncargo install ripgrep",
    "crumbs": [
      "基础篇",
      "cargo"
    ]
  },
  {
    "objectID": "docs/rust/basic/13.cargo.html#自定义命令扩展",
    "href": "docs/rust/basic/13.cargo.html#自定义命令扩展",
    "title": "斯巴拉稀",
    "section": "6 自定义命令扩展",
    "text": "6 自定义命令扩展\n在系统中你可以直接运行的一个命令 名字是cargo-xxxx,那么你就可以运行cargo xxxx 这样来替代运行它, cargo --list 可以查看到.\n我们在安装rust后, 可以在~/.cargo/bin 看到一些可执行文件, cargo-fmt 就是其中的一个, 我们可以发现有cargo fmt这个命令,就像cargo 的内置命令一样",
    "crumbs": [
      "基础篇",
      "cargo"
    ]
  },
  {
    "objectID": "docs/rust/basic/11.closure.html",
    "href": "docs/rust/basic/11.closure.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "Tip\n\n\n\n\nclosures can capture values from the scope in which they’re defined\n可以捕获其所在环境的匿名函数\n\n在它定义的作用域中捕获值\n\n\n\n\nfn main() {\n    fn add_one_v1(x: u32) -&gt; u32 {\n        x + 1\n    }\n    // 闭包,匿名函数, |参数|-&gt;返回值 { 函数体}\n    let add_one_v2 = |x: u32| -&gt; u32 { x + 1 };\n    // 等价与 |x| {x + 1}  因为只有一个表达式, 所以 {} 可以省略\n    let add_one_v3 = |x| x + 1;\n    // 上面的定义没有类型, 如果没有的调用语句, 是会报错的, 因为函数没有类型,内存占用无法确定\n    // 调用后, 编译器推断了类型,这个时候类型就确定了\n    let r = add_one_v3(1);\n    println!(\"{}\", r);\n    // 后续如果你用其他类型,就会报错的\n    // let r2 = add_one_v3(\"a\");\n}\n\n\n\n不可变借用\nfn main() {\n    let list = vec![1, 2, 3];\n    println!(\"Before defining closure: {:?}\", list);\n    // 捕获了闭包所在环境, 变量list\n    let only_borrows = || {\n        // 这里的list,就是外面的那个list,不是赋值操作\n        // 只有我们指定 move|| {} 时才会 转移所有权\n        // println! 本身使用list的不可变借用\n        println!(\"From closure: {:?}\", list);\n    }\n\n    println!(\"Before calling closure: {:?}\", list);\n    only_borrows();\n    println!(\"After calling closure: {:?}\", list);\n}\n可变借用\nfn main() {\n    let mut list = vec![1, 2, 3];\n    println!(\"Before defining closure: {:?}\", list);\n    // 需要mut\n    let mut borrows_mutably = || list.push(7);\n\n    borrows_mutably();\n    println!(\"After calling closure: {:?}\", list); // [1, 2, 3, 7]\n}\nmove 所有权\nuse std::thread;\n\nfn main() {\n    let list = vec![1, 2, 3];\n    println!(\"Before defining closure: {:?}\", list);\n    // 指定move, 所有权移动\n    thread::spawn(move || println!(\"From thread: {:?}\", list))\n        .join()\n        .unwrap();\n    // println!(\"after defining closure: {:?}\", list); // 被move了,报错\n}\n\n\n\n\n\n\n\n\n\nTip\n\n\n\n\n闭包可能实现了Fn,FnMut,FnOnce这三个trait中的一个或多个\n创建闭包时,通过闭包对环境值的使用情况,rust推断出闭包实现了哪些trait\n\n\n\n\n\n\n\n\n\n\n\nFnOnce表示的意思\n\n\n\n\n可以被调用一次,很显然我们编写的闭包肯定是要能被调用至少一次的.\n如果只实现了 FnOnce这个trait, 其他trait没有实现,那么表示该闭包只能被调用一次\n当你闭包捕获的环境值离开闭包它自己的body时(值无效了),它就是 只实现了 FnOnce,因为它被调用一次后,里面变量值无效了,再调用就报错了\n\n\n\nfn main() {\n    let farewell = \"goodbye\".to_owned();\n    let diary = move || {\n        println!(\"I said {}.\", farewell);\n    };\n    diary(); // ok\n    diary(); // ok\n}\n// trait 是FnOnce , 表示传递的参数必须是实现了FnOnce的闭包\n// 这里的写法 和一般的trait 不太一样\nfn apply&lt;F&gt;(f: F)\nwhere\n    F: FnOnce(),\n{\n    f();\n}\nfn main() {\n    let mut farewell = \"goodbye\".to_owned();\n1    let diary = move || {\n        println!(\"I said {}.\", farewell);\n        {\n            farewell;\n        } // farewell 被drop掉了,\n    };\n    apply(diary);\n    // diary();\n    // 我们可以推断, 因为闭包内部使用的farewell 已经drop掉了,再次调用就有问题了\n    // 闭包对应的汇编指令,使用的farewell的地址是确定的\n    // 所以报错了, 提示diary 变量本身被move掉了\n    // 你可以认为因为你这样使用捕获的变量,导致 该闭包没有实现 copy,使用时就是move操作\n    diary();\n    // 可以用这个,也是报错了\n    // println!(\"{:p}\", &diary);\n}\n\n1\n\n不用move 去捕获变量,这里的结果还是一样的,主要是看你闭包内部是如何使用这个捕获的变量\n\n\n看这个例子,只能调用一次\nfn main() {\n    let mut farewell = \"goodbye\".to_owned();\n    let diary = || {\n        println!(\"I said {}.\", farewell);\n        // 将farewell 作为返回值move给了 diary\n        // 我们没有使用move, 这个farewell 就是外面的那个变量本身\n        // 如果使用move || {}, 只不过将外部的move给这里的farewell\n        farewell\n    };\n    diary();\n    // diary(); //报错\n    // println!(\"{}\", farewell); //报错\n}\n使用move但是实际可以被调用多次,因为实际要看闭包内部如何使用这个捕获的变量\nfn main() {\n    let farewell = \"goodbye\".to_owned();\n    let diary = move || {\n        println!(\"I said {}.\", farewell);\n    };\n    diary();\n    diary();\n}\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\n\n闭包可以修改它捕获的变量,但是不能move 捕获的值 out of their body\n说到底就是能够调用多次(内部使用的变量多次调用还有效),还能修改捕获的变量\n\n\n\nfn apply&lt;F&gt;(mut f: F)\nwhere\n    F: FnMut(),\n{\n    f();\n    f();\n}\nfn main() {\n    let mut farewell = \"goodbye\".to_owned();\n    // 使用 move || {} 结果也是一样的\n    // 还是那句话, 关键在闭包内部如何使用这个捕获的值\n    let mut diary = || {\n        farewell.push_str(\"hello\");\n        // 内部修改捕获的值, 值没有失效\n        println!(\"I said {}.\", farewell);\n    };\n    diary(); // 调用本身需要 let mut diary\n    apply(diary);\n}\n看看这个…\nfn apply&lt;F&gt;(mut f: F)\nwhere\n    F: FnMut(),\n{\n    f();\n}\nfn main() {\n    let x = \"goodbye\".to_owned();\n    let print = || {\n        println!(\"{}\", x);\n    };\n    apply(print);\n}\n\n\n\n\n\n\n\n\n\nTip\n\n\n\n不修改捕获的值,不move 捕获的值 out of their body,或者那种不捕获任何值的闭包\n\n\nfn apply&lt;F&gt;(f: F)\nwhere\n    F: Fn(),\n{\n    f();\n}\n// 也是实现了 Fn() trait\nfn function() {\n    println!(\"I'm a function!\");\n}\nfn main() {\n    let x = 7;\n    let print = || {\n        println!(\"{}\", x);\n    };\n    apply(print);\n    apply(function);\n}\n\n\n\n\nfn create_fn() -&gt; impl Fn() {\n    let text = \"Fn\".to_owned();\n    // move 必须要有,要不然最后 text 会被 drop\n    move || println!(\"This is a: {}\", text)\n}\n\nfn create_fnmut() -&gt; impl FnMut() {\n    let text = \"FnMut\".to_owned();\n    // 同样move\n    move || println!(\"This is a: {}\", text)\n}\n\nfn create_fnonce() -&gt; impl FnOnce() {\n    let text = \"FnOnce\".to_owned();\n\n    move || println!(\"This is a: {}\", text)\n}\n\nfn main() {\n    let fn_plain = create_fn();\n    let mut fn_mut = create_fnmut();\n    let fn_once = create_fnonce();\n\n    fn_plain();\n    fn_mut();\n    fn_once();\n}",
    "crumbs": [
      "基础篇",
      "闭包与迭代器"
    ]
  },
  {
    "objectID": "docs/rust/basic/11.closure.html#闭包",
    "href": "docs/rust/basic/11.closure.html#闭包",
    "title": "斯巴拉稀",
    "section": "",
    "text": "Tip\n\n\n\n\nclosures can capture values from the scope in which they’re defined\n可以捕获其所在环境的匿名函数\n\n在它定义的作用域中捕获值\n\n\n\n\nfn main() {\n    fn add_one_v1(x: u32) -&gt; u32 {\n        x + 1\n    }\n    // 闭包,匿名函数, |参数|-&gt;返回值 { 函数体}\n    let add_one_v2 = |x: u32| -&gt; u32 { x + 1 };\n    // 等价与 |x| {x + 1}  因为只有一个表达式, 所以 {} 可以省略\n    let add_one_v3 = |x| x + 1;\n    // 上面的定义没有类型, 如果没有的调用语句, 是会报错的, 因为函数没有类型,内存占用无法确定\n    // 调用后, 编译器推断了类型,这个时候类型就确定了\n    let r = add_one_v3(1);\n    println!(\"{}\", r);\n    // 后续如果你用其他类型,就会报错的\n    // let r2 = add_one_v3(\"a\");\n}\n\n\n\n不可变借用\nfn main() {\n    let list = vec![1, 2, 3];\n    println!(\"Before defining closure: {:?}\", list);\n    // 捕获了闭包所在环境, 变量list\n    let only_borrows = || {\n        // 这里的list,就是外面的那个list,不是赋值操作\n        // 只有我们指定 move|| {} 时才会 转移所有权\n        // println! 本身使用list的不可变借用\n        println!(\"From closure: {:?}\", list);\n    }\n\n    println!(\"Before calling closure: {:?}\", list);\n    only_borrows();\n    println!(\"After calling closure: {:?}\", list);\n}\n可变借用\nfn main() {\n    let mut list = vec![1, 2, 3];\n    println!(\"Before defining closure: {:?}\", list);\n    // 需要mut\n    let mut borrows_mutably = || list.push(7);\n\n    borrows_mutably();\n    println!(\"After calling closure: {:?}\", list); // [1, 2, 3, 7]\n}\nmove 所有权\nuse std::thread;\n\nfn main() {\n    let list = vec![1, 2, 3];\n    println!(\"Before defining closure: {:?}\", list);\n    // 指定move, 所有权移动\n    thread::spawn(move || println!(\"From thread: {:?}\", list))\n        .join()\n        .unwrap();\n    // println!(\"after defining closure: {:?}\", list); // 被move了,报错\n}\n\n\n\n\n\n\n\n\n\nTip\n\n\n\n\n闭包可能实现了Fn,FnMut,FnOnce这三个trait中的一个或多个\n创建闭包时,通过闭包对环境值的使用情况,rust推断出闭包实现了哪些trait\n\n\n\n\n\n\n\n\n\n\n\nFnOnce表示的意思\n\n\n\n\n可以被调用一次,很显然我们编写的闭包肯定是要能被调用至少一次的.\n如果只实现了 FnOnce这个trait, 其他trait没有实现,那么表示该闭包只能被调用一次\n当你闭包捕获的环境值离开闭包它自己的body时(值无效了),它就是 只实现了 FnOnce,因为它被调用一次后,里面变量值无效了,再调用就报错了\n\n\n\nfn main() {\n    let farewell = \"goodbye\".to_owned();\n    let diary = move || {\n        println!(\"I said {}.\", farewell);\n    };\n    diary(); // ok\n    diary(); // ok\n}\n// trait 是FnOnce , 表示传递的参数必须是实现了FnOnce的闭包\n// 这里的写法 和一般的trait 不太一样\nfn apply&lt;F&gt;(f: F)\nwhere\n    F: FnOnce(),\n{\n    f();\n}\nfn main() {\n    let mut farewell = \"goodbye\".to_owned();\n1    let diary = move || {\n        println!(\"I said {}.\", farewell);\n        {\n            farewell;\n        } // farewell 被drop掉了,\n    };\n    apply(diary);\n    // diary();\n    // 我们可以推断, 因为闭包内部使用的farewell 已经drop掉了,再次调用就有问题了\n    // 闭包对应的汇编指令,使用的farewell的地址是确定的\n    // 所以报错了, 提示diary 变量本身被move掉了\n    // 你可以认为因为你这样使用捕获的变量,导致 该闭包没有实现 copy,使用时就是move操作\n    diary();\n    // 可以用这个,也是报错了\n    // println!(\"{:p}\", &diary);\n}\n\n1\n\n不用move 去捕获变量,这里的结果还是一样的,主要是看你闭包内部是如何使用这个捕获的变量\n\n\n看这个例子,只能调用一次\nfn main() {\n    let mut farewell = \"goodbye\".to_owned();\n    let diary = || {\n        println!(\"I said {}.\", farewell);\n        // 将farewell 作为返回值move给了 diary\n        // 我们没有使用move, 这个farewell 就是外面的那个变量本身\n        // 如果使用move || {}, 只不过将外部的move给这里的farewell\n        farewell\n    };\n    diary();\n    // diary(); //报错\n    // println!(\"{}\", farewell); //报错\n}\n使用move但是实际可以被调用多次,因为实际要看闭包内部如何使用这个捕获的变量\nfn main() {\n    let farewell = \"goodbye\".to_owned();\n    let diary = move || {\n        println!(\"I said {}.\", farewell);\n    };\n    diary();\n    diary();\n}\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\n\n闭包可以修改它捕获的变量,但是不能move 捕获的值 out of their body\n说到底就是能够调用多次(内部使用的变量多次调用还有效),还能修改捕获的变量\n\n\n\nfn apply&lt;F&gt;(mut f: F)\nwhere\n    F: FnMut(),\n{\n    f();\n    f();\n}\nfn main() {\n    let mut farewell = \"goodbye\".to_owned();\n    // 使用 move || {} 结果也是一样的\n    // 还是那句话, 关键在闭包内部如何使用这个捕获的值\n    let mut diary = || {\n        farewell.push_str(\"hello\");\n        // 内部修改捕获的值, 值没有失效\n        println!(\"I said {}.\", farewell);\n    };\n    diary(); // 调用本身需要 let mut diary\n    apply(diary);\n}\n看看这个…\nfn apply&lt;F&gt;(mut f: F)\nwhere\n    F: FnMut(),\n{\n    f();\n}\nfn main() {\n    let x = \"goodbye\".to_owned();\n    let print = || {\n        println!(\"{}\", x);\n    };\n    apply(print);\n}\n\n\n\n\n\n\n\n\n\nTip\n\n\n\n不修改捕获的值,不move 捕获的值 out of their body,或者那种不捕获任何值的闭包\n\n\nfn apply&lt;F&gt;(f: F)\nwhere\n    F: Fn(),\n{\n    f();\n}\n// 也是实现了 Fn() trait\nfn function() {\n    println!(\"I'm a function!\");\n}\nfn main() {\n    let x = 7;\n    let print = || {\n        println!(\"{}\", x);\n    };\n    apply(print);\n    apply(function);\n}\n\n\n\n\nfn create_fn() -&gt; impl Fn() {\n    let text = \"Fn\".to_owned();\n    // move 必须要有,要不然最后 text 会被 drop\n    move || println!(\"This is a: {}\", text)\n}\n\nfn create_fnmut() -&gt; impl FnMut() {\n    let text = \"FnMut\".to_owned();\n    // 同样move\n    move || println!(\"This is a: {}\", text)\n}\n\nfn create_fnonce() -&gt; impl FnOnce() {\n    let text = \"FnOnce\".to_owned();\n\n    move || println!(\"This is a: {}\", text)\n}\n\nfn main() {\n    let fn_plain = create_fn();\n    let mut fn_mut = create_fnmut();\n    let fn_once = create_fnonce();\n\n    fn_plain();\n    fn_mut();\n    fn_once();\n}",
    "crumbs": [
      "基础篇",
      "闭包与迭代器"
    ]
  },
  {
    "objectID": "docs/rust/basic/11.closure.html#iterator-迭代器",
    "href": "docs/rust/basic/11.closure.html#iterator-迭代器",
    "title": "斯巴拉稀",
    "section": "2 iterator 迭代器",
    "text": "2 iterator 迭代器\n\n\n\n\n\n\nTip\n\n\n\n除非调用迭代器的方法,否则迭代器本身没有任何消耗\n\n\n\n2.1 简单使用\nlet v1 = vec![1, 2, 3];\n// 仅仅定义而没有使用它, 这样不会有任何的消耗\nlet v1_iter = v1.iter();\nfn main() {\n    let v1 = vec![1, 2, 3];\n\n    // v1_iter 本身取得的是 v1元素的不可变借用\n    let v1_iter = v1.iter();\n\n    // for循环 会取得v1_iter的所有权\n    // 底层是调用next\n    for val in v1_iter {\n        println!(\"Got: {}\", val);\n    }\n    //  v1_iter 已经被move了, 报错\n    // println!(\"{:?}\", v1_iter);\n\n    let mut v1_iter = v1.iter();\n    if let Some(b) = v1_iter.next() {\n        println!(\"{}\", b);\n    }\n    // 调用next 会消耗迭代器 (体会一下消耗的意思)\n    v1_iter.next();\n    v1_iter.next();\n    if let None = v1_iter.next() {\n        println!(\"没有元素后再调用next 返回None\");\n    }\n\n    let v1_iter = v1.iter();\n    let total: i32 = v1_iter.sum();\n    println!(\"{total}\");\n    // 调用sum 会获取v1_iter的所有权,所以报错了,提示move掉了\n    // println!(\"{:?}\", v1_iter);\n\n    // into_iter 会获取v1的所有权\n    let v1_iter = v1.into_iter();\n    // println!(\"{:?}\", v1); 报错\n\n    let mut v1 = vec![1, 2, 3];\n    // 取得v1的可变借用\n    let v1_iter = v1.iter_mut();\n\n}\n\n\n2.2 迭代器适配器\n\n\n\n\n\n\nTip\n\n\n\n\n非消耗型迭代器适配器 是定义在 迭代器 trait上的一些方法,它不会消耗迭代器,相反它是产生一个新的迭代器\n消耗型迭代器适配器, 前面我们使用的next 就是\n\n\n\nfn main() {\n    let v1: Vec&lt;i32&gt; = vec![1, 2, 3];\n\n    let v1_iter = v1.iter();\n    // 取得迭代器的所有权,生成新的迭代器\n    let v_map = v1_iter.map(|x| x + 1);\n    // 使用消耗迭代器适配器\n    let v2: Vec&lt;_&gt; = v_map.collect();\n\n    assert_eq!(v2, vec![2, 3, 4]);\n}\n使用闭包捕获环境\nfn main() {\n    let v1: Vec&lt;i32&gt; = vec![1, 2, 3];\n    // any 如果有一个满足条件就返回true\n    // v1.iter() =&gt; iter(&v1)\n    println!(\"2 in v1: {}\", v1.iter().any(|&x| x == 2));\n\n    let mut iter = v1.iter();\n    println!(\"Find 2 in v1: {:?}\", iter.find(|&&x| x == 2));\n\n    let v1: Vec&lt;i32&gt; = vec![1, 2, 3];\n    println!(\"Find 2 in v1: {:?}\", v1.into_iter().find(|&x| x == 2));\n\n    let v1: Vec&lt;i32&gt; = vec![1, 2, 3];\n    let index_of_first_even_number = v1.iter().position(|&x| x % 2 == 0);\n    assert_eq!(index_of_first_even_number, Some(5));\n\n    let v1: Vec&lt;i32&gt; = vec![1, 2, 3];\n    let v1_iter = v1.into_iter();\n    let two = 2;\n    // filter 将符合条件的返回 (true的情况)\n    let v_map = v1_iter.filter(|x| x &gt;= &two);\n    let v2: Vec&lt;_&gt; = v_map.collect();\n    println!(\"{:?}\", v2);\n}\n/*\nfn any&lt;F&gt;(&mut self, mut f: F) -&gt; bool\nwhere\n    Self: Sized,\n    F: FnMut(Self::Item) -&gt; bool,\n{\n    while let Some(x) = self.next() {\n        if f(x) {\n            return true;\n        }\n    }\n    false\n}\npub trait Iterator {\n    type Item;\n\n    fn find&lt;P&gt;(&mut self, predicate: P) -&gt; Option&lt;Self::Item&gt; where\n        P: FnMut(&Self::Item) -&gt; bool;\n}\n*/\n\n\n2.3 iterator trait\n所有迭代器都实现了 iterator trait\n\n\nIterator trait 在标准库中的定义\n\npub trait Iterator {\n    type Item;\n\n    fn next(&mut self) -&gt; Option&lt;Self::Item&gt;;\n\n    // methods with default implementations elided\n}\n\n我们自定义迭代器时,只需要实现next方法即可\n// 定义一个能生成范围内所有奇数的迭代器\nstruct OddNumbers {\n    current: u32,\n    end: u32,\n}\n\n// 为 OddNumbers 实现迭代器 trait\nimpl Iterator for OddNumbers {\n    type Item = u32; // 迭代器的项类型是 u32\n\n    // next() 方法返回下一个奇数，如果没有更多奇数则返回 None\n    fn next(&mut self) -&gt; Option&lt;Self::Item&gt; {\n        if self.current &gt;= self.end {\n            None // 如果当前值已经大于或等于结束值，返回 None\n        } else {\n            let result = self.current;\n            self.current += 2; // 移动到下一个奇数\n            Some(result) // 返回当前的奇数\n        }\n    }\n}\n\nfn main() {\n    // 创建迭代器实例，生成从 1 到 9 的所有奇数\n    let mut odd_numbers = OddNumbers {\n        current: 1,\n        end: 10,\n    };\n\n    // 通过循环来迭代奇数\n    loop {\n        match odd_numbers.next() {\n            Some(n) =&gt; println!(\"{}\", n),\n            None =&gt; break, // 如果没有更多元素，则退出循环\n        }\n    }\n\n    let odd_numbers = OddNumbers {\n        current: 1,\n        end: 10,\n    };\n    // 使用 for 循环来简化迭代\n    for odd in odd_numbers {\n        println!(\"{}\", odd);\n    }\n}",
    "crumbs": [
      "基础篇",
      "闭包与迭代器"
    ]
  },
  {
    "objectID": "docs/rust/basic/02.quick-start.html",
    "href": "docs/rust/basic/02.quick-start.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "hello.rs\n\n// fn : function\nfn main() {\n    // rust的缩进是4个空格\n    // println! 是一个 rust macro 宏, 不是函数, 如果结尾没有! 则是函数\n    println!(\"hello\"); // 结尾 要有 ;\n    /* let 定义变量及初始化 */\n    // : i32 这种表示 变量x的类型\n    let x: i32 =6;\n    println!(\"{:?}\", x);\n    let y: i32;\n1    println!(\"{:?}\", y);\n\n    // 定义了变量,但是没有使用它,rust会警告你,_开头的 rust不会警告\n    let _z = 5;\n}\n\n\n1\n\n报错, 没有初始化会报错\n\n\nrustc 这个只适合编译简单的程序,大型程序 用cargo\n# -o 输出的名字, 没有则默认文件名\nrustc hello.rs -o main",
    "crumbs": [
      "基础篇",
      "快速入门"
    ]
  },
  {
    "objectID": "docs/rust/basic/02.quick-start.html#main.rs",
    "href": "docs/rust/basic/02.quick-start.html#main.rs",
    "title": "斯巴拉稀",
    "section": "",
    "text": "hello.rs\n\n// fn : function\nfn main() {\n    // rust的缩进是4个空格\n    // println! 是一个 rust macro 宏, 不是函数, 如果结尾没有! 则是函数\n    println!(\"hello\"); // 结尾 要有 ;\n    /* let 定义变量及初始化 */\n    // : i32 这种表示 变量x的类型\n    let x: i32 =6;\n    println!(\"{:?}\", x);\n    let y: i32;\n1    println!(\"{:?}\", y);\n\n    // 定义了变量,但是没有使用它,rust会警告你,_开头的 rust不会警告\n    let _z = 5;\n}\n\n\n1\n\n报错, 没有初始化会报错\n\n\nrustc 这个只适合编译简单的程序,大型程序 用cargo\n# -o 输出的名字, 没有则默认文件名\nrustc hello.rs -o main",
    "crumbs": [
      "基础篇",
      "快速入门"
    ]
  },
  {
    "objectID": "docs/rust/basic/02.quick-start.html#immutable",
    "href": "docs/rust/basic/02.quick-start.html#immutable",
    "title": "斯巴拉稀",
    "section": "2 immutable",
    "text": "2 immutable\nfn main() {\n    // 变量默认不可变\n    let a: i32 = 5;\n    // a=2;  会直接报错,提示不能修改 不可变的变量\n    println!(\"{:p}\", &a);\n\n    // 申明可变变量\n    let mut c: i32 = 5;\n    c = 7;\n    println!(\"{c}\");\n}",
    "crumbs": [
      "基础篇",
      "快速入门"
    ]
  },
  {
    "objectID": "docs/rust/basic/02.quick-start.html#shadowing",
    "href": "docs/rust/basic/02.quick-start.html#shadowing",
    "title": "斯巴拉稀",
    "section": "3 shadowing",
    "text": "3 shadowing\nfn main() {\n    let a: i32 = 5;\n    // a=2;  会直接报错,提示不能修改 不可变的变量\n    println!(\"{:p}\", &a);\n    // shadowing  隐藏了上面的变量a\n    let a: i32 = 5;\n    // 与上面的地址不同, 已经是一个不同的变量了,只是用了相同的变量名\n    // 一开始申明的a 被隐藏了\n    println!(\"重新申明的a变量地址: {:p}\", &a);\n\n    let b = 5i32;\n    {\n        // 在这个作用域中, b 也确实shadowing 了外面的b\n        let b = 8i32;\n        println!(\"b 在作用域中的值: {b}\"); // 是8\n    }\n    // 但是在退出块作用域后, b还是5\n    println!(\"作用域外,b的值:{b}\");\n\n    // shadowing 可以使用完全不同的类型, 因为实际就是2个完全不同的变量\n    let b = \"abc\";\n    println!(\"{b}\");\n}",
    "crumbs": [
      "基础篇",
      "快速入门"
    ]
  },
  {
    "objectID": "docs/rust/basic/02.quick-start.html#常量",
    "href": "docs/rust/basic/02.quick-start.html#常量",
    "title": "斯巴拉稀",
    "section": "4 常量",
    "text": "4 常量\n常量是在编译期就进行求值的. 所以常量 = 的右边是可以使用表达式的\nunsafe章节里有关于static定义的方式\nconst A: u32 = 60 * 60 * 3;\n\nfn main() {\n    // 一般用大写并且下划线来申明常量\n    // 不可修改, 不可shadowing\n    // 不可以使用mut,永远不可变\n    // 可以在任何作用域申明\n    const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;\n    println!(\"{}\", THREE_HOURS_IN_SECONDS);\n}",
    "crumbs": [
      "基础篇",
      "快速入门"
    ]
  },
  {
    "objectID": "docs/rust/basic/02.quick-start.html#数据类型",
    "href": "docs/rust/basic/02.quick-start.html#数据类型",
    "title": "斯巴拉稀",
    "section": "5 数据类型",
    "text": "5 数据类型\n\n\n\n\n\n\nTip\n\n\n\n标量类型是指那些不可再分的、基本的、单个值的数据类型。 标量类型通常用于存储单一的数据项，如一个数字、一个字符或一个布尔值。 与标量类型相对的是复合数据类型，如数组、列表、对象和结构体，这些类型可以包含多个值\n\n\n\n5.1 整型\n\n介绍一些方法\n\n\nuse std::mem;\nfn main() {\n    // 有符号 i8 i16 i32 i64 i128 isize(根据系统架构决定)\n    // 无符号 u8 u16 u32 u64 u128 usize(根据系统架构决定)\n    let a=6;\n    // 打印i32类型的大小\n    println!(\"{}\",mem::size_of::&lt;i32&gt;());\n    // 打印变量占用的内存大小\n    println!(\"{}\",mem::size_of_val(&a));\n    // 十进制 2_100  下划线只是为了增加可读性, 这里相当于美国的千位加,的意思\n    let b:i32=2_100;\n    println!(\"{}\",b);\n    // hex 16进制 0x 开头\n    let c:i32=0xff;\n    println!(\"{}\",c);\n    // 八进制 0o 开头\n    let d:i32=0o12;\n    println!(\"{}\",d);\n    // 二进制\n    let e:i32=0b1111_0000;\n    println!(\"{}\",e);\n    // byte \n    let f:u8=b'A';\n    println!(\"{}\",f);  \n    // 可以使用类型后缀, 在值后边写上\n    let g=5i16;\n    println!(\"{}\",g);\n}\n\n\nfn main() {\n    println!(\"{}\", i32::MAX); // i32最大值\n    println!(\"{}\", 2_u16.pow(4)); // 求指数幂\n    println!(\"{}\", (-4_i32).abs()); // 求绝对值\n    println!(\"{}\", 0b0011_1101_u8.count_ones()); // 位计数(多少个1)\n    // 可以使用这种方式来调用方法\n    println!(\"{}\", i32::abs(-4));\n    println!(\"{}\", i8::count_zeros(0b0011_1101));\n\n    // Checked_ 操作返回一个结果的 Option 值：如果运算结果可以被结果类型正确表示就返\n    // 回 Some(v)，否则返回 None\n    assert_eq!((10_u8).checked_add(20), Some(30));\n    assert_eq!((100_u8).checked_add(200), None);\n\n    // wrapping_ 的结果是对 2的8次方 256的取模得到的余数\n    assert_eq!(16_u8.wrapping_mul(15), 240);\n    assert_eq!(18_u8.wrapping_mul(15), 14);\n\n    // 有符号数的操作可能会回环成负数。\n    // 0111 1111 + 1  =&gt;1000 0000 补码的 -128\n    assert_eq!(127_i8.wrapping_add(1), -128);\n    // 0111 1111 + 1+1  =&gt; 补码 1000 0001 =&gt; 反码:1000 0000 ==&gt; 1111 1111 原码\n    assert_eq!(127_i8.wrapping_add(2), -127);\n\n    // 在移位操作中，移动的位数会回环到该类型的位数之内\n    // 因此对 8位的数字移动 9位等于移动 1位\n    // 0000 0101 相当于左移 1位=&gt; 0000 1010\n    assert_eq!(5_i8.wrapping_shl(9), 10);\n\n    // Saturating_ 操作会返回最接近正确结果的表示,结果被“截断”到这个类型能表示的最大或最小值\n    assert_eq!(127_i8.saturating_add(1), 127);\n\n    // Overflowing_ 操作返回一个 tuple (result, overflowed)，其中result 是回环版本的方法\n    // 返回的结果，而 overflowed 是一个指示是否发生溢出的 bool 值：\n    assert_eq!(255_u8.overflowing_sub(2), (253, false));\n    assert_eq!(255_u8.overflowing_add(2), (1, true));\n    // 只有当位移距离大于等 于类型的位宽度时 overflowed 才为 true\n    // 实际的移位距离等于要求的距离对位宽度取余后的结果\n    // 0000 0101 相当于左移1位 (9%8)=&gt; 0000 1010\n    assert_eq!(5_u8.overflowing_shl(9), (10, true));\n    // 0000 0101 左移6位=&gt; 1 0100 0000: 64\n    assert_eq!(5_u8.overflowing_shl(6), (64, false));\n}\n\n\n\n\n\n5.2 浮点数\n\n介绍一些方法提供的一些常量\n\n\nfn main() {\n    let x = 2.0; // f64 默认\n    let y: f32 = 3.0; // f32\n    // 科学计数法\n    let a = 1e6; // f64类型\n    let b = 7.6e-4; // f64类型\n    println!(\"a is {}\", a);\n    println!(\"a is {}\", b);\n}\n\n\nfn main() {\n    // 平方根\n    println!(\"{}\", 8f32.sqrt());\n    println!(\"{}\", 8.2f32.floor()); // 8\n    println!(\"{}\", 8.9f32.floor()); // 8\n    println!(\"{}\", (-8.9f32).floor()); // -9\n    // 方法调用的优先级高于前缀运算符，因此对负数调用方法时确保要用括号括起来\n    println!(\"{}\", -8.9f32.floor()); // -8\n    println!(\"{}\", 8.2f32.round()); // 8\n    println!(\"{}\", 8.5f32.round()); // 9\n}\n\n\nuse std::f32::consts;\nfn main() {\n    // rust 提供了一些常量, 比如 PI\n    println!(\"{}\", consts::PI);\n}\n\n\n\n\n\n5.3 bool\nfn main() {\n    let t = true;\n    println!(\"{t}\");\n    // 同样必须初始化,否则报错\n    let f: bool = false;\n    println!(\"{f}\"); // false\n    // bool 可以转 整型\n    let d = false as i8;\n    println!(\"{d}\"); // 0\n    // 整型不能转 bool\n    //    let c = 1i8 as bool;\n}\n\n\n5.4 char\nuse std::mem;\n\nfn main() {\n    let c = 'z'; // 这个是字符, 和前面 b'z' 是整型不同哦\n    println!(\"{}\", mem::size_of_val(&c)); // 4\n    let z: char = 'ℤ';\n    println!(\"{c}-{z}\");\n    // rust 中的char 是 4个字节,Unicode, 可以表示表情\n    let heart_eyed_cat = '😻';\n    println!(\"{heart_eyed_cat}\");\n\n    let a = 'a';\n    println!(\"{}\", a as u8); // 97\n    // 标准库提供了函数 std::char::from_u32 接受\n    // 任何 u32 值，并返回 Option&lt;char&gt;：\n        // 如果 u32 的值不是合法的 Unicode 码点，from_u32 会返回 None；\n        // 否则，它会返回 Some(c)，c 就是作为转换结果的 char\n    let hex_char = char::from_u32(97);\n    println!(\"{:?}\", hex_char);\n}\n\n\n5.5 tuple\nfn main() {\n    // 元素可以是多种类型\n    let tup: (i32, f64, u8) = (100, 3.14, 2);\n    println!(\"{},{},{}\", tup.0, tup.1, tup.2);\n    let (x, y, z) = tup;\n    println!(\"{},{},{}\", x, y, z);\n}\n\n\n5.6 数组\n\n\n\n\n\n\nTip\n\n\n\n\n元素类型必须一致\n长度是固定的,运行时不能修改, 长度是类型的一部分\n数组是在栈上分配的单个块的内存\n常用于开辟一个固定大小的Buffer作为缓冲区,比如接收IO输入输出等\n\n\n\nfn main() {\n    let x = [1, 2, 3, 4];\n    println!(\"{}\", x[1]);\n    // [i32;5] 表示每个元素是i32,一共有5个元素\n    let x: [i32; 5] = [1, 2, 3, 4, 5];\n    println!(\"{}\", x.len());\n    // 相当于 let x=[3,3,3,3,3];\n    let x = [3; 5];\n    // 下标读取\n    println!(\"{}\", x[2]);\n}\n\n\n5.7 切片\n\n\n\n\n\n\nNote\n\n\n\n\n医学上切片的意思是将组织样本切成薄片以便于在显微镜下观察,可以说切片是原物品的一部分\n编程上切片的意思: 原数据一段连续部分的引用,不难推断出它的数据结构是一个原数据的地址和引用的长度\n\n\n\nuse std::mem;\nfn main() {\n    let mut x = [1, 2, 3];\n    println!(\"{}\", mem::size_of_val(&x));  // 12\n    println!(\"{:p}\", x.as_ptr());\n    // 切片是对一块连续内存数据的引用\n    // 由2个部分组成, 一个是data指向数据,一个len 表示长度\n    // 这种比一般指针要多出一些信息的叫 胖指针\n    let y = &mut x[1..3];\n    println!(\"{:p}\", y.as_ptr());\n    println!(\"{}\", y.len());\n    println!(\"{}\", mem::size_of_val(&y));  // 16\n\n    let x = [1, 2, 3, 4, 5];\n    let (a, b) = x.split_at(2);\n    println!(\"{:?}\", a); // [1,2]\n    println!(\"{:?}\", b); // [3,4,5]\n}\n// &[T] 切片的表示方式\nfn analyze_slice(slice: &[i32]) {\n    println!(\"First element of the slice: {}\", slice[0]);\n    println!(\"The slice has {} elements\", slice.len());\n}\nfn main() {\n    let x: [i32; 5] = [2, 1, 4, 3, 5];\n    let y = &x[1..3];\n    analyze_slice(&y);\n\n    let mut chaos = [3, 5, 4, 1, 2];\n    //Rust会隐式的把数组的引用转换为切片\n    chaos.sort();\n    println!(\"{:?}\", chaos);\n    chaos.reverse();\n    println!(\"{:?}\", chaos);\n}",
    "crumbs": [
      "基础篇",
      "快速入门"
    ]
  },
  {
    "objectID": "docs/rust/basic/02.quick-start.html#类型转换",
    "href": "docs/rust/basic/02.quick-start.html#类型转换",
    "title": "斯巴拉稀",
    "section": "6 类型转换",
    "text": "6 类型转换\nfn main() {\n    let a: i8 = 9;\n    // 需要加上 as 否则报错\n    let b: i32 = a as i32;\n    println!(\"{}\",b);\n}",
    "crumbs": [
      "基础篇",
      "快速入门"
    ]
  },
  {
    "objectID": "docs/rust/basic/02.quick-start.html#函数",
    "href": "docs/rust/basic/02.quick-start.html#函数",
    "title": "斯巴拉稀",
    "section": "7 函数",
    "text": "7 函数\n\n\n\n\n\n\nTip\n\n\n\n\n语句: 执行动作, 没有返回值\n表达式: 是有一个值的\n函数体是由一系列语句和一个结尾(可以是语句或者表达式)组成\nunit type 单元类型 () 表示一种类型. 表示没有什么特殊的价值, 它的值就是它本身 也是()\n\n\n\n\n7.1 语句\nfn main() {\n    // 直接报错, 右边是个语句,没有返回值\n    let x = (let y = 6);\n}\n\n\n7.2 表达式\nfn main() {\n    let y = {\n        let x = 3;\n        // 注意没有; , 这样就是表达式了,有返回值\n        // 如果加上; , 那么就变成一个语句了\n        x + 1\n    };\n\n    println!(\"The value of y is: {y}\");\n}\n\n\n7.3 返回值\nfn five() -&gt; i32 {\n    // 表达式 ,值为5\n    5\n}\n\nfn main() {\n    let x = five();\n\n    println!(\"The value of x is: {x}\");\n}\n添加;号试试, 会直接报错提示 期望i32, 而实际发现是the unit type ()\n// -&gt; i32 , 表示返回值类型\nfn five() -&gt; i32 {\n    5;\n}\n我们将上面的返回值类型改成 () , 这样就不会报错了\nfn five() -&gt; () {\n    5;\n}\n实际上就是不用写返回值 的类型\n// 没有指明返回值的, 那么返回值类型就是 unit type :()\nfn five(){\n    5;\n}\nfn main() {\n    // 单元值判断\n    if five() == () {\n        // ok的\n        println!(\"ok\");\n    }\n}\nfn t() {\n    // 这里返回了5, 要求的是(),所以会提示错误\n    5\n}\n\n\n7.4 函数内部创建函数\nfn main() {\n    // 函数内部可以定义函数\n    fn add(t1: i32, t2: i32) -&gt; i32 {\n        t1 + t2\n    }\n    let r = add(1, 2);\n    print!(\"{}\", r);\n}\n\n\n7.5 函数的类型\nfn add1(t: (i32, i32)) -&gt; i32 {\n    t.0 + t.1\n}\n// 实际看来 与add1 参数一样\nfn add2((t1, t2): (i32, i32)) -&gt; i32 {\n    t1 + t2\n}\nfn main() {\n    let a = 1;\n    let b = 2;\n    let c = (1, 2);\n    println!(\"{}\", add1(c));\n    println!(\"{}\", add2((a, b)));\n\n    // f1的类型是 fn (t: (i32, i32)) -&gt; i32\n    let f1 = add1;\n    // 报错了 expected fn item, found a different fn item\n    // 不同的类型, 所以报错了.\n    // f1 = add2;\n\n    // 正确的方式是 定义变量时将 他的类型设置为 fn item 通用的fn 类型\n    let f1 = add1 as fn((i32, i32)) -&gt; i32;\n    println!(\"{}\", f1((1, 2)));\n\n    // 这样定义也可以\n    let mut f1: fn((i32, i32)) -&gt; i32 = add1;\n    f1 = add2; // 不会报错了\n    println!(\"{}\", f1((a, b)));\n}\n\n\n7.6 发散函数 !\ndiverging functions, ! 被称为 The Never Type\n我们知道前面提到的函数其实都是有返回值, 即使是没有返回值的函数, 也会返回一个 () 单元类型的值\n那么一个 永远不会返回的函数它有返回值吗? 还有 panic 这种函数呢?\nfn main() {\n    let a = bar();\n    a=2;// 虽然不会执行到这里, 但是编译器不会报错\n    println!(\"{}\", a);\n}\n// 返回 ! never type\nfn bar() -&gt; ! {\n    loop {\n        print!(\"and ever \");\n    }\n}\n\nfn foo() -&gt;!{\n    panic!(\"error\");\n}\n下面我们都知道会报错\nfn main() {\n    let guess = \"42\";\n    let guess = match guess.trim().parse() {\n        Ok(_) =&gt; 5,\n        Err(_) =&gt; \"hello\", // 报错了\n    };\n}\n下面这个没有报错\nfn main() {\n    let r = bar();\n}\nfn bar() -&gt; ! {\n    let guess = \"42\";\n    loop {\n        let guess = match guess.trim().parse::&lt;i32&gt;() {\n            Ok(_) =&gt; 5,\n            Err(_) =&gt; continue, // ! 类型可以被转换为任何类型\n        };\n    }\n}",
    "crumbs": [
      "基础篇",
      "快速入门"
    ]
  },
  {
    "objectID": "docs/rust/basic/02.quick-start.html#控制流程",
    "href": "docs/rust/basic/02.quick-start.html#控制流程",
    "title": "斯巴拉稀",
    "section": "8 控制流程",
    "text": "8 控制流程\n\n8.1 if\nfn main() {\n    let number = 3;\n    // 报错的, 需要bool类型\n    if number {\n        println!(\"number was three\");\n    }\n\n    let condition = true;\n    let number = if condition { 5 } else { 6 };\n\n    println!(\"The value of number is: {number}\");\n    let number2 = if condition {\n        5;\n        7  // 还是看的返回值\n    } else {\n        6\n    };\n\n    println!(\"The value of number is: {number2}\");\n\n    // 报错\n    let number3 = if condition { 5 } else { \"six\" };\n}\n\n\n8.2 loop\nfn main() {\n    let mut i = 0;\n    let ret = loop {\n        i += 1;\n        if i &gt; 10 {\n            break i; // 返回值, 就是loop的返回值\n        }\n    };\n    println!(\"{}\", ret)\n\n    let y: i32;\n    // 编译器是能够判断出 后面的打印时, y肯定已经赋值了.\n    let x = loop {\n        y = 1;\n        break;\n    };\n    println!(\"{:?}\", x);\n    println!(\"{:?}\", y);\n}\n跳出多层 loop\n#![allow(unreachable_code, unused_labels)]\nfn main() {\n    'outer: loop {\n        println!(\"Entered the outer loop\");\n\n        'inner: loop {\n            println!(\"Entered the inner loop\");\n            // This would break only the inner loop\n            //break;\n            // This breaks the outer loop\n            break 'outer;\n        }\n        println!(\"This point will never be reached\");\n    }\n    println!(\"Exited the outer loop\");\n}\n\n\n8.3 for (and range)\n标签 label loop使用也一样\nfn main() {\n    // label 前面有个 ' 单引号\n    'outer: for i in 0..5 {\n        println!(\"Outer loop value: {}\", i);\n\n        for j in 0..5 {\n            println!(\"Inner loop value: {}\", j);\n\n            if i == 2 && j == 3 {\n                break 'outer;\n            }\n        }\n    }\n\n    let a = [10, 20, 30, 40, 50];\n\n    for element in a {\n        println!(\"the value is: {element}\");\n    }\n\n    // (1..4)  1 2 3\n    // 会提示不需要 用 () 将1..4 阔气来\n    for number in (1..4) {\n        println!(\"{number}!\");\n    }\n    // 不包含4\n    for number in 1..4 {\n        println!(\"{number}!\");\n    }\n    // =4 包含4\n    for number in 1..=4 {\n        println!(\"{number}\");\n    }\n\n    for number in 1.. {\n        if number == 10 {\n            break;\n        }\n        println!(\"{}\", number);\n    }\n\n    use std::ops::Range;\n    let a = Range { start: 1, end: 10 };\n    for j in a {\n        println!(\"{}\", j);\n    }\n    // x 是一个RangeFrom&lt;i32&gt; 类型\n    let x = (0..);\n    // Range\n    let x = (0..5);\n}\n数组来测试 range\n\n#[cfg(test)] //配置测试模块\nmod abc {\n    #[test] //单元测试用例\n    fn it_works() {\n        let result = 2 + 2;\n        assert_eq!(result, 4);\n    }\n    #[test]\n    fn arr_range() {\n        let arr = [0, 1, 2, 3, 4];\n        assert_eq!(arr[..], [0, 1, 2, 3, 4]);\n        assert_eq!(arr[..3], [0, 1, 2]);\n        assert_eq!(arr[..=3], [0, 1, 2, 3]);\n        assert_eq!(arr[1..], [1, 2, 3, 4]);\n        assert_eq!(arr[1..3], [1, 2]); // This is a `Range`\n        assert_eq!(arr[1..=3], [1, 2, 3]);\n        assert_eq!((3..5), std::ops::Range { start: 3, end: 5 });\n    }\n}\n\n\n8.4 while\nfn main() {\n    let z: i32;\n    while true {\n        z = 1;\n        break;\n    }\n    // 打印这个的时候, 编译器无法直到 z到底是不是赋值了,\n    // 因为他认为while 能否进去是要判断的,\n    // 当然我们一看就知道是true 能进去,但是编译器不行\n    // 相比while loop 肯定是能进去的.\n    println!(\"{}\", z); //报错了\n}",
    "crumbs": [
      "基础篇",
      "快速入门"
    ]
  },
  {
    "objectID": "docs/rust/basic/02.quick-start.html#测试",
    "href": "docs/rust/basic/02.quick-start.html#测试",
    "title": "斯巴拉稀",
    "section": "9 测试",
    "text": "9 测试\n#[cfg(test)]  //配置测试模块\nmod tests {\n    #[test]  //单元测试用例\n    fn it_works() {\n        let result = 2 + 2;\n        assert_eq!(result, 4);\n    }\n    // 再来一个测试用例\n    #[test]\n    fn it_works2() {\n        let result = 2 + 2;\n        assert_eq!(result, 4);\n    }\n}\ncargo test",
    "crumbs": [
      "基础篇",
      "快速入门"
    ]
  },
  {
    "objectID": "docs/rust/basic/02.quick-start.html#查看汇编",
    "href": "docs/rust/basic/02.quick-start.html#查看汇编",
    "title": "斯巴拉稀",
    "section": "10 查看汇编",
    "text": "10 查看汇编\nrustc --emit=asm main.rs",
    "crumbs": [
      "基础篇",
      "快速入门"
    ]
  },
  {
    "objectID": "docs/rust/basic/02.quick-start.html#打印信息",
    "href": "docs/rust/basic/02.quick-start.html#打印信息",
    "title": "斯巴拉稀",
    "section": "11 打印信息",
    "text": "11 打印信息\n\n11.1 打印变量类型名\nuse std::any::type_name;\n\nfn print_type_of&lt;T&gt;(_: &T) {\n    println!(\"{}\", type_name::&lt;T&gt;());\n}\n\nfn main() {\n    let x = 42;\n    print_type_of(&x); // 输出: i32\n\n    let y = 3.14;\n    print_type_of(&y); // 输出: f64\n\n    let z = \"hello\";\n    print_type_of(&z); // 输出: &str\n}\n\n\n11.2 常用打印\n\nformat!: 格式化文本到 String\nprint!: 同format! 只不过输出到 (io::stdout).\nprintln!: 同print! 但是换行\neprint!: 同 print! 只不过输出到 (io::stderr).\neprintln!: 同eprint! 但是换行\n\nfn main() {\n    println!(\"{} days\", 31);\n    // 多个可以使用 0 1 指定\n    println!(\"{0}, this is {1}. {1}, this is {0}\", \"Alice\", \"Bob\");\n    let x = \"Alice\";\n    let y = \"Bob\";\n    println!(\"{x}, this is {y}. {y}, this is {x}\");\n    println!(\"{a}, this is {b}. {b}, this is {a}\", a = \"Alice\", b = \"Bob\");\n    println!(\"Base 10:               {}\", 69420); // 69420\n    println!(\"Base 2 (binary):       {:b}\", 69420); // 10000111100101100\n    println!(\"Base 8 (octal):        {:o}\", 69420); //八进制: 207454\n    println!(\"Base 16 (hexadecimal): {:x}\", 69420); //16禁止: 10f2c\n                                                    // &gt; 表示往右对齐,然后这里左边填充\n    println!(\"|{number:&gt;5}|\", number = 1); // 4个空格 和一个1\n    println!(\"{number:0&gt;5}\", number = 1); // 用0填充 :   00001\n    println!(\"{number:0&lt;5}\", number = 1); // 用0填充 :   10000\n                                          // 注意 需要 $\n    println!(\"{number:0&gt;width$}\", number = 1, width = 5);\n\n    let number: f64 = 1.0;\n    let width: usize = 5;\n    println!(\"{number:&gt;width$}\");\n}\n\n\n11.3 Debug\n所有实现了fmt::Debug这个trait(暂时不用管这个概念)的类型,才能使用println!(\"{:?}\")中{:?}或{:#?}这种打印方式\nstruct Cat(i32);\n\n#[derive(Debug)] // 添加这个就自动实现了Debug trait\nstruct Dog(i32);\nfn main() {\n    println!(\"Cat: {:?} \", Cat(5)); // 报错了\n    println!(\"Dog: {:?} \", Dog(5)); // ok\n}\n\n\n11.4 Display\n所有实现了fmt::Display这个trait(暂时不用管这个概念)的类型,才能使用println!(\"{}\")中{}这种打印方式\nuse std::fmt;\nstruct Point2D {\n    x: f64,\n    y: f64,\n}\n\n// implement `Display` for `Point2D`.\nimpl fmt::Display for Point2D {\n    fn fmt(&self, f: &mut fmt::Formatter) -&gt; fmt::Result {\n        // Customize so only `x` and `y` are denoted.\n        write!(f, \"x: {}, y: {}\", self.x, self.y)\n    }\n}\nfn main() {\n    let p = Point2D { x: 3.3, y: 7.2 };\n    println!(\"p: {}\", p);\n    // 实现了Display, 就能.to_string() 获取字符串 String\n    println!(\"{}\", p.to_string());\n}",
    "crumbs": [
      "基础篇",
      "快速入门"
    ]
  },
  {
    "objectID": "docs/rust/basic/12.crate-mod.html#crate",
    "href": "docs/rust/basic/12.crate-mod.html#crate",
    "title": "斯巴拉稀",
    "section": "1 crate",
    "text": "1 crate\nRust 程序由 crate组成. 每个 crate 都是既完整又内聚的单元,包括单个库(library)或可执行程序的所有源代码,以及任何相关的测试、示例、工具、配置和其他杂项\ncrate root 是源代码文件,编译器会从这里开始组成你的crate的根module\ncargo new hello\ncd hello\ntree\n.\n├── Cargo.toml\n└── src\n    ├   # 这个是 binary crate 的crate root\n    ├   # 这个 binary crate 的名字与package相同, hello\n    └── main.rs\n# 我们手动创建一个library crate\n# 这个 library crate 的名字也是与package相同,hello\ntouch src/lib.rs # 这个文件默认就是 library crate 的crate root\nCargo.toml 没有指定上面2个文件名是 crate root ,因为这个是一种默认约定, 就像go里的main.go, cargo 会把crate root 文件给 rustc来构建",
    "crumbs": [
      "基础篇",
      "模块系统"
    ]
  },
  {
    "objectID": "docs/rust/basic/12.crate-mod.html#module",
    "href": "docs/rust/basic/12.crate-mod.html#module",
    "title": "斯巴拉稀",
    "section": "2 module",
    "text": "2 module\n模块是组织代码的一种方式,它允许你将代码分割到不同的文件中,并让每个文件只包含相关的代码. 模块可以嵌套,并且可以被任意数量的模块使用\nmod front_of_house {\n    mod hosting {\n        fn add_to_waitlist() {}\n        fn seat_at_table() {}\n    }\n    mod serving {\n        fn take_order() {}\n        fn serve_order() {}\n        fn take_payment() {}\n    }\n}\n前面我们说到 src/main.rs and src/lib.rs 之所以被称为 crate root, 这是因为 main.rs或lib.rs 文件的内容形成了一个名字叫做 crate的模块,位于module tree的root位置\n上面代码的 module tree\ncrate #(根部,名字为crate的模块)\n └── front_of_house # (名字为front_of_house的模块)\n     ├── hosting #(名字为hosting的模块)\n     │   ├── add_to_waitlist\n     │   └── seat_at_table\n     └── serving #(名字为serving的模块)\n         ├── take_order\n         ├── serve_order\n         └── take_payment\n就像目录一样, 这样我们是不是就可以像目录一样的访问方式去找到我们的模块",
    "crumbs": [
      "基础篇",
      "模块系统"
    ]
  },
  {
    "objectID": "docs/rust/basic/12.crate-mod.html#path",
    "href": "docs/rust/basic/12.crate-mod.html#path",
    "title": "斯巴拉稀",
    "section": "3 path",
    "text": "3 path\n.\n├── Cargo.toml\n└── src\n    ├── lib.rs\n    └── main.rs\n\n\nsrc/lib.rs\n\nmod front_of_house {\n    // hosting 是模块, 是front_of_house 私有的\n    // 如果要让外部访问, 需要 + pub\n    pub mod hosting {\n        // 同理\n        pub fn add_to_waitlist() {}\n    }\n}\n\npub fn eat_at_restaurant() {\n    // 绝对路径调用, 这个lib.rs 文件隐含着 形成的 名为 crate的模块\n    // 因为 front_of_house 和 eat_at_restaurant 在同一个crate中,\n    // 注意 eat_at_restaurant 是方法,不是模块, 所以它是在 根模块 crate 中\n    // 好比 linux的目录 / 中, 而 front_of_house 是模块, 就好比 /front_of_house 目录\n    // 所以可以直接使用 crate:: 来,不需要 pub front_of_house\n    crate::front_of_house::hosting::add_to_waitlist();\n\n    // 相对路径\n    // 好比在目录 / 中访问 front_of_house/hosting/add_to_waitlist\n    front_of_house::hosting::add_to_waitlist();\n\n    let mut meal = back_of_house::Breakfast::summer(\"Rye\");\n    meal.toast = String::from(\"Wheat\");\n    println!(\"I'd like {} toast please\", meal.toast);\n\n    //  seasonal_fruit 是私有的, 无法访问\n    // meal.seasonal_fruit = String::from(\"blueberries\");\n}\n\nfn deliver_order() {}\n\nmod back_of_house {\n    fn fix_incorrect_order() {\n        cook_order();\n        // super 父模块 ,得到根模块 crate\n        // 子模块访问父模块的方法, 方法不需要pub\n        super::deliver_order();\n        // 绝对路径\n        crate::deliver_order();\n    }\n\n    fn cook_order() {\n        // 父模块访问子模块 fridge里的方法, 方法需要pub\n        fridge::get_item();\n    }\n\n    mod fridge {\n        pub fn get_item() {}\n    }\n\n    // 结构体的 权限\n    pub struct Breakfast {\n        pub toast: String, // pub\n        seasonal_fruit: String, //私有\n    }\n\n    impl Breakfast {\n        pub fn summer(toast: &str) -&gt; Breakfast {\n            Breakfast {\n                toast: String::from(toast),\n                seasonal_fruit: String::from(\"peaches\"),\n            }\n        }\n    }\n    // 枚举的权限, 只要 pub enum ,成员变体就全是pub了\n    pub enum Appetizer {\n        Soup,\n        Salad,\n    }\n}",
    "crumbs": [
      "基础篇",
      "模块系统"
    ]
  },
  {
    "objectID": "docs/rust/basic/12.crate-mod.html#use",
    "href": "docs/rust/basic/12.crate-mod.html#use",
    "title": "斯巴拉稀",
    "section": "4 use",
    "text": "4 use\n\n\n\n\n\n\nTip\n\n\n\nuse 语句将路径引入到当前作用域,从而允许你使用路径中指定的名称\n\n\n\n4.1 mod\nmod front_of_house {\n    pub mod hosting {\n        pub fn add_to_waitlist() {}\n        pub struct Dog {}\n    }\n}\n// 将hosting 引入当前作用域, 这样 就能直接使用 这个hosting模块\n// 相当于在 crate 根模块中 定义了 hosting 模块\n1use crate::front_of_house::hosting;\n// 使用相对路径, as 别名\nuse front_of_house::hosting as hosting2;\n// 引入函数一般是引入到父级模块\n// 可以use 引入具体的函数,但是一般我们不这样弄,\n// 因为 最后是让你自己知道使用的函数是引入的模块里的还是你自己这里定义的\nuse front_of_house::hosting::add_to_waitlist as waitlist;\n// 如果是引入 struct enum 等其他不是函数的东西 ,一般就use 到 具体的struct,enum.\nuse front_of_house::hosting::Dog;\n\n// 外部代码 默认是不能访问, use 还需要 加上pub\n// pub use 表示导出, 这样外部代码就能 导入到它的作用域\npub use front_of_house::hosting as pub_hosting;\n\npub fn eat_at_restaurant() {\n    hosting::add_to_waitlist();\n    hosting2::add_to_waitlist();\n    waitlist();\n    let a = Dog {};\n}\n\nmod back_of_house {\n    use crate::front_of_house::hosting;\n\n    fn take() {\n        // 当前这个 back_of_house 模块下想直接使用, 还是得 use 引入\n        // add_to_waitlist 还是必须pub\n        hosting::add_to_waitlist();\n        // 使用super 来\n        super::hosting::add_to_waitlist();\n    }\n}\n\n1\n\n将hosting 引入当前作用域, 这样 就能直接使用 这个hosting模块 相当于在 crate 根模块中 定义了 hosting 模块\n\n\n\n\n4.2 package\n\n\n\n\n\n\n使用外部package\n\n\n\n\nCargo.toml 添加要依赖的包\n代码中使用 use 将包引入到自己的作用域\n虽然std标准库也是外部包,但是已经被内置,所以不需要Cargo.toml 中添加\n\n\n\n添加包\ncargo add rand\n查看一下Cargo.toml\n[package]\nname = \"hello\"\nversion = \"0.1.0\"\nedition = \"2021\"\n[dependencies]\nrand = \"0.8.5\"\nuse rand::Rng;  // 引入添加的外部包\nuse std::collections::HashMap; // 引入标准库\nfn main() {}\n\n\n4.3 use 其他语法\nuse std::cmp::Ordering;\nuse std::io;\n使用{} 来简写\nuse std::{cmp::Ordering, io};\nuse std::io;\nuse std::io::Write;\n使用 self\nuse std::io::{self, Write};\n使用*\nuse std::collections::*;",
    "crumbs": [
      "基础篇",
      "模块系统"
    ]
  },
  {
    "objectID": "docs/rust/basic/12.crate-mod.html#模块拆分",
    "href": "docs/rust/basic/12.crate-mod.html#模块拆分",
    "title": "斯巴拉稀",
    "section": "5 模块拆分",
    "text": "5 模块拆分\n1mod front_of_house;\n\npub use crate::front_of_house::hosting;\n\npub fn eat_at_restaurant() {\n    hosting::add_to_waitlist();\n}\n\n1\n\n如果我们在定义mod 时, 模块名后面跟着 ; 号,那么rust会从src目录下找与模块同名的文件,里面的内容就是这个模块的定义\n\n\n\n\nsrc/front_of_house.rs\n\npub mod hosting {\n    pub fn add_to_waitlist() {\n        println!(\"hello\");\n    }\n}\n\n我们继续将front_of_house.rs里的hosting模块进行拆分\n\n\nsrc/front_of_house.rs\n\npub mod hosting;\n\ncd src\nmkdir -p front_of_house\n我们需要在 front_of_house 目录下创建hosting.rs 文件\n\n\nsrc/front_of_house/hosting.rs\n\npub fn add_to_waitlist() {\n    println!(\"hello\");\n}",
    "crumbs": [
      "基础篇",
      "模块系统"
    ]
  },
  {
    "objectID": "docs/rust/basic/12.crate-mod.html#参考链接",
    "href": "docs/rust/basic/12.crate-mod.html#参考链接",
    "title": "斯巴拉稀",
    "section": "6 参考链接",
    "text": "6 参考链接\ncrates.io github crates.io",
    "crumbs": [
      "基础篇",
      "模块系统"
    ]
  },
  {
    "objectID": "docs/rust/basic/03.ownership.html",
    "href": "docs/rust/basic/03.ownership.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "所有权是rust用来管理内存的一系列规则",
    "crumbs": [
      "基础篇",
      "所有权"
    ]
  },
  {
    "objectID": "docs/rust/basic/03.ownership.html#所有权规则",
    "href": "docs/rust/basic/03.ownership.html#所有权规则",
    "title": "斯巴拉稀",
    "section": "",
    "text": "所有权是rust用来管理内存的一系列规则",
    "crumbs": [
      "基础篇",
      "所有权"
    ]
  },
  {
    "objectID": "docs/rust/basic/03.ownership.html#变量作用域",
    "href": "docs/rust/basic/03.ownership.html#变量作用域",
    "title": "斯巴拉稀",
    "section": "2 变量作用域",
    "text": "2 变量作用域\nfn main() {\n    println!(\"{}\", 1);\n    {// 这一行时  s 变量 还没申明, 不可用\n        let s = \"hello\"; // s 变量可用\n\n        // do stuff with s\n    } // 这个作用域结束了, s 变量无效了\n    // println!(\"{}\", s); // cannot find value s in this scope\n}\n    {\n        let s = String::from(\"hello\");\n    }\n    // s 无效了\n\n\n\n\n\n\n为什么内存在持有它的变量离开作用域后会被无效了呢?\n\n\n\n当变量离开作用域, Rust 会调用一个名为drop的特殊函数\n设计string类型的作者可以在该drop函数中写一些释放内存的代码,以此实现自动释放内存的功能\n不同类型变量的drop的实现可能不一样\nRust 在结尾的 } 处会自动调用 drop",
    "crumbs": [
      "基础篇",
      "所有权"
    ]
  },
  {
    "objectID": "docs/rust/basic/03.ownership.html#move-copy",
    "href": "docs/rust/basic/03.ownership.html#move-copy",
    "title": "斯巴拉稀",
    "section": "3 Move & Copy",
    "text": "3 Move & Copy\n\n3.1 copy\n类型实现了 Copy trait 则会被copy\nfn main() {\n    let x = 5;\n    // 将x的值copy 给y, 2个变量同时存在\n    // 因为这里是直接在栈上,拷贝起来是非常快的\n    // 所以在设计上就直接简单复制,对比看后面的字符串的情况\n    let y = x;\n    println!(\"{:p}-{:p}\", &x, &y);\n    println!(\"{x},{y}\");\n}\n不可变引用的赋值\nfn main() {\n    let a = 1;\n    let b = &a;\n    let c = b; // copy\n\n    println!(\"{b}\"); //ok\n    println!(\"{c}\");\n}\n\n\n3.2 move\nfn main() {\n    // s1 拥有这个hello字符串的所有权\n    let s1 = String::from(\"hello\");\n    println!(\"{:p}\", &s1);\n    // s1 没有了 hello字符串的所有权,s1 将处于不可用状态\n    //  转移给了 s2,s2有了所有权\n    let s2 = s1;\n    println!(\"{:p}\", &s2);\n    // 提示错误 : borrow of moved value,s1 已经被borrow了\n    // println!(\"{s1}\");\n    println!(\"{s2}\");\n}\n\n\n\n\n\n\n字符串为啥设计成move?\n\n\n\n\ns2=s1 实际会将栈上的数据复制一份\n如果这个时候 s1和s2 离开作用域, 那么要drop(释放堆上实际的字符串)了,会做释放同一块内存的操作,导致double free error,这样有安全问题\n既然这样rust 设计成让执行 s2=s1的时候, 让s1 无效,这样s1跳出作用域时,不需要free了, 这就是 Move ,s1 was moved into s2\n\n\n\n\n可变引用的赋值操作\nfn main() {\n    let mut a = 1;\n    let b = &mut a;\n    let c = b;\n    // 报错了\n    // 因为 b 已经移动给了 c, b 已经不可用了\n    println!(\"{b}\");\n}\n\n\n\n\n\n\nImportant\n\n\n\nrust 永远不会做深拷贝的事情,因为开销大,当然除非你主动\n\n\n    let s1 = String::from(\"hello\");\n    // 深拷贝了\n    let s2 = s1.clone();\n\n    println!(\"s1 = {}, s2 = {}\", s1, s2);\n\n\n3.3 move 还是 copy",
    "crumbs": [
      "基础篇",
      "所有权"
    ]
  },
  {
    "objectID": "docs/rust/basic/03.ownership.html#函数传参所有权问题",
    "href": "docs/rust/basic/03.ownership.html#函数传参所有权问题",
    "title": "斯巴拉稀",
    "section": "4 函数传参所有权问题",
    "text": "4 函数传参所有权问题\n\n\n4.1 官方例子\nfn main() {\n    let s = String::from(\"hello\");\n    // s move into 函数\n    takes_ownership(s);\n    // 所以s 这个时候已经不可用了.\n    // println!(\"{s}\"); //报错了\n\n    let x = 5;\n    // x would move into the function,\n    // 但是 x 是i32 类型,在栈上,前面说过它会 copy 操作\n    makes_copy(x);\n    println!(\"{x}\"); // 这里还是可以访问的\n} // Here, x goes out of scope, then s. But because s's value was moved, nothing\n  // special happens.\n\nfn takes_ownership(some_string: String) {\n    // some_string comes into scope\n    println!(\"{}\", some_string);\n} // 跳出作用域,some_string 指向的堆以及自身(栈会弹)都会被drop, 内存会释放\n\nfn makes_copy(some_integer: i32) {\n    // some_integer comes into scope\n    println!(\"{}\", some_integer);\n} // Here, some_integer goes out of scope. Nothing special happens.\nTODO",
    "crumbs": [
      "基础篇",
      "所有权"
    ]
  },
  {
    "objectID": "docs/rust/basic/03.ownership.html#函数返回值所有权",
    "href": "docs/rust/basic/03.ownership.html#函数返回值所有权",
    "title": "斯巴拉稀",
    "section": "5 函数返回值所有权",
    "text": "5 函数返回值所有权\nfn main() {\n    let s1 = gives_ownership();\n\n    let s2 = String::from(\"hello\");\n\n    // s2 move 给了 takes_and_gives_back的参数\n    // takes_and_gives_back 返回值 move 给了 调用者, 给了s3\n    let s3 = takes_and_gives_back(s2);\n} // Here, s3 goes out of scope and is dropped. s2 was moved, so nothing\n  // happens. s1 goes out of scope and is dropped.\n\n// 会将返回值 move 给它的调用者\nfn gives_ownership() -&gt; String {\n    let some_string = String::from(\"yours\");\n\n    // 这个会作为返回值, move 给 当前函数的调用者\n    some_string\n}\n\n// This function takes a String and returns one\nfn takes_and_gives_back(a_string: String) -&gt; String {\n    // a_string comes into\n    // scope\n\n    a_string // a_string is returned and moves out to the calling function\n}",
    "crumbs": [
      "基础篇",
      "所有权"
    ]
  },
  {
    "objectID": "docs/rust/basic/03.ownership.html#借用-borrow",
    "href": "docs/rust/basic/03.ownership.html#借用-borrow",
    "title": "斯巴拉稀",
    "section": "6 借用 borrow",
    "text": "6 借用 borrow\n前面调用函数我们发现,每次调用函数,都会有 taking ownership 和 returning ownership,很烦, 有没有 可以直接使用某个值,而不需要 转移所有权的呢? –&gt; 引用\n\n\n\n\n\n\nTip\n\n\n\n我们想一想: 你引用某个文章, 这个文章肯定不是你的,对吧, 就好像你借了别人东西来用一样, 所有权还是别人的. 所以在rsut中 引用也叫借用\n\n\n& 表示引用某些值, 而不取得其所有权\nfn main() {\n    let s1 = String::from(\"hello\");\n    // &s1, 引用s1,  知道s1的地址, 就意味着 知道它的值\n    let len = calculate_length(&s1);\n\n    println!(\"The length of '{}' is {}.\", s1, len);\n}\n\nfn calculate_length(s: &String) -&gt; usize {\n    s.len()\n}//s 并不拥有 s1变量指向的值的所有权, 所以当 drop 后, s1变量指向的值不会free\n\n6.1 不可变和可变\nfn main() {\n    let s = String::from(\"hello\");\n\n    // changeImmutable(&s);\n\n    // 字符串 需要 可变\n    let mut s2 = String::from(\"hello\");\n    // 引用也需要可变\n    changeMutable(&mut s2);\n    println!(\"{:?}-{:?}\", s.as_ptr(), s2.as_ptr());\n\n}\n\nfn changeImmutable(some_string: &String) {\n    some_string.push_str(\", world\");  //报错了\n}\n// 参数需要可变\nfn changeMutable(some_string: &mut String) {\n    // some_string.push_str(\", world\");\n    some_string.pop();\n}\n\n\n6.2 编译是否成功的判断方法\n\n\n\n\n\n\n含引用的代码,编译是否成功的判断逻辑\n\n\n\n\nrust 希望你是明确知道自己是想要如何使用这块内存,然后正确定义合适的变量\n如果你使用不可变引用\n\n那么定义这个不可变引用后到最后一次使用它之前, 你肯定是希望它指向的数据不会被修改, 要不然你用个屁的不可变啊\n所以在定义一个不可变引用后 &a,你修改了a的数据, 然后你再使用这个不可变引用,那么就报错了,因为这和你的初衷是违背的\n\n如果你使用了可变引用\n\n那么定义这个可变引用后到最后一次使用它之前, 你肯定不希望有其他人来修改它,你希望只有你自己可以修改a的值,就是你在最后使用它之前,对 a 完全可控的,你不希望在读取它之前,被其他人修改\n所以在定义一个可变引用后, 你要确保你最后在使用它之前, 没有其他人修改它\n\n你可以认为 从你定义引用后到最后一次使用这个引用这段代码块是你这个引用变量的作用域\n\n前面的逻辑是我从 rust为什么要这样设计去思考得出的结论\n这里说的作用域是网上有这样说, 我觉得刚好符合我的逻辑思考,觉得挺好.\n\n\n\n\n报错的\nfn main() {\n    let mut a = 3;\n    let b = &mut a;\n    a = 31; // 这里提示错误\n    // 在使用这个 可变引用前,有其他人对a做了修改了\n    // 这不符合 定义可变引用的初衷\n    println!(\"{}\", b);\n}\n正确的\nfn main() {\n    let mut a = 3;\n    let b = &mut a;\n    *b = 11;\n    // 前面自己修改, 最后使用的地方, 都是想要的结果\n    // 用作用域来理解 也ok的\n    println!(\"{}\", b);\n    a = 31;\n    println!(\"{}\", a);\n}\n作用域\nfn main() {\n    let mut s2 = String::from(\"hello\");\n    {\n        let r3 = &mut s2;\n        println!(\"{}\", r3);\n    } // 这个时候r3 drop了. 所以后面 可以有 r4\n    let r4 = &mut s2;\n    println!(\"{}\", r4);\n}\n多个可变引用,ok的\nfn main() {\n    let mut a = 3;\n    let b = &mut a;\n    println!(\"{}\", b);\n    let c = &mut a;\n    println!(\"{}\", c);\n}\n报错的\nfn main() {\n    let mut a = 3;\n    let b = &mut a;\n    let c = &mut a;\n    // 你使用b的时候,前面有 个c 可能做 对a的修改\n    // 这样你这里使用b时,可能就不是你想要的结果了.\n    // 按照前面的说法, 可以理解为: 一个作用域内 只能有一个可变引用\n    println!(\"{}\", b);\n    println!(\"{}\", c);\n}\n报错了\nfn main() {\n    let mut a = 3;\n    let b = &a;\n    let c = &mut a;\n    // 报错了, 你使用不可变引用,但是前面c 可能会修改a\n    println!(\"{}\", b);\n    println!(\"{}\", c);\n}\n多个不可变引用\nfn main() {\n    let mut s = String::from(\"hello\");\n    // 在有一个可变引用之前的 多个不可变引用, 完全ok\n    // 这个道理很好理解,因为在 可变引用之前,变量不存在竞争\n    let a1 = &s; // 不可变引用\n    let a2 = &s; // 多个不可变引用 ,可以的\n    // 关键: 因为在可变引用之前,所以使用的时候,不会出现被修改的情况\n    println!(\"{}-{}\", a1, a2);\n    let x1 = &mut s; // 可变引用\n    println!(\"{}\", x1);\n}\n报错\nfn main() {\n    let mut s = String::from(\"hello\");\n    let a1 = &s;\n    let a2 = &s;\n    s.push_str(\"world\");  // 同样会报错\n    // 因为这个时候, s 已经被修改了, 不可变引用的意义没了\n    println!(\"{}-{}\", a1, a2);\n}\n\n\n6.3 悬挂引用\nrust 编译器会直接报错\nfn main() {\n    let reference_to_nothing = dangle();\n}\n\nfn dangle() -&gt; &String {\n    let s = String::from(\"hello\");\n\n    &s\n} // s drop 掉了, 所在内存被释放了. &s 引用了一个不可控的内存\n\n\n6.4 reborrow (好好看看)\n\n6.4.1 可变借用直接赋值\n报错的\nfn main() {\n    let mut a = 3;\n    let b = &mut a;\n    let c = b;  // 被move掉了, \n    println!(\"{}\", b); //报错\n    println!(\"{}\", c);\n}\n报错了, 你可能以为这不和上面一样吗, b move给了c, 你打印b肯定错了\nfn main() {\n    let mut a = 3;\n    let b = &mut a;\n    let c: &mut i32 = b;\n    println!(\"{}\", b);\n    println!(\"{}\", c);\n}\n实际上我们看下报错信息,非常有意思, 竟然说b被可变借用了,而不是move给了c?\n\n\nerror信息\n\nerror[E0502]: cannot borrow `b` as immutable because it is also borrowed as mutable\n --&gt; src/main.rs:5:20\n  |\n4 |     let c: &mut i32 = b;\n  |                       - mutable borrow occurs here\n5 |     println!(\"{}\", b);\n  |                    ^ immutable borrow occurs here\n6 |     println!(\"{}\", c); //\n  |                    - mutable borrow later used here\n\n先看下这个类比\nfn main() {\n    let mut b = 1;\n    let c=&mut b;\n    // 报错了 b的一个不可变借用在一个可变借用的包围圈里\n    // 这里我再说下我自己对于前面理论的一种理解\n    // 可能有人觉得 这里不可变借用就刚好是我想要的结果,即使前面c对b做了修改\n    // 我想编译器可不会搞这么细, 我想它是认为你在可变借用包围里,可能被修改了\n    // 就好比\n    /*\n    let d=&b;\n    *c=11;  ---&gt; 可能有这种情况的,所以编译器不会搞那么细,直接交集就当错\n    println!(\"{}\", d);\n    */\n    println!(\"{}\", b);\n    println!(\"{}\", c);\n}\n再看看前面的 let c: &mut i32 = b; 说是b被可变借用了,怎么就可变借用了? 只有下面这种可能了 let c: &mut i32 = b; 估计是等价于\nlet c= &mut *b; // 这样b 确实可以说被可变借用了\n完整类比\nfn main() {\n    let mut a = 3;\n    let b = &mut a;\n    let c = &mut *b;\n    println!(\"{}\", b);\n    println!(\"{}\", c);\n}\n现在在看看正确的\nfn main() {\n    let mut a = 3;\n    let b = &mut a;\n    // c是(*b)的可变借用,认为与a无关, 虽然实际和 &mut a一样\n    // 这样 实际上 就好像有 a的2个可变借用,且还有交集的样子\n    let c = &mut *b;\n    *c = 4;\n    println!(\"{}\", c);\n    println!(\"{}\", b);\n}\n\n\n6.4.2 可变借用函数传参\n我是最先测试函数传可变借用时,发现奇怪现象的\nfn main() {\n    let mut a = 3;\n    let b = &mut a;\n    ppp(b);\n    // ppp(&mut a); // 对比这个,如果用这个,就会报错了\n    println!(\"{b}\"); // ok\n}\n// 相当于 let s:&mut i32=b;\nfn ppp(s: &mut i32) {\n    *s = 11;\n}\n同样的,b 没有发生 move",
    "crumbs": [
      "基础篇",
      "所有权"
    ]
  },
  {
    "objectID": "docs/rust/basic/07.generic.html",
    "href": "docs/rust/basic/07.generic.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "fn largest_i32(list: &[i32]) -&gt; &i32 {\n    let mut largest = &list[0];\n\n    for item in list {\n        if item &gt; largest {\n            largest = item;\n        }\n    }\n\n    largest\n}\n\nfn largest_char(list: &[char]) -&gt; &char {\n    let mut largest = &list[0];\n\n    for item in list {\n        if item &gt; largest {\n            largest = item;\n        }\n    }\n\n    largest\n}\n\nfn main() {\n    let number_list = vec![34, 50, 25, 100, 65];\n\n    let result = largest_i32(&number_list);\n    println!(\"The largest number is {}\", result);\n\n    let char_list = vec!['y', 'm', 'a', 'q'];\n\n    let result = largest_char(&char_list);\n    println!(\"The largest char is {}\", result);\n}\n我们发现 同样的逻辑代码,我们写了2遍, 很麻烦,重复代码, 使用泛型来作为具体类型的抽象\n泛型是一种类型,在函数中使用它作为参数的类型,是需要申明的,首先肯定不会和参数的申明放在一块,所以rust在函数名和参数列表之间使用&lt;T&gt;,一般用T来作为泛型标识\n// T: std::cmp::PartialOrd\n// 这里的代码 运行会提示错误, 很显然 不是所有的类型都能做比较大小的操作的\n// 将T改成 T: std::cmp::PartialOrd 就ok了, 后面trait 里会说\nfn largest&lt;T&gt;(list: &[T]) -&gt; &T {\n    let mut largest = &list[0];\n\n    for item in list {\n        if item &gt; largest {\n            largest = item;\n        }\n    }\n\n    largest\n}\n\nfn main() {\n    let number_list = vec![34, 50, 25, 100, 65];\n\n    let result = largest(&number_list);\n    println!(\"The largest number is {}\", result);\n\n    let char_list = vec!['y', 'm', 'a', 'q'];\n\n    let result = largest(&char_list);\n    println!(\"The largest char is {}\", result);\n}",
    "crumbs": [
      "基础篇",
      "泛型"
    ]
  },
  {
    "objectID": "docs/rust/basic/07.generic.html#在函数中使用",
    "href": "docs/rust/basic/07.generic.html#在函数中使用",
    "title": "斯巴拉稀",
    "section": "",
    "text": "fn largest_i32(list: &[i32]) -&gt; &i32 {\n    let mut largest = &list[0];\n\n    for item in list {\n        if item &gt; largest {\n            largest = item;\n        }\n    }\n\n    largest\n}\n\nfn largest_char(list: &[char]) -&gt; &char {\n    let mut largest = &list[0];\n\n    for item in list {\n        if item &gt; largest {\n            largest = item;\n        }\n    }\n\n    largest\n}\n\nfn main() {\n    let number_list = vec![34, 50, 25, 100, 65];\n\n    let result = largest_i32(&number_list);\n    println!(\"The largest number is {}\", result);\n\n    let char_list = vec!['y', 'm', 'a', 'q'];\n\n    let result = largest_char(&char_list);\n    println!(\"The largest char is {}\", result);\n}\n我们发现 同样的逻辑代码,我们写了2遍, 很麻烦,重复代码, 使用泛型来作为具体类型的抽象\n泛型是一种类型,在函数中使用它作为参数的类型,是需要申明的,首先肯定不会和参数的申明放在一块,所以rust在函数名和参数列表之间使用&lt;T&gt;,一般用T来作为泛型标识\n// T: std::cmp::PartialOrd\n// 这里的代码 运行会提示错误, 很显然 不是所有的类型都能做比较大小的操作的\n// 将T改成 T: std::cmp::PartialOrd 就ok了, 后面trait 里会说\nfn largest&lt;T&gt;(list: &[T]) -&gt; &T {\n    let mut largest = &list[0];\n\n    for item in list {\n        if item &gt; largest {\n            largest = item;\n        }\n    }\n\n    largest\n}\n\nfn main() {\n    let number_list = vec![34, 50, 25, 100, 65];\n\n    let result = largest(&number_list);\n    println!(\"The largest number is {}\", result);\n\n    let char_list = vec!['y', 'm', 'a', 'q'];\n\n    let result = largest(&char_list);\n    println!(\"The largest char is {}\", result);\n}",
    "crumbs": [
      "基础篇",
      "泛型"
    ]
  },
  {
    "objectID": "docs/rust/basic/07.generic.html#在结构体中使用",
    "href": "docs/rust/basic/07.generic.html#在结构体中使用",
    "title": "斯巴拉稀",
    "section": "2 在结构体中使用",
    "text": "2 在结构体中使用\nstruct Point&lt;T&gt; {\n    x: T,\n    y: T,\n}\n\nfn main() {\n    let integer = Point { x: 5, y: 10 };\n    let float = Point { x: 1.0, y: 4.0 };\n}\n使用多个泛型\nstruct Point&lt;T, U&gt; {\n    x: T,\n    y: U,\n}\n\nfn main() {\n    let both_integer = Point { x: 5, y: 10 };\n    let both_float = Point { x: 1.0, y: 4.0 };\n    // 这样你随便写啥都行\n    let integer_and_float = Point { x: 5, y: 4.0 };\n}",
    "crumbs": [
      "基础篇",
      "泛型"
    ]
  },
  {
    "objectID": "docs/rust/basic/07.generic.html#在枚举中使用",
    "href": "docs/rust/basic/07.generic.html#在枚举中使用",
    "title": "斯巴拉稀",
    "section": "3 在枚举中使用",
    "text": "3 在枚举中使用\nenum Option&lt;T&gt; {\n    Some(T),\n    None,\n}\n\nenum Result&lt;T, E&gt; {\n    Ok(T),\n    Err(E),\n}\n\nfn main() {\n    let some_value = Option::Some(5);\n    let none_value = Option::None;\n\n    let integer_value = Result::Ok(5);\n    let error_value = Result::Err(5);\n}",
    "crumbs": [
      "基础篇",
      "泛型"
    ]
  },
  {
    "objectID": "docs/rust/basic/07.generic.html#在方法中使用",
    "href": "docs/rust/basic/07.generic.html#在方法中使用",
    "title": "斯巴拉稀",
    "section": "4 在方法中使用",
    "text": "4 在方法中使用\nstruct Point&lt;T&gt; {\n    x: T,\n    y: T,\n}\n// 在impl 后&lt;T&gt; 来申明\n// 来表明是为  Point&lt;T&gt; 这个类型实现方法\nimpl&lt;T&gt; Point&lt;T&gt; {\n    fn x(&self) -&gt; &T {\n        &self.x\n    }\n}\n// 可以为 某个具体的类型实现方法\n// 因为上面的泛型包含了这种情况, 所以同时存在会报错\n// impl Point&lt;i32&gt; {\n//     fn x(&self) -&gt; &i32 {\n//         &self.x\n//     }\n// }\nfn main() {\n    let p = Point { x: 5, y: 10 };\n\n    println!(\"p.x = {}\", p.x());\n}\n方法与结构体使用不同的泛型\nstruct Point&lt;X1, Y1&gt; {\n    x: X1,\n    y: Y1,\n}\n\nimpl&lt;X1, Y1&gt; Point&lt;X1, Y1&gt; {\n    // 这里mixup后申明的X2,Y2,表示 方法里使用了X2,Y2泛型,与Point&lt;X1, Y1&gt;中的X1,Y1不一样\n    fn mixup&lt;X2, Y2&gt;(self, other: Point&lt;X2, Y2&gt;) -&gt; Point&lt;X1, Y2&gt; {\n        Point {\n            x: self.x,\n            y: other.y,\n        }\n    }\n}\n\nfn main() {\n    let p1 = Point { x: 5, y: 10.4 };\n    let p2 = Point { x: \"Hello\", y: 'c' };\n\n    let p3 = p1.mixup(p2);\n\n    println!(\"p3.x = {}, p3.y = {}\", p3.x, p3.y);\n}",
    "crumbs": [
      "基础篇",
      "泛型"
    ]
  },
  {
    "objectID": "docs/rust/basic/07.generic.html#性能问题",
    "href": "docs/rust/basic/07.generic.html#性能问题",
    "title": "斯巴拉稀",
    "section": "5 性能问题",
    "text": "5 性能问题\n\n\n\n\n\n\nTip\n\n\n\n其实泛型相当于占位符,然后把你编写的代码理解成模板, 编译器编译的时候,会将这些占位符替换成具体的类型, 比如上面的例子, 编译器会根据你实际使用的情况,将T替换成具体的类型比如 i32,f64,会生成对应的代码, 这个叫单态化, 这样运行时不会有额外的开销\n\n\nimpl Point&lt;i32&gt; {\n    fn x(&self) -&gt; &i32 {\n        &self.x\n    }\n}\n\nimpl Point&lt;f64&gt; {\n    fn x(&self) -&gt; &f64 {\n        &self.x\n    }\n}",
    "crumbs": [
      "基础篇",
      "泛型"
    ]
  },
  {
    "objectID": "docs/rust/basic/14.smart-pointer.html",
    "href": "docs/rust/basic/14.smart-pointer.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "指针: 指向一块内存地址的变量,变量的值是内存地址\n智能指针\n\nRust 的智能指针是一类数据结构，它们对传统指针的功能进行了扩展\n它们通常包含元数据（例如，引用计数）以管理内存和对象的生命周期\nRust 标准库中定义了几种智能指针，如 Box, Rc, Arc, Ref, RefMut, Cell, RefCell 等\n智能指针的主要目的是提供对内存安全、并发安全以及数据共享和所有权转移的更精细的控制\n\n\n\n智能指针通常使用struct来实现,实现了Deref和Drop trait\n\nDeref trait 允许智能指针像引用一样使用, 例如解引用\nDrop trait 智能指针在离开作用域时执行的代码",
    "crumbs": [
      "基础篇",
      "智能指针"
    ]
  },
  {
    "objectID": "docs/rust/basic/14.smart-pointer.html#相关概念",
    "href": "docs/rust/basic/14.smart-pointer.html#相关概念",
    "title": "斯巴拉稀",
    "section": "",
    "text": "指针: 指向一块内存地址的变量,变量的值是内存地址\n智能指针\n\nRust 的智能指针是一类数据结构，它们对传统指针的功能进行了扩展\n它们通常包含元数据（例如，引用计数）以管理内存和对象的生命周期\nRust 标准库中定义了几种智能指针，如 Box, Rc, Arc, Ref, RefMut, Cell, RefCell 等\n智能指针的主要目的是提供对内存安全、并发安全以及数据共享和所有权转移的更精细的控制\n\n\n\n智能指针通常使用struct来实现,实现了Deref和Drop trait\n\nDeref trait 允许智能指针像引用一样使用, 例如解引用\nDrop trait 智能指针在离开作用域时执行的代码",
    "crumbs": [
      "基础篇",
      "智能指针"
    ]
  },
  {
    "objectID": "docs/rust/basic/14.smart-pointer.html#box",
    "href": "docs/rust/basic/14.smart-pointer.html#box",
    "title": "斯巴拉稀",
    "section": "2 Box",
    "text": "2 Box\nBox 是一个智能指针,它允许在堆上存储数据，并确保在离开作用域时正确清理\nfn main() {\n    // 5 是在 堆上分配的, 栈上的变量b 指向了 它\n    let b = Box::new(5);\n    println!(\"b = {}\", b);\n}\n我们运行一下这个,看看报错的信息\n// 这里的定义本身就报错了, 因为这个 枚举类型的大小无法确定\nenum List {\n    Cons(i32, List),\n    Nil,\n}\n\nuse crate::List::{Cons, Nil};\n\nfn main() {\n    let list = Cons(1, Cons(2, Cons(3, Nil)));\n}\n提示使用Box ,这样 cons(i32, Box&lt;List&gt;) 大小就确定了.\nhelp: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to break the cycle\n  |\n2 |     Cons(i32, Box&lt;List&gt;),\n修改后\nenum List {\n    Cons(i32, Box&lt;List&gt;),\n    Nil,\n}\n\nuse crate::List::{Cons, Nil};\n\nfn main() {\n    let list = Cons(1, Box::new(Cons(2, Box::new(Cons(3, Box::new(Nil))))));\n}",
    "crumbs": [
      "基础篇",
      "智能指针"
    ]
  },
  {
    "objectID": "docs/rust/basic/14.smart-pointer.html#deref-trait",
    "href": "docs/rust/basic/14.smart-pointer.html#deref-trait",
    "title": "斯巴拉稀",
    "section": "3 deref trait",
    "text": "3 deref trait\n\n3.1 Box\nfn main() {\n    let x = 5;\n    let y = &x;\n\n    assert_eq!(5, x);\n    assert_eq!(5, *y);// *y 解引用 得到 x\n}\n因为Box 实现了Deref trait,所以可以对Box&lt;T&gt;进行解引用操作是可以的\nfn main() {\n    let x = 5;  // 栈上的5\n    let y = Box::new(x); // 将5复制到堆上\n\n    assert_eq!(5, x);\n    assert_eq!(5, *y);\n}\n\n\n3.2 自定义智能指针\nstruct MyBox&lt;T&gt;(T, T);\n\nimpl&lt;T&gt; MyBox&lt;T&gt; {\n    fn new(x: T, y: T) -&gt; MyBox&lt;T&gt; {\n        MyBox(x, y)\n    }\n}\nuse std::ops::Deref;\n\nimpl&lt;T&gt; Deref for MyBox&lt;T&gt; {\n    type Target = T;\n    // 实现 Deref trait 的这个deref 方法的返回值,就是我们 * 操作的真正目标\n    // 因为返回的是引用, 所以 * 操作 ok的\n    fn deref(&self) -&gt; &Self::Target {\n        &self.1\n    }\n}\n\nfn main() {\n    let x = 5;\n    let y = MyBox::new(x, 12);\n    // 如果没有实现 Deref trait, 那么 * 操作就会报错\n    println!(\"{}\", *y); // 12\n    // 显然 上面实现的 deref(&self)方法是 类型MyBox的方法,\n    // 所以可以 y.deref() 获取\n    println!(\"{}\", *(y.deref())); // 12\n}\n\n\n3.3 隐式解引用转化(Deref coercion)\n\n\n\n\n\n\nTip\n\n\n\n当把某个类型T(实现了Deref trait)的引用传递给一个函数或方法时,与函数或方法定义的参数类型不一样时,会自动进行式解引用转化,转化为经过 deref 操作后返回的那个引用\n可变引用的情况需要实现 DerefMut trait\n\n下面三种情况会发生自动转化\n\nFrom &T to &U when T: Deref&lt;Target=U&gt;\nFrom &mut T to &mut U when T: DerefMut&lt;Target=U&gt;\nFrom &mut T to &U when T: Deref&lt;Target=U&gt;\n\n\n\n\nstruct MyBox&lt;T&gt;(T);\n\nimpl&lt;T&gt; MyBox&lt;T&gt; {\n    fn new(x: T) -&gt; MyBox&lt;T&gt; {\n        MyBox(x)\n    }\n}\nuse std::ops::Deref;\n\nimpl&lt;T&gt; Deref for MyBox&lt;T&gt; {\n    type Target = T;\n    // 实现 Deref trait 的这个deref 方法的返回值,就是我们 * 操作的真正目标\n    // 因为返回的是引用, 所以 * 操作 ok的\n    fn deref(&self) -&gt; &Self::Target {\n        &self.0\n    }\n}\nfn hello(name: &str) {\n    println!(\"Hello, {name}!\");\n}\n\nfn main() {\n    let m = MyBox::new(String::from(\"Rust\"));\n    // &m: MyBox&lt;String&gt; deref 转化为 &String\n    // String 也实现了 Deref trait ,&String deref返回的是 &str\n    // 这些过程在编译时就完成了, 所以不会有额外的开销\n    hello(&m);\n    // 如果 没有这个自动转化功能,需要这样写\n    hello(&(*m)[..])\n}",
    "crumbs": [
      "基础篇",
      "智能指针"
    ]
  },
  {
    "objectID": "docs/rust/basic/14.smart-pointer.html#drop-trait",
    "href": "docs/rust/basic/14.smart-pointer.html#drop-trait",
    "title": "斯巴拉稀",
    "section": "4 drop trait",
    "text": "4 drop trait\n\n相当于析构函数\n通过实现 Drop trait, 可以自定义值离开作用域时发生的事情(比如文件资源的释放).\n任何类型都可以实现这个 Drop trait\n\ndrop 一个 实现了copy的类型, 不会执行任何操作\n\n\nstruct CustomSmartPointer {\n    data: String,\n}\n// Drop 在预导入模块里, 所以不需要use\nimpl Drop for CustomSmartPointer {\n    // 参数是可变借用 &mut self\n    fn drop(&mut self) {\n        println!(\"Dropping CustomSmartPointer with data `{}`!\", self.data);\n    }\n}\n\nfn main() {\n    let a = CustomSmartPointer {\n        data: String::from(\"hello stuff\"),\n    };\n    // 无法显示的调用 drop 方法\n    // a.drop()\n    // 可以使用  std::mem::drop(a); 来提前调用\n    // drop(a);  这样就行了, 因为drop 是预导入模块里的\n    {\n        let c = CustomSmartPointer {\n            data: String::from(\"my stuff\"),\n        };\n    }// c 最先执行drop, 所以先打印 my stuff\n    let d = CustomSmartPointer {\n        data: String::from(\"other stuff\"),\n    };\n    println!(\"CustomSmartPointers created.\");\n}",
    "crumbs": [
      "基础篇",
      "智能指针"
    ]
  },
  {
    "objectID": "docs/rust/basic/14.smart-pointer.html#rc-引用计数智能指针",
    "href": "docs/rust/basic/14.smart-pointer.html#rc-引用计数智能指针",
    "title": "斯巴拉稀",
    "section": "5 Rc 引用计数智能指针",
    "text": "5 Rc 引用计数智能指针\n\nRc = reference counting\nRc 允许同一个数据有多个所有者\n当最后是0个引用,那么该值就会被清理\n就好像有一群人在看电视, 不知道最后是谁离开, 所以首先谁离开了是不能关掉电视,只有最后一个人走了,才能关,这种需求的时候我们就可以用这个 Rc 类型\n通过不可变引用来共享数据,只读\n\nenum List {\n    Cons(i32, Box&lt;List&gt;),\n    Nil,\n}\n\nuse crate::List::{Cons, Nil};\n\nfn main() {\n    let a = Cons(5, Box::new(Cons(10, Box::new(Nil))));\n    let b = Cons(3, Box::new(a));\n    let c = Cons(4, Box::new(a)); // 报错了, a 被move了\n}\n使用 Rc 就可以解决这个问题\nenum List {\n    Cons(i32, Rc&lt;List&gt;),\n    Nil,\n}\n\nuse crate::List::{Cons, Nil};\nuse std::rc::Rc;\n\nfn main() {\n    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));\n    println!(\"count after creating a = {}\", Rc::strong_count(&a)); //1\n    // Rc::clone() 只会使 引用计数+1, 不会进行深度 copy \n    // a.clone()  会进行深度copy\n    let b = Cons(3, Rc::clone(&a)); // a 的引用计数+1\n    println!(\"count after creating b = {}\", Rc::strong_count(&a)); //2\n     {\n        let d = Cons(4, Rc::clone(&a));\n        println!(\"count after creating d = {}\", Rc::strong_count(&a)); // 3\n    } // 这里d离开作用域,drop操作, 所以a的引用计数-1, 变为2\n    let c = Cons(4, Rc::clone(&a)); // a 的引用计数+1\n    println!(\"count after creating c = {}\", Rc::strong_count(&a)); // 3\n}",
    "crumbs": [
      "基础篇",
      "智能指针"
    ]
  },
  {
    "objectID": "docs/rust/basic/14.smart-pointer.html#refcell",
    "href": "docs/rust/basic/14.smart-pointer.html#refcell",
    "title": "斯巴拉稀",
    "section": "6 RefCell",
    "text": "6 RefCell\n\n单线程内部使用\n数据所有者只有一个\n运行时检查\n\n报错了,因为你不能可变借用一个不可变的值\nfn main() {\n    let x = 5;\n    let y = &mut x;\n}\n有这样的需求, 我们希望该值对外部是不可变的, 对于它内部可以有方法来修改它的值.\nRefCell 就是能够可变借用一个原本不可变的值\nuse std::cell::RefCell;\n\nfn main() {\n    let shared_map = RefCell::new(vec![1, 2, 3]);\n    // 创建1个可变引用\n    let mut first_ref = shared_map.borrow_mut();\n    // 不允许多个可变借用同时存在\n    // let mut second_ref = shared_map.borrow_mut();\n\n    // 修改通过不可变引用获取的数据\n    first_ref.push(4);\n    println!(\"{:?}\", shared_map);\n}\nuse std::cell::RefCell;\n\nfn main() {\n    let c = RefCell::new(5);\n    // 多个不可变借用\n    let borrowed_five = c.borrow();\n    let borrowed_five2 = c.borrow();\n}\n\n每次 调用 .borrow() 方法, 不可变借用计数+1, 其返回值离开作用域,不可变计数-1\n每次调用 .borrow_mut() 方法, 可变借用计数+1,其返回值离开作用域,可变计数-1\n根据上面2点来检查借用规则, 只允许一个可变借用,或多个不可变借用",
    "crumbs": [
      "基础篇",
      "智能指针"
    ]
  },
  {
    "objectID": "docs/rust/basic/14.smart-pointer.html#rc-refcell-结合使用",
    "href": "docs/rust/basic/14.smart-pointer.html#rc-refcell-结合使用",
    "title": "斯巴拉稀",
    "section": "7 Rc RefCell 结合使用",
    "text": "7 Rc RefCell 结合使用\n#[derive(Debug)]\nenum List {\n    Cons(Rc&lt;RefCell&lt;i32&gt;&gt;, Rc&lt;List&gt;),\n    Nil,\n}\n\nuse crate::List::{Cons, Nil};\nuse std::cell::RefCell;\nuse std::rc::Rc;\n\nfn main() {\n    let value = Rc::new(RefCell::new(5));\n\n    let a = Rc::new(Cons(Rc::clone(&value), Rc::new(Nil)));\n\n    let b = Cons(Rc::new(RefCell::new(3)), Rc::clone(&a));\n    let c = Cons(Rc::new(RefCell::new(4)), Rc::clone(&a));\n\n    *value.borrow_mut() += 10;\n\n    println!(\"a after = {:?}\", a);\n    println!(\"b after = {:?}\", b);\n    println!(\"c after = {:?}\", c);\n}",
    "crumbs": [
      "基础篇",
      "智能指针"
    ]
  },
  {
    "objectID": "docs/rust/basic/14.smart-pointer.html#引用循环",
    "href": "docs/rust/basic/14.smart-pointer.html#引用循环",
    "title": "斯巴拉稀",
    "section": "8 引用循环",
    "text": "8 引用循环\n\n8.1 Rc\nuse crate::List::{Cons, Nil};\nuse std::cell::RefCell;\nuse std::rc::Rc;\n\n#[derive(Debug)]\nenum List {\n    Cons(i32, RefCell&lt;Rc&lt;List&gt;&gt;),\n    Nil,\n}\n\nimpl List {\n    fn tail(&self) -&gt; Option&lt;&RefCell&lt;Rc&lt;List&gt;&gt;&gt; {\n        // self: &Self\n        match self {\n            Cons(_, item) =&gt; Some(item),\n            Nil =&gt; None,\n        }\n    }\n}\n\nfn main() {\n    let a = Rc::new(Cons(5, RefCell::new(Rc::new(Nil))));\n\n    println!(\"a initial rc count = {}\", Rc::strong_count(&a)); // 1\n    println!(\"a next item = {:?}\", a.tail());\n    // b的下一个元素是a\n    let b = Rc::new(Cons(10, RefCell::new(Rc::clone(&a))));\n\n    println!(\"a rc count after b creation = {}\", Rc::strong_count(&a)); //2\n    println!(\"b initial rc count = {}\", Rc::strong_count(&b)); //1\n    println!(\"b next item = {:?}\", b.tail());\n\n    if let Some(link) = a.tail() {\n        // a的下一个元素是b, a和b 之间循环引用了.\n        *link.borrow_mut() = Rc::clone(&b); // b +1\n    }\n\n    println!(\"b rc count after changing a = {}\", Rc::strong_count(&b)); //2\n    println!(\"a rc count after changing a = {}\", Rc::strong_count(&a)); //2\n\n    // 栈溢出了, 因为打印 a.tail() ,就是要打印b, 而要完全打印b,就需要打印a的值,因为b的\"下一个元素\"是a\n    // println!(\"a next item = {:?}\", a.tail());\n} // 离开作用域, b 做引用计数-1操作,那么还有1个, 接着a离开作用域 引用计数-1,也是还剩1个. 这样2个都没被释放\n\n\n8.2 Weak\n\n强引用\n\nRc.clone 后rc的引用计数(strong_count)会+1, 实例只有在 strong_count=0,才会被释放\n\n弱引用\n\nRc::downgrade 会创建值的弱引用(weak_count+1),返回类型是 Weak\nweak_count不为0,不会影响值的释放\nstrong_ount为0, 弱引用会自动断开\n使用Weak前,需要确保它指向的值依然存在\n\n\nuse std::cell::RefCell;\nuse std::rc::{Rc, Weak};\n\n#[derive(Debug)]\nstruct Node {\n    value: i32,\n    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,\n    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,\n}\nfn main() {\n    let leaf = Rc::new(Node {\n        value: 3,\n        parent: RefCell::new(Weak::new()),\n        children: RefCell::new(vec![]),\n    });\n    println!(\n        \"leaf strong = {}, weak = {}\",\n        Rc::strong_count(&leaf),\n        Rc::weak_count(&leaf),\n    );\n    // upgrade: 从 Weak&lt;T&gt; 获取一个 Rc&lt;T&gt;\n    println!(\"leaf parent = {:?}\", leaf.parent.borrow().upgrade());\n\n    let branch = Rc::new(Node {\n        value: 5,\n        parent: RefCell::new(Weak::new()),\n        children: RefCell::new(vec![Rc::clone(&leaf)]),\n    });\n    *leaf.parent.borrow_mut() = Rc::downgrade(&branch);\n    println!(\n        \"branch strong = {}, weak = {}\",\n        Rc::strong_count(&branch),\n        Rc::weak_count(&branch),\n    );\n\n    println!(\n        \"leaf strong = {}, weak = {}\",\n        Rc::strong_count(&leaf), //2\n        Rc::weak_count(&leaf),\n    );\n\n    println!(\"leaf parent = {:?}\", leaf.parent.borrow().upgrade());\n    println!(\n        \"leaf strong = {}, weak = {}\",\n        Rc::strong_count(&leaf),\n        Rc::weak_count(&leaf),\n    );\n}",
    "crumbs": [
      "基础篇",
      "智能指针"
    ]
  },
  {
    "objectID": "docs/rust/basic/08.trait.html",
    "href": "docs/rust/basic/08.trait.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "Tip\n\n\n\n\ntrait在其他语言里,类似接口interface\ntrait是一种约束,定义了类型应该实现哪些方法,也是一种代码共享(默认trait方法)\n\n类型是对变量申请的内存空间的一种约束\n泛型可以说就是因为类型约束的过于严格而产生的\n然后泛型又过于宽泛了,啥都行,我就想要符合某种特征的类型,这样就产生了trait用来约束类型\n\n\n\n\n// 定义一个trait\npub trait Summary {\n    // 实现这个Summary trait的 type 自己写具体方法的body\n    // 如果没有方法体, 那么必须实现这个方法, 否则编译不过\n    fn summarize(&self) -&gt; String;\n    // 默认实现, 实现这个Summary trait的 type 可以不写这个方法的具体实现,直接用\n    // 当然你也可以重新写来覆盖这个方法的具体实现\n    fn hello(&self) {\n        println!(\"hello\");\n    }\n}\n\npub struct NewsArticle {\n    pub headline: String,\n    pub location: String,\n    pub author: String,\n    pub content: String,\n}\n\n// 为 NewsArticle 实现  Summary trait\nimpl Summary for NewsArticle {\n    fn summarize(&self) -&gt; String {\n        format!(\"{}, by {} ({})\", self.headline, self.author, self.location)\n    }\n}\n\npub struct Tweet {\n    pub username: String,\n    pub content: String,\n    pub reply: bool,\n    pub retweet: bool,\n}\n\nimpl Summary for Tweet {\n    fn summarize(&self) -&gt; String {\n        format!(\"{}: {}\", self.username, self.content)\n    }\n}\n\nfn main() {\n    let article = NewsArticle {\n        headline: String::from(\"Penguins win the Stanley Cup Championship!\"),\n        location: String::from(\"Pittsburgh, PA, USA\"),\n        author: String::from(\"Iceburgh\"),\n        content: String::from(\n            \"The Pittsburgh Penguins once again are the best \\\n             hockey team in the NHL.\",\n        ),\n    };\n\n    println!(\"New article available! {}\", article.summarize());\n    article.hello();\n}\n\n\n\nuse std::fmt::Display;\n\ntrait Animal&lt;T&gt;\nwhere\n    T: Display,\n{\n    fn shout(&self, _: T);\n}\nstruct Dog;\n\n\nimpl&lt;T&gt; Animal&lt;T&gt; for Dog\nwhere\n    T: Display,\n{\n    fn shout(&self, _: T) {\n        println!(\"汪汪汪\");\n    }\n}\n// 这里会报错, 因为 前面 的  `impl&lt;T&gt; Animal&lt;T&gt; for Dog` 已经包含了这里的情况\n// 如果你 上面的不要写, 单独为Dog 实现多个 trait, `impl Animal&lt;String&gt;` ,`impl Animal&lt;i32&gt;`这样具化类型, 是可以的\n// impl Animal&lt;String&gt; for Dog {\n//     fn shout(&self, _t: String) {\n//         println!(\"汪汪汪\");\n//     }\n// }\n\nfn main() {\n    let a = Dog;\n    // Dog 的实例实现了 trait (Animal&lt;T&gt;)的shout 方法\n    // shout 使用的参数类型, 具化了 T\n    // 下面2个都ok\n    a.shout(123);\n    a.shout(\"wang wang\"); \n}\n\n\n\nuse std::fmt::Display;\n\ntrait Animal&lt;T = String&gt;\nwhere\n    T: Display,\n{\n    fn shout(&self, _: T);\n}\nstruct Dog;\n\n// 默认 用的 前面定义 trait时 T=String 的String\nimpl Animal for Dog {\n    fn shout(&self, _: String) {\n        println!(\"String 汪汪汪\");\n    }\n}\n\n// 还是可以指定\nimpl Animal&lt;i32&gt; for Dog {\n    fn shout(&self, _: i32) {\n        println!(\"i32 wang wang wang \");\n    }\n}\nfn main() {\n    let a = Dog;\n    // Dog 的实例实现了 trait (Animal&lt;String&gt; 和Animal&lt;i32&gt;)的shout 方法\n    // shout 使用的参数类型, 具化了 T\n    // 下面2个都ok\n    a.shout(123);\n    a.shout(\"wang wang\".to_string());\n}",
    "crumbs": [
      "基础篇",
      "trait"
    ]
  },
  {
    "objectID": "docs/rust/basic/08.trait.html#定义一个trait",
    "href": "docs/rust/basic/08.trait.html#定义一个trait",
    "title": "斯巴拉稀",
    "section": "",
    "text": "Tip\n\n\n\n\ntrait在其他语言里,类似接口interface\ntrait是一种约束,定义了类型应该实现哪些方法,也是一种代码共享(默认trait方法)\n\n类型是对变量申请的内存空间的一种约束\n泛型可以说就是因为类型约束的过于严格而产生的\n然后泛型又过于宽泛了,啥都行,我就想要符合某种特征的类型,这样就产生了trait用来约束类型\n\n\n\n\n// 定义一个trait\npub trait Summary {\n    // 实现这个Summary trait的 type 自己写具体方法的body\n    // 如果没有方法体, 那么必须实现这个方法, 否则编译不过\n    fn summarize(&self) -&gt; String;\n    // 默认实现, 实现这个Summary trait的 type 可以不写这个方法的具体实现,直接用\n    // 当然你也可以重新写来覆盖这个方法的具体实现\n    fn hello(&self) {\n        println!(\"hello\");\n    }\n}\n\npub struct NewsArticle {\n    pub headline: String,\n    pub location: String,\n    pub author: String,\n    pub content: String,\n}\n\n// 为 NewsArticle 实现  Summary trait\nimpl Summary for NewsArticle {\n    fn summarize(&self) -&gt; String {\n        format!(\"{}, by {} ({})\", self.headline, self.author, self.location)\n    }\n}\n\npub struct Tweet {\n    pub username: String,\n    pub content: String,\n    pub reply: bool,\n    pub retweet: bool,\n}\n\nimpl Summary for Tweet {\n    fn summarize(&self) -&gt; String {\n        format!(\"{}: {}\", self.username, self.content)\n    }\n}\n\nfn main() {\n    let article = NewsArticle {\n        headline: String::from(\"Penguins win the Stanley Cup Championship!\"),\n        location: String::from(\"Pittsburgh, PA, USA\"),\n        author: String::from(\"Iceburgh\"),\n        content: String::from(\n            \"The Pittsburgh Penguins once again are the best \\\n             hockey team in the NHL.\",\n        ),\n    };\n\n    println!(\"New article available! {}\", article.summarize());\n    article.hello();\n}\n\n\n\nuse std::fmt::Display;\n\ntrait Animal&lt;T&gt;\nwhere\n    T: Display,\n{\n    fn shout(&self, _: T);\n}\nstruct Dog;\n\n\nimpl&lt;T&gt; Animal&lt;T&gt; for Dog\nwhere\n    T: Display,\n{\n    fn shout(&self, _: T) {\n        println!(\"汪汪汪\");\n    }\n}\n// 这里会报错, 因为 前面 的  `impl&lt;T&gt; Animal&lt;T&gt; for Dog` 已经包含了这里的情况\n// 如果你 上面的不要写, 单独为Dog 实现多个 trait, `impl Animal&lt;String&gt;` ,`impl Animal&lt;i32&gt;`这样具化类型, 是可以的\n// impl Animal&lt;String&gt; for Dog {\n//     fn shout(&self, _t: String) {\n//         println!(\"汪汪汪\");\n//     }\n// }\n\nfn main() {\n    let a = Dog;\n    // Dog 的实例实现了 trait (Animal&lt;T&gt;)的shout 方法\n    // shout 使用的参数类型, 具化了 T\n    // 下面2个都ok\n    a.shout(123);\n    a.shout(\"wang wang\"); \n}\n\n\n\nuse std::fmt::Display;\n\ntrait Animal&lt;T = String&gt;\nwhere\n    T: Display,\n{\n    fn shout(&self, _: T);\n}\nstruct Dog;\n\n// 默认 用的 前面定义 trait时 T=String 的String\nimpl Animal for Dog {\n    fn shout(&self, _: String) {\n        println!(\"String 汪汪汪\");\n    }\n}\n\n// 还是可以指定\nimpl Animal&lt;i32&gt; for Dog {\n    fn shout(&self, _: i32) {\n        println!(\"i32 wang wang wang \");\n    }\n}\nfn main() {\n    let a = Dog;\n    // Dog 的实例实现了 trait (Animal&lt;String&gt; 和Animal&lt;i32&gt;)的shout 方法\n    // shout 使用的参数类型, 具化了 T\n    // 下面2个都ok\n    a.shout(123);\n    a.shout(\"wang wang\".to_string());\n}",
    "crumbs": [
      "基础篇",
      "trait"
    ]
  },
  {
    "objectID": "docs/rust/basic/08.trait.html#参数指定trait",
    "href": "docs/rust/basic/08.trait.html#参数指定trait",
    "title": "斯巴拉稀",
    "section": "2 参数指定trait",
    "text": "2 参数指定trait\n\n2.1 指定单个trait\n// 参数item ,必须是实现了Summary这个trait的类型\npub fn notify(item: &impl Summary) {\n    println!(\"Breaking news! {}\", item.summarize());\n}\nimpl Summary 相比较这个写法, 我们一般用下面这样的写法\npub fn notify&lt;T: Summary&gt;(item: &T) {\n    println!(\"Breaking news! {}\", item.summarize());\n}\n\npub fn notify(item1: &impl Summary, item2: &impl Summary) {}\n//这样写就比上面的简洁\npub fn notify&lt;T: Summary&gt;(item1: &T, item2: &T) {}\n\n\n2.2 指定多个trait\npub fn notify(item: &(impl Summary + Display)) {}\n\npub fn notify&lt;T: Summary + Display&gt;(item: &T) {}\n\n\n2.3 where\n当我们在指定多个参数 然后每个参数要实现多个trait时, 写起来可能不是那么清晰, 这时我们可以使用where来简化\nfn some_function&lt;T: Display + Clone, U: Clone + Debug&gt;(t: &T, u: &U) -&gt; i32 {}\n使用where的写法\nfn some_function&lt;T, U&gt;(t: &T, u: &U) -&gt; i32\nwhere\n    T: Display + Clone,\n    U: Clone + Debug,\n{\n}",
    "crumbs": [
      "基础篇",
      "trait"
    ]
  },
  {
    "objectID": "docs/rust/basic/08.trait.html#返回值指定trait",
    "href": "docs/rust/basic/08.trait.html#返回值指定trait",
    "title": "斯巴拉稀",
    "section": "3 返回值指定trait",
    "text": "3 返回值指定trait\nfn returns_summarizable() -&gt; impl Summary {\n    Tweet {\n        username: String::from(\"horse_ebooks\"),\n        content: String::from(\n            \"of course, as you probably already know, people\",\n        ),\n        reply: false,\n        retweet: false,\n    }\n}\n下面这个会报错\nfn returns_summarizable(switch: bool) -&gt; impl Summary {\n    if switch {\n        NewsArticle {\n            headline: String::from(\n                \"Penguins win the Stanley Cup Championship!\",\n            ),\n            location: String::from(\"Pittsburgh, PA, USA\"),\n            author: String::from(\"Iceburgh\"),\n            content: String::from(\n                \"The Pittsburgh Penguins once again are the best \\\n                 hockey team in the NHL.\",\n            ),\n        }\n    } else {\n        Tweet {\n            username: String::from(\"horse_ebooks\"),\n            content: String::from(\n                \"of course, as you probably already know, people\",\n            ),\n            reply: false,\n            retweet: false,\n        }\n    }\n}",
    "crumbs": [
      "基础篇",
      "trait"
    ]
  },
  {
    "objectID": "docs/rust/basic/08.trait.html#关联类型associated-types",
    "href": "docs/rust/basic/08.trait.html#关联类型associated-types",
    "title": "斯巴拉稀",
    "section": "4 关联类型(Associated types)",
    "text": "4 关联类型(Associated types)\n关联类型起到一种类型占位功能,定义trait时声明,在把trait实现到类型上的时候为其指定具体的类型\n\n4.1 产生的原因\ntrait上使用泛型的情况\nstruct Container(i32, i32);\n\ntrait Contains&lt;A, B&gt; {\n    fn contains(&self, _: &A, _: &B) -&gt; bool;\n    fn first(&self) -&gt; i32;\n    fn last(&self) -&gt; i32;\n}\n\nimpl Contains&lt;i32, i32&gt; for Container {\n    fn contains(&self, number_1: &i32, number_2: &i32) -&gt; bool {\n        println!(\"{:p}-{:p}\", &self.0, number_1);\n        (&self.0 == number_1) && (&self.1 == number_2)\n    }\n    fn first(&self) -&gt; i32 {\n        self.0\n    }\n    fn last(&self) -&gt; i32 {\n        self.1\n    }\n}\n\n// 由于 trait 用的是 泛型, 我们可以为 Container 实现很多个trait(用不同参数类型)\n// 这种感觉  有些时候应该不是我们希望的\n// impl Contains&lt;i64, i64&gt; for Container {\n// ...\n// }\n\n// 然后比如定义这类函数时, 实际上 内部没有调用到A,B, 但是你还是要标注类型, 就繁琐了\nfn difference&lt;A, B, C&gt;(container: &C) -&gt; i32\nwhere\n    C: Contains&lt;A, B&gt;,\n{\n    container.last() - container.first()\n}\n\nfn main() {\n    let number_1 = 3;\n    let number_2 = 10;\n\n    let container = Container(number_1, number_2);\n\n    println!(\n        \"Does container contain {} and {}: {}\",\n        &number_1,\n        &number_2,\n        container.contains(&number_1, &number_2)\n    );\n    println!(\"First number: {}\", container.first());\n    println!(\"Last number: {}\", container.last());\n\n    println!(\"The difference is: {}\", difference(&container));\n}\n使用 关联类型, 无需标注类型\nstruct Container(i32, i32);\n\ntrait Contains {\n    type A;\n    type B;\n\n    fn contains(&self, _: &Self::A, _: &Self::B) -&gt; bool;\n    fn first(&self) -&gt; i32;\n    fn last(&self) -&gt; i32;\n}\n\nimpl Contains for Container {\n    // 在类中 定义 具体 A 和 B\n    type A = i32;\n    type B = i32;\n\n    // `&Self::A` and `&Self::B` are also valid here.\n    fn contains(&self, number_1: &i32, number_2: &i32) -&gt; bool {\n        (&self.0 == number_1) && (&self.1 == number_2)\n    }\n    fn first(&self) -&gt; i32 {\n        self.0\n    }\n    fn last(&self) -&gt; i32 {\n        self.1\n    }\n}\n\n// 简洁了\nfn difference&lt;C: Contains&gt;(container: &C) -&gt; i32 {\n    container.last() - container.first()\n}\n\nfn main() {\n    let number_1 = 3;\n    let number_2 = 10;\n\n    let container = Container(number_1, number_2);\n\n    println!(\n        \"Does container contain {} and {}: {}\",\n        &number_1,\n        &number_2,\n        container.contains(&number_1, &number_2)\n    );\n    println!(\"First number: {}\", container.first());\n    println!(\"Last number: {}\", container.last());\n\n    println!(\"The difference is: {}\", difference(&container));\n}\n\n\n4.2 泛型上使用 关联类型\ntrait Person {\n    type AAA;\n    fn shout(&self, msg: Self::AAA);\n}\n// 定义一个结构体, 约束了内部成员homeowner的类型必须是 实现了Person 这个trait的类,\n// 成员 house_name 的类型 必须是 实现了Person 这个trait的类 中定义的关联类型 AAA\nstruct House&lt;T: Person&gt; {\n    homeowner: T,\n    house_name: T::AAA,\n}\n\nstruct Man {\n    name: String,\n}\nimpl Person for Man {\n    // 如果将这个 AAA 改成其他类型, 那么就会在实例化 House时house_name 也要改成这里指定的类型\n    type AAA = String;\n    fn shout(&self, msg: Self::AAA) {\n        println!(\"{}\", msg);\n    }\n}\nfn main() {\n    let s = House {\n        homeowner: Man {\n            name: \"jerry\".to_string(),\n        },\n        house_name: \"jerry's home\".to_string(),\n    };\n    s.homeowner.shout(\"啊啊啊\".to_string());\n}\n\n\n4.3 直接指定具体类型来约束关联类型\ntrait Person {\n    type AAA;\n    fn shout(&self, msg: Self::AAA);\n}\n// 定义一个结构体, 约束了内部成员的类型必须是 实现了Person 这个trait的类,\n// 并且直接设置了它的关联类型是String ,也就是再约束了你具体实现类中使用的哪种关联类型\nstruct House&lt;T: Person&lt;AAA = String&gt;&gt; {\n    homeowner: T,\n}\n\nstruct Man {\n    name: String,\n}\nimpl Person for Man {\n    // 如果将这个 AAA 改成其他类型, 那么就会在实例化 House 那里报错\n    // 因为这样的 Man 不是我们要的\n    type AAA = String;\n    fn shout(&self, msg: Self::AAA) {\n        println!(\"{}\", msg);\n    }\n}\nfn main() {\n    let s = House {\n        homeowner: Man {\n            name: \"jerry\".to_string(),\n        },\n    };\n    s.homeowner.shout(\"啊啊啊\".to_string());\n}\n\n\n4.4 使用trait 约束关联类型\nuse std::fmt::Display;\n\ntrait Person {\n    type AAA: Display;\n    fn shout(&self, msg: Self::AAA);\n}\nstruct House&lt;T: Person&gt; {\n    homeowner: T,\n}\n\nstruct Man {\n    name: String,\n}\nimpl Person for Man {\n    type AAA = i32; //String 也行, 必须是实现了 Display 这个trait\n    fn shout(& self, msg: Self::AAA) {\n        println!(\"{}\", msg);\n    }\n}\nfn main() {\n    let  s = House {\n        homeowner: Man {\n            name: \"jerry\".to_string(),\n        },\n    };\n    s.homeowner.shout(123);\n}",
    "crumbs": [
      "基础篇",
      "trait"
    ]
  },
  {
    "objectID": "docs/rust/basic/08.trait.html#关联常量",
    "href": "docs/rust/basic/08.trait.html#关联常量",
    "title": "斯巴拉稀",
    "section": "5 关联常量",
    "text": "5 关联常量\ntrait Country {\n    const HISTORY: u32 = 5000;\n    const INDEPENDENT: bool = true;\n}\n\nstruct China;\nimpl Country for China {\n    const HISTORY: u32 = 7000;\n}\n\nfn main() {\n    println!(\"{:?}\", China::HISTORY);\n    println!(\"{:?}\", &lt;China as Country&gt;::HISTORY);\n    println!(\"{:?}\", China::INDEPENDENT);\n    println!(\"{:?}\", &lt;China as Country&gt;::INDEPENDENT);\n}",
    "crumbs": [
      "基础篇",
      "trait"
    ]
  },
  {
    "objectID": "docs/rust/basic/08.trait.html#trait的依赖",
    "href": "docs/rust/basic/08.trait.html#trait的依赖",
    "title": "斯巴拉稀",
    "section": "6 trait的依赖",
    "text": "6 trait的依赖\ntrait Animal {\n    fn shout(&self);\n}\n// 表示如果有类型要实现 Person 这个 trait, 那么它必须也要实现 Animal这个trait\n// 相当于 T: Person + Animal\ntrait Person: Animal {\n    fn speak(&self);\n    fn shout(&self);\n}\n\nstruct Student;\n\nimpl Person for Student {\n    fn speak(&self) {\n        println!(\"hello...\");\n    }\n    fn shout(&self) {\n        println!(\"person...\");\n    }\n}\nimpl Animal for Student {\n    fn shout(&self) {\n        println!(\"animal...\");\n    }\n}\nimpl Student {\n    // 如果没有自己实现自己的方法,\n    // 上面2个trait 中都有shout, main中调用 d.shout() 会报错\n    fn shout(&self) {\n        println!(\"类自己的方法...\");\n    }\n}\nfn main() {\n    let d = &Student;\n    d.shout(); // 类自己的方法...\n    // &lt;Type as Trait&gt;:: 完全限定语法,\n        // 在没有参数的情况下使用Person::shout()会报错, 需要用这个语法才可以\n    //  使用  Student 实现Person 这个trait 时的shout 方法\n    &lt;Student as Person&gt;::shout(d); // person...\n    Person::shout(d); // person...\n    &lt;Student as Animal&gt;::shout(d); // animal...\n    Animal::shout(d); // animal...\n}",
    "crumbs": [
      "基础篇",
      "trait"
    ]
  },
  {
    "objectID": "docs/rust/basic/08.trait.html#孤儿规则orphan-rule",
    "href": "docs/rust/basic/08.trait.html#孤儿规则orphan-rule",
    "title": "斯巴拉稀",
    "section": "7 孤儿规则(orphan rule)",
    "text": "7 孤儿规则(orphan rule)\n\n如果你想要为类型A实现trait B,那么至少有一个是本地crate（即你当前的crate）所拥有的\n换句话说,要么类型A是在当前的crate中定义的,要么trait B是在当前的crate中定义的\n如果要实现外部定义的trait需要先将其导入作用域\n\n不允许对外部类型实现外部trait\n\n可以对外部类型实现自定义的trait\n可以对自定义类型上实现外部trait\n外部是指不是由自己,而是由外部定义的,包括标准库",
    "crumbs": [
      "基础篇",
      "trait"
    ]
  },
  {
    "objectID": "docs/rust/basic/08.trait.html#newtype-实现外部trait",
    "href": "docs/rust/basic/08.trait.html#newtype-实现外部trait",
    "title": "斯巴拉稀",
    "section": "8 newtype 实现外部trait",
    "text": "8 newtype 实现外部trait\n孤儿规则: 只有当 trait或类型定义在本地crate的时候,才能为类型实现trait\n我们可以用newtype 模式来绕过这个\nuse std::fmt;\n\n// only traits defined in the current crate can be implemented for types defined outside of the crate\n// define and implement a trait or new type instead\n// impl fmt::Display for Vec&lt;String&gt; {\n//     fn fmt(&self, f: &mut fmt::Formatter) -&gt; fmt::Result {\n//         write!(f, \"[{}]\", self.0.join(\", \"))\n//     }\n// }\n// 使用元祖结构体 变成一个新的类型,是本地的\nstruct Wrapper(Vec&lt;String&gt;);\n// fmt::Display 这个是外部trait\nimpl fmt::Display for Wrapper {\n    fn fmt(&self, f: &mut fmt::Formatter) -&gt; fmt::Result {\n        write!(f, \"[{}]\", self.0.join(\", \"))\n    }\n}\n\nfn main() {\n    let w = Wrapper(vec![String::from(\"hello\"), String::from(\"world\")]);\n    println!(\"w = {}\", w);\n}",
    "crumbs": [
      "基础篇",
      "trait"
    ]
  },
  {
    "objectID": "docs/rust/basic/08.trait.html#运算符重载",
    "href": "docs/rust/basic/08.trait.html#运算符重载",
    "title": "斯巴拉稀",
    "section": "9 运算符重载",
    "text": "9 运算符重载\nuse std::ops::Add;\n\n#[derive(Debug, Copy, Clone, PartialEq)]\nstruct Point {\n    x: i32,\n    y: i32,\n}\n// 给Point 实现Add trait, Add trait 定义了+加法 会如何操作\nimpl Add for Point {\n    type Output = Point;\n\n    fn add(self, other: Point) -&gt; Point {\n        Point {\n            x: self.x + other.x,\n            y: self.y + other.y,\n        }\n    }\n}\n\nfn main() {\n    assert_eq!(\n        Point { x: 1, y: 0 } + Point { x: 2, y: 3 },\n        Point { x: 3, y: 3 }\n    );\n}\n我们看下Add trait的定义,发现实际带有类型参数,默认值是Self\npub trait Add&lt;Rhs = Self&gt; {\n    // ...\n}\n不同类型的+ 加法重载\nuse std::ops::Add;\n\nstruct Millimeters(u32);\nstruct Meters(u32);\n\nimpl Add&lt;Meters&gt; for Millimeters {\n    type Output = Millimeters;\n\n    fn add(self, other: Meters) -&gt; Millimeters {\n        Millimeters(self.0 + (other.0 * 1000))\n    }\n}\n\nfn main() {\n    let mm = Millimeters(10);\n    let m = Meters(1);\n\n    let sum = mm + m;\n    // sum is of type Millimeters\n    println!(\"sum is {}\", sum.0); // 1010\n    // 注意这样是不行的, 顺序是有关系的\n    // let sum2 = m + mm;\n}",
    "crumbs": [
      "基础篇",
      "trait"
    ]
  },
  {
    "objectID": "docs/rust/basic/08.trait.html#类型别名",
    "href": "docs/rust/basic/08.trait.html#类型别名",
    "title": "斯巴拉稀",
    "section": "10 类型别名",
    "text": "10 类型别名\nfn main() {\n    // 类型别名\n    // 让类型含义更加的有意义\n    type Kilometers = i32;\n\n    let x: i32 = 5;\n    let y: Kilometers = 5;\n    // 实际还是是i32 所以可以 +\n    println!(\"x + y = {}\", x + y);\n}\n减少重复代码, 让代码更简洁\n    type Thunk = Box&lt;dyn Fn() + Send + 'static&gt;;\n\n    let f: Thunk = Box::new(|| println!(\"hi\"));\n\n    fn takes_long_type(f: Thunk) {\n        // --snip--\n    }\n\n    fn returns_long_type() -&gt; Thunk {\n        // --snip--\n    }\n我们可以看到 Result&lt;usize, Error&gt; 类似这样的很多, 都要写Error\nuse std::fmt;\nuse std::io::Error;\n\npub trait Write {\n    fn write(&mut self, buf: &[u8]) -&gt; Result&lt;usize, Error&gt;;\n    fn flush(&mut self) -&gt; Result&lt;(), Error&gt;;\n\n    fn write_all(&mut self, buf: &[u8]) -&gt; Result&lt;(), Error&gt;;\n    fn write_fmt(&mut self, fmt: fmt::Arguments) -&gt; Result&lt;(), Error&gt;;\n}\nfn main() {}\n使用别名后的情况\nuse std::fmt;\n// std::io 中有这样一个别名\n// 标准库中类似这样的别名设计有还多\n// type Result&lt;T&gt; = std::result::Result&lt;T, std::io::Error&gt;;\n\n// 我们本地这样设计一个别名, 就不用每次 都写上Error\ntype Result&lt;T&gt; = std::io::Result&lt;T&gt;;\npub trait Write {\n    fn write(&mut self, buf: &[u8]) -&gt; Result&lt;usize&gt;;\n    fn flush(&mut self) -&gt; Result&lt;()&gt;;\n\n    fn write_all(&mut self, buf: &[u8]) -&gt; Result&lt;()&gt;;\n    fn write_fmt(&mut self, fmt: fmt::Arguments) -&gt; Result&lt;()&gt;;\n}\nfn main() {}",
    "crumbs": [
      "基础篇",
      "trait"
    ]
  },
  {
    "objectID": "docs/rust/basic/08.trait.html#trait-object",
    "href": "docs/rust/basic/08.trait.html#trait-object",
    "title": "斯巴拉稀",
    "section": "11 trait object",
    "text": "11 trait object\n\n11.1 使用\n我们有这样一个需求, 创建一个GUI 工具, 会遍历一个列表, 调用每个元素的draw方法\n我们很快就能想到使用泛型,试试看\npub trait Draw {\n    fn draw(&self);\n}\npub struct ScreenWithGeneric&lt;T: Draw&gt; {\n    pub components: Vec&lt;T&gt;,\n}\n\nimpl&lt;T&gt; ScreenWithGeneric&lt;T&gt;\nwhere\n    T: Draw,\n{\n    pub fn run(&self) {\n        for component in self.components.iter() {\n            component.draw();\n        }\n    }\n}\n\npub struct Button {}\n\nimpl Draw for Button {\n    fn draw(&self) {\n        println!(\"Button\");\n    }\n}\nstruct SelectBox {}\nimpl Draw for SelectBox {\n    fn draw(&self) {\n        println!(\"SelectBox\");\n    }\n}\n\nfn main() {\n    let botton = Button {};\n    let botton2 = Button {};\n    let select_box = SelectBox {};\n    let s = ScreenWithGeneric {\n        // 报错了, 类型不一致了\n        components: vec![botton, select_box],\n    };\n    s.run();\n}\n结果发现行不通, 问题的关键是我们只要列表里的元素能够执行 draw 方法就行, 不管它是什么类型. 有什么办法呢? trait object 可以解决这个问题\n\npub trait Draw {\n    fn draw(&self);\n}\npub struct Screen {\n    // Box&lt;dyn Draw&gt; : 定义了一个 trait object\n    // 表示 Box里的元素必须都实现了 Draw 这个trait 就行, 不管它是什么类型\n    pub components: Vec&lt;Box&lt;dyn Draw&gt;&gt;,\n}\nimpl Screen {\n    pub fn run(&self) {\n        for component in self.components.iter() {\n            component.draw();\n        }\n    }\n}\npub struct Button {}\n\nimpl Draw for Button {\n    fn draw(&self) {\n        println!(\"Button\");\n    }\n}\nstruct SelectBox {}\nimpl Draw for SelectBox {\n    fn draw(&self) {\n        println!(\"SelectBox\");\n    }\n}\nfn main() {\n    let button = Button {};\n\n    let select_box = SelectBox {};\n    let s = Screen {\n        // 这里ok了\n        components: vec![Box::new(button), Box::new(select_box)],\n    };\n    s.run();\n}\n\n\n\n11.2 动态派发\n\n\n\n\n\n\nTip\n\n\n\n\n当你使用泛型函数或方法时，编译器会为每个具体使用的数据类型生成专门的代码。这种机制称为单态化（Monomorphization）,单态化后的代码 会执行静态派发\n\n\n\n// 使用trait约束泛型T，这里T必须实现了Summary trait\nfn notify&lt;T: Summary&gt;(item: T) {\n    println!(\"Breaking news! {}\", item.summarize());\n}\n\n// 编译器会为每个具体使用的数据类型生成专门的代码,这样，当调用notify(tweet)和notify(article)时，直接调用的就是针对Tweet和NewsArticle预先生成好的、类型特定的函数，这就是静态派发的过程\n\n// 为Tweet类型特化生成的notify函数\nfn notify_Tweet(item: Tweet) {\n    println!(\"Breaking news! {}\", item.summarize());\n}\n\n// 为NewsArticle类型特化生成的notify函数\nfn notify_NewsArticle(item: NewsArticle) {\n    println!(\"Breaking news! {}\", item.summarize());\n}\n动态派发 ,使用dyn trait会用动态派发, 无法在编译期确定你调用的是哪个方法,会在运行时确定\n\n\n\n11.3 对象安全\n只能把满足对象安全的trait 转为 trait object\n\n安全的标准\n\n方法返回类型不是Self\n方法中没有泛型类型参数",
    "crumbs": [
      "基础篇",
      "trait"
    ]
  },
  {
    "objectID": "docs/rust/basic/08.trait.html#sized-trait",
    "href": "docs/rust/basic/08.trait.html#sized-trait",
    "title": "斯巴拉稀",
    "section": "12 Sized Trait",
    "text": "12 Sized Trait\n动态大小的类型 DST (Dynamically Sized Types)\n类型可以说是规定了你如何去使用一块内存: 占用多少空间, 怎么读写,比如给你弄了写方法, 方便读写\n在数组里, [1i32,2] 占用了8字节 [1i32,2,3] 12个字节, 这2个是不同的类型, 虽然我们都说他们是数组\n报错了, str 类型,我们看过 &str 字符串切片类型, 很明显, 有一个&符号, 这看起来就是某个类型的取地址操作, 那么这个str 是啥呢? 应该是 字符串实际存放的地方?\nstr 就是一个DST, 所以下面的操作是会报错的, 你可能会问号脸, 啊? 下面的占用多少空间不是很明显,好像没问题? 实际 s1 s2 两个变量是同一个类型, 但是占用的空间却不一样? 这就有问题了\n\nlet s1: str = \"Hello there!\";\nlet s2: str = \"How's it going?\";\n\n// 这个就ok了, 因为这个 &str 类型的 占用空间是确定的,\n// 可以说 动态类型的数据的  一种通用使用方式, 就是 一个指针去指向它的实际数据,其他比如长度等信息, 看具体设计\nlet s3: &str = \"Hello there!\";\n为了处理这种动态大小的类型,rust提供了Sized trait 来去确定一个类型的大小在编译器是否是已知的.\n在编译期知道大小的类型, rust会为其自动的实现一个trait (Sized)\nfn generic&lt;T&gt;(t: T) {\n    // --snip--\n}\n上面的代码实际上 等同与, rust 会为 每个泛型函数隐式添加 Sized trait约束\nfn generic&lt;T: Sized&gt;(t: T) {\n    // --snip--\n}\n默认情况下, 泛型函数只能在编译期知道其类型大小的情况下工作。但是, 你可以使用以下特殊语法来放宽这一限制:\n// ?Sized 表示 T的大小可能是不确定的\nfn generic&lt;T: ?Sized&gt;(t: &T) {\n    // --snip--\n}",
    "crumbs": [
      "基础篇",
      "trait"
    ]
  },
  {
    "objectID": "docs/rust/basic/08.trait.html#常用trait",
    "href": "docs/rust/basic/08.trait.html#常用trait",
    "title": "斯巴拉稀",
    "section": "13 常用trait",
    "text": "13 常用trait\n\n13.1 From & Into\nFrom trait 让你可以从另外一个B类型的数据,创建一个A类型的数据\nuse std::convert::From;\n\n#[derive(Debug)]\nstruct Number {\n    value: i32,\n}\n\nimpl From&lt;i32&gt; for Number {\n    fn from(item: i32) -&gt; Self {\n        Number { value: item  }\n    }\n}\n\nfn main() {\n    let num = Number::from(30);\n    println!(\"My number is {:?}\", num);\n}\nuse std::convert::Into;\n\n#[derive(Debug)]\nstruct Number {\n    value: i32,\n}\n\nimpl Into&lt;Number&gt; for i32 {\n    fn into(self) -&gt; Number {\n        Number { value: self }\n    }\n}\n\nfn main() {\n    let int = 5;\n    // Try removing the type annotation\n    let num: Number = int.into();\n    println!(\"My number is {:?}\", num);\n}\n\n\n13.2 TryFrom and TryInto\n会报错的情况 使用\nuse std::convert::TryFrom;\nuse std::convert::TryInto;\n\n#[derive(Debug, PartialEq)]\nstruct EvenNumber(i32);\n\nimpl TryFrom&lt;i32&gt; for EvenNumber {\n    type Error = ();\n\n    fn try_from(value: i32) -&gt; Result&lt;Self, Self::Error&gt; {\n        if value % 2 == 0 {\n            Ok(EvenNumber(value))\n        } else {\n            Err(())\n        }\n    }\n}\n\nfn main() {\n    // TryFrom\n\n    assert_eq!(EvenNumber::try_from(8), Ok(EvenNumber(8)));\n    assert_eq!(EvenNumber::try_from(5), Err(()));\n\n    // TryInto\n\n    let result: Result&lt;EvenNumber, ()&gt; = 8i32.try_into();\n    assert_eq!(result, Ok(EvenNumber(8)));\n    let result: Result&lt;EvenNumber, ()&gt; = 5i32.try_into();\n    assert_eq!(result, Err(()));\n}\n\n\n13.3 Display (to_string方法)\nuse std::fmt;\n\nstruct Circle {\n    radius: i32\n}\n// 实现这个trait ,就有了 to_string 方法\nimpl fmt::Display for Circle {\n    fn fmt(&self, f: &mut fmt::Formatter) -&gt; fmt::Result {\n        write!(f, \"Circle of radius {}\", self.radius)\n    }\n}\n\nfn main() {\n    let circle = Circle { radius: 6 };\n    let c=circle.to_string();\n    println!(\"{}\", c);\n}\n\n\n13.4 FromStr\n定义一个类型如何从字符串转换而来\nuse std::str::FromStr;\n\n// 定义一个简单的结构体，它包含一个 u32 类型的值\nstruct MyNumber {\n    value: u32,\n}\n\n// 为 MyNumber 实现 FromStr trait\nimpl FromStr for MyNumber {\n    type Err = &'static str; // 定义错误类型为 &'static str\n\n    // from_str 方法尝试将字符串解析为 MyNumber\n    fn from_str(s: &str) -&gt; Result&lt;Self, Self::Err&gt; {\n        // 尝试将字符串转换为 u32\n        let value = s.parse::&lt;u32&gt;().map_err(|_| \"Parse error\")?;\n        // 如果成功，创建并返回 MyNumber 实例\n        Ok(Self { value })\n    }\n}\n\nfn main() {\n    // 使用 parse::&lt;MyNumber&gt;() 方法将字符串转换为 MyNumber\n    // 如果不实现 MyNumber 类型的from_str 方法, 是不能 parse的\n    let number = \"42\".parse::&lt;MyNumber&gt;().unwrap();\n    println!(\"Parsed value: {}\", number.value);\n\n    // 如果解析失败，会返回一个错误\n    if let Err(e) = \"not a number\".parse::&lt;MyNumber&gt;() {\n        println!(\"Failed to parse: {}\", e);\n    }\n}\nTODO\n    let a = 42;\n    let b = 42;\n\n    let ref_a = &a;\n    let ref_b = &b;\n\n    println!(\"{}\", ref_a == ref_b); // true",
    "crumbs": [
      "基础篇",
      "trait"
    ]
  },
  {
    "objectID": "docs/ai/index.html",
    "href": "docs/ai/index.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "deepseek https://chat.deepseek.com/sign_in kimi SenseNova 5 万知AI\n\n\n\n Back to top"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Welcome",
    "section": "",
    "text": "Welcome\n之后会将 http://x.y00y.cn逐渐迁移到这里, 时代变了,很多笔记其实也没啥用了\n\n\n\nRust\nRust is a systems programming language that runs blazingly fast, prevents segfaults, and guarantees thread safety.\n\nLearn more »\n\n\n\nGo\nGo is an open source programming language that makes it easy to build simple, reliable, and efficient software.\n\nLearn more »\n\n\n\n\n\n\n\n\n Back to top"
  }
]
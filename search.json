[
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "References\n\n\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "docs/quarto/basic.html",
    "href": "docs/quarto/basic.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "git clone --depth=1 https://github.com/quarto-dev/quarto-web.git\ncd quarto-web\n# 查看官方文档的本地离线版本\nquarto preview\n# 我们指定端口, 然后不要自动打开浏览器,\n# 有时候 你需要重新执行时,就不会打开浏览器了\nquarto preview --port 4858 --no-browser\n# 使用这个 生成静态文件, 然后直接打开那个 index.html 也可以\nquarto render",
    "crumbs": [
      "快速入门"
    ]
  },
  {
    "objectID": "docs/quarto/basic.html#安装quarto1",
    "href": "docs/quarto/basic.html#安装quarto1",
    "title": "斯巴拉稀",
    "section": "",
    "text": "git clone --depth=1 https://github.com/quarto-dev/quarto-web.git\ncd quarto-web\n# 查看官方文档的本地离线版本\nquarto preview\n# 我们指定端口, 然后不要自动打开浏览器,\n# 有时候 你需要重新执行时,就不会打开浏览器了\nquarto preview --port 4858 --no-browser\n# 使用这个 生成静态文件, 然后直接打开那个 index.html 也可以\nquarto render",
    "crumbs": [
      "快速入门"
    ]
  },
  {
    "objectID": "docs/quarto/basic.html#website-book",
    "href": "docs/quarto/basic.html#website-book",
    "title": "斯巴拉稀",
    "section": "2 website book",
    "text": "2 website book\nvscode command+shift+p create project -&gt; website 或者book\n或者使用命令来创建\nquarto create project\nquarto create project &lt;type&gt; &lt;name&gt;\n# 安装主题\n# 可直接使用Footnotes提到的25个主题,不需要安装\n# quarto add schochastics/quarto-sketchy-html\n_quarto.yml 修改主题\nformat:\n# 发布的时候, 会生成的格式类型,如果只要html, 其他可以删除\n  html:\n    theme: sketchy # 修改主题为我们前面添加的\n  # 输出多种格式\n  pdf:\n    documentclass: scrreport\n  epub:\n    cover-image: cover.png",
    "crumbs": [
      "快速入门"
    ]
  },
  {
    "objectID": "docs/quarto/basic.html#静态目录配置",
    "href": "docs/quarto/basic.html#静态目录配置",
    "title": "斯巴拉稀",
    "section": "3 静态目录配置",
    "text": "3 静态目录配置\n_quarto.yml\nproject:\n  type: website\n  # output-dir: _site\n  # 设置 resources, quarto render时,会将下列设置的目录 复制到 _site目录下\n  # 这样 当你访问url /stylesheets/custom.scss 时, 就可以访问到该文件\n  resources:\n    - \"/stylesheets\"\n    - \"/.diagram\"\n我们可以统一将图片放到这里,然后 markdown中 这样插入图片\n![](/.diagram/xxx.png)",
    "crumbs": [
      "快速入门"
    ]
  },
  {
    "objectID": "docs/quarto/basic.html#siderbar",
    "href": "docs/quarto/basic.html#siderbar",
    "title": "斯巴拉稀",
    "section": "4 siderbar",
    "text": "4 siderbar",
    "crumbs": [
      "快速入门"
    ]
  },
  {
    "objectID": "docs/quarto/basic.html#发布部署",
    "href": "docs/quarto/basic.html#发布部署",
    "title": "斯巴拉稀",
    "section": "5 发布部署",
    "text": "5 发布部署\n# 预览, 开发阶段 这样看\nquarto preview\n# 生成\nquarto render   # render all formats\nquarto render --to pdf  # render PDF format only\n_book/\n    index.html # and other book files\n    rust.pdf\n    rust.epub",
    "crumbs": [
      "快速入门"
    ]
  },
  {
    "objectID": "docs/quarto/basic.html#页面format设置",
    "href": "docs/quarto/basic.html#页面format设置",
    "title": "斯巴拉稀",
    "section": "6 页面format设置",
    "text": "6 页面format设置\n我们在某个页面这样设置, 然后 quarto preview 执行后,打开的网页里, 你点击该页面会看到实际打开的是一个pdf了, 不是web 页面了\n---\ntitle: \"Hello Typst!\"\nformat:\n  typst:\n    toc: true\n    section-numbering: 1.1.a\n    columns: 2\n---",
    "crumbs": [
      "快速入门"
    ]
  },
  {
    "objectID": "docs/quarto/basic.html#配置评论",
    "href": "docs/quarto/basic.html#配置评论",
    "title": "斯巴拉稀",
    "section": "7 配置评论",
    "text": "7 配置评论\n\ngiscus\n文档\n\n默认已经全局设置, 想要单个取消显示评论\n---\ncomments: false\n---",
    "crumbs": [
      "快速入门"
    ]
  },
  {
    "objectID": "docs/quarto/basic.html#右边栏设置链接",
    "href": "docs/quarto/basic.html#右边栏设置链接",
    "title": "斯巴拉稀",
    "section": "8 右边栏设置链接",
    "text": "8 右边栏设置链接\n\n\n在单个qmd文件里写上\n\n---\nformat:\n  html:\n    other-links:\n      - text: hello\n        href: https://www.google.com\n    code-links:\n      - text: Data Import Code\n        icon: file-code\n        href: data-import.py\n---",
    "crumbs": [
      "快速入门"
    ]
  },
  {
    "objectID": "docs/quarto/basic.html#搜索",
    "href": "docs/quarto/basic.html#搜索",
    "title": "斯巴拉稀",
    "section": "9 搜索",
    "text": "9 搜索\n直接键盘输入s 即可弹出搜索框 ## darkmode vapor主题 scss文件",
    "crumbs": [
      "快速入门"
    ]
  },
  {
    "objectID": "docs/quarto/basic.html#footnotes",
    "href": "docs/quarto/basic.html#footnotes",
    "title": "斯巴拉稀",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nquarto官网awesome-quarto可以选择看看效果quarto bootstrap 主题githubrough-notation这个主题quarto-sketchy-html和原生带的sketchy 是有点不一样的.(支持高亮文字), 我们直接用原生的就行了↩︎",
    "crumbs": [
      "快速入门"
    ]
  },
  {
    "objectID": "docs/quarto/markdown.html",
    "href": "docs/quarto/markdown.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "可以查看该颜色相近的一些颜色\n\n@startuml\ncolors chocolate\n@enduml",
    "crumbs": [
      "markdown"
    ]
  },
  {
    "objectID": "docs/quarto/markdown.html#color",
    "href": "docs/quarto/markdown.html#color",
    "title": "斯巴拉稀",
    "section": "",
    "text": "可以查看该颜色相近的一些颜色\n\n@startuml\ncolors chocolate\n@enduml",
    "crumbs": [
      "markdown"
    ]
  },
  {
    "objectID": "docs/quarto/markdown.html#html",
    "href": "docs/quarto/markdown.html#html",
    "title": "斯巴拉稀",
    "section": "2 html",
    "text": "2 html\n直接写原生的html代码来渲染,参考sketchy\n\n  \n    Cras justo odio\n    14\n  \n  \n    Dapibus ac facilisis in\n    2\n  \n  \n    Morbi leo risus\n    1\n  \n    Cras justo odio\n    5\n  \n  \n    Dapibus ac facilisis in\n    4\n  \n  \n    Morbi leo risus\n    9\n  \n  \n    Morbi leo risus\n    8\n  \n  \n    Morbi leo risus\n    0",
    "crumbs": [
      "markdown"
    ]
  },
  {
    "objectID": "docs/quarto/markdown.html#table3",
    "href": "docs/quarto/markdown.html#table3",
    "title": "斯巴拉稀",
    "section": "3 table1",
    "text": "3 table1\n\nPlatform Command\n\n\n\n\n\n\nPlatform\nCommand\n\n\n\n\nMac/Linux\nconda activate ./env\n\n\nWindows\nconda activate .\\env\n\n\n\n控制 颜色,在table代码下方写上\ntbl-colwidths 控制列的宽度, 百分比\n: Platform Command {.striped .hover tbl-colwidths=\"[25,75]\"}",
    "crumbs": [
      "markdown"
    ]
  },
  {
    "objectID": "docs/quarto/markdown.html#code",
    "href": "docs/quarto/markdown.html#code",
    "title": "斯巴拉稀",
    "section": "4 code",
    "text": "4 code\n\n4.1 line-numbers\n{.bash code-line-numbers=\"false\"} 全局已经设置显示行号, 这里可以临时禁止\nls -l\n\n\n4.2 filename\n\n\nmain.py\n\nprint(1)\n\n\n\n4.3 code annotation\n---\n1code-annotations: hover\n---\n\n1\n\n还可以设置成 below,会在下方直接显示, select 则需要点击\n\n\nlibrary(tidyverse)\nlibrary(palmerpenguins)\n1penguins |&gt;\n2  mutate(\n    bill_ratio = bill_depth_mm / bill_length_mm,\n    bill_area  = bill_depth_mm * bill_length_mm\n  )\n\n1\n\nTake penguins, and then,\n\n2\n\nadd new columns for the bill ratio and bill area.\n\n\n\n\n4.4 include code file\nfn main() {\n    let mut x = 5;\n    println!(\"{x}\");\n}\n\n\n4.5 line highlight",
    "crumbs": [
      "markdown"
    ]
  },
  {
    "objectID": "docs/quarto/markdown.html#highlight",
    "href": "docs/quarto/markdown.html#highlight",
    "title": "斯巴拉稀",
    "section": "5 highlight",
    "text": "5 highlight\nThis is some text\nhello world\nhello world\nhello world",
    "crumbs": [
      "markdown"
    ]
  },
  {
    "objectID": "docs/quarto/markdown.html#card",
    "href": "docs/quarto/markdown.html#card",
    "title": "斯巴拉稀",
    "section": "6 card",
    "text": "6 card\n生成后是 .class_name的div结构 ,去看 sketchy 里的元素源码来搞\n\n\nHere is a warning.\n\n\nabc",
    "crumbs": [
      "markdown"
    ]
  },
  {
    "objectID": "docs/quarto/markdown.html#icon",
    "href": "docs/quarto/markdown.html#icon",
    "title": "斯巴拉稀",
    "section": "7 icon",
    "text": "7 icon\nhttps://icons.getbootstrap.com/ ## panel-tabset\n::: {.panel-tabset}\n## Python\nabc\n\n## rust\nefg\n:::\n\ncode结果\n\n\n::: {.panel-tabset}\n## Python\nabc\n\n## rust\nefg\n:::\n\n\n\nPythonrust\n\n\nabc\n\n\nefg",
    "crumbs": [
      "markdown"
    ]
  },
  {
    "objectID": "docs/quarto/markdown.html#callout",
    "href": "docs/quarto/markdown.html#callout",
    "title": "斯巴拉稀",
    "section": "8 callout",
    "text": "8 callout\n\n\n\n\n\n\nnote with Title\n\n\n\nNote that there are five types of callouts, including: note, warning, important, tip, and caution.\n\n\n\n\n\n\n\n\nTip with Title\n\n\n\nThis is an example of a callout with a title.\n\n\n\n\n\n\n\n\nExpand To Learn About Collapse\n\n\n\n\n\nThis is an example of a ‘folded’ caution callout that can be expanded by the user. You can use collapse=\"true\" to collapse it by default or collapse=\"false\" to make a collapsible callout that is expanded by default.\n\n\n\n\n\n\n\n\n\nPowerShell Note\n\n\n\nSome quick example text to build on the card title and make up the bulk of the card’s content.",
    "crumbs": [
      "markdown"
    ]
  },
  {
    "objectID": "docs/quarto/markdown.html#citation-footnote-and-cross-reference",
    "href": "docs/quarto/markdown.html#citation-footnote-and-cross-reference",
    "title": "斯巴拉稀",
    "section": "9 citation, footnote and cross-reference",
    "text": "9 citation, footnote and cross-reference\n鼠标移动到 Xie (2015) 上面 knitr2. Listing 1 shows you how to disable hover behaviour.\n\n\n\nListing 1\n\n\nformat:\n  html:\n    citations-hover: false\n    footnotes-hover: false\n    crossrefs-hover: false\n\n\n\n添加class 让这个隐藏了, 这样只有我们hover 才会显示, 暂时还有问题,这个移动移出有2种显示..\n\n\nreferences.bib 添加如下\n\n@Book{xie2015,\n  title = {Dynamic Documents with {R} and knitr},\n  author = {Yihui Xie},\n  publisher = {Chapman and Hall/CRC},\n  address = {Boca Raton, Florida},\n  year = {2015},\n  edition = {2nd},\n  note = {ISBN 978-1498716963},\n  url = {https://yihui.name/knitr/},\n}\n\n\n\n_quarto.yml 添加如下设置\n\nbibliography: references.bib\n\nHere is an inline note.3 longnote4",
    "crumbs": [
      "markdown"
    ]
  },
  {
    "objectID": "docs/quarto/markdown.html#extension",
    "href": "docs/quarto/markdown.html#extension",
    "title": "斯巴拉稀",
    "section": "10 extension",
    "text": "10 extension\n\n10.1 quarto-rust\n将代码块 中使用的 rust改成 playground-rust, 用{} 包起来\n\n\n10.2 kroki\nquarto install extension pandoc-ext/diagram\nquarto add data-intuitive/quarto-d2\ndiagram d2\n上面2个扩展可以抛弃了, 使用下面这个就足够了.\n这个插件有问题, 需要自己修改, 我已经修复bug, 并且增加了会下载生成的svg到本地\nquarto add GabrielCoffee9/quarto-kroki\n_quarto.yml 配置自己的kroki 服务器\nkroki:\n  serviceUrl: \"http://192.168.1.103:8000\"\n在页面文件里头部写上, 使用kroki过滤, 到时候就会执行 _extension/xxxx/kroki.lua\n---\nfilters:\n- kroki\n---\n\n10.2.1 plantuml等\n```{kroki-plantuml}\n@startuml\nBob -&gt; Alice : hello\n@enduml\n```\n\n\n\n\n10.2.2 excalidraw\n\n\n\n\n\n\nTip\n\n\n\n\n以导入文件的方式来, 其他diagram 也可以\n使用这种方式,如果你修改了 diagram文件,是不会重新生成图片的,你可以代码块里 加一行空格,保存\n\n\n\n\n\n\n10.2.3 d25\n生成的svg 太大了,可以使用svgo进行压缩,我已经修改了_extension扩展下相关文件,增加了压缩svg的代码\nnpm install -g svgo\nsvgo one.svg two.svg -o one.min.svg two.min.svg\n我发现 不要用302主题, 会变小多了, 然后 sketch: true 不要用,再变小\nd2 themes # 查看可用的主题\nclasses: {\n  empty: {\n    label: \"\"\n    style: {\n      fill: transparent\n      stroke-width: 0\n    }\n  }\n  text: {\n    style: {\n      fill: transparent\n      stroke-width: 0\n    }\n  }\n  cluster: {\n    style: {\n      fill: transparent\n      stroke-dash: 4\n      stroke: \"#C6D3DF\"\n    }\n  }\n  grid: {\n    grid-columns: 1\n    label: \"\"\n    style: {\n      fill: white\n      stroke-width: 0\n    }\n  }\n  row: {\n    grid-rows: 1\n    label: \"\"\n    style: {\n      fill: transparent\n      stroke-width: 0\n    }\n  }\n}\n\nvars: {\n  left-cluster: {\n    label: \"n-sized Vector\"\n    class: cluster\n    0*.style.fill: \"#DFEFFA\"\n    0*.style.stroke: black\n    grid-rows: 1\n    grid-gap: 0\n    label.near: outside-top-left\n\n    \"0.62\"\n    \"0.15\"\n    empty1.class: empty\n    n.class: text\n    empty2.class: empty\n    \"0.91\"\n    \"0.48\"\n\n    \"0.15\" &lt;- n -&gt; \"0.91\"\n  }\n  right-cluster: {\n    label: \"m-sized Vector\"\n    class: cluster\n    0*.style.fill: \"#72F5FF\"\n    0*.style.stroke: black\n    grid-rows: 1\n    grid-gap: 0\n    label.near: outside-top-left\n\n    \"0.62\"\n    \"0.15\"\n    empyt1.class: empty\n    m.class: text\n    empty2.class: empty\n    \"0.91\"\n    \"0.48\"\n\n    \"0.15\" &lt;- m -&gt; \"0.91\"\n  }\n}\n\ngrid-rows: 2\n\ntop-row: {\n  class: row\n  empty.class: empty\n  empty.width: 1100\n\n  Random Matrix Generator: {\n    width: 300\n    height: 170\n    style.font-size: 20\n    style.fill: \"#A7BBCF\"\n    style.stroke: black\n    style.border-radius: 10\n  }\n}\n\nbottom-row: {\n  class: row\n  left-grid: {\n    class: grid\n\n    1: ${left-cluster}\n    2: ${left-cluster}\n    3: ${left-cluster}\n  }\n\n  dot-container: {\n    class: empty\n    grid-columns: 1\n    empty1.class: empty\n    dot: Dot product {\n      class: text\n      circle: \"\" {\n        shape: circle\n        style.fill: black\n        style.stroke-width: 0\n        width: 20\n        height: 20\n      }\n      label.near: outside-bottom-center\n    }\n  }\n\n  matrix-container: {\n    class: empty\n    grid-columns: 1\n    matrix: Target dimension matrix {\n      label.near: outside-top-center\n      grid-rows: 4\n      grid-gap: 0\n      *.width: 100\n      *.height: 100\n      *.style.fill: \"#F1F6F9\"\n      *.style.stroke: black\n      \"0.41\"\n      \"0.32\"\n      \"0.92\"\n      \"0.13\"\n\n      \"0.74\"\n      \"0.15\"\n      \"0.53\"\n      \"0.21\"\n\n      \"0.97\"\n      \"0.45\"\n      \"0.11\"\n      \"0.05\"\n\n      \"0.61\"\n      \"0.77\"\n      \"0.59\"\n      \"0.83\"\n    }\n  }\n\n  empty.class: empty\n\n  right-grid: {\n    class: grid\n\n    1: ${right-cluster}\n    2: ${right-cluster}\n    3: ${right-cluster}\n  }\n\n  matrix-container -&gt; right-grid\n}\n\ntop-row.Random Matrix Generator -&gt; bottom-row.matrix-container.matrix",
    "crumbs": [
      "markdown"
    ]
  },
  {
    "objectID": "docs/quarto/markdown.html#footnotes",
    "href": "docs/quarto/markdown.html#footnotes",
    "title": "斯巴拉稀",
    "section": "Footnotes",
    "text": "Footnotes\n\n\ntablesgenerator↩︎\nmarkdown 文档↩︎\n直接写在这里.↩︎\nHere’s one with multiple blocks.\n\npython\n\nprintln(1)\n\nrust\n\n↩︎\nhttps://d2lang.com↩︎",
    "crumbs": [
      "markdown"
    ]
  },
  {
    "objectID": "docs/ai/000-linear-algebra.html#向量的线性组合",
    "href": "docs/ai/000-linear-algebra.html#向量的线性组合",
    "title": "斯巴拉稀",
    "section": "2 向量的线性组合",
    "text": "2 向量的线性组合\n向量v和w ,如果以它们为基向量,然后a*v+b*w这个结果集 ,我们称为v和w这2个向量的向性组合 (向量张成的空间: 下面提到的平面或一条线)\n如果在多个向量中比如(v和w 在一条线上的情况),你移除了一个向量, 而张成的空间没有减少,则这个向量 v和w 是 ==线性相关的==, 或者说其中一个向量v 是w所在向量张成的空间内, 或是说v 可以表示为w的向性组合.\n同样,如果所有向量给张成的空间增加了新的维度, 那么它们就被称为”向性无关”.\n而一组这样向性无关的向量集是张成该空间的一组基(比如二维的情况, 向性无关的v和w 就能画出一个平面,v和w 就称为一组基)"
  },
  {
    "objectID": "docs/ai/000-linear-algebra.html#三维",
    "href": "docs/ai/000-linear-algebra.html#三维",
    "title": "斯巴拉稀",
    "section": "3 三维",
    "text": "3 三维\n\n三维的向性组合一样, 如果是2个向量\nV+W 的向性组合, 是一个圆(二维平面) 或者一条线\nv+w+u 3个向量的线性组合呢? 可以先v+w 进行计算, 这里的组合最大是一个平面, 这种情况和u相加,就是整个球了, 三维的 所有可能了"
  },
  {
    "objectID": "docs/ai/000-linear-algebra.html#向量与点",
    "href": "docs/ai/000-linear-algebra.html#向量与点",
    "title": "斯巴拉稀",
    "section": "4 向量与点",
    "text": "4 向量与点\n由于在向量表示上, 我们是一个长度加上ygie箭头, 在图形表示上 如果有很多向量的话,会让画面很拥挤, 所以可以用点 来表示向量, 当然如果只有一个向量的时候,用箭头更好.\n所以我们将多个向量用点来表示"
  },
  {
    "objectID": "docs/ai/000-linear-algebra.html#矩阵-matrix",
    "href": "docs/ai/000-linear-algebra.html#矩阵-matrix",
    "title": "斯巴拉稀",
    "section": "5 矩阵 (Matrix)",
    "text": "5 矩阵 (Matrix)\n\n5.1 线性变换\n变换: 可以理解为函数, 输入-&gt;得到输出\n接收一个向量(vector input) ,输出一个向量(vector output)\n使用变换这个词, 是因为我们想用一种特殊方式来可视化这个-输入输出关系, 变换这个词是希望你使用 {==运动==}去思考\n首先变换后还是一个向量, 在二维中\n\n每一个v 都可以通过转换 i和j ,通过旋转等方式来得出转换后的w,试着想一下,你拉长i/j,旋转等这种运动的方式来得到w, 保持平行,等距分布\n\n\n\n\n\n\nImportant\n\n\n\n当你看到一个2*2的矩阵时, 你脑子里想到的是一种空间的变换,从标准的 90度i,j基准向量 –&gt; 平行的等距某个角度的 新基准向量 i和j"
  },
  {
    "objectID": "docs/ai/000-linear-algebra.html#复合矩阵",
    "href": "docs/ai/000-linear-algebra.html#复合矩阵",
    "title": "斯巴拉稀",
    "section": "6 复合矩阵",
    "text": "6 复合矩阵\n\n乘积顺序变化会影响结果的, 比如先剪切后旋转 和先旋转再剪切 结果不一样\n结合律 : ABC=(AB)C=A(BC) 注意从右向左 运动, 反正都是先运动C,再B,C,\n这和上面说的顺序不一样, 先剪切后旋转是 AB, 反过来就是BA了"
  },
  {
    "objectID": "docs/programming/node/env.html",
    "href": "docs/programming/node/env.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "直接执行下面脚本\n\nexport NVM_DIR=\"$HOME/.nvm\" && (\n  git clone https://github.com/nvm-sh/nvm.git \"$NVM_DIR\"\n  cd \"$NVM_DIR\"\n  git checkout `git describe --abbrev=0 --tags --match \"v[0-9]*\" $(git rev-list --tags --max-count=1)`\n) && \\. \"$NVM_DIR/nvm.sh\"\n\n配置写入~/.bash_profile, ~/.zshrc, ~/.profile, or ~/.bashrc\nexport NVM_DIR=\"$([ -z \"${XDG_CONFIG_HOME-}\" ] && printf %s \"${HOME}/.nvm\" || printf %s \"${XDG_CONFIG_HOME}/nvm\")\"\n[ -s \"$NVM_DIR/nvm.sh\" ] && \\. \"$NVM_DIR/nvm.sh\" # This loads nvm\n\n\n升级, 直接运行下面脚本\n\n(\n  cd \"$NVM_DIR\"\n  git fetch --tags origin\n  git checkout `git describe --abbrev=0 --tags --match \"v[0-9]*\" $(git rev-list --tags --max-count=1)`\n) && \\. \"$NVM_DIR/nvm.sh\"\n\n\n\n\n\n\n\n\n\n\nCaution\n\n\n\n版本前面带上 v 是一样的 v16.20.2\n\n\n# 列出远程稳定的node版本\nnvm ls-remote --lts\n# 安装 16.20.2 版本的node\nnvm install 16.20.2\n# 将 16.20.2版本 设置为默认 (重开终端 生效)\nnvm alias default 16.20.2\n# 使用版本,当前shell 生效\nnvm use 16.20.2\n# 查看 指定版本node 的安装位置\nnvm which 20.12.1"
  },
  {
    "objectID": "docs/programming/node/env.html#nvm1",
    "href": "docs/programming/node/env.html#nvm1",
    "title": "斯巴拉稀",
    "section": "",
    "text": "直接执行下面脚本\n\nexport NVM_DIR=\"$HOME/.nvm\" && (\n  git clone https://github.com/nvm-sh/nvm.git \"$NVM_DIR\"\n  cd \"$NVM_DIR\"\n  git checkout `git describe --abbrev=0 --tags --match \"v[0-9]*\" $(git rev-list --tags --max-count=1)`\n) && \\. \"$NVM_DIR/nvm.sh\"\n\n配置写入~/.bash_profile, ~/.zshrc, ~/.profile, or ~/.bashrc\nexport NVM_DIR=\"$([ -z \"${XDG_CONFIG_HOME-}\" ] && printf %s \"${HOME}/.nvm\" || printf %s \"${XDG_CONFIG_HOME}/nvm\")\"\n[ -s \"$NVM_DIR/nvm.sh\" ] && \\. \"$NVM_DIR/nvm.sh\" # This loads nvm\n\n\n升级, 直接运行下面脚本\n\n(\n  cd \"$NVM_DIR\"\n  git fetch --tags origin\n  git checkout `git describe --abbrev=0 --tags --match \"v[0-9]*\" $(git rev-list --tags --max-count=1)`\n) && \\. \"$NVM_DIR/nvm.sh\"\n\n\n\n\n\n\n\n\n\n\nCaution\n\n\n\n版本前面带上 v 是一样的 v16.20.2\n\n\n# 列出远程稳定的node版本\nnvm ls-remote --lts\n# 安装 16.20.2 版本的node\nnvm install 16.20.2\n# 将 16.20.2版本 设置为默认 (重开终端 生效)\nnvm alias default 16.20.2\n# 使用版本,当前shell 生效\nnvm use 16.20.2\n# 查看 指定版本node 的安装位置\nnvm which 20.12.1"
  },
  {
    "objectID": "docs/programming/node/env.html#nrm",
    "href": "docs/programming/node/env.html#nrm",
    "title": "斯巴拉稀",
    "section": "2 nrm",
    "text": "2 nrm\n# 全局安装nrm\nnpm i nrm -g\n# 列出可用的 源(registry)\nnrm ls\n# 使用某个源\nnrm use tencent"
  },
  {
    "objectID": "docs/programming/node/env.html#npm",
    "href": "docs/programming/node/env.html#npm",
    "title": "斯巴拉稀",
    "section": "3 npm",
    "text": "3 npm\n\n3.1 安装包\n# -g 全局安装\nnpm install -g @vue/cli\n# i = install\n# -S = --save\n# 会把依赖包名称写入到package.json的dependencies\n# 上线时 用到的\nnpm i node-sass  -S\n# -D = --save-dev\n# 会把依赖包名称写入到package.json的 devDependencies\n# 表示我们开发时需要用到的依赖,上线是不需要的\n# babel 开发时用它将es6 转换为es5,  上线后是用的转换后的代码, 所以上线是不需要babel\n# 类似 babel 的依赖就放到devDependencies \nnpm i node-sass  -D\n\n\n3.2 查看包\n# 查看全局已安装的包, 会把包的所有依赖也显示出来\nnpm ls -g\n# 只显示安装的包,包的依赖不会显示\nnpm ls -g --depth 0\n# 当前项目的包, (有package.json文件)\nnpm ls\n# 显示开放环境依赖的包\nnpm ls --depth 0 --dev\n\n\n3.3 卸载包\n# 卸载全局的包\nnpm uninstall xxxx -g"
  },
  {
    "objectID": "docs/programming/node/env.html#yarn",
    "href": "docs/programming/node/env.html#yarn",
    "title": "斯巴拉稀",
    "section": "4 yarn",
    "text": "4 yarn"
  },
  {
    "objectID": "docs/programming/node/env.html#deno2",
    "href": "docs/programming/node/env.html#deno2",
    "title": "斯巴拉稀",
    "section": "5 deno2",
    "text": "5 deno2"
  },
  {
    "objectID": "docs/programming/node/env.html#footnotes",
    "href": "docs/programming/node/env.html#footnotes",
    "title": "斯巴拉稀",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nnvm↩︎\ndeno 官网,deno github↩︎"
  },
  {
    "objectID": "docs/programming/rust/hands-on/compiler/index.html",
    "href": "docs/programming/rust/hands-on/compiler/index.html",
    "title": "rust实战编译器",
    "section": "",
    "text": "BrainFuck八种符号\n\n\n\n\n\n\n字符\n含义\n\n\n&gt;\n指针加一\n\n\n&lt;\n指针减一\n\n\n+\n指针指向的字节的值加一\n\n\n-\n指针指向的字节的值减一\n\n\n.\n输出指针指向的单元内容（ASCⅡ码）\n\n\n,\n输入内容到指针指向的单元（ASCⅡ码）\n\n\n[\n如果指针指向的单元值为零，向后跳转到对应的]指令的次一指令处\n\n\n]\n如果指针指向的单元值不为零，向前跳转到对应的[指令的次一指令处\n打印Hello World!1",
    "crumbs": [
      "实战",
      "编译器"
    ]
  },
  {
    "objectID": "docs/programming/rust/hands-on/compiler/index.html#footnotes",
    "href": "docs/programming/rust/hands-on/compiler/index.html#footnotes",
    "title": "rust实战编译器",
    "section": "Footnotes",
    "text": "Footnotes\n\n\n图形化查看代码执行过程↩︎",
    "crumbs": [
      "实战",
      "编译器"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/ownership.html",
    "href": "docs/programming/rust/basic/ownership.html",
    "title": "rust 所有权与借用",
    "section": "",
    "text": "所有权是rust用来管理内存的一系列规则\n\n\n\n\n\n\n\nfn main() {\n    let x = 12;\n    let y = x;\n    println!(\"{}\", x);\n\n    let x = \"abc\".to_string();\n    let y = x;\n    // println!(\"{}\", x);\n}\n\n\n\n\n\n\n分析一下到底会如何执行\n\n\n\n\n先有设计思想(即: 所有权三个规则),然后才去设计代码如何执行, 现在我们根据这个思想看第3行和第7行, 我们推断一下代码的执行\n因为值只能有一个所有者原则(所有者的概念有一重点,就是只有它可以将值销毁),所以\n\n第3行, 因为x变量内容只在栈上分配,let y=x; 会将x的值复制给 y, 就是将x变量存放的内容复制到y变量所在内存上,这个时候有2种选择\n\n使x失效(表示无法再通过变量x来访问x所在的那块内存), 这样给人感觉 值 12 只有一个所有者了, 给人一种 x “move 移动” y的感觉\n使x还是有效, 这样2个值都有自己的所有者, 注意这本身就不违反值只有一个所有者(因为是其实是2个不同地方的值了,提醒下所有权规则是为了内存管理,这里的情况就各自管理各自的值, 不会有安全问题)\n\n第7行, x变量是字符串,在栈上分配的内存存放的数据,里面有一个是指向堆内存数据的指针, 那么let y=x;的操作可能有3种选择\n\n将堆上的数据复制一份, 然后栈上的数据也复制后,把里面指向实际字符串的指针设置指向新复制的堆内存, 这个操作如果是默认行为的, 那显然很蛋疼,不可能如此设计\n只复制栈上的数据, y和x 同时有效, 但是这违反了, 只有一个所有者的规则, 因为他们2个还都指向了同一个值:堆上的数据, 有2个所有者,当离开作用域时,会导致释放同一个块内存,出现double free error 这样的安全问题 , 这就是String字符串为啥设计成move的原因\n只复制栈上的数据, 使x失效, 给人一种 x “move 移动” y 的感觉\n\n\n根据上面的思考, 既然设计思想里是 值 只有一个所有者, 那么 默认上(注意这个默认), 应该是使用 “move 移动”的.\n运行上面代码结果 是, 第4行 ok, 第8行 错误. 按照设计,默认来说, 第4行应该也报错才对, 没错就说明 rust 对 i32类型做了特殊处理,就是前面说的复制,但是变量不失效\n结论: 关于Move和Copy:\n\nrust 默认使用 Move 语义, 就是转移所有权\nrust 会给一些基本类型 自动实现一个 std::markder::Copy 这样一个标记型 trait, 来表明它会用复制但变量不失效的处理方式. 这个就是 Copy 语义. 我们也可以手动为某类型实现 Copy trait, 这样它就是Copy 语义的了.\n当你看到一个变量和它的类型时, 先是默认Move,然后思考它会不会设计成 Copy 语义\n\n\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\n\n来看 Move 语义的例子, 涉及到 裸指针相关知识点\n\n\n\n\n结构体字符串 String\n\n\nfn main() {\n    #[derive(Debug)]\n    struct Dog {\n        age: i32,\n        weight: i32,\n    }\n    let a = Dog {\n        age: 11,\n        weight: 22,\n    };\n    // 裸指针 没有指向的数据的所有权. 可以指向任意地方\n    let c = &a as *const Dog;\n    let mut b = a;\n    b.age = 10;\n    b.weight = 20;\n    // 报错,  自定义类型结构体默认是move\n    // println!(\"{:?}\",a);\n    unsafe {\n        println!(\"原a变量所在内存现在的内容: {:?}\", *c);\n        println!(\"原a变量  age 字段的地址: {:p}\", &(*c).age);\n        println!(\"原a变量weight字段的地址: {:p}\", &(*c).weight);\n    }\n    println!(\"原a变量地址: {:p}\", c);\n    println!(\"c 变量地址: {:p}\", &c);\n    println!(\"b 变量地址: {:p}\", &b);\n    println!(\"b.age 地址:{:p}\", &b.age);\n    println!(\"b.weight 地址:{:p}\", &b.weight);\n    // 是move ,实际也是 复制, 只不过让 a 失效\n    println!(\"b 的值: {:?}\", b);\n}\n\n\nfn main() {\n    let a = \"abc\".to_string(); // a 拥有 字符串的所有权\n    let c = &a as *const String as *const [u64; 3];\n    let b = a;  // a 将 abc字符串的所有权转移给了 ,a 失效了,处于不可用状态\n    // move 了, a 变量失效, 无法通过a 来读取原来的数据,报错了\n    // println!(\"{}\", a);\n\n    unsafe {\n        println!(\"原a变量所在内存内容: {:?}\", *c);\n        println!(\"原a变量字符串 中ptr字段的值: 0x{:x}\", (*c)[1]);\n    }\n    println!(\"原a 变量地址 {:p}\", c);\n    println!(\"c 变量地址: {:p}\", &c);\n    println!(\"b 变量地址: {:p}\", &b);\n    println!(\"b 变量字符串 中ptr字段的值{:p}\", b.as_ptr());\n}\n\n\n\n\n\n\n\n\n\n\nImportant\n\n\n\nrust 永远不会做深拷贝的事情,因为开销大,当然除非你主动\n\n\nfn main(){\n    let s1 = String::from(\"hello\");\n    // 深拷贝了\n    let s2 = s1.clone();\n    println!(\"s1 = {}, s2 = {}\", s1, s2);\n}\n\n\n\n\n\n\n\n\n\n\n\nImportant\n\n\n\n\n前面我们提到 实现Copy 语义,需要给类型实现 Copy trait\n类型的值可以通过简单的位拷贝来复制, 这意味着类型在内存中的表示可以直接复制而不需要进行任何其他操作(不会产生任何内存安全问题),那种还有指向堆上数据的类型就不可以实现Copy\n\n\n\n\n\n\n\nCopy\n\n整型不可变借用数组\n\n\nfn main() {\n    let x = 5;\n    // 将x的值copy 给y, 2个变量同时存在\n    // 因为这里是直接在栈上,拷贝起来是非常快的\n    // 所以在设计上就直接简单复制,对比看后面的字符串的情况\n    let y = x;\n    println!(\"{:p}-{:p}\", &x, &y);\n    println!(\"{x},{y}\");\n}\n\n\nfn main() {\n    let a = 1;\n    let b = &a;\n    let c = b; // copy\n\n    println!(\"{b}\"); //ok\n    println!(\"{c}\");\n}\n\n\nfn main() {\n    // 元素是整型, 则是copy\n    let a = [1, 2, 3];\n    let b = a; // 栈上的 数据会复制一份给b\n    println!(\"{:?}-{:p}\", a, &a);\n    println!(\"{:?}-{:p}\", b, &b);\n}\n\n\n\nMove\n\n可变借用的赋值结构体\n\n\nfn main() {\n    let mut a = 1;\n    let b = &mut a;\n    let _c = b;\n    // 报错了\n    // 因为 b 已经移动给了 c, b 已经不可用了\n    println!(\"{b}\");\n}\n\n\nfn main() {\n    struct Dog {\n        age: u8,\n    }\n    let a = Dog { age: 1 };\n    let _b = a;\n    // 根据图5所示,move类型, 所以这里报错了,提示a已经被move了\n    println!(\"{}\", a.age);\n}\n\n\n\n\n\n\n\n\n\nCopy trait定义\n\npub trait Copy: Clone {\n    // Empty.\n}\n\n\n\n\n\n\n\nImportant\n\n\n\n\n实现Copy trait 必须也实现 Clone trait\n\n\n\n\n\n\n\n\n\n\nImportant\n\n\n\n\n自定义类型比如struct和enum,只有所有成员都能实现了Copy trait, 该类型才能实现Copy trait\n\n\n\n\n\n字段是整型的结构体\n\nfn main() {\n    // 自动给实现Copy Clone\n    #[derive(Copy, Clone, Debug)]\n    struct Dog {\n        age: u8,\n    }\n    let a = Dog { age: 1 };\n    let _b = a;\n    println!(\"{:?}\", a);  // OK\n}\n\n\n\n报错: 字段含字符串的结构体\n\nfn main() {\n    // 自动给实现Copy Clone\n    #[derive(Copy, Clone, Debug)] // 直接报错这里\n    struct Dog {\n        name: String,\n    }\n    let a = Dog { name: \"tom\".to_string() };\n    let _b = a;\n    println!(\"{:?}\", a);\n}\n\n\n\n\n\n\n\n\n\n\n\nImportant\n\n\n\n\n一个变量的生命周期: 一个变量的出生到死亡的整个过程\n一个变量离开它的作用域时, 就是它死亡的时候, 会释放资源\n\n\n\n\n\n&str 变量离开作用域后\n\nfn main() {\n    let ptr;\n    {   // 这一行时 a变量 还没申明, 不可用\n        let a = \"hello\"; // a 变量可用\n        // a.as_ptr() 就是 a as *const str\n        ptr = a as *const str;\n        unsafe {\n            println!(\"a指向的实际字符串的地址上的数据:  {}\", &*ptr);\n        }\n    } // a 离开作用域, a变量无效了\n    unsafe {\n        // 我们发现数据还在, 这是因为 a 是&str类型, 没有 \"hello\" 的所有权,\n        // 它只是它的借用, 实际字符串数据放在只读区\n        println!(\"离开作用域后,a指向的实际字符串的地址上的数据: {}\", &*ptr);\n    }\n    // println!(\"{}\", a); // cannot find value s in this scope\n}\n\n\n\nString字符串离开作用域后查看其指向的堆内存的内容\n\nfn main() {\n    let c;\n    {\n        let mut a = \"hello\".to_string();\n        a.push_str(\"tom\");\n        c = &a as *const String as *const (u64, *const u8, u64);\n        unsafe {\n            let len = (*c).2 as usize;\n            let ptr = (*c).1;\n            print!(\"|\");\n            let mut d;\n            for i in 0..len {\n                d = ptr.add(i);\n                // hellotom\n                print!(\"{}\", *d as char);\n            }\n            println!(\"|\");\n        }\n    } // a 离开作用域, 释放资源\n    unsafe {\n        let len = (*c).2 as usize;\n        let ptr = (*c).1;\n        print!(\"|\");\n        let mut d;\n        // 这里打印是空的了, 堆上的内存被释放了.\n        for i in 0..len {\n            d = ptr.add(i);\n            print!(\"{}\", *d as char);\n        }\n        println!(\"|\");\n    }\n}\n\n\n\n\n\n\n\n\n\n\n为什么内存在持有它的变量离开作用域后会被无效了呢?\n\n\n\n\n当变量离开作用域, Rust 会调用一个名为drop的特殊函数\n设计string类型的作者可以在该drop函数中写一些释放内存的代码,以此实现自动释放内存的功能,这样就实现资源的自动管理\n不同类型变量的drop的实现可能不一样\nRust 在结尾的 } 处会自动调用 drop\n\n\n\n\n\n\n\n\n\nImportant\n\n\n\n\n实现Copy trait的类型 无法实现 drop trait\n\n\n\n\n\n自定义析构函数\n\n#[derive(Debug)]\nstruct Dog {\n    age: i32,\n}\n// 实现 std::ops::Drop 这个trait\nimpl Drop for Dog {\n    fn drop(&mut self) {\n        println!(\"dog drop...{}\", self.age);\n    }\n}\nfn main() {\n    {\n        let a = Dog { age: 1 }; // 最先 drop\n    } // 离开作用域, 会自动调用drop 方法\n    let b = Dog { age: 2 }; // 最后一个drop\n    let c = Dog { age: 3 };  // 这个是第二个drop ,局部变量 先进后出\n}\n\n\n\n\n主动触发析构drop\n\n// #[derive(Copy,Clone,Debug)]\n#[derive(Debug)]\nstruct Dog {\n    age: i32,\n}\n// 实现 std::ops::Drop 这个trait\nimpl Drop for Dog {\n    fn drop(&mut self) {\n        // 传递的是可变借用\n        println!(\"dog drop...{}\", self.age);\n    }\n}\n\nfn main() {\n    {\n        let a = Dog { age: 1 };\n    }\n    let b = Dog { age: 2 };\n    std::mem::drop(b);\n    let c = Dog { age: 3 };\n}\n\n\n执行结果std::mem::drop 源码\n\n\ndog drop...1\ndog drop...2\ndog drop...3\n\n\n\n我们发现, 其实这个就是进行了主动的move 操作,转移所有权,然后函数调用结束,参数的生命周期结束了,触发析构函数drop\n这样看来, Copy 语义的类型, 使用这个drop 没有任何意义, 所以直接就是实现Copy trait的类型无法实现 drop trait\n\npub fn drop&lt;T&gt;(_x: T) {\n    // 函数体是空的\n}\n\n\n\n\n\n\n变量shadowing\n\n#[derive(Debug)]\nstruct Dog {\n    age: i32,\n}\n// 实现 std::ops::Drop 这个trait\nimpl Drop for Dog {\n    fn drop(&mut self) {\n        println!(\"dog drop...{}\", self.age);\n    }\n}\n\nfn main() {\n    {\n        let a = Dog { age: 1 };\n    }\n    // 之前说过,变量shadowing ,2个就是不通的变量\n    let b = Dog { age: 2 };\n    let b = Dog { age: 3 };\n}\n\n\n\n_\n\n#[derive(Debug)]\nstruct Dog {\n    age: i32,\n}\n// 实现 std::ops::Drop 这个trait\nimpl Drop for Dog {\n    fn drop(&mut self) {\n        println!(\"dog drop...{}\", self.age);\n    }\n}\n\nfn main() {\n    {\n        let a = Dog { age: 1 };\n    }\n    // _ 这样的 会马上执行 析构函数\n    let _ = Dog { age: 2 };\n    let b = Dog { age: 3 };\n}\n\n\n\n\n\nfn main() {\n    let s = String::from(\"hello\");\n    // s move into 函数\n    takes_ownership(s);\n    // 所以s 这个时候已经不可用了.\n    // println!(\"{s}\"); //报错了\n\n    let x = 5;\n    // x would move into the function,\n    // 但是 x 是i32 类型,在栈上,前面说过它会 copy 操作\n    makes_copy(x);\n    println!(\"{x}\"); // 这里还是可以访问的\n} // Here, x goes out of scope, then s. But because s's value was moved, nothing\n  // special happens.\n\nfn takes_ownership(some_string: String) {\n    // some_string comes into scope\n    println!(\"{}\", some_string);\n} // 跳出作用域,some_string 指向的堆以及自身(栈会弹)都会被drop, 内存会释放\n\nfn makes_copy(some_integer: i32) {\n    // some_integer comes into scope\n    println!(\"{}\", some_integer);\n} // Here, some_integer goes out of scope. Nothing special happens.\n\n\n\nfn main() {\n    let s1 = gives_ownership();\n\n    let s2 = String::from(\"hello\");\n\n    // s2 move 给了 takes_and_gives_back的参数\n    // takes_and_gives_back 返回值 move 给了 调用者, 给了s3\n    let s3 = takes_and_gives_back(s2);\n} // Here, s3 goes out of scope and is dropped. s2 was moved, so nothing\n  // happens. s1 goes out of scope and is dropped.\n\n// 会将返回值 move 给它的调用者\nfn gives_ownership() -&gt; String {\n    let some_string = String::from(\"yours\");\n\n    // 这个会作为返回值, move 给 当前函数的调用者\n    some_string\n}\n\n// This function takes a String and returns one\nfn takes_and_gives_back(a_string: String) -&gt; String {\n    // a_string comes into\n    // scope\n\n    a_string // a_string is returned and moves out to the calling function\n}",
    "crumbs": [
      "基础篇",
      "所有权与借用"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/ownership.html#所有权-ownership",
    "href": "docs/programming/rust/basic/ownership.html#所有权-ownership",
    "title": "rust 所有权与借用",
    "section": "",
    "text": "所有权是rust用来管理内存的一系列规则\n\n\n\n\n\n\n\nfn main() {\n    let x = 12;\n    let y = x;\n    println!(\"{}\", x);\n\n    let x = \"abc\".to_string();\n    let y = x;\n    // println!(\"{}\", x);\n}\n\n\n\n\n\n\n分析一下到底会如何执行\n\n\n\n\n先有设计思想(即: 所有权三个规则),然后才去设计代码如何执行, 现在我们根据这个思想看第3行和第7行, 我们推断一下代码的执行\n因为值只能有一个所有者原则(所有者的概念有一重点,就是只有它可以将值销毁),所以\n\n第3行, 因为x变量内容只在栈上分配,let y=x; 会将x的值复制给 y, 就是将x变量存放的内容复制到y变量所在内存上,这个时候有2种选择\n\n使x失效(表示无法再通过变量x来访问x所在的那块内存), 这样给人感觉 值 12 只有一个所有者了, 给人一种 x “move 移动” y的感觉\n使x还是有效, 这样2个值都有自己的所有者, 注意这本身就不违反值只有一个所有者(因为是其实是2个不同地方的值了,提醒下所有权规则是为了内存管理,这里的情况就各自管理各自的值, 不会有安全问题)\n\n第7行, x变量是字符串,在栈上分配的内存存放的数据,里面有一个是指向堆内存数据的指针, 那么let y=x;的操作可能有3种选择\n\n将堆上的数据复制一份, 然后栈上的数据也复制后,把里面指向实际字符串的指针设置指向新复制的堆内存, 这个操作如果是默认行为的, 那显然很蛋疼,不可能如此设计\n只复制栈上的数据, y和x 同时有效, 但是这违反了, 只有一个所有者的规则, 因为他们2个还都指向了同一个值:堆上的数据, 有2个所有者,当离开作用域时,会导致释放同一个块内存,出现double free error 这样的安全问题 , 这就是String字符串为啥设计成move的原因\n只复制栈上的数据, 使x失效, 给人一种 x “move 移动” y 的感觉\n\n\n根据上面的思考, 既然设计思想里是 值 只有一个所有者, 那么 默认上(注意这个默认), 应该是使用 “move 移动”的.\n运行上面代码结果 是, 第4行 ok, 第8行 错误. 按照设计,默认来说, 第4行应该也报错才对, 没错就说明 rust 对 i32类型做了特殊处理,就是前面说的复制,但是变量不失效\n结论: 关于Move和Copy:\n\nrust 默认使用 Move 语义, 就是转移所有权\nrust 会给一些基本类型 自动实现一个 std::markder::Copy 这样一个标记型 trait, 来表明它会用复制但变量不失效的处理方式. 这个就是 Copy 语义. 我们也可以手动为某类型实现 Copy trait, 这样它就是Copy 语义的了.\n当你看到一个变量和它的类型时, 先是默认Move,然后思考它会不会设计成 Copy 语义\n\n\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\n\n来看 Move 语义的例子, 涉及到 裸指针相关知识点\n\n\n\n\n结构体字符串 String\n\n\nfn main() {\n    #[derive(Debug)]\n    struct Dog {\n        age: i32,\n        weight: i32,\n    }\n    let a = Dog {\n        age: 11,\n        weight: 22,\n    };\n    // 裸指针 没有指向的数据的所有权. 可以指向任意地方\n    let c = &a as *const Dog;\n    let mut b = a;\n    b.age = 10;\n    b.weight = 20;\n    // 报错,  自定义类型结构体默认是move\n    // println!(\"{:?}\",a);\n    unsafe {\n        println!(\"原a变量所在内存现在的内容: {:?}\", *c);\n        println!(\"原a变量  age 字段的地址: {:p}\", &(*c).age);\n        println!(\"原a变量weight字段的地址: {:p}\", &(*c).weight);\n    }\n    println!(\"原a变量地址: {:p}\", c);\n    println!(\"c 变量地址: {:p}\", &c);\n    println!(\"b 变量地址: {:p}\", &b);\n    println!(\"b.age 地址:{:p}\", &b.age);\n    println!(\"b.weight 地址:{:p}\", &b.weight);\n    // 是move ,实际也是 复制, 只不过让 a 失效\n    println!(\"b 的值: {:?}\", b);\n}\n\n\nfn main() {\n    let a = \"abc\".to_string(); // a 拥有 字符串的所有权\n    let c = &a as *const String as *const [u64; 3];\n    let b = a;  // a 将 abc字符串的所有权转移给了 ,a 失效了,处于不可用状态\n    // move 了, a 变量失效, 无法通过a 来读取原来的数据,报错了\n    // println!(\"{}\", a);\n\n    unsafe {\n        println!(\"原a变量所在内存内容: {:?}\", *c);\n        println!(\"原a变量字符串 中ptr字段的值: 0x{:x}\", (*c)[1]);\n    }\n    println!(\"原a 变量地址 {:p}\", c);\n    println!(\"c 变量地址: {:p}\", &c);\n    println!(\"b 变量地址: {:p}\", &b);\n    println!(\"b 变量字符串 中ptr字段的值{:p}\", b.as_ptr());\n}\n\n\n\n\n\n\n\n\n\n\nImportant\n\n\n\nrust 永远不会做深拷贝的事情,因为开销大,当然除非你主动\n\n\nfn main(){\n    let s1 = String::from(\"hello\");\n    // 深拷贝了\n    let s2 = s1.clone();\n    println!(\"s1 = {}, s2 = {}\", s1, s2);\n}\n\n\n\n\n\n\n\n\n\n\n\nImportant\n\n\n\n\n前面我们提到 实现Copy 语义,需要给类型实现 Copy trait\n类型的值可以通过简单的位拷贝来复制, 这意味着类型在内存中的表示可以直接复制而不需要进行任何其他操作(不会产生任何内存安全问题),那种还有指向堆上数据的类型就不可以实现Copy\n\n\n\n\n\n\n\nCopy\n\n整型不可变借用数组\n\n\nfn main() {\n    let x = 5;\n    // 将x的值copy 给y, 2个变量同时存在\n    // 因为这里是直接在栈上,拷贝起来是非常快的\n    // 所以在设计上就直接简单复制,对比看后面的字符串的情况\n    let y = x;\n    println!(\"{:p}-{:p}\", &x, &y);\n    println!(\"{x},{y}\");\n}\n\n\nfn main() {\n    let a = 1;\n    let b = &a;\n    let c = b; // copy\n\n    println!(\"{b}\"); //ok\n    println!(\"{c}\");\n}\n\n\nfn main() {\n    // 元素是整型, 则是copy\n    let a = [1, 2, 3];\n    let b = a; // 栈上的 数据会复制一份给b\n    println!(\"{:?}-{:p}\", a, &a);\n    println!(\"{:?}-{:p}\", b, &b);\n}\n\n\n\nMove\n\n可变借用的赋值结构体\n\n\nfn main() {\n    let mut a = 1;\n    let b = &mut a;\n    let _c = b;\n    // 报错了\n    // 因为 b 已经移动给了 c, b 已经不可用了\n    println!(\"{b}\");\n}\n\n\nfn main() {\n    struct Dog {\n        age: u8,\n    }\n    let a = Dog { age: 1 };\n    let _b = a;\n    // 根据图5所示,move类型, 所以这里报错了,提示a已经被move了\n    println!(\"{}\", a.age);\n}\n\n\n\n\n\n\n\n\n\nCopy trait定义\n\npub trait Copy: Clone {\n    // Empty.\n}\n\n\n\n\n\n\n\nImportant\n\n\n\n\n实现Copy trait 必须也实现 Clone trait\n\n\n\n\n\n\n\n\n\n\nImportant\n\n\n\n\n自定义类型比如struct和enum,只有所有成员都能实现了Copy trait, 该类型才能实现Copy trait\n\n\n\n\n\n字段是整型的结构体\n\nfn main() {\n    // 自动给实现Copy Clone\n    #[derive(Copy, Clone, Debug)]\n    struct Dog {\n        age: u8,\n    }\n    let a = Dog { age: 1 };\n    let _b = a;\n    println!(\"{:?}\", a);  // OK\n}\n\n\n\n报错: 字段含字符串的结构体\n\nfn main() {\n    // 自动给实现Copy Clone\n    #[derive(Copy, Clone, Debug)] // 直接报错这里\n    struct Dog {\n        name: String,\n    }\n    let a = Dog { name: \"tom\".to_string() };\n    let _b = a;\n    println!(\"{:?}\", a);\n}\n\n\n\n\n\n\n\n\n\n\n\nImportant\n\n\n\n\n一个变量的生命周期: 一个变量的出生到死亡的整个过程\n一个变量离开它的作用域时, 就是它死亡的时候, 会释放资源\n\n\n\n\n\n&str 变量离开作用域后\n\nfn main() {\n    let ptr;\n    {   // 这一行时 a变量 还没申明, 不可用\n        let a = \"hello\"; // a 变量可用\n        // a.as_ptr() 就是 a as *const str\n        ptr = a as *const str;\n        unsafe {\n            println!(\"a指向的实际字符串的地址上的数据:  {}\", &*ptr);\n        }\n    } // a 离开作用域, a变量无效了\n    unsafe {\n        // 我们发现数据还在, 这是因为 a 是&str类型, 没有 \"hello\" 的所有权,\n        // 它只是它的借用, 实际字符串数据放在只读区\n        println!(\"离开作用域后,a指向的实际字符串的地址上的数据: {}\", &*ptr);\n    }\n    // println!(\"{}\", a); // cannot find value s in this scope\n}\n\n\n\nString字符串离开作用域后查看其指向的堆内存的内容\n\nfn main() {\n    let c;\n    {\n        let mut a = \"hello\".to_string();\n        a.push_str(\"tom\");\n        c = &a as *const String as *const (u64, *const u8, u64);\n        unsafe {\n            let len = (*c).2 as usize;\n            let ptr = (*c).1;\n            print!(\"|\");\n            let mut d;\n            for i in 0..len {\n                d = ptr.add(i);\n                // hellotom\n                print!(\"{}\", *d as char);\n            }\n            println!(\"|\");\n        }\n    } // a 离开作用域, 释放资源\n    unsafe {\n        let len = (*c).2 as usize;\n        let ptr = (*c).1;\n        print!(\"|\");\n        let mut d;\n        // 这里打印是空的了, 堆上的内存被释放了.\n        for i in 0..len {\n            d = ptr.add(i);\n            print!(\"{}\", *d as char);\n        }\n        println!(\"|\");\n    }\n}\n\n\n\n\n\n\n\n\n\n\n为什么内存在持有它的变量离开作用域后会被无效了呢?\n\n\n\n\n当变量离开作用域, Rust 会调用一个名为drop的特殊函数\n设计string类型的作者可以在该drop函数中写一些释放内存的代码,以此实现自动释放内存的功能,这样就实现资源的自动管理\n不同类型变量的drop的实现可能不一样\nRust 在结尾的 } 处会自动调用 drop\n\n\n\n\n\n\n\n\n\nImportant\n\n\n\n\n实现Copy trait的类型 无法实现 drop trait\n\n\n\n\n\n自定义析构函数\n\n#[derive(Debug)]\nstruct Dog {\n    age: i32,\n}\n// 实现 std::ops::Drop 这个trait\nimpl Drop for Dog {\n    fn drop(&mut self) {\n        println!(\"dog drop...{}\", self.age);\n    }\n}\nfn main() {\n    {\n        let a = Dog { age: 1 }; // 最先 drop\n    } // 离开作用域, 会自动调用drop 方法\n    let b = Dog { age: 2 }; // 最后一个drop\n    let c = Dog { age: 3 };  // 这个是第二个drop ,局部变量 先进后出\n}\n\n\n\n\n主动触发析构drop\n\n// #[derive(Copy,Clone,Debug)]\n#[derive(Debug)]\nstruct Dog {\n    age: i32,\n}\n// 实现 std::ops::Drop 这个trait\nimpl Drop for Dog {\n    fn drop(&mut self) {\n        // 传递的是可变借用\n        println!(\"dog drop...{}\", self.age);\n    }\n}\n\nfn main() {\n    {\n        let a = Dog { age: 1 };\n    }\n    let b = Dog { age: 2 };\n    std::mem::drop(b);\n    let c = Dog { age: 3 };\n}\n\n\n执行结果std::mem::drop 源码\n\n\ndog drop...1\ndog drop...2\ndog drop...3\n\n\n\n我们发现, 其实这个就是进行了主动的move 操作,转移所有权,然后函数调用结束,参数的生命周期结束了,触发析构函数drop\n这样看来, Copy 语义的类型, 使用这个drop 没有任何意义, 所以直接就是实现Copy trait的类型无法实现 drop trait\n\npub fn drop&lt;T&gt;(_x: T) {\n    // 函数体是空的\n}\n\n\n\n\n\n\n变量shadowing\n\n#[derive(Debug)]\nstruct Dog {\n    age: i32,\n}\n// 实现 std::ops::Drop 这个trait\nimpl Drop for Dog {\n    fn drop(&mut self) {\n        println!(\"dog drop...{}\", self.age);\n    }\n}\n\nfn main() {\n    {\n        let a = Dog { age: 1 };\n    }\n    // 之前说过,变量shadowing ,2个就是不通的变量\n    let b = Dog { age: 2 };\n    let b = Dog { age: 3 };\n}\n\n\n\n_\n\n#[derive(Debug)]\nstruct Dog {\n    age: i32,\n}\n// 实现 std::ops::Drop 这个trait\nimpl Drop for Dog {\n    fn drop(&mut self) {\n        println!(\"dog drop...{}\", self.age);\n    }\n}\n\nfn main() {\n    {\n        let a = Dog { age: 1 };\n    }\n    // _ 这样的 会马上执行 析构函数\n    let _ = Dog { age: 2 };\n    let b = Dog { age: 3 };\n}\n\n\n\n\n\nfn main() {\n    let s = String::from(\"hello\");\n    // s move into 函数\n    takes_ownership(s);\n    // 所以s 这个时候已经不可用了.\n    // println!(\"{s}\"); //报错了\n\n    let x = 5;\n    // x would move into the function,\n    // 但是 x 是i32 类型,在栈上,前面说过它会 copy 操作\n    makes_copy(x);\n    println!(\"{x}\"); // 这里还是可以访问的\n} // Here, x goes out of scope, then s. But because s's value was moved, nothing\n  // special happens.\n\nfn takes_ownership(some_string: String) {\n    // some_string comes into scope\n    println!(\"{}\", some_string);\n} // 跳出作用域,some_string 指向的堆以及自身(栈会弹)都会被drop, 内存会释放\n\nfn makes_copy(some_integer: i32) {\n    // some_integer comes into scope\n    println!(\"{}\", some_integer);\n} // Here, some_integer goes out of scope. Nothing special happens.\n\n\n\nfn main() {\n    let s1 = gives_ownership();\n\n    let s2 = String::from(\"hello\");\n\n    // s2 move 给了 takes_and_gives_back的参数\n    // takes_and_gives_back 返回值 move 给了 调用者, 给了s3\n    let s3 = takes_and_gives_back(s2);\n} // Here, s3 goes out of scope and is dropped. s2 was moved, so nothing\n  // happens. s1 goes out of scope and is dropped.\n\n// 会将返回值 move 给它的调用者\nfn gives_ownership() -&gt; String {\n    let some_string = String::from(\"yours\");\n\n    // 这个会作为返回值, move 给 当前函数的调用者\n    some_string\n}\n\n// This function takes a String and returns one\nfn takes_and_gives_back(a_string: String) -&gt; String {\n    // a_string comes into\n    // scope\n\n    a_string // a_string is returned and moves out to the calling function\n}",
    "crumbs": [
      "基础篇",
      "所有权与借用"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/ownership.html#借用-borrow",
    "href": "docs/programming/rust/basic/ownership.html#借用-borrow",
    "title": "rust 所有权与借用",
    "section": "2 借用 borrow",
    "text": "2 借用 borrow\n前面调用函数我们发现,每次调用函数,都会有 taking ownership 和 returning ownership,很烦, 有没有可以直接使用某个值,而不需要转移所有权的呢? –&gt; 借用\n\n\n\n\n\n\nTip\n\n\n\n\n你借给别人你的书, 书的所有权还是你的,别人只是借用一下.\n你借给别人书时,说只能看,别涂涂画画的, =&gt; 不可变借用\n你借给别人书时,说可以写写画画, =&gt; 可变借用\n\n\n\n& 表示引用某些值, 而不取得其所有权, 所以是没有权限去管理值的销毁的\nfn main() {\n    let s1 = String::from(\"hello\");\n    // &s1, 引用s1,  知道s1的地址, 就意味着 知道它的值\n    let len = calculate_length(&s1);\n\n    println!(\"The length of '{}' is {}.\", s1, len);\n}\n\nfn calculate_length(s: &String) -&gt; usize {\n    s.len()\n}//s 并不拥有 s1变量指向的值的所有权, 所以当 drop 后, s1变量指向的值不会free\n\n2.1 不可变和可变\nfn main() {\n    let s = String::from(\"hello\");\n\n    // changeImmutable(&s);\n\n    // 字符串 需要 可变\n    let mut s2 = String::from(\"hello\");\n    // 引用也需要可变\n    changeMutable(&mut s2);\n    println!(\"{:?}-{:?}\", s.as_ptr(), s2.as_ptr());\n\n}\n\nfn changeImmutable(some_string: &String) {\n    some_string.push_str(\", world\");  //报错了\n}\n// 参数需要可变\nfn changeMutable(some_string: &mut String) {\n    // some_string.push_str(\", world\");\n    some_string.pop();\n}\nstruct Sheep&lt;'a&gt; {\n    a: &'a mut i32,\n}\nfn main() {\n    // 表示c 可变, 意思是它可以重新绑定数据(重新赋值)\n    let mut c = 11;\n    // 表示d 指向的数据 是可变的.\n    // d本身不可变\n    let d = &mut c;\n    // 这里实际修改的c,所以d不需要mut\n    // 对谁做修改,谁就要mut\n    *d = 12;\n    // ====\n    let mut c = 11;\n    // d 本身可变, 就是说 我可以 d = &mut 12\n    let mut d = &mut c;\n    let f = &mut d;\n    // *f 是对d 修改, d就要mut\n    **f = 12;\n    // ====\n    let mut c = 11;\n    // 这里需要mut\n    let d = &mut Sheep { a: &mut c };\n    println!(\"{}\", d.a);\n    // 这里修改d.a, 就是对d 进行了修改,需要d &mut\n    // 虽然实际上a的值没有修改, 修改的是a指向的内存的值\n    *d.a = 22;\n    println!(\"{}\", d.a);\n}\n\n\n2.2 编译是否成功的判断方法\n\n\n\n\n\n\n含借用的代码,编译是否成功的判断逻辑\n\n\n\n\nrust 希望你是明确知道自己是想要如何使用这块内存,然后正确定义合适的变量\n如果你使用不可变借用\n\n那么定义这个不可变引用后到最后一次使用它之前, 你肯定是希望它指向的数据不会被修改, 要不然你用个屁的不可变啊\n所以在定义一个不可变借用后 &a, 接着有代码修改了a的数据, 然后你再使用这个不可变引用,那么就报错了,因为这和你的初衷是违背的\n\n如果你使用了可变借用\n\n那么定义这个可变借用后到最后一次使用它之前, 你肯定不希望有其他人来修改它,你希望只有你自己可以修改a的值,就是你在最后使用它之前,对 a 完全可控的,你不希望在读取它之前,被其他人修改\n所以在定义一个可变借用后, 你要确保你最后在使用它之前, 没有其他人修改它\n\n你可以认为 从你定义借用变量到最后一次使用这个借用变量,这段代码块是你这个借用变量的作用域, 在这样一个作用域内不能有对一个变量的多个可变借用 , 类似于读写锁, 某一时间内只能有一个写操作\n以上我是从 rust为什么要这样设计 这个角度去思考得出的结论, 现在应该不难判断了.\n\n\n\n报错的\nfn main() {\n    let mut a = 3;\n    let b = &mut a;\n    a = 31; // 这里提示错误\n    // 在使用这个 可变引用前,有其他人对a做了修改了\n    // 这不符合 定义可变引用的初衷\n    println!(\"{}\", b);\n}\n正确的\nfn main() {\n    let mut a = 3;\n    let b = &mut a;\n    *b = 11;\n    // 前面自己修改, 最后使用的地方, 都是想要的结果\n    // 用作用域来理解 也ok的\n    println!(\"{}\", b);\n    a = 31;\n    println!(\"{}\", a);\n}\n作用域\nfn main() {\n    let mut s2 = String::from(\"hello\");\n    {\n        let r3 = &mut s2;\n        println!(\"{}\", r3);\n    } // 这个时候r3 drop了. 所以后面 可以有 r4\n    let r4 = &mut s2;\n    println!(\"{}\", r4);\n}\n多个可变引用,ok的\nfn main() {\n    let mut a = 3;\n    let b = &mut a;\n    println!(\"{}\", b);\n    let c = &mut a;\n    println!(\"{}\", c);\n}\n报错的\nfn main() {\n    let mut a = 3;\n    let b = &mut a;\n    let c = &mut a;\n    // 你使用b的时候,前面有 个c 可能做 对a的修改\n    // 这样你这里使用b时,可能就不是你想要的结果了.\n    // 按照前面的说法, 可以理解为: 一个作用域内 只能有一个可变引用\n    println!(\"{}\", b);\n    println!(\"{}\", c);\n}\n报错了\nfn main() {\n    let mut a = 3;\n    let b = &a;\n    let c = &mut a;\n    // 报错了, 你使用不可变引用,但是前面c 可能会修改a\n    println!(\"{}\", b);\n    println!(\"{}\", c);\n}\n多个不可变引用\nfn main() {\n    let mut s = String::from(\"hello\");\n    // 在有一个可变引用之前的 多个不可变引用, 完全ok\n    // 这个道理很好理解,因为在 可变引用之前,变量不存在竞争\n    let a1 = &s; // 不可变引用\n    let a2 = &s; // 多个不可变引用 ,可以的\n    // 关键: 因为在可变引用之前,所以使用的时候,不会出现被修改的情况\n    println!(\"{}-{}\", a1, a2);\n    let x1 = &mut s; // 可变引用\n    println!(\"{}\", x1);\n}\n报错\nfn main() {\n    let mut s = String::from(\"hello\");\n    let a1 = &s;\n    let a2 = &s;\n    s.push_str(\"world\");  // 同样会报错\n    // 因为这个时候, s 已经被修改了, 不可变引用的意义没了\n    println!(\"{}-{}\", a1, a2);\n}\n\n\n2.3 悬挂引用\nrust 编译器会直接报错\nfn main() {\n    let reference_to_nothing = dangle();\n}\n\nfn dangle() -&gt; &String {\n    let s = String::from(\"hello\");\n\n    &s\n} // s drop 掉了, 所在内存被释放了. &s 引用了一个不可控的内存\n\n\n2.4 reborrow?\n\n2.4.1 可变借用直接赋值\n报错的\nfn main() {\n    let mut a = 3;\n    let b = &mut a;\n    // 可变借用是move类比, 因此b move 给了c\n    let c = b;\n    println!(\"{}\", b); //报错\n    println!(\"{}\", c);\n}\n报错了, 你可能以为这不和上面一样吗, b move给了c, 你打印b肯定错了\nfn main() {\n    let mut a = 3;\n    let b = &mut a;\n    let c: &mut i32 = b;\n    println!(\"{}\", b);\n    println!(\"{}\", c);\n}\n实际上我们看下报错信息,非常有意思, 竟然说b被可变借用了,而不是move给了c?\n\n\nerror信息\n\nerror[E0502]: cannot borrow `b` as immutable because it is also borrowed as mutable\n --&gt; src/main.rs:5:20\n  |\n4 |     let c: &mut i32 = b;\n  |                       - mutable borrow occurs here\n5 |     println!(\"{}\", b);\n  |                    ^ immutable borrow occurs here\n6 |     println!(\"{}\", c); //\n  |                    - mutable borrow later used here\n\n先看下这个类比\nfn main() {\n    let mut b = 1;\n    let c=&mut b;\n    // 使用b 前, 可能已经被修改了(因为c), 所以报错\n    println!(\"{}\", b);\n    println!(\"{}\", c);\n}\n再看看前面的 let c: &mut i32 = b; 说是b被可变借用了,怎么就可变借用了? 只有下面这种可能了 let c: &mut i32 = b; 估计是等价于\nlet c= &mut *b; // 这样b 确实可以说被可变借用了\n完整类比\nfn main() {\n    let mut a = 3;\n    let b = &mut a;\n    let c = &mut *b;\n    println!(\"{}\", b);\n    println!(\"{}\", c);\n}\n现在在看看正确的\nfn main() {\n    let mut a = 3;\n    let b = &mut a;\n    // c是(*b)的可变借用,认为与a无关, 虽然实际和 &mut a一样\n    // 这样 实际上 对于a来说,有2个可变借用,且还有交集的样子\n    // 但是对于b 来说, 只有一个对b的可变借用, 在这个可变借用 折腾完后,再使用b 是ok的.\n    let c = &mut *b;\n    *c = 4;\n    /* 类比这个肯定最后报错\n    let d= &mut a;\n    *d = 4;\n    */\n    println!(\"{}\", c);\n    println!(\"{}\", b);\n}\n\n\n2.4.2 可变借用函数传参\n我是最先测试函数传可变借用时,发现奇怪现象的\nfn main() {\n    let mut a = 3;\n    let b = &mut a;\n    ppp(b);\n    // 对比这个,如果用这个,就会报错了\n    // 因为这样就有2个a的可变借用且作用域有交叉(后面使用了b的,但是在之前有对a新的可变借用)\n    // ppp(&mut a);\n    println!(\"{b}\"); // ok\n}\n// 相当于 let s:&mut i32=b;\nfn ppp(s: &mut i32) {\n    *s = 11;\n}\n同样的,b 没有发生 move\n\n\n再来看看这个例子,相当于存在2个a的可变借用\n\nfn main() {\n    let mut a = 3;\n    let b = &mut a;\n    // 通过一个函数使用该可变借用, 来修改数据,这样的功能需求很正常\n    // 当然这里我们返回了这个可变借用,一般不会这么做,这里只是演示\n    let c = new_mut_borrow(b);\n    *c = 33;\n    println!(\"{b}\"); // ok\n}\n// 相当于 let s:&mut i32=b;\nfn new_mut_borrow(s: &mut i32) -&gt; &mut i32 {\n    *s = 11;\n    s\n}\n\n\n\n2.4.3 可变借用函数传参为何这样设计\nstruct Cat&lt;'a&gt; {\n    a: &'a mut String,\n}\nimpl&lt;'a&gt; Cat&lt;'a&gt; {\n    fn mut_fn(&'a mut self, n: &'a str) {\n        // self= &mut Cat\n        // let mut c = Cat { a: &mut s }; 为例\n        // self.a 变量是 &mut s ,是可变借用类型\n        // push_str=&gt; String::push_str(&mut self, )\n        // 会使用reborrow , =&gt; 将&mut (*self.a) 作为 String::push_str() 的参数\n        self.a.push_str(n);\n    }\n}\nfn main() {\n    let mut s = \"hello\".to_string();\n    // 如果 去掉mut c的mut, 会提示, can't mutate immutable variable 'c'\n    let mut c = Cat { a: &mut s };\n    // 因为 Cat::mut_fn(&mut c)\n    c.mut_fn(\" world\");\n\n    let mut c = Cat { a: &mut s };\n    // 如果去掉&mut c的mut,则提示\n    // can't borrow `*d` as mutable\n    // mut_fn 是对 *d 的 可变借用 &(*d)\n    // 这和我们之前说的一致 reborrow\n    let d = &mut c;\n    // 如果不是用reborrow, 直接move 的形式 (可变借用本身是move,前面说过),\n    // 那么执行完后, d 失效了.. 除非你返回又接收.. ,不太好!\n    d.mut_fn(\"abc\");\n    // 还有比如这个, 你不用执行完后, d.a 失效了...\n    d.a.push_str(\"string\");\n}\n\n\n\n\n\n\nImportant\n\n\n\n\n看上面例子, 从功能上讲, 使用reborrow 更加方便, 我们传递一个可变借用给函数, 在这个函数空间内,是独立作用域,会创建一个临时的可变借用,函数执行完毕, 该临时可变借用就失效了. 外部一开始的可变借用可以继续使用. 这个应该是你开发人员希望的, 因为自己清楚使用可变借用传递给函数是做某种修改,后续可能还继续使用另外一个函数来修改",
    "crumbs": [
      "基础篇",
      "所有权与借用"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/unsafe.html",
    "href": "docs/programming/rust/basic/unsafe.html",
    "title": "rust unsafe",
    "section": "",
    "text": "为什么需要?\n\n\n\n\nRust 是一种系统编程语言, 强调内存安全、数据竞争自由和并发性. 尽管 Rust 提供了许多机制来保证内存安全, 但有时程序员需要执行一些操作,这些操作无法通过 Rust 的安全抽象来表示, 或者执行起来效率较低.\n在这种情况下, Rust 提供了 unsafe 块或 unsafe 函数\nunsafe 代码表明 可能有不安全的操作, 因为里面编写的代码 ,一些检查可能是不执行的, 需要程序员自己注意代码的编写, 写的没问题 ,那实际上就是安全的, 换句话说如果没写unsafe 编译器会报错, 是为了提醒你 这块代码 可能有不安全的操作, 需要你注意代码的编写\n根据上面的说法, 显然 unsafe代码块里的 代码 本来会做的检查还是会做",
    "crumbs": [
      "基础篇",
      "unsafe"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/unsafe.html#为什么需要以及它的作用",
    "href": "docs/programming/rust/basic/unsafe.html#为什么需要以及它的作用",
    "title": "rust unsafe",
    "section": "",
    "text": "为什么需要?\n\n\n\n\nRust 是一种系统编程语言, 强调内存安全、数据竞争自由和并发性. 尽管 Rust 提供了许多机制来保证内存安全, 但有时程序员需要执行一些操作,这些操作无法通过 Rust 的安全抽象来表示, 或者执行起来效率较低.\n在这种情况下, Rust 提供了 unsafe 块或 unsafe 函数\nunsafe 代码表明 可能有不安全的操作, 因为里面编写的代码 ,一些检查可能是不执行的, 需要程序员自己注意代码的编写, 写的没问题 ,那实际上就是安全的, 换句话说如果没写unsafe 编译器会报错, 是为了提醒你 这块代码 可能有不安全的操作, 需要你注意代码的编写\n根据上面的说法, 显然 unsafe代码块里的 代码 本来会做的检查还是会做",
    "crumbs": [
      "基础篇",
      "unsafe"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/unsafe.html#裸指针",
    "href": "docs/programming/rust/basic/unsafe.html#裸指针",
    "title": "rust unsafe",
    "section": "2 裸指针",
    "text": "2 裸指针\n\n\n直接访问和操作内存指向不合法内存,忽略借用检查Box的裸指针不自动清理\n\n\nfn main() {\n    struct Two {\n        first: i8,\n        second: i8,\n    }\n    let mut num = 777i32;\n    // 0000 0011  0000 1001\n    println!(\"num的二进制表示: {:b}\", num);\n    // 先将地址 &num 转换为 指针 *const i32 ,\n    // 然后将它转换为 *const i8, 表示现在是以一个字节的方式读取这块内存地址\n    let r1 = &num as *const i32 as *const i8;\n    // 步进1后的指针, 这里就表示该指针指向 r1 所在地址下一个字节的内存\n    // 这些操作无需 unsafe 包裹\n    let f = r1.wrapping_add(1);\n    // 转换为结构体的方式来读取这块内存\n    let r2 = &num as *const i32 as *const Two;\n    // 转换为以数组的方式来读写这块内存\n    let r3 = &mut num as *mut i32 as *mut [i8; 2];\n    // 在解引用操作的时候,才需要unsafe包裹\n    unsafe {\n        println!(\"num第一个字节==&gt; r1 : {}\", *r1); // 9\n        println!(\"num第二个字节==&gt; r1 : {}\", *f);  // 3\n        println!(\"num第一个字节==&gt; r2 : {:?}\", (*r2).first); // 9\n        println!(\"num第二个字节==&gt; r2 : {}\", (*r2).second);  // 3\n        println!(\"转换为数组 r3,num第一个字节:{}-num第二个字节:{}\", (*r3)[0], (*r3)[1]);\n        (*r3)[0] = 11; // 将第一个字节修改为11\n        println!(\"{num}\");\n    }\n\n}\n\n\nfn main() {\n    let b;\n    {\n        let a = \"hello\".to_string();\n        b = &a as *const String;\n    } // 编译器没有报错, 说明忽略了借用检查\n    let c = b.wrapping_add(1);\n    unsafe {\n        let d = b as *const [u64; 3];\n        println!(\"{}-0x{:x}-{}\", (*d)[0], (*d)[1], (*d)[2])\n    }\n    // 可以指向不合理的内存地址, 这里也说明了, 它不会像智能指针那样自动清理, 如果清理了, 那还得了\n    let address = 0x012345usize;\n    let r = address as *const i32;\n\n    // 空指针, 不指向任何有效的i32值\n    let p = std::ptr::null::&lt;i32&gt;();\n    println!(\"p 是否为空指针 {}\", p.is_null());\n}\n\n\nfn main() {\n    let f;\n    {\n        let b = Box::new(5);\n        println!(\"{:p}\", b); // 堆上的5的地址\n        println!(\"{:p}\", &b); // 栈上b变量的地址\n        // 将 b 转换为 *mut T 可变裸指针\n        // c 的类型是 这里是 *mut i32\n        // b 被move 掉了,但是这个c指向了 b指向的内存,且c没有这块内存的所有权\n        let c = Box::into_raw(b);\n        println!(\"{:p}\", c); // 堆上5的地址\n        unsafe {\n            println!(\"{}\", *c);\n            *c = 23;\n            f = &*c;\n            // Box::from_raw 重新获取所有权,这样离开作用域后, 回收了\n            // 取消注释后, *f 的值就不对了, 因为堆上的数据5被回收了\n            // let s = Box::from_raw(c);\n        }\n    }// 由于没有 变量对 堆上的数据5  拥有所有权, 所以没 回收\n    println!(\"f=={}\", *f);\n}\n\n\n\n\n需要 cargo add libc\n\nfn main() {\n    // 使用 libc 库中的 malloc 函数分配内存\n    let raw_ptr = unsafe { libc::malloc(std::mem::size_of::&lt;i32&gt;() as libc::size_t) as *mut i32 };\n    println!(\n        \"raw_ptr在栈上分配的地址: {:p}\\nraw_ptr申请的堆地址: {:p}\",\n        &raw_ptr,\n        unsafe { &*raw_ptr }\n    );\n    let b = Box::new(11);\n    println!(\"b指向的堆地址: {:p}\", b);\n    if raw_ptr.is_null() {\n        eprintln!(\"Memory allocation failed\");\n        return;\n    }\n\n    // 安全地使用裸指针\n    unsafe {\n        // 初始化内存\n        *raw_ptr = 42;\n\n        // 打印内存中的值\n        println!(\"Value at raw pointer: {}\", *raw_ptr);\n    }\n\n    // 注意：这里没有释放内存，这将导致内存泄漏\n    // 正确的做法应该是调用 libc::free 来释放内存\n    unsafe {\n        libc::free(raw_ptr as *mut libc::c_void);\n        println!(\"free 后 raw_ptr指向的值: {}\", *raw_ptr); // 0\n    }\n}",
    "crumbs": [
      "基础篇",
      "unsafe"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/unsafe.html#修改可变静态变量",
    "href": "docs/programming/rust/basic/unsafe.html#修改可变静态变量",
    "title": "rust unsafe",
    "section": "3 修改可变静态变量",
    "text": "3 修改可变静态变量\n\n\n可变的静态变量,修改需要unsafe\n\nstatic mut COUNTER: u32 = 0;\nfn add_to_count(inc: u32) {\n    unsafe {\n        COUNTER += inc;\n    }\n}\n\nfn main() {\n    add_to_count(3);\n\n    println!(\"COUNTER: {}\", unsafe { COUNTER });\n}",
    "crumbs": [
      "基础篇",
      "unsafe"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/unsafe.html#unsafe-fn",
    "href": "docs/programming/rust/basic/unsafe.html#unsafe-fn",
    "title": "rust unsafe",
    "section": "4 unsafe fn",
    "text": "4 unsafe fn\n\n\n\n\n\n\nTip\n\n\n\nunsafe函数或方法: 就是在定义前面加上unsafe关键字.\n\n\nunsafe fn dangerous() {}\nfn main() {\n    // 需要unsafe\n    unsafe {\n        dangerous();\n    }\n}\n\n\n\n调用内部实现有unsafe代码块的函数或方法,不需要unsafe包裹\n\nfn main() {\n    let mut v = vec![1, 2, 3, 4, 5, 6];\n\n    let r = &mut v[..];\n    // 切分成2个切片 [0,mid) [mid,len)\n    // split_at_mut 方法里面有 unsafe 代码块, 但是我们这里调用的时候 不需要unsafe\n    let (a, b) = r.split_at_mut(3);\n\n    assert_eq!(a, &mut [1, 2, 3]);\n    assert_eq!(b, &mut [4, 5, 6]);\n}\n\n\n\nsplit_at_mut源码\n\nuse std::slice;\n\nfn split_at_mut(values: &mut [i32], mid: usize) -&gt; (&mut [i32], &mut [i32]) {\n    let len = values.len();\n    let ptr = values.as_mut_ptr();\n\n    assert!(mid &lt;= len);\n\n    unsafe {\n        (\n            slice::from_raw_parts_mut(ptr, mid),\n            slice::from_raw_parts_mut(ptr.add(mid), len - mid),\n        )\n    }\n}\n\n\n\n\n直接使用std::slice库\n\nuse std::slice;\nfn main() {\n    let mut a = [1, 2, 3, 4, 5];\n    let b = &mut a;\n    let r = b as *mut i32; // a.as_mut_ptr()\n    let values: &[i32] = unsafe { slice::from_raw_parts_mut(r, 2) };\n    println!(\"{:?}\", values);\n}",
    "crumbs": [
      "基础篇",
      "unsafe"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/unsafe.html#unsafe-trait-unsafe-impl",
    "href": "docs/programming/rust/basic/unsafe.html#unsafe-trait-unsafe-impl",
    "title": "rust unsafe",
    "section": "5 unsafe trait, unsafe impl",
    "text": "5 unsafe trait, unsafe impl\nunsafe trait Foo {\n    // methods go here\n}\n\nunsafe impl Foo for i32 {\n    // method implementations go here\n}\n\nfn main() {}",
    "crumbs": [
      "基础篇",
      "unsafe"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/unsafe.html#extern-调用外部函数ffi",
    "href": "docs/programming/rust/basic/unsafe.html#extern-调用外部函数ffi",
    "title": "rust unsafe",
    "section": "6 extern 调用外部函数(FFI)",
    "text": "6 extern 调用外部函数(FFI)\n\n\n\n\n\n\nTip\n\n\n\n\nFFI: Foreign Function Interface 外部函数接口, 可以让一种编程语言定义函数,然后其他语言可以调用\n\n\n\n\n6.1 rust 调用C\nextern \"C\" {\n    // 我们想要调用的外部函数的名称和参数返回值定义\n    fn abs(input: i32) -&gt; i32;\n}\n\nfn main() {\n    unsafe {\n        println!(\"Absolute value of -3 according to C: {}\", abs(-3));\n    }\n}\n\n\n6.2 c语言调用rust\n\ncargo new ccc\ntree\n.\n├── Cargo.lock\n├── Cargo.toml\n├── main.c\n├── src\n│   └── lib.rs\n\nCargo.toml 添加src/lib.rsmain.c最后ubuntu下执行过程\n\n\n[package]\nname = \"ccc\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[dependencies]\n[lib]\ncrate-type = [\"cdylib\"]\n\n\n#[no_mangle]\npub extern \"C\" fn call_from_c() {\n    println!(\"Just called a Rust function from C!\");\n}\n\n\n#include &lt;stdio.h&gt;\n\n// 声明 Rust 函数\nextern int call_from_c();\n\nint main() {\n    call_from_c();\n    return 0;\n}\n\n\n# 编译rust lib, 会在 target/release目录下生成 libccc.so\n# 不同的操作系统 生成的不太一样.\ncargo build --release\n# 编译 main.c, -lccc 中的ccc 是rust lib package name\ngcc -o main main.c -L target/release -lccc -Wl,-rpath,target/release\n# 运行编译后的c程序\n./main\n\n\n\n\n\n\n\n\n\n\n#[no_mangle] 关于名称混淆(Name Mangling)\n\n\n\n\n名称混淆是编译器的一种行为,它会根据函数的参数类型、返回类型、函数名、命名空间等信息生成一个唯一的名称\n这个过程确保即使在同一个程序中存在多个同名但参数类型不同的函数时,编译后的二进制文件中也不会出现命名冲突\n#[no_mangle] 的作用\n\n当你使用 #[no_mangle] 属性时,Rust 编译器会保留函数的原始名称,而不是生成一个混淆后的名称\n当你需要从其他语言（如 C 或 C++）调用 Rust 函数时, 才可以通过这个函数名找到对应的函数\n所以你在rust中定义的rust函数必须全局唯一的函数名",
    "crumbs": [
      "基础篇",
      "unsafe"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/unsafe.html#禁用-unsafe",
    "href": "docs/programming/rust/basic/unsafe.html#禁用-unsafe",
    "title": "rust unsafe",
    "section": "7 禁用 unsafe",
    "text": "7 禁用 unsafe\n\n\n在文件顶部写上\n\n#![forbid(unsafe_code)]\nfn main() {\n    // 执行 程序, 会报错, 提示你不能用unsafe{}\n    unsafe{\n\n    }\n}",
    "crumbs": [
      "基础篇",
      "unsafe"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/unsafe.html#内置函数",
    "href": "docs/programming/rust/basic/unsafe.html#内置函数",
    "title": "rust unsafe",
    "section": "8 内置函数",
    "text": "8 内置函数",
    "crumbs": [
      "基础篇",
      "unsafe"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/generic.html",
    "href": "docs/programming/rust/basic/generic.html",
    "title": "rust 泛型",
    "section": "",
    "text": "fn largest_i32(list: &[i32]) -&gt; &i32 {\n    let mut largest = &list[0];\n\n    for item in list {\n        if item &gt; largest {\n            largest = item;\n        }\n    }\n\n    largest\n}\n\nfn largest_char(list: &[char]) -&gt; &char {\n    let mut largest = &list[0];\n\n    for item in list {\n        if item &gt; largest {\n            largest = item;\n        }\n    }\n\n    largest\n}\n\nfn main() {\n    let number_list = vec![34, 50, 25, 100, 65];\n\n    let result = largest_i32(&number_list);\n    println!(\"The largest number is {}\", result);\n\n    let char_list = vec!['y', 'm', 'a', 'q'];\n\n    let result = largest_char(&char_list);\n    println!(\"The largest char is {}\", result);\n}\n我们发现 同样的逻辑代码,我们写了2遍, 很麻烦,重复代码, 使用泛型来作为具体类型的抽象\n泛型是一种类型,在函数中使用它作为参数的类型,是需要申明的,首先肯定不会和参数的申明放在一块,所以rust在函数名和参数列表之间使用&lt;T&gt;,一般用T来作为泛型标识\n// T: std::cmp::PartialOrd\n// 这里的代码 运行会提示错误, 很显然 不是所有的类型都能做比较大小的操作的\n// 将T改成 T: std::cmp::PartialOrd 就ok了, 后面trait 里会说\nfn largest&lt;T&gt;(list: &[T]) -&gt; &T {\n    let mut largest = &list[0];\n\n    for item in list {\n        if item &gt; largest {\n            largest = item;\n        }\n    }\n\n    largest\n}\n\nfn main() {\n    let number_list = vec![34, 50, 25, 100, 65];\n\n    let result = largest(&number_list);\n    println!(\"The largest number is {}\", result);\n\n    let char_list = vec!['y', 'm', 'a', 'q'];\n\n    let result = largest(&char_list);\n    println!(\"The largest char is {}\", result);\n}",
    "crumbs": [
      "基础篇",
      "泛型"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/generic.html#在函数中使用",
    "href": "docs/programming/rust/basic/generic.html#在函数中使用",
    "title": "rust 泛型",
    "section": "",
    "text": "fn largest_i32(list: &[i32]) -&gt; &i32 {\n    let mut largest = &list[0];\n\n    for item in list {\n        if item &gt; largest {\n            largest = item;\n        }\n    }\n\n    largest\n}\n\nfn largest_char(list: &[char]) -&gt; &char {\n    let mut largest = &list[0];\n\n    for item in list {\n        if item &gt; largest {\n            largest = item;\n        }\n    }\n\n    largest\n}\n\nfn main() {\n    let number_list = vec![34, 50, 25, 100, 65];\n\n    let result = largest_i32(&number_list);\n    println!(\"The largest number is {}\", result);\n\n    let char_list = vec!['y', 'm', 'a', 'q'];\n\n    let result = largest_char(&char_list);\n    println!(\"The largest char is {}\", result);\n}\n我们发现 同样的逻辑代码,我们写了2遍, 很麻烦,重复代码, 使用泛型来作为具体类型的抽象\n泛型是一种类型,在函数中使用它作为参数的类型,是需要申明的,首先肯定不会和参数的申明放在一块,所以rust在函数名和参数列表之间使用&lt;T&gt;,一般用T来作为泛型标识\n// T: std::cmp::PartialOrd\n// 这里的代码 运行会提示错误, 很显然 不是所有的类型都能做比较大小的操作的\n// 将T改成 T: std::cmp::PartialOrd 就ok了, 后面trait 里会说\nfn largest&lt;T&gt;(list: &[T]) -&gt; &T {\n    let mut largest = &list[0];\n\n    for item in list {\n        if item &gt; largest {\n            largest = item;\n        }\n    }\n\n    largest\n}\n\nfn main() {\n    let number_list = vec![34, 50, 25, 100, 65];\n\n    let result = largest(&number_list);\n    println!(\"The largest number is {}\", result);\n\n    let char_list = vec!['y', 'm', 'a', 'q'];\n\n    let result = largest(&char_list);\n    println!(\"The largest char is {}\", result);\n}",
    "crumbs": [
      "基础篇",
      "泛型"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/generic.html#在结构体中使用",
    "href": "docs/programming/rust/basic/generic.html#在结构体中使用",
    "title": "rust 泛型",
    "section": "2 在结构体中使用",
    "text": "2 在结构体中使用\nstruct Point&lt;T&gt; {\n    x: T,\n    y: T,\n}\n\nfn main() {\n    let integer = Point { x: 5, y: 10 };\n    let float = Point { x: 1.0, y: 4.0 };\n}\n使用多个泛型\nstruct Point&lt;T, U&gt; {\n    x: T,\n    y: U,\n}\n\nfn main() {\n    let both_integer = Point { x: 5, y: 10 };\n    let both_float = Point { x: 1.0, y: 4.0 };\n    // 这样你随便写啥都行\n    let integer_and_float = Point { x: 5, y: 4.0 };\n}",
    "crumbs": [
      "基础篇",
      "泛型"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/generic.html#在枚举中使用",
    "href": "docs/programming/rust/basic/generic.html#在枚举中使用",
    "title": "rust 泛型",
    "section": "3 在枚举中使用",
    "text": "3 在枚举中使用\nenum Option&lt;T&gt; {\n    Some(T),\n    None,\n}\n\nenum Result&lt;T, E&gt; {\n    Ok(T),\n    Err(E),\n}\n\nfn main() {\n    let some_value = Option::Some(5);\n    let none_value = Option::None;\n\n    let integer_value = Result::Ok(5);\n    let error_value = Result::Err(5);\n}",
    "crumbs": [
      "基础篇",
      "泛型"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/generic.html#impl中使用",
    "href": "docs/programming/rust/basic/generic.html#impl中使用",
    "title": "rust 泛型",
    "section": "4 impl中使用",
    "text": "4 impl中使用\nstruct Point&lt;T&gt; {\n    x: T,\n    y: T,\n}\n// 在impl 后&lt;T&gt; 是申明泛型参数 T\n// 来表明是为  Point&lt;T&gt; 这个类型实现方法,这里的T就使用了前面申明的T\nimpl&lt;T&gt; Point&lt;T&gt; {\n    fn x(&self) -&gt; &T {\n        &self.x\n    }\n}\n// 可以为 某个具体的类型实现方法\n// 因为上面的泛型包含了这种情况, 所以同时存在会报错\n// impl Point&lt;i32&gt; {\n//     fn x(&self) -&gt; &i32 {\n//         &self.x\n//     }\n// }\nfn main() {\n    let p = Point { x: 5, y: 10 };\n\n    println!(\"p.x = {}\", p.x());\n}\n方法与结构体使用不同的泛型\nstruct Point&lt;X1, Y1&gt; {\n    x: X1,\n    y: Y1,\n}\n\nimpl&lt;X1, Y1&gt; Point&lt;X1, Y1&gt; {\n    // 这里mixup后申明的X2,Y2,表示 方法里使用了X2,Y2泛型,与Point&lt;X1, Y1&gt;中的X1,Y1不一样\n    fn mixup&lt;X2, Y2&gt;(self, other: Point&lt;X2, Y2&gt;) -&gt; Point&lt;X1, Y2&gt; {\n        Point {\n            x: self.x,\n            y: other.y,\n        }\n    }\n}\n\nfn main() {\n    let p1 = Point { x: 5, y: 10.4 };\n    let p2 = Point { x: \"Hello\", y: 'c' };\n\n    let p3 = p1.mixup(p2);\n\n    println!(\"p3.x = {}, p3.y = {}\", p3.x, p3.y);\n}",
    "crumbs": [
      "基础篇",
      "泛型"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/generic.html#t",
    "href": "docs/programming/rust/basic/generic.html#t",
    "title": "rust 泛型",
    "section": "5 ::<T>",
    "text": "5 ::&lt;T&gt;\nfn main() {\n    // 声明一个类型为 Vec&lt;i32&gt; 的变量，并初始化它\n    let numbers: Vec&lt;i32&gt; = Vec::new();\n\n    // 泛型函数\n    fn create_empty_vec&lt;T&gt;() -&gt; Vec&lt;T&gt; {\n        Vec::new()\n    }\n\n    let empty_int_vec = create_empty_vec::&lt;i32&gt;();\n    let empty_int_vec2: Vec&lt;i32&gt; = create_empty_vec();\n}\ntrait Hello {\n    fn world(&self);\n}\nimpl&lt;T&gt; Hello for Vec&lt;T&gt; {\n    fn world(&self) {\n        println!(\"hello\");\n    }\n}\nfn main() {\n    // 声明一个类型为 Vec&lt;i32&gt; 的变量，并初始化它\n    let numbers: Vec&lt;i32&gt; = Vec::new();\n    numbers.world();\n    // Vec::&lt;i32&gt; 表示元素是i32类型的 Vec\n    Vec::&lt;i32&gt;::world(&numbers);\n}",
    "crumbs": [
      "基础篇",
      "泛型"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/generic.html#性能问题",
    "href": "docs/programming/rust/basic/generic.html#性能问题",
    "title": "rust 泛型",
    "section": "6 性能问题",
    "text": "6 性能问题\n\n\n\n\n\n\nTip\n\n\n\n其实泛型相当于占位符,然后把你编写的代码理解成模板, 编译器编译的时候,会将这些占位符替换成具体的类型, 比如上面的例子, 编译器会根据你实际使用的情况,将T替换成具体的类型比如 i32,f64,会生成对应的代码, 这个叫单态化, 这样运行时不会有额外的开销\n\n\nimpl Point&lt;i32&gt; {\n    fn x(&self) -&gt; &i32 {\n        &self.x\n    }\n}\n\nimpl Point&lt;f64&gt; {\n    fn x(&self) -&gt; &f64 {\n        &self.x\n    }\n}",
    "crumbs": [
      "基础篇",
      "泛型"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/lifetime.html",
    "href": "docs/programming/rust/basic/lifetime.html",
    "title": "rust 生命周期",
    "section": "",
    "text": "fn main() {\n    let r;\n\n    {\n        let x = 5;\n        r = &x;\n    }    // x 离开作用域，其值被丢弃\n\n    println!(\"r: {}\", r);\n}\ncargo run \n --&gt; src/main.rs:6:13\n  |\n5 |         let x = 5;\n  |             - binding `x` declared here\n6 |         r = &x;\n  |             ^^ borrowed value does not live long enough\n7 |     }\n  |     - `x` dropped here while still borrowed\n8 |\n9 |     println!(\"r: {}\", r);\n  |                       - borrow later used here\nrust编译器 如何发现问题的呢?",
    "crumbs": [
      "基础篇",
      "生命周期"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/lifetime.html#先看个例子",
    "href": "docs/programming/rust/basic/lifetime.html#先看个例子",
    "title": "rust 生命周期",
    "section": "",
    "text": "fn main() {\n    let r;\n\n    {\n        let x = 5;\n        r = &x;\n    }    // x 离开作用域，其值被丢弃\n\n    println!(\"r: {}\", r);\n}\ncargo run \n --&gt; src/main.rs:6:13\n  |\n5 |         let x = 5;\n  |             - binding `x` declared here\n6 |         r = &x;\n  |             ^^ borrowed value does not live long enough\n7 |     }\n  |     - `x` dropped here while still borrowed\n8 |\n9 |     println!(\"r: {}\", r);\n  |                       - borrow later used here\nrust编译器 如何发现问题的呢?",
    "crumbs": [
      "基础篇",
      "生命周期"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/lifetime.html#借用检查器",
    "href": "docs/programming/rust/basic/lifetime.html#借用检查器",
    "title": "rust 生命周期",
    "section": "2 借用检查器",
    "text": "2 借用检查器\nThe Borrow Checker\n\n\n\n\n\n\nCaution\n\n\n\n借用的生命周期必须比 所有者的生命周期 短, 就是 所有者离开作用域前,你才可以使用它的借用\n\n\nrust编译器 有一个 borrow checker 它会比较作用域来判断所有借用是否合法\n标注上变量的生命周期,我们看看\nfn main() {\n    let r;                // ---------+-- 'a\n                          //          |\n    {                     //          |\n        let x = 5;        // -+-- 'b  |\n        r = &x;           //  |       |\n    }                     // -+       |\n                          //          |\n    println!(\"r: {}\", r); //          |\n}                         // ---------+\n这里用 ’a 表示 变量r 的生命周期, ’b 表示变量x 的生命周期 变量r (借用了x)的生命周期 ’a 比 所有者x 的生命周期 ’b 长 , 而这个时候x的生命周期 ’b 已经结束了,x不可用了\n将上面的代码修改成如下,就ok了\nfn main() {\n    let x = 5;            // ----------+-- 'b\n                          //           |\n    let r = &x;           // --+-- 'a  |\n                          //   |       |\n    println!(\"r: {}\", r); //   |       |\n                          // --+       |\n}                         // ----------+",
    "crumbs": [
      "基础篇",
      "生命周期"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/lifetime.html#生命周期的标注",
    "href": "docs/programming/rust/basic/lifetime.html#生命周期的标注",
    "title": "rust 生命周期",
    "section": "3 生命周期的标注",
    "text": "3 生命周期的标注\n\n3.1 为什么需要\n\nfn longest(x: &str, y: &str) -&gt; &str {\n    if x.len() &gt; y.len() {\n        x\n    } else {\n        y\n    }\n}\nfn main() {\n    let string1 = String::from(\"long string is long\");\n    let result;\n    {\n        let string2 = \"xyz\".to_string();\n        result = longest(string1.as_str(), string2.as_str());\n    }\n    println!(\"The longest string is {}\", result);\n}\n\n\n\n\n\n\n分析一下上面例子\n\n\n\n\nlongest返回一个借用, 那么我们必须知道, 这个返回值(调用方的接收者)借用的值的生命周期要比这个借用长,编译器需要能够检查是否达到这样的要求\n因为函数内的局部变量在函数执行完毕后, 都会失效的, 所以返回值是借用的情况下, 它肯定只能是来至于函数参数且该参数必定是引用类型 (这里 暂不考虑 &’static ),只要知道它来至于哪个, 就能确定接收者和谁的生命周期有关\n现在所有问题的关键在于编译器不知道longest函数返回值来至于哪个参数,而生命周期标注最终就是为了让编译器知道它返回的引用与谁有关,这样就知道最后需要和谁的生命周期比较, 这样就帮助了编译器进行静态分析,去防止悬垂指针和其他内存安全问题\n生命周期标注 只是描述多个借用之间的关系, 并不会改变他们的生命周期\n上面的例子中编译器不知道返回哪个, 意味着编译器需要将2种情况都考虑,使用情况最坏的哪个,就是生命周期最短的哪个, 因为你不可能让编译器强制认为返回其中一个,让编译通过吧? 例子中 最坏的情况是返回 string2的借用, 因为string2 生命周期很短,会导致result 悬垂引用\n\n\n\n\n\n\n3.2 标注的真实含义\n\n\n\n\n\n\nNote\n\n\n\n\n只有引用类型才需要标注\n这个就类似类型来约束你申请的内存, 生命周期标注是表示你的生命周期在哪个范围 , 可以理解为: 生命周期标注表示生命周期的类型\n\n\n\n\n\n3.3 函数\n\n\n\n\n\n\n前置知识: 什么是函数的签名(Function Signature)\n\n\n\n在编程中, 是指函数的定义中描述函数接口的部分. 它通常包括以下几个方面:\n\n函数名: 函数的名称,用于标识和调用函数\n参数列表: 函数接受的参数及其类型. 参数列表定义了函数可以接收的数据类型和数量\n返回类型: 函数返回值的类型.如果函数不返回值,通常会标记为 void（在 C/C++ 中）或省略返回类型(在 Rust 中为 ())\n生命周期(在 Rust 中): Rust 中的函数签名还包括生命周期注解,用于描述引用之间的生命周期关系\n\n\n\n使用 ’a ’b 这种 单个简单字母, 放在 &后面\n&i32        // 一个借用\n&'a i32     // 一个带有显式生命周期的借用\n&'a mut i32 //\n也可以先去看 covariant-协变, 早期还没看covariant相关教程,只是看完book那个教程, 浪费了很多思考, 教程分不同批次,对于我来说是恶心的.\n\n例子1例子2例子3例子4 ’b:’a例子5例子6例子7\n\n\n\n\n\n报错了\n\nfn longest(x: &str, y: &str) -&gt; &str {\n    x\n}\nfn main() {\n    let string1 = String::from(\"long string is long\");\n    let result;\n    let string2 = String::from(\"xyz\");\n    result = longest(string1.as_str(), string2.as_str());\n}\n\n\n\n\n\n\n\n分析\n\n\n\n\n上面这个例子, 你可能最开始有这样的疑惑,这不是很明显返回的是x吗,还需要标注生命周期吗?\n提示错误说函数签名没有标注生命周期\n高亮第8行处, 实际上编译器在编译到这里的时候,它是只能根据函数签名的信息来判断返回值来至于哪里,所以它不知道该函数返回值和谁有关了., 我们继续看例子2\n\n\n\n\n\n\n\n\n\n还是报错了\n\n// 生命周期标注表示返回值与y 有关, 表示 返回值的生命周期必须符合 `'a`这样长的范围,至少和y 一样长\nfn longest&lt;'a&gt;(x: &str, y: &'a str) -&gt; &'a str {\n    x\n}\nfn main(){}\n\n\n\n\n\n\n\n分析\n\n\n\n\n好了,这样我们标注了 返回值和y有关, 唉? 这是不是感觉就行了啊?\n报错了, 因为编译器编译longest函数, 它确实肯定是知道返回值是x的, 然而我们设置的返回值类型是 &'a str, x能否转换为这个类型?\n\n不行!, 因为x的标注是 'b (没写就是默认自己的生命周期,这里就用'b表示) 与'a 没有指明任何关系, &'b str 类型 不能转换为 &'a str\n\n把’a 生命周期标注作为类型的一部分\n\n\n\n\n\n\n// 从代码上看 y和返回值 没有任何关系, 那么我们不需要标注\n// 表示 返回值的生命周期必须符合 'a这样长的范围\n// 就这个例子而言, 编译器编译这个函数时是知道它返回 了 x\n// 而x 符合 返回类型 &'a str , 本身就是 'a 这样的长度\n// 'a 的长度或说范围 是实际调用该函数时传递的参数的生命周期, 实际调用处是string1 是main函数都有效的生命周期\n// 然后实际调用处接收者 result的生命周期 比如说是 'c , 将 'a 类型的 赋值给 'c 类型的 能否成功,  这里是可以的, 他们生命周期长度一样.\n// 赋值相当于类型转换, 'a 类型 转换为 'c 类型, 'a 如果是 'c 的子类 就可以了, 表示 'a的生命周期 &gt;= 'c\nfn longest&lt;'a&gt;(x: &'a str, y: &str) -&gt; &'a str {\n    x\n}\nfn main() {\n    let string1 = String::from(\"long string is long\");\n    let result;\n    {\n        let string2 = String::from(\"xyz\");\n        // 注意编译器编译到这里, 它是不关注函数体的, 它只会关注到函数的签名\n        // 如果函数签名没有生命周期标注,它根本不知道返回值和哪个参数有关.\n        // 现在发现有了生命周期标注, 表示返回值和string1有关系\n        // 那么 string2的死活与它无关了.\n        result = longest(string1.as_str(), string2.as_str());\n    } // 这个时候 string2 指向的 xyz (在堆上) 已经被free了\n      // 而编译器知道 longest 返回的是来至于第一个参数x: string1.as_str()\n      // 这个所谓的知道是通过 生命周期标注 知道的\n      // ok\n    println!(\"The longest string is {}\", result);\n}\n\n\n\n\n\n\n\n\nCaution\n\n\n\n例子2里我们说 ’b 因为没有指明 和’a的关系, 所以他们之间不能转换, 那么他们需要什么样的关系才能转换能?\n\n\n// 设置返回值生命周期 约束为 'a , 表示至少和y 一样长\n// 但是实际返回值是x, 它的生命周期 是 'b\n// 'b 能不能转为 'a  就是问题的关键了. 当'b 是 'a的子类就可以了,('b:'a) 表示'b 生命周期比 &gt;= 'a\n// 子类, 就是继承了父类 所有特征的类, 所以它可以转换为 父类, 这个好理解的(这里是子类生命周期比父类长)\nfn longest&lt;'a,'b:'a&gt;(x: &'b str, y: &'a str) -&gt; &'a str {\n    x\n}\nfn longest2&lt;'a, 'b&gt;(x: &'b str, y: &'a str) -&gt; &'a str\nwhere // 和泛型 使用方式类似, 可以这样写\n    'b: 'a,\n{\n    x\n}\nfn main(){\n    let string1 = String::from(\"long string is long\");\n    let result;\n    {\n        let string2 = String::from(\"xyz\");\n        // string1 的生命周期比 string2 长\n        // 为了符合 签名中 'b 要&gt;= 'a , 只能转换为 'b = string2的生命周期\n        // 这样 'b = 'a  符合 'b:'a\n        // 所以实际返回的x 它的生命周期变成了 string2 一样了,\n        // 当然根据签名我们直接知道与string2有关,\n        //      它的生命周期就是string2的生命周期,因为string2 能活多久,它就多久\n        // 编译直接报错,提示string2, borrowed value does not live long enough\n        // 从代码角度看, 返回的值的生命周期和 string2一样, 而result的生命周期 比这个长,\n        // 无法从一个 短的生命周期 赋值给一个长的生命周期, 可理解为父类无法转换为子类\n        result = longest(string1.as_str(), string2.as_str());\n    } // string2 释放\n    println!(\"The longest string is {}\", result);\n}\n\n\n\n\n报错了\n\n// 生命周期标注表示返回值与x,y有关, 表示 返回值的生命周期必须符合 'a这样长的范围\n// 返回值 x 符合 'a 类型的生命周期 编译通过\n// 传递来的时候, 确定出 'a =x的实参的生命周期 , 然后又确定出 'a=y的实参的生命周期\n// 最终是 'a = x和y 实参生命周期短的那个\nfn longest&lt;'a&gt;(x: &'a str, y: &'a str) -&gt; &'a str {\n    x\n}\nfn main(){\n    let string1 = String::from(\"long string is long\");\n    let result;\n    {\n        let string2 = String::from(\"xyz\");\n        // 注意编译器编译到这里, 它是不关心函数体的, 它只会关注到函数的签名\n        // 所以它根本不知道返回值和哪个参数有关.(虽然函数内部很明显返回了谁)\n        // 现在看了函数签名, 发现有了生命周期标注, 表示string1,string2有关系\n        // 从人的角度看, 可以理解为, 编译器在这种情形下会考虑最坏的情况,\n        // 所以这里认为返回值 返回生命周期短的那个, 就是string2,所以最终和string2有关\n        // 从代码角度看, 返回的值的生命周期是 string2, 而result的生命周期 比这个长,\n        // 无法从一个 短的生命周期 赋值给一个长的生命周期, 可理解为父类无法转换为子类.\n        result = longest(string1.as_str(), string2.as_str());\n    } // 这个时候 string2 指向的 xyz (在堆上) 已经被free了\n    // 报错了\n    println!(\"The longest string is {}\", result);\n}\n\n\n\nfn longest&lt;'a&gt;(x: &'a str, y: &'a str) -&gt; &'a str {\n    if x.len() &gt; y.len() {\n        x\n    } else {\n        y\n    }\n}\nfn main() {\n    let string1 = String::from(\"long string is long\");\n    let result;\n    {\n        let string2 = \"xyz\";\n        result = longest(string1.as_str(), string2);\n    } // string2 所借用的 xyz 这个数据实际是在 只读区中分配的,生命周期是到程序运行结束,所以到这里,没有被free掉\n      // println!(\"{}\", string2); 注意这个还是会报错的, 因为变量string2 离开作用域 已经不可用了\n      // OK\n    println!(\"The longest string is {}\", result);\n}\n\n\nfn longest&lt;'a&gt;(x: &'a str, y: &'a str) -&gt; &'a str {\n    if x.len() &gt; y.len() {\n        x\n    } else {\n        y\n    }\n}\nfn main() {\n    let string1 = String::from(\"long string is long\");\n    let result;\n    {\n        let string2 = String::from(\"xyz\");\n        result = longest(string1.as_str(), string2.as_str());\n    } \n    println!(\"The longest string is {}\", result);\n}\n\n\n\n\n\n\n\n\n\n生命周期的总结\n\n\n\n\n返回值的 ’a 标注 如果与多个函数参数有关, 那么选择 生命周期短的那个参数, 表示 返回值与 该参数有关, 最后借用检查就知道返回值的生命周期和谁做比较\n如果返回值 ’a 就和一个参数有关, 那么就和它有关\n\n\n\n// 不带参数的函数, 不过有一个生命周期参数 'a\n// 'a: 表示至少和函数的生命周期一样长 : &gt;=\nfn failed_borrow&lt;'a&gt;() {\n    let _x = 12;\n\n    // 报错：_x 的生命周期不够长\n    let y: &'a i32 = &_x;\n    // 在函数内部使用生命周期 'a 作为显式类型标注将导致失败\n    // 因为 &_x 的生命周期比 y 的短. 短生命周期不能强制转换成长生命周期.\n}\nfn main(){}\n\n\n3.4 结构体\n\n\n\n\n\n\nImportant\n\n\n\n\n生命周期标注 ’a 表明这两个字段的生命周期是相同的,并且它们至少活得和 Book 实例一样久\n如果没有生命周期标注,编译器就无法确定title 和 author 引用的数据是否会在 Book 实例化之前被释放\n生命周期标注提供了一种方式,让编译器能够检查引用是否在有效范围内,从而确保内存安全\n\n\n\nstruct Book&lt;'a&gt; {\n    title: &'a str,\n    author: &'a str,\n}\n\nfn main() {\n    let title = \"The Rust Programming Language\";\n    let author = \"Steve Klabnik and Carol Nichols\";\n    let book = Book { title, author };\n\n    println!(\"Book title: {}\", book.title);\n    println!(\"Book author: {}\", book.author);\n}\n\n\n3.5 约束\n\n\n\n\n\n\nImportant\n\n\n\n\nT: ’a\n\n在 T 中的 所有引用都必须至少和生命周期 ’a 活得一样长 (&gt;=’a)\n\nT: Trait + ’a\n\nT 类型必须实现 Trait trait, 并且在 T 中的所有引用都必须至少和 ’a 活得一样长\n\n&’a T\n\n’a 表示T 的生命周期至少和’a 一样长\n\n\n\n\nfn main() {\n    let s2 = \"hello\".to_string();\n    test2(&s2); // ok\n    test2(&&s2); // 报错了\n    test1(&s2) // 报错了 &'static T , T 需要满足'static\n}\nfn test1&lt;T&gt;(_arg: &'static T) {\n    println!(\"hello\");\n}\n// T: 'static 表示T中使用的引用 必须至少 比'static 一样长\n// test2(&s2); 调用的情况 这里T 是 String 类型, 不是引用类型,所以啥都行\nfn test2&lt;T: 'static&gt;(_arg: &T) {\n    println!(\"hello\");\n}\n\n\n3.6 &’static\n\n\n\n\n\n\nTip\n\n\n\n整个程序的持续时间就是静态生命周期\n\n\nlet s: &'static str = \"I have a static lifetime.\";\n\n\n3.7 泛型,trait\n\n\n\n\n\n\nImportant\n\n\n\nlifetimes are a type of generic,所以会将它和泛型T的申明放在一起\n\n\nuse std::fmt::Display;\n\nfn longest_with_an_announcement&lt;'a, T&gt;(\n    x: &'a str,\n    y: &'a str,\n    ann: T,\n) -&gt; &'a str\nwhere\n    T: Display,\n{\n    println!(\"Announcement! {}\", ann);\n    if x.len() &gt; y.len() {\n        x\n    } else {\n        y\n    }\n}\n\n\n3.8 标注省略三规则\n// 早期像这样的,都是需要 进行生命周期标注的\n// fn first_word(s: &str) -&gt; &str {\nfn first_word&lt;'a&gt;(s: &'a str) -&gt; &'a str {\n    let bytes = s.as_bytes();\n\n    for (i, &item) in bytes.iter().enumerate() {\n        if item == b' ' {\n            return &s[0..i];\n        }\n    }\n    &s[..]\n}\n\n\n\n\n\n\n三个规则\n\n\n\n\nrust的开发人员注意到, 每次都要写很多这种标注, 很麻烦, 于是总结了一些规则,让编译器自动处理\n概念说明\n\n生命周期在函数的参数时,被称为输入生命周期\n生命周期在函数的返回值时,被称为输出生命周期\n\n三个规则\n\n每个引用参数都有自己的生命周期参数\n如果只有一个输入生命周期参数，那么它被赋予所有输出生命周期参数\n如果有多个输入生命周期参数, 且其中一个是&self 或 &mut self(是方法), 则self的生命周期会被赋予所有的输出生命周期参数\n\n如果编译器应用完这3个规则,还有无法确定生命周期,那么就报错\n\n\n\n// 我们写的代码\nfn first_word(s: &str) -&gt; &str {}\n// 1. 编译器应用第一条规则后\nfn first_word&lt;'a&gt;(s: &'a str) -&gt; &str {}\n// 2. 编译器应用第二条规则后\nfn first_word&lt;'a&gt;(s: &'a str) -&gt; &'a str {}\n\n// 我们写的代码\nfn longest(x: &str, y: &str) -&gt; &str {}\n// 1. 编译器应用第一条规则后\nfn longest&lt;'a, 'b&gt;(x: &'a str, y: &'b str) -&gt; &str {\n// 2. 编译器应用第二条规则,发现有多个输入参数,pass\n// 3. 编译器应用第三条规则,发现是个函数,不是方法,pass\n//  结果, 返回值的生命周期 还是不确定, 所以报错了\n结构体方法生命周期\n// 需要在 impl后面申明,这个生命周期是结构体类型的一部分\nimpl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {\n    fn level(&self) -&gt; i32 {\n        3\n    }\n}\n// 1. 编译器应用第一条规则, &'a self, 所以我们不用标注了\n\n// 我们来看看方法中多个参数的情况,\nimpl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {\n    fn announce_and_return_part(&self, announcement: &str) -&gt; &str {\n        println!(\"Attention please: {}\", announcement);\n        self.part\n    }\n}\n// 1. 编译器应用第一条规则后,\n    fn announce_and_return_part(&'a self, announcement: &'a str) -&gt; &str {}\n// 2. 编译器应用第三条规则后,\n    fn announce_and_return_part&lt;'a&gt;(&'a self, announcement: &'a str) -&gt; &'a str {}",
    "crumbs": [
      "基础篇",
      "生命周期"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/lifetime.html#drop-check",
    "href": "docs/programming/rust/basic/lifetime.html#drop-check",
    "title": "rust 生命周期",
    "section": "4 drop check",
    "text": "4 drop check",
    "crumbs": [
      "基础篇",
      "生命周期"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/lifetime.html#subtyping1",
    "href": "docs/programming/rust/basic/lifetime.html#subtyping1",
    "title": "rust 生命周期",
    "section": "5 subtyping1",
    "text": "5 subtyping1\n\n\n\n\n\n\nImportant\n\n\n\n\n在前面章节中 我们看到下面这样的代码\n这里 其实明确表示 需要传递的参数的 生命周期是一样长的,然而在实际调用的时候, 传递的参数的生命周期不一样,为什么可以这样呢\n还有返回值的生命周期类型 和接收者的生命周期类型 也是不一样的, 为什么也可以成功赋值呢\n之前就说到子类可以转换为 父类,rust 提供这样的机制,可以让子类生命周期(长生命周期)降级转换为父类生命周期(短生命周期), 所以编译不会报错\n\n\n\n// x 生命周期长的情况, 就降级转换为 和 y一样的短的生命周期\nfn longest&lt;'a&gt;(x: &'a str, y: &'a str) -&gt; &'a str {\n    x\n}\nfn main() {\n    let string1 = String::from(\"long string is long\");\n    let result;\n    {\n        let string2 = String::from(\"xyz\");\n        result = longest(string1.as_str(), string2.as_str());\n    }\n    println!(\"The longest string is {}\", result);\n}",
    "crumbs": [
      "基础篇",
      "生命周期"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/lifetime.html#variance-型变2",
    "href": "docs/programming/rust/basic/lifetime.html#variance-型变2",
    "title": "rust 生命周期",
    "section": "6 Variance 型变2",
    "text": "6 Variance 型变2\n\n\n\nType\nVariance in ’a\nVariance in T\n\n\n\n\n&'a T\ncovariant\ncovariant\n\n\n&'a mut T\ncovariant\ninvariant\n\n\nBox&lt;T&gt;\n\ncovariant\n\n\nVec&lt;T&gt;\n\ncovariant\n\n\n*const T\n\ncovariant\n\n\n*mut T\n\ninvariant\n\n\n[T] and [T; n]\n\ncovariant\n\n\nfn() -&gt; T\n\ncovariant\n\n\nfn(T) -&gt; ()\n\ncontravariant\n\n\nstd::cell::UnsafeCell&lt;T&gt;\n\ninvariant\n\n\nstd::cell::Cell&lt;T&gt;\n\ninvariant\n\n\ndyn Trait&lt;T&gt; + 'a\ncovariant\ninvariant\n\n\n\n\n6.1 covariant 协变\n\n\n\n\n\n\nTip\n\n\n\n\n协变指的是在类型层次中, 子类型可以替代父类型\n当T:U(T是U的子类) 时, F&lt;T&gt; 如果也是 F&lt;U&gt;的子类,那么就称为 F&lt;T&gt; 对于参数T 是协变关系\n在rust中, 生命周期有这类机制\n\n\n\n\n&’a T有趣的例子(重要)&’a mut TBox&lt;T&gt;fn() -&gt; T\n\n\n\n\n\n\n\n\n\n协变规则\n\n\n\n\n&'a T 对于 'a 是协变的, 当 'a:'b ,那么 &'a T 也是 &'b T 的子类\n\n\n\n\n\n例子说明\n\n// 要求 2个借用变量的生命周期一样长, 而实际上传递的参数的生命周期不一样\n// rust 会通过将长的生命周期的参数 降级为 短生命周期参数一样长的 生命周期\nfn debug&lt;'a&gt;(a: &'a str, b: &'a str) {\n    println!(\"a = {a:?} b = {b:?}\");\n}\n\nfn main() {\n    let hello: &'static str = \"hello\";\n    {\n        let world = String::from(\"world\");\n        // 'world 生命周期短于 'static\n        let world = &world;\n        // hello 隐式的从 &'static str 降级 或者说转换为 &'world str\n        // &'static str是  &'world str 的子类, 所以可以执行成功\n        debug(hello, world);\n    }\n}\n\n\n\n\n\n\n\n\n\n协变规则\n\n\n\n\n&'a T 对于 T 是协变的, 当 T:U ,那么 &'a T 也是 &'a U 的子类\n\n\n\n\n\n例子说明\n\n// 这里T 是 &'b str ,U 是 &'a str, 根据前面的因为'b:'a 则 &'b str 是&'a str 的子类\n// 现在程序OK, 就说明了, &'a &'b str 是 &'a &'a str 的子类了\nfn covariant_ref&lt;'a, 'b: 'a&gt;(x: &'a &'b str) -&gt; &'a &'a str {\n    x\n}\n\nfn main() {\n    let x: &'static str = \"hello\";\n    let y: &&str = covariant_ref(&x);\n    println!(\"{}\", y);\n}\n\n\n\n\n\n\n\n\n\n\nImportant\n\n\n\n\n下面例子中的test1, 我不知道网上是否有人也这样测过, 一开始根据参数的推理,我是很快就想到的,不过返回值的推理没有马上注意到,可以看看下面的注释.\n\n\n\n// 根据前面结构体章节, 我们知道 该结构体对于T 和 'a 都是协变的\nstruct MyStruct&lt;'a, T: 'a&gt; {\n    ptr: &'a T,\n}\n// 编译通过, 可能没想到 这个竟然能通过\n// 看参数 我们知道T:'a 表示T 中引用必须至少和'a 一样长,\n// 传递的T = &'b str, 这个时候T的生命周期是'b,\n// 它必须活着至少&gt;= 'a ,则MyStruct&lt;'a, &'b str&gt; 推断出  'b:'a\n// 看返回值 MyStruct&lt;'b, &'a str&gt;,T的生命周期是'a, 它至少和'b 一样长, 即推断出: 'a:'b\n// 现在'a:'b  'b:'a  , 其实 'a='b\nfn test1&lt;'a, 'b&gt;(v: MyStruct&lt;'a, &'b str&gt;) -&gt; MyStruct&lt;'b, &'a str&gt; {\n    v\n}\n// 看看下面4个测试 来间接说明我们test1 的判断\n// 这个符合我们的判断对于 参数'a 和T 都是协变的, 很容易理解的版本\nfn test2&lt;'a: 'c, 'b: 'd, 'c, 'd&gt;(v: MyStruct&lt;'a, &'b str&gt;) -&gt; MyStruct&lt;'c, &'d str&gt; {\n    v\n}\n\n// 很容易得出 我们需要 'b:'c 才能通过编译\nfn test3&lt;'a, 'b: 'c, 'c&gt;(v: MyStruct&lt;'a, &'b str&gt;) -&gt; MyStruct&lt;'a, &'c str&gt; {\n    v\n}\n// 现在我们看看这个,'b:'c 才能通过编译, 而这里我们用 'a:'c 也能通过, 间接说明 'b:'a\nfn test4&lt;'a: 'c, 'b, 'c&gt;(v: MyStruct&lt;'a, &'b str&gt;) -&gt; MyStruct&lt;'a, &'c str&gt; {\n    v\n}\n// 通过编译的.\n// 参数推断出 'a:'b  , 返回值推断出 'b:'c\n// 刚好符合 我们的要求, 直接不用设置了\nfn test5&lt;'a, 'b, 'c&gt;(v: MyStruct&lt;'b, &'a str&gt;) -&gt; MyStruct&lt;'c, &'b str&gt; {\n    v\n}\nfn main(){}\n\n\n\n\n\n\n\n\n\n协变规则\n\n\n\n\n&'a mut T 对于 'a 是协变的\n\n\n\n\n\n例子说明\n\n// 'b: 'a  ,这里没有报错, 则表示 &'b mut T 也是  &'a mut T 的子类\nfn invariant_mut&lt;'a, 'b: 'a, T&gt;(x: &'b mut T) -&gt; &'a mut T {\n    x\n}\n\nfn main() {\n    let mut x = 5;\n    let y = invariant_mut(&mut x);\n    *y += 1;\n    println!(\"{}\", x);\n}\n\n\n\n\n\n\n\n\n\n\n\n协变规则\n\n\n\n\nBox&lt;T&gt; 对于 T 是协变的\n\n\n\n\n\n例子说明\n\nfn set_box_ref&lt;'a&gt;(x: Box&lt;&'static str&gt;) {\n    let s: Box&lt;&'a str&gt; = x;\n    println!(\"{s}\");\n}\n\nfn main() {\n    let hello: Box&lt;&'static str&gt; = Box::new(\"hello\");\n    set_box_ref(hello);\n}\n\n\n\n\n\n\n\n\n\n\n\n协变规则\n\n\n\n\nfn() -&gt; T 对于 T 是协变的\n\n\n\n\n\n例子说明\n\nfn set_fn_ret&lt;'a&gt;(f: fn() -&gt; &'static str) {\n    let _: fn() -&gt; &'a str = f;\n}\n// 直接报错的, 说明不是逆变的\n// fn set_fn_ret2&lt;'a&gt;(f: fn() -&gt; &'a str) {\n//     let _: fn() -&gt; &'static str = f;\n// }\nfn main() {\n    fn test() -&gt; &'static str {\n        \"hello\"\n    }\n    set_fn_ret(test);\n}\n\n\n\n\n\n\n\n6.2 Contravariance 逆变\n\n\n\n\n\n\nTip\n\n\n\n逆变指的是在类型层次中, 父类型可以替代子类型\n\n\n\nfn(T) -&gt; ()\n\n\n\n\n\n\n\n\n\n逆变规则\n\n\n\n\nfn(T) -&gt; () 对于 T 是逆变的\n\n\n\n// OK , 说明是逆变的\nfn set_fn_arg&lt;'a&gt;(f: fn(&'a str)) {\n    let _: fn(&'static str) = f;\n}\n// 报错了, 不是协变\nfn set_fn_arg2&lt;'a&gt;(f: fn(&'static str)) {\n    let _: fn(&'a str) = f;\n}\nfn main() {}\n\n\n\n\n\n\n6.3 invariant 不变\n\n\n\n\n\n\nImportant\n\n\n\n不是协变也不是逆变的情况, 就是不变\n\n\n\n&’a mut T\n\n\n\n\n\n\n\n\n\n不变规则\n\n\n\n\n&'a mut T 对于 T 是不变的, 这意味着你不能将 &'a mut T 隐式地转换成 &'a mut U 即使 T 是 U 的子类型或者父类型\n和 协变规则2 比较一下\n\n\n\n\n\n例子说明\n\n// 前面已经验证 &'b str 是&'a str 的子类\n// T 就是 &'b str ,U 是 &'a str\n// 然而编译报错, 说明了&'a mut &'b str 不是 &'a mut &'a str 的子类\n// vscode 提示的错误 ,可以了解到 &'a mut T 对于T 是不变的\nfn covariant_ref&lt;'a, 'b: 'a&gt;(x: &'a mut &'b str) -&gt; &'a mut &'a str {\n    x\n}\n\nfn main() {\n    let mut x: &str = \"hello\";\n    let y: &&str = covariant_ref(&mut x);\n    println!(\"{}\", y);\n}\n\n\n\n\n\n\n\n6.4 自定义类型的情况\n\n\n\n\n\n\n\n看下面代码\n\n\n\n\n如果所有使用泛型A 的成员 对A 都是 协变的, 那么 MyType 对于A 就是 协变的\n如果所有使用泛型A 的成员 对A 都是 逆变的, 那么 MyType 对于A 就是 逆变的\n否则就是不变的\n\n\n\nuse std::cell::Cell;\nstruct MyType&lt;'a, 'b, A: 'a, B: 'b, C, D, E, F, G, H, In, Out, Mixed&gt; {\n    a: &'a A,     // covariant over 'a and A\n    b: &'b mut B, // covariant over 'b and invariant over B\n\n    c: *const C,  // covariant over C\n    d: *mut D,    // invariant over D\n\n    e: E,         // covariant over E\n    f: Vec&lt;F&gt;,    // covariant over F\n    g: Cell&lt;G&gt;,   // invariant over G\n\n    h1: H,        // would also be covariant over H except...\n    h2: Cell&lt;H&gt;,  // invariant over H, because invariance wins all conflicts\n\n    i: fn(In) -&gt; Out,       // contravariant over In, covariant over Out\n\n    k1: fn(Mixed) -&gt; usize, // would be contravariant over Mixed except..\n    k2: Mixed,              // invariant over Mixed, because invariance wins all conflicts\n}\n\n\n\n\n\n\n\n\n举例 a: &’a A\n\n\n\n\n注意 &'b Cat&lt;'c, T&gt; 对于 'b 是协变的(将 Cat&lt;'c, T&gt; 看成一个整体 就是前面说过的 &'a T 对于 'a 是协变的 )\nCat&lt;'c, T&gt; 因为成员对于 'c 是协变的, 所以 Cat&lt;'c, T&gt; 对于 'c 也是协变的\n\n\n\n\n\n运行OK\n\nfn covariant_mut&lt;'a, 'b: 'a, 'c: 'd, 'd, T&gt;(x: &'b Cat&lt;'c, T&gt;) -&gt; &'a Cat&lt;'d, T&gt; {\n    x\n}\n\nstruct Cat&lt;'a, T&gt; {\n    name: &'a T,\n}\nfn main() {}",
    "crumbs": [
      "基础篇",
      "生命周期"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/lifetime.html#phantomdata-类型3",
    "href": "docs/programming/rust/basic/lifetime.html#phantomdata-类型3",
    "title": "rust 生命周期",
    "section": "7 PhantomData 类型3",
    "text": "7 PhantomData 类型3\n\nphantom: 幽灵, 无形的东西, 假象,虚构的事物 PhantomData 翻译为 幽灵数据 好了…\n\n\n7.1 为什么需要4\n\nstruct Iter&lt;'a, T: 'a&gt; {// 没有使用到生命周期参数 'a\n    ptr: *const T,\n    end: *const T,\n}\nstruct Dog&lt;T&gt; { // 没有使用到类型参数 T\n    data: i32\n}\n\n\n\n\n\n\n分析\n\n\n\n\n在自定义类型的情况中,我们提到自定义类型对泛型参数A(生命周期也是一种泛型参数)的型变关系需要通过成员对A的型变关系来推断, 但是上面代码struct Iter&lt;'a,T:'a&gt;申明了生命周期参数, 但是实际光有申明又没法使用它(裸指针本身不带生命周期参数), 这样导致无法知道该类型的型变关系, 因此编译器会报错\nstruct Dog&lt;T&gt; 申明了泛型T 但是实际里面没有使用它, Dog&lt;i32&gt;和Dog&lt;i64&gt;就没有什么区别, 那么编译器会推断他们是可以互换的,这就很不合理\nPhantomData 类型可以解决这些问题,std::marker::PhantomData是一个特殊的标记类型, 不占用任何内存空间 ZST\n作用\n\n向编译器提供对静态分析有用的信息, 比如正确处理 泛型参数(T和生命周期)的 型变\n它用于在类型系统中表示和某类型有关, 但实际上并不存储该类型的值, 可以消除未使用类型参数的警告\n控制 Variance (协变,逆变还是不变)\n\n\n\n\n\n\n\n7.2 消除未使用类型参数的错误\nuse std::marker::PhantomData;\nstruct Dog&lt;T&gt; {\n    data: i32,\n    // 这个字段不会增加结构体的内存占用\n    // 表示尽管结构体没有使用泛型T, 但是这里就认为它使用了T\n    // 像一个幽灵一样, 我们假装有这个一个字段 使用了 T , 就好比一个字段名 _marker:T 这样\n    // 只是表明该结构体 和 T 有关\n    _marker: PhantomData&lt;T&gt;,\n}\n\n\n7.3 控制Variance\n\n7.3.1 控制 T\n\n\n\nType\nVariance in T\n\n\n\n\nPhantomData&lt;T&gt;\ncovariant\n\n\nPhantomData&lt;fn(T)&gt;\ncontravariant\n\n\nPhantomData&lt;Cell&lt;T&gt;&gt;\ninvariant\n\n\n\n\nPhantomData&lt;T&gt;PhantomData&lt;fn(T)&gt;PhantomData&lt;Cell&lt;T&gt;&gt;\n\n\n\n\n\n\n\n\nImportant\n\n\n\n\n使整个结构体对于 T 是协变的\n\n\n\nstruct Dog&lt;T&gt; {\n    data: i32,\n    _marker: PhantomData&lt;T&gt;,\n}\n\nfn test1&lt;'a: 'b, 'b&gt;(v: Dog&lt;&'a str&gt;) -&gt; Dog&lt;&'b str&gt; {\n    v\n}\nfn main(){}\n\n\n\n\n\n\n\n\nImportant\n\n\n\n\n使整个结构体对于 T 是逆变的\n\n\n\nstruct MyStruct&lt;T&gt; {\n    data: i32,\n    _marker: PhantomData&lt;fn(T)&gt;,\n}\n\nfn test1&lt;'a, 'b: 'a&gt;(v: MyStruct&lt;&'a str&gt;) -&gt; MyStruct&lt;&'b str&gt; {\n    v\n}\n\n\n\n\n\n\n\n\nImportant\n\n\n\n\n使整个结构体对于 T 是不变的\n根据前面型变表格, 你可以使用其他比如PhantomData&lt;*mut T&gt;\n\n\n\nstruct MyStruct&lt;T&gt; {\n    data: i32,\n    _marker: PhantomData&lt;std::cell::Cell&lt;T&gt;&gt;,\n}\n\nfn test1&lt;'a: 'b, 'b: 'a&gt;(v: MyStruct&lt;&'a str&gt;) -&gt; MyStruct&lt;&'b str&gt; {\n    v\n}\n\n\n\n\n\n7.3.2 控制 ’a\n\n\n\nType\nVariance in ’a\n\n\n\n\nPhantomData&lt;&'a ()&gt;\ncovariant\n\n\nPhantomData&lt;fn(&'a ())&gt;\ncontravariant\n\n\nPhantomData&lt;Cell&lt;&'a ()&gt;&gt;\ninvariant\n\n\n\n\nPhantomData&lt;&’a ()&gt;PhantomData&lt;fn(&’a ())&gt;PhantomData&lt;Cell&lt;&’a ()&gt;&gt;\n\n\n\n\n\n\n\n\nImportant\n\n\n\n\n使整个结构体对于 ’a 是协变的\n\n\n\n\n\nPhantomData&lt;&'a ()&gt;\n\nuse std::marker::PhantomData;\n\nstruct MyIter&lt;'a, T: 'a&gt; {\n    ptr: *const T,\n    end: *const T,\n    // 我们知道结构体对于'a 的型变关系 取决于 里面的成员对于'a 的型变关系\n    // 本来结构体没有使用'a , 现在我们假装有一个成员 是 &'a (), 比如假装一个成员是 name: &'a ()\n    // &'a () 对'a 是协变的, 只要该成员使用了'a ,那么整个结构体对于'a 就是协变的了 (因为只有这个成员使用了'a)\n    // 而对于T 来说, 看ptr 和end 成员就知道了, 他们对T 是协变的, 所以结构体对于T 也是协变的了\n    // 可能有人会说 为什么不用 PhantomData&lt;&'a T&gt; , 因为结构体对于T 的型变规则已经决定了, 由成员ptr 和end 确定\n    // 所以你没有这个意图去写成 () , 等下后面的例子我们 改成 mut T 就能更理解了.\n    _marker: PhantomData&lt;&'a ()&gt;,\n}\n// 编译ok\nfn test1&lt;'a: 'b, 'b, T: 'a&gt;(v: MyIter&lt;'a, T&gt;) -&gt; MyIter&lt;'b, T&gt; {\n    v\n}\n// 编译ok了,  T这个时候=&'a str  返回值的T 是&'c str\n//  说明了  MyIter 对于T 是协变\nfn test2&lt;'a: 'c, 'b, 'c&gt;(v: MyIter&lt;'b, &'a str&gt;) -&gt; MyIter&lt;'b, &'c str&gt; {\n    v\n}\n\nfn main() {}\n\n\n\nPhantomData&lt;&'a mut T&gt;\n\nuse std::marker::PhantomData;\nstruct MyIter&lt;'a, T: 'a&gt; {\n    ptr: *const T,\n    end: *const T,\n    // 注意这里 T 实际是不可能这样写的, 因为关于结构体对T的协变规则编译器已经能得出了, 你是没有意图去这样做的\n    // 相当于假装这里有个成员 , 它的类型是 &'a mut T\n    // &mut T对T 是不可变的, 那么现在整个结构体对于T 从原来的协变 变成 不变了.\n    // 这改变了 原本对T 的型变情况(*const T 对T 是协变的), 是完全没有必要的, 没有这个意图的.\n    // 所以我们对这种情况使用 PhantomData&lt;&'a ()&gt; 就可以了.\n    _marker: PhantomData&lt;&'a mut T&gt;,\n}\n// 编译ok ,'a 是协变的\nfn test1&lt;'a: 'b, 'b, T: 'a&gt;(v: MyIter&lt;'a, T&gt;) -&gt; MyIter&lt;'b, T&gt; {\n    v\n}\n// 'a:'c , 'c:'a 说明需要'a='c, T 是不变的\nfn test2&lt;'a: 'c, 'b, 'c: 'a&gt;(v: MyIter&lt;'b, &'a str&gt;) -&gt; MyIter&lt;'b, &'c str&gt; {\n    v\n}\n// 编译ok\n// 参数推断出'a:'b , 返回值推断出'b:'c\n// 因为我们需要  'a='b , 设置 'b:'a 就能编译通过.\n// 这里我们设置 'c:'a  能得出 'a='b='c了, 也是ok的\n// 对于T 是不变的\nfn test3&lt;'a, 'b, 'c: 'a&gt;(v: MyIter&lt;'b, &'a str&gt;) -&gt; MyIter&lt;'c, &'b str&gt; {\n    v\n}\n\nfn main(){}\n\n\n\nPhantomData&lt;&'a T&gt;\n\nuse std::marker::PhantomData;\n\nstruct MyIter&lt;'a, T: 'a&gt; {\n    ptr: *mut T,\n    end: *mut T,\n    // 因为自定义类型 对T 的型变要看成员对T的型变\n    // 所以这里 PhantomData&lt;&'a T&gt;,设置上对T 是协变的\n    // 但是实际上 是 不变的, 因为 成员类型*mut T对T 是不变的\n    _marker: PhantomData&lt;&'a T&gt;,\n}\n// 编译ok\nfn test&lt;'a: 'b, 'b, T: 'a&gt;(v: MyIter&lt;'a, T&gt;) -&gt; MyIter&lt;'b, T&gt; {\n    v\n}\n// 编译错误, 因为MyIter 对于T 是不变的\nfn test2&lt;'a: 'b, 'b&gt;(v: MyIter&lt;'b, &'a str&gt;) -&gt; MyIter&lt;'b, &'b str&gt; {\n    v\n}\nfn main(){}\n\n\n\n\n\n\n\n\n\nImportant\n\n\n\n\n使整个结构体对于 ’a 是逆变的\n\n\n\nuse std::marker::PhantomData;\nstruct MyStruct&lt;'a&gt; {\n    data: i32,\n    _marker: PhantomData&lt;fn(&'a ())&gt;,\n}\n\nfn test1&lt;'a, 'b: 'a&gt;(v: MyStruct&lt;'a&gt;) -&gt; MyStruct&lt;'b&gt; {\n    v\n}\nfn main() {}\n\n\n\n\n\n\n\n\nImportant\n\n\n\n\n使整个结构体对于 ’a 是不变的\n\n\n\nuse std::marker::PhantomData;\nstruct MyStruct&lt;'a&gt; {\n    data: i32,\n    _marker: PhantomData&lt;std::cell::Cell&lt;&'a ()&gt;&gt;,\n}\n\nfn test1&lt;'a: 'b, 'b: 'a&gt;(v: MyStruct&lt;'a&gt;) -&gt; MyStruct&lt;'b&gt; {\n    v\n}\nfn main() {}",
    "crumbs": [
      "基础篇",
      "生命周期"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/lifetime.html#footnotes",
    "href": "docs/programming/rust/basic/lifetime.html#footnotes",
    "title": "rust 生命周期",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nsubtyping↩︎\nvariance↩︎\nphantom-data↩︎\nrust rfcs#0738↩︎",
    "crumbs": [
      "基础篇",
      "生命周期"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/trait.html",
    "href": "docs/programming/rust/basic/trait.html",
    "title": "rust trait",
    "section": "",
    "text": "Tip\n\n\n\n\ntrait在其他语言里,类似接口interface\ntrait里定义若干行为或者说功能(在代码中体现为方法)\n\n是一种约束\n\n类型是对变量申请的内存空间的一种约束\n泛型可以说就是因为类型约束的过于严格而产生的\n然后泛型又过于宽泛了,啥都行,我就想要符合某种特征(具有某些行为)的类型,这样就产生了trait用来约束泛型\n\n只要实现某个trait\n\n就具备了某种能力或功能\n共享了一些能力: trait 定义里有默认实现的方法,所有实现该trait的类型都可以直接用",
    "crumbs": [
      "基础篇",
      "trait"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/trait.html#定义",
    "href": "docs/programming/rust/basic/trait.html#定义",
    "title": "rust trait",
    "section": "",
    "text": "Tip\n\n\n\n\ntrait在其他语言里,类似接口interface\ntrait里定义若干行为或者说功能(在代码中体现为方法)\n\n是一种约束\n\n类型是对变量申请的内存空间的一种约束\n泛型可以说就是因为类型约束的过于严格而产生的\n然后泛型又过于宽泛了,啥都行,我就想要符合某种特征(具有某些行为)的类型,这样就产生了trait用来约束泛型\n\n只要实现某个trait\n\n就具备了某种能力或功能\n共享了一些能力: trait 定义里有默认实现的方法,所有实现该trait的类型都可以直接用",
    "crumbs": [
      "基础篇",
      "trait"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/trait.html#入门例子",
    "href": "docs/programming/rust/basic/trait.html#入门例子",
    "title": "rust trait",
    "section": "2 入门例子",
    "text": "2 入门例子\n\n\n\n\n\n\nImportant\n\n\n\n\n我们在结构体章节中已经提到, self 相当于 self: Self, Self是一种类型,表示结构体本身\ntrait中定义的方法里也是一样的省略写法\n\nSelf 表示实现了该trait的具体类型\nself = self: Self\n&self = self: &Self\n&mut self = self: &mut Self\n如果trait中定义的方法的第一个参数是以上三种(还有类似这种参数设置 self: Box&lt;Self&gt;), 那么表示这是一个实例方法, 其他情况则称为关联方法(或者称:静态方法)\n\n\n\n\ntrait ExampleTrait {\n    // 没有方法体的方法, 实现该trait的类型 必须实现该方法\n    // 使用 &self 参数的方法，不修改数据\n    fn inspect(&self) -&gt; &str;\n\n    // 使用 &mut self 参数的方法，可以修改数据\n    fn modify(&mut self, tmp: &str);\n\n    // 使用 self 参数的方法，通常用于消费 trait 对象本身\n    fn consume(self);\n    // 有默认实现的方法, 实现该trait的类型可以不用写\n    // 当然也可以重新写来覆盖这个方法的具体实现\n    // 可以说是一种代码共享了, 因为可以直接用了\n    fn say(&self) {\n        println!(\"hello rust\");\n    }\n    // 无接收者的静态方法\n    fn hello();\n    // 不是self:&Self, 用其他的名字看看\n    // 有默认实现\n    fn world(this: &Self) {\n        println!(\"use this\");\n    }\n}\n\nstruct ExampleStruct {\n    value: String,\n}\n\n// 为ExampleStruct实现 ExampleTrait\nimpl ExampleTrait for ExampleStruct {\n    fn inspect(&self) -&gt; &str {\n        &self.value\n    }\n    fn modify(&mut self, tmp: &str) {\n        self.value.push_str(tmp);\n    }\n    fn consume(self) {\n        println!(\"Consumed value: {}\", self.value);\n        // `self` 被消费，之后无法使用\n    }\n    // 必须实现这个\n    fn hello(){\n        println!(\"hello example\");\n    }\n}\n\nfn main() {\n    let mut example = ExampleStruct {\n        value: \"Hello\".to_string(),\n    };\n    // 直接调用trait里的已经实现了的方法\n    example.say();\n\n    ExampleStruct::hello(); // 调用静态函数\n    // 第一个参数名不是 self, 用其他, 只能用这种方式, 不能用 实例.方法()\n    ExampleTrait::world(&example); // 调用trait 有默认实现的静态方法\n\n    // 调用 inspect 方法, 相当于 ExampleTrait::inspect(&example)\n    println!(\"Before modification: {}\", example.inspect());\n    println!(\"Before modification: {}\", ExampleTrait::inspect(&example));\n\n    // 调用 modify 方法\n    example.modify(\" world\");\n\n    // 调用 inspect 方法，查看修改结果\n    println!(\"After modification: {}\", example.inspect());\n    // 相当于\n    ExampleTrait::modify(&mut example, \" rust\");\n    println!(\"After modification: {}\", example.inspect());\n\n    // 调用 consume 方法，这会消费 example，之后不能再使用 example\n    example.consume();\n    // 下面这行代码如果取消注释会导致编译错误，因为 example 已经被消费了\n    // println!(\"Cannot use example after consume: {}\", example.inspect());\n}\ntrait方法第一个参数的变量名是self, 但是类型是这种Box&lt;Self&gt; 的情况\ntrait ExampleTrait {\n    fn consume(self: Box&lt;Self&gt;);\n}\n\nstruct ExampleStruct {\n    value: String,\n}\n\nimpl ExampleTrait for ExampleStruct {\n    fn consume(self: Box&lt;Self&gt;) {\n        println!(\"Consumed value: {}\", (*self).value);\n        println!(\"Consumed value: {}\", self.value);\n    }\n}\nfn main() {\n    let example = Box::new(ExampleStruct {\n        value: \"Hello\".to_string(),\n    });\n\n    example.consume();\n}",
    "crumbs": [
      "基础篇",
      "trait"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/trait.html#给内置或外部类型实现trait",
    "href": "docs/programming/rust/basic/trait.html#给内置或外部类型实现trait",
    "title": "rust trait",
    "section": "3 给内置或外部类型实现trait",
    "text": "3 给内置或外部类型实现trait\n\n3.1 为i32 实现一个我们定义的trait\ntrait Pow {\n    fn pow(&self) -&gt; i32;\n}\nimpl Pow for i32 {\n    fn pow(&self) -&gt; i32 {\n        *self * *self\n    }\n}\nfn main() {\n    let a = 3;\n    println!(\"{}\", a.pow());\n}\n\n\n3.2 孤儿规则 (orphan rule)\n\n\n\n\n\n\nCaution\n\n\n\n\n如果你想要为类型A实现trait B,那么要么类型A是在当前的crate中定义的,要么trait B是在当前的crate中定义的\n如果要实现外部定义的trait需要先将其导入作用域\n再换句话说就是\n\n可以对外部类型实现自定义的trait\n可以对自定义类型上实现外部trait\n外部是指不是由当前crate,而是由外部定义的,比如标准库\n\n\n\n\n\n\n3.3 newtype”绕过”孤儿规则\nuse std::fmt;\n\n// only traits defined in the current crate can be implemented for types defined outside of the crate\n// define and implement a trait or new type instead\n// impl fmt::Display for Vec&lt;String&gt; {\n//     fn fmt(&self, f: &mut fmt::Formatter) -&gt; fmt::Result {\n//         write!(f, \"[{}]\", self.0.join(\", \"))\n//     }\n// }\n// 使用元祖结构体 变成一个新的类型,是本地的\n// Vec 是标准库里的,属于外部类型\nstruct Wrapper(Vec&lt;String&gt;);\n// fmt::Display 这个是外部trait\nimpl fmt::Display for Wrapper {\n    fn fmt(&self, f: &mut fmt::Formatter) -&gt; fmt::Result {\n        write!(f, \"[{}]\", self.0.join(\", \"))\n    }\n}\n\nfn main() {\n    let w = Wrapper(vec![String::from(\"hello\"), String::from(\"world\")]);\n    println!(\"w = {}\", w);\n}",
    "crumbs": [
      "基础篇",
      "trait"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/trait.html#完全限定语法",
    "href": "docs/programming/rust/basic/trait.html#完全限定语法",
    "title": "rust trait",
    "section": "4 完全限定语法",
    "text": "4 完全限定语法\n\n\n\n\n\n\nImportant\n\n\n\n\n当一个结构体实现了多个trait,而这些trait里有相同的方法,无法直接用实例.方法()来调用,那么如何调用这些方法呢?\n\n\n\n// 定义第一个trait，它有一个名为`announce`的方法\ntrait TraitOne {\n    fn announce(&self);\n}\n\n// 定义第二个trait，它也有一个名为`announce`的方法\ntrait TraitTwo {\n    fn announce(&self);\n}\n\n// 定义一个结构体`Speaker`\nstruct Speaker {\n    message: String,\n}\n\n// 为`Speaker`实现`TraitOne`\nimpl TraitOne for Speaker {\n    fn announce(&self) {\n        println!(\"traitOne: {}\", &self.message)\n    }\n}\n\n// 为`Speaker`实现`TraitTwo`\nimpl TraitTwo for Speaker {\n    fn announce(&self) {\n        println!(\"traitTwo: {}\", &self.message)\n    }\n}\n\nfn main() {\n    // 创建一个`Speaker`实例\n    let speaker = Speaker {\n        message: \"Hello\".to_string(),\n    };\n\n    // speaker.announce(); 报错了 提示用多个announce\n    // 使用完全限定语法调用`TraitOne`的`announce`方法\n    &lt;Speaker as TraitOne&gt;::announce(&speaker);\n    TraitOne::announce(&speaker);\n\n    // 使用完全限定语法调用`TraitTwo`的`announce`方法\n    &lt;Speaker as TraitTwo&gt;::announce(&speaker);\n    TraitTwo::announce(&speaker);\n}",
    "crumbs": [
      "基础篇",
      "trait"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/trait.html#trait-作为约束",
    "href": "docs/programming/rust/basic/trait.html#trait-作为约束",
    "title": "rust trait",
    "section": "5 trait 作为约束",
    "text": "5 trait 作为约束\n\n5.1 impl 写法\n参数item, 必须是实现了Summary这个trait的类型,这里是该类型的可变借用\npub fn notify(item: &impl Summary) {\n    println!(\"Breaking news! {}\", item.summarize());\n}\n\n\n5.2 泛型 写法\nimpl Summary 相比较这个写法, 我们一般用下面这样的写法\npub fn notify&lt;T: Summary&gt;(item: &T) {\n    println!(\"Breaking news! {}\", item.summarize());\n}\n\npub fn notify(item1: &impl Summary, item2: &impl Summary) {\n    // ...\n}\n// 多个参数, 这样写就比上面的简洁\npub fn notify&lt;T: Summary&gt;(item1: &T, item2: &T) {\n    // ...\n}\n\n\n指定多个trait\n\npub fn notify(item: &(impl Summary + Display)) {\n    // ...\n}\n\npub fn notify&lt;T: Summary + Display&gt;(item: &T) {\n    // ...\n}\n\n\n\n5.3 where 写法\n当我们在指定多个参数 然后每个参数要实现多个trait时, 写起来可能不是那么清晰, 这时我们可以使用where来简化\nfn some_function&lt;T: Display + Clone, U: Clone + Debug&gt;(t: &T, u: &U) -&gt; i32 {\n    //...\n}\n\n\n使用where的写法\n\nfn some_function&lt;T, U&gt;(t: &T, u: &U) -&gt; i32\nwhere\n    T: Display + Clone,\n    U: Clone + Debug,\n{\n    // ...\n}",
    "crumbs": [
      "基础篇",
      "trait"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/trait.html#trait的不同形式",
    "href": "docs/programming/rust/basic/trait.html#trait的不同形式",
    "title": "rust trait",
    "section": "6 trait的不同形式",
    "text": "6 trait的不同形式\n\n6.1 简单 trait\n入门例子中举的例子就属于非常简单的类型\ntrait ExampleTrait {\n    fn inspect(&self) -&gt; &str;\n}\n\n\n6.2 泛型 trait\n\n6.2.1 产生原因和使用方式\n\n\n不使用泛型的情况\n\n#[derive(Debug)]\nstruct Number {\n    value: i32,\n}\n// 定义一个trait\ntrait MyFrom {\n    // 这个\"行为\"的想法是 想从类型i32,生成一个类型 Self (即: 实现该trait的主体)\n    fn my_from(item: i32) -&gt; Self;\n}\nimpl MyFrom for Number {\n    fn my_from(item: i32) -&gt; Self {\n        Self { value: item }\n    }\n}\n#[derive(Debug)]\nstruct MyString {\n    value: String,\n}\ntrait MyFrom2 {\n    // 由于类型不同, 我们不得不 重新定义个 trait\n    // 里面的\"行为\" 实际它的逻辑一样, 都是从一个类型生成 Self 类型\n    // 但是我们不得不重新写一遍\n    fn my_from(item: String) -&gt; Self;\n}\nimpl MyFrom2 for MyString {\n    fn my_from(item: String) -&gt; Self {\n        Self { value: item }\n    }\n}\nfn main() {\n    let num = Number::my_from(30);\n    let str2 = MyString::my_from(\"hello\".to_string());\n    println!(\"My number is {:?}\", num);\n    println!(\"My string is {:?}\", str2);\n}\n\n\n可以从一种类型生成另外一种类型, 这个行为应该是非常抽象的, 是说几乎每个类型都可以有这样一个行为\n\n\n\n使用泛型参数的trait\n\n#[derive(Debug)]\nstruct Number {\n    value: i32,\n}\n// trait 定义的行为 依赖于多个不同类型, 我们就使用泛型\ntrait MyFrom&lt;T&gt; {\n    fn my_from(item: T) -&gt; Self;\n}\nimpl MyFrom&lt;i32&gt; for Number {\n    fn my_from(item: i32) -&gt; Self {\n        Number { value: item }\n    }\n}\n#[derive(Debug)]\nstruct MyString {\n    value: String,\n}\nimpl MyFrom&lt;String&gt; for MyString {\n    fn my_from(item: String) -&gt; Self {\n        Self { value: item }\n    }\n}\n\nfn main() {\n    let num = Number::my_from(30);\n    let str2 = MyString::my_from(\"hello\".to_string());\n    println!(\"My number is {:?}\", num);\n    println!(\"My string is {:?}\", str2);\n}\n\nuse std::fmt::Display;\n\ntrait Animal&lt;T&gt;\nwhere\n    T: Display,\n{\n    fn shout(&self, v: T);\n}\nstruct Dog;\n\n// impl&lt;T&gt; 中的&lt;T&gt; 是申明泛型\n// Aniaml&lt;T&gt; 中的T 就已经是在使用了,不是申明\nimpl&lt;T&gt; Animal&lt;T&gt; for Dog\nwhere\n    T: Display,\n{\n    fn shout(&self, v: T) {\n        println!(\"{}\", v);\n    }\n}\n// 这里会报错, 因为 前面 的  `impl&lt;T&gt; Animal&lt;T&gt; for Dog` 已经包含了这里的情况\n// 如果你 上面的不要写, 单独为Dog 实现多个 trait, `impl Animal&lt;String&gt;` ,`impl Animal&lt;i32&gt;`这样具化类型, 是可以的\n// impl Animal&lt;String&gt; for Dog {\n//     fn shout(&self, v: String) {\n//         println!(\"{}\", v);\n//     }\n// }\n\nfn main() {\n    let a = Dog;\n    // Dog 的实例实现了 trait (Animal&lt;T&gt;)的shout 方法\n    // shout 使用的参数类型, 具化了 T\n    // 下面2个都ok\n    a.shout(123);\n    a.shout(\"wang wang\");\n}\n\n\n6.2.2 设置泛型默认值\ntrait Summable&lt;T = i32&gt; {\n    fn sum(&self) -&gt; T;\n}\n\n// 实现Summable trait，使用默认的泛型类型 i32\nimpl Summable for Vec&lt;i32&gt; {\n    fn sum(&self) -&gt; i32 {\n        self.iter().sum()\n    }\n}\n\n// 实现Summable trait，但为泛型指定一个不同的类型 f64\nimpl Summable&lt;f64&gt; for Vec&lt;f64&gt; {\n    fn sum(&self) -&gt; f64 {\n        self.iter().sum()\n    }\n}\n\nfn main() {\n    let vec_i32: Vec&lt;i32&gt; = vec![1, 2, 3];\n    let vec_f64: Vec&lt;f64&gt; = vec![1.0, 2.0, 3.0];\n\n    // 使用默认的泛型类型 i32\n    println!(\"Sum of vec_i32: {}\", vec_i32.sum());\n\n    // 使用指定的泛型类型 f64\n    println!(\"Sum of vec_f64: {}\", vec_f64.sum());\n}\n\n\n\n6.3 关联类型 trait\n\n6.3.1 产生的原因和使用\n// 有一个trait, 需要多个泛型参数\ntrait ExampleTrait&lt;A, B, C&gt; {\n    fn tmp(&self, x: A, y: B) -&gt; C;\n    fn get(&self) -&gt; C;\n}\nstruct ExampleStruct {}\n// 每次你为某个结构体实现这个trait时, 就需要写 很多个泛型参数\n// 很麻烦\nimpl ExampleTrait&lt;i32, i64, i8&gt; for ExampleStruct {\n    fn tmp(&self, x: i32, y: i64) -&gt; i8 {\n        6i8\n    }\n    fn get(&self) -&gt; i8 {\n        self.tmp(1, 2)\n    }\n}\n// 当你写一个函数, 参数类型需要 实现ExampleTrait 的时候\n// 你需要这样写上一堆 泛型参数, 也很麻烦\nfn test&lt;A, B, C, D&gt;(x: &D) -&gt; C\nwhere\n    D: ExampleTrait&lt;A, B, C&gt;,\n{\n    x.get()\n}\n\n\n使用关联类型\n\ntrait ExampleTrait {\n    type A; // 像占位符一样\n    type B;\n    type C;\n    fn tmp(&self, x: Self::A, y: Self::B) -&gt; Self::C;\n    fn get(&self) -&gt; Self::C;\n}\nstruct ExampleStruct1 {}\nimpl ExampleTrait for ExampleStruct1 {\n    // 给具体类型实现 trait的时候\n    // 我们就写成具体的类型\n    type A = i32;\n    type B = i64;\n    type C = i8;\n    // 里面可以直接写 具体的类型\n    fn tmp(&self, x: i32, y: i64) -&gt; i8 {\n        // ... 这里无需关心具体实现.. 我们就只是说明关联类型的优点\n        6i8\n    }\n    fn get(&self) -&gt; i8 {\n        self.tmp(1, 2)\n    }\n}\nstruct ExampleStruct2 {}\nimpl ExampleTrait for ExampleStruct2 {\n    type A = i32;\n    type B = i64;\n    type C = i8;\n    // 当然可以写 Self::A 这种 (和前面写具体类型都是可以的)\n    fn tmp(&self, x: Self::A, y: Self::B) -&gt; Self::C {\n        1i8\n    }\n    fn get(&self) -&gt; Self::C {\n        self.tmp(1, 2)\n    }\n}\n// 有一个函数, 参数类型需要 实现ExampleTrait2\nfn test&lt;D&gt;(x: &D) -&gt; D::C\nwhere\n    D: ExampleTrait,\n{\n    x.get()\n}\nfn main() {\n    let a = ExampleStruct1 {};\n    let f = test(&a);\n    println!(\"{}\", f);\n    let b = ExampleStruct2 {};\n    let f = test(&b);\n    println!(\"{}\", f);\n}\n\n\n\n6.3.2 使用trait的关联类型来约束类型\ntrait Person {\n    type AAA;\n    fn shout(&self, msg: Self::AAA);\n}\n// 定义一个结构体,规定内部成员homeowner的类型必须实现Person这个trait\n// 成员 house_name 的类型 必须是 实现了Person 这个trait的类 中定义的关联类型 AAA\nstruct House&lt;T: Person&gt; {\n    homeowner: T,\n    house_name: T::AAA,\n}\n\nstruct Man {\n    name: String,\n}\nimpl Person for Man {\n    // 如果将这个 AAA 改成其他类型, 那么就会在实例化 House时house_name 也要改成这里指定的类型\n    type AAA = String;\n    fn shout(&self, msg: Self::AAA) {\n        println!(\"{}\", msg);\n    }\n}\nfn main() {\n    let s = House {\n        homeowner: Man {\n            name: \"jerry\".to_string(),\n        },\n        house_name: \"jerry's home\".to_string(),\n    };\n    s.homeowner.shout(\"啊啊啊\".to_string());\n}\n\n\n6.3.3 直接指定具体类型来约束关联类型\ntrait Person {\n    type AAA;\n    fn shout(&self, msg: Self::AAA);\n}\n// 定义一个结构体\n//  1. 约束了内部成员的类型必须实现Person这个trait\n//  2. Person实现这个trait的代码中使用的关联类型必须是String\nstruct House&lt;T: Person&lt;AAA = String&gt;&gt; {\n    homeowner: T,\n}\n\nstruct Man {\n    name: String,\n}\n// 为了实例化 House 中使用的字段 homeowner 可以用\n// 我们为其实现Person trait\nimpl Person for Man {\n    // 关联类型 设置为String\n    // 如果将这个 AAA 改成其他类型, 那么就会在实例化 House 那里报错\n    // 因为这样的 Man 不是我们要的\n    type AAA = String;\n    fn shout(&self, msg: Self::AAA) {\n        println!(\"{}\", msg);\n    }\n}\nfn main() {\n    let s = House {\n        homeowner: Man {\n            name: \"jerry\".to_string(),\n        },\n    };\n    s.homeowner.shout(\"啊啊啊\".to_string());\n}\n\n\n6.3.4 使用trait 约束关联类型\nuse std::fmt::Display;\n\ntrait Person {\n    type AAA: Display;\n    fn shout(&self, msg: Self::AAA);\n}\nstruct House&lt;T: Person&gt; {\n    homeowner: T,\n}\n\nstruct Man {\n    name: String,\n}\nimpl Person for Man {\n    type AAA = i32; //String 也行, 必须是实现了 Display 这个trait\n    fn shout(& self, msg: Self::AAA) {\n        println!(\"{}\", msg);\n    }\n}\nfn main() {\n    let  s = House {\n        homeowner: Man {\n            name: \"jerry\".to_string(),\n        },\n    };\n    s.homeowner.shout(123);\n}\n\n\n\n6.4 关联常量 trait\ntrait Country {\n    const HISTORY: u32 = 5000;\n    const INDEPENDENT: bool = true;\n    fn get_code(&self) -&gt; u32 {\n        Self::HISTORY\n    }\n}\n\nstruct China;\nimpl Country for China {\n    const HISTORY: u32 = 7000;\n}\n\nfn main() {\n    let c = China;\n    println!(\"{}\", c.get_code());\n    println!(\"{:?}\", China::HISTORY);\n    println!(\"{:?}\", &lt;China as Country&gt;::HISTORY);\n    println!(\"{:?}\", China::INDEPENDENT);\n    println!(\"{:?}\", &lt;China as Country&gt;::INDEPENDENT);\n}\n\n\n6.5 继承 trait\n\n\n\n\n\n\nCaution\n\n\n\n\n用继承这个词, 其实我觉得不太好\n比如如果说trait A继承了B, 但是实际A并没有B的行为, 只是你在实现trait A的时候,必须实现trait B\n\n\n\ntrait Animal {\n    fn shout(&self);\n}\n// 表示如果有类型要实现 Person 这个 trait, 那么它必须也要实现 Animal这个trait\n// 相当于 T: Person + Animal\ntrait Person: Animal {\n    fn speak(&self);\n    fn shout(&self);\n}\n\nstruct Student;\n\nimpl Person for Student {\n    fn speak(&self) {\n        println!(\"hello...\");\n    }\n    fn shout(&self) {\n        println!(\"person...\");\n    }\n}\nimpl Animal for Student {\n    fn shout(&self) {\n        println!(\"animal...\");\n    }\n}\nimpl Student {\n    // 如果没有自己实现自己的方法,\n    // 上面2个trait 中都有shout, main中调用 d.shout() 会报错\n    fn shout(&self) {\n        println!(\"类自己的方法...\");\n    }\n}\nfn main() {\n    let d = &Student;\n    d.shout(); // 类自己的方法...\n    // &lt;Type as Trait&gt;:: 完全限定语法,\n        // 在没有参数的情况下使用Person::shout()会报错, 需要用这个语法才可以\n    //  使用  Student 实现Person 这个trait 时的shout 方法\n    &lt;Student as Person&gt;::shout(d); // person...\n    Person::shout(d); // person...\n    &lt;Student as Animal&gt;::shout(d); // animal...\n    Animal::shout(d); // animal...\n}\n\n\n6.6 标记用 trait\n\n\n\n\n\n\nImportant\n\n\n\n\n这些trait 没有任何行为,里面是空的. 是给编译器用的, 会给类型打上一个标记,这些标记会影响编译器的静态检查和代码生成\n分别是 Copy ,Send, Sync, Sized 这4个\nSized trait\n\n表示类型能确定大小\n编译阶段能确定大小的类型,编译器就自动为其实现该trait\n\n\n\n\n我们分别在其他地方详细说明",
    "crumbs": [
      "基础篇",
      "trait"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/trait.html#返回值指定trait",
    "href": "docs/programming/rust/basic/trait.html#返回值指定trait",
    "title": "rust trait",
    "section": "7 返回值指定trait",
    "text": "7 返回值指定trait\nfn returns_summarizable() -&gt; impl Summary {\n    Tweet {\n        username: String::from(\"horse_ebooks\"),\n        content: String::from(\n            \"of course, as you probably already know, people\",\n        ),\n        reply: false,\n        retweet: false,\n    }\n}\n下面这个会报错\nfn returns_summarizable(switch: bool) -&gt; impl Summary {\n    if switch {\n        NewsArticle {\n            headline: String::from(\n                \"Penguins win the Stanley Cup Championship!\",\n            ),\n            location: String::from(\"Pittsburgh, PA, USA\"),\n            author: String::from(\"Iceburgh\"),\n            content: String::from(\n                \"The Pittsburgh Penguins once again are the best \\\n                 hockey team in the NHL.\",\n            ),\n        }\n    } else {\n        Tweet {\n            username: String::from(\"horse_ebooks\"),\n            content: String::from(\n                \"of course, as you probably already know, people\",\n            ),\n            reply: false,\n            retweet: false,\n        }\n    }\n}",
    "crumbs": [
      "基础篇",
      "trait"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/trait.html#运算符重载",
    "href": "docs/programming/rust/basic/trait.html#运算符重载",
    "title": "rust trait",
    "section": "8 运算符重载",
    "text": "8 运算符重载\nuse std::ops::Add;\n\n#[derive(Debug, Copy, Clone, PartialEq)]\nstruct Point {\n    x: i32,\n    y: i32,\n}\n// 给Point 实现Add trait, Add trait 定义了+加法 会如何操作\nimpl Add for Point {\n    type Output = Point;\n\n    fn add(self, other: Point) -&gt; Point {\n        Point {\n            x: self.x + other.x,\n            y: self.y + other.y,\n        }\n    }\n}\n\nfn main() {\n    assert_eq!(\n        Point { x: 1, y: 0 } + Point { x: 2, y: 3 },\n        Point { x: 3, y: 3 }\n    );\n}\n我们看下Add trait的定义,发现实际带有类型参数,默认值是Self\npub trait Add&lt;Rhs = Self&gt; {\n    // ...\n}\n不同类型的+ 加法重载\nuse std::ops::Add;\n\nstruct Millimeters(u32);\nstruct Meters(u32);\n\nimpl Add&lt;Meters&gt; for Millimeters {\n    type Output = Millimeters;\n\n    fn add(self, other: Meters) -&gt; Millimeters {\n        Millimeters(self.0 + (other.0 * 1000))\n    }\n}\n\nfn main() {\n    let mm = Millimeters(10);\n    let m = Meters(1);\n\n    let sum = mm + m;\n    // sum is of type Millimeters\n    println!(\"sum is {}\", sum.0); // 1010\n    // 注意这样是不行的, 顺序是有关系的\n    // let sum2 = m + mm;\n}",
    "crumbs": [
      "基础篇",
      "trait"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/trait.html#trait-object",
    "href": "docs/programming/rust/basic/trait.html#trait-object",
    "title": "rust trait",
    "section": "9 trait object",
    "text": "9 trait object\n\n9.1 使用\n我们有这样一个需求, 创建一个GUI 工具, 会遍历一个列表, 调用每个元素的draw方法\n我们很快就能想到使用泛型,试试看\npub trait Draw {\n    fn draw(&self);\n}\npub struct ScreenWithGeneric&lt;T: Draw&gt; {\n    pub components: Vec&lt;T&gt;,\n}\n\nimpl&lt;T&gt; ScreenWithGeneric&lt;T&gt;\nwhere\n    T: Draw,\n{\n    pub fn run(&self) {\n        for component in self.components.iter() {\n            component.draw();\n        }\n    }\n}\n\npub struct Button {}\n\nimpl Draw for Button {\n    fn draw(&self) {\n        println!(\"Button\");\n    }\n}\nstruct SelectBox {}\nimpl Draw for SelectBox {\n    fn draw(&self) {\n        println!(\"SelectBox\");\n    }\n}\n\nfn main() {\n    let botton = Button {};\n    let botton2 = Button {};\n    let select_box = SelectBox {};\n    let s = ScreenWithGeneric {\n        // 报错了, 类型不一致了\n        components: vec![botton, select_box],\n    };\n    s.run();\n}\n结果发现行不通, 问题的关键是我们只要列表里的元素能够执行 draw 方法就行, 不管它是什么类型. 有什么办法呢? trait object 可以解决这个问题\n\npub trait Draw {\n    fn draw(&self);\n}\npub struct Screen {\n    // Box&lt;dyn Draw&gt; : 定义了一个 trait object\n    // 表示 Box里的元素必须都实现了 Draw 这个trait 就行, 不管它是什么类型\n1    pub components: Vec&lt;Box&lt;dyn Draw&gt;&gt;,\n}\nimpl Screen {\n    pub fn run(&self) {\n        for component in self.components.iter() {\n            component.draw();\n        }\n    }\n}\npub struct Button {}\n\nimpl Draw for Button {\n    fn draw(&self) {\n        println!(\"Button\");\n    }\n}\nstruct SelectBox {}\nimpl Draw for SelectBox {\n    fn draw(&self) {\n        println!(\"SelectBox\");\n    }\n}\nfn main() {\n    let button = Button {};\n\n    let select_box = SelectBox {};\n    let s = Screen {\n        // 这里ok了\n        components: vec![Box::new(button), Box::new(select_box)],\n    };\n    s.run();\n}\n\n1\n\n使用Box 包起来很好理解, 因为实现了Draw 这个trait的类型的大小不知道,直接用指针指向,所以用Box装箱\n\n\n\n\n9.2 动态派发\n\n\n\n\n\n\nTip\n\n\n\n\n当你使用泛型函数或方法时，编译器会为每个具体使用的数据类型生成专门的代码。这种机制称为单态化（Monomorphization）,单态化后的代码 会执行静态派发\n\n\n\n// 使用trait约束泛型T，这里T必须实现了Summary trait\nfn notify&lt;T: Summary&gt;(item: T) {\n    println!(\"Breaking news! {}\", item.summarize());\n}\n\n// 编译器会为每个具体使用的数据类型生成专门的代码,这样，当调用notify(tweet)和notify(article)时，直接调用的就是针对Tweet和NewsArticle预先生成好的、类型特定的函数，这就是静态派发的过程\n\n// 为Tweet类型特化生成的notify函数\nfn notify_Tweet(item: Tweet) {\n    println!(\"Breaking news! {}\", item.summarize());\n}\n\n// 为NewsArticle类型特化生成的notify函数\nfn notify_NewsArticle(item: NewsArticle) {\n    println!(\"Breaking news! {}\", item.summarize());\n}\n动态派发 ,使用dyn trait会用动态派发, 无法在编译期确定你调用的是哪个方法,会在运行时确定\n\n\n\n9.3 对象安全\n只能把满足对象安全的trait 转为 trait object\n\n安全的标准\n\n方法返回类型不是Self\n方法中没有泛型类型参数",
    "crumbs": [
      "基础篇",
      "trait"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/trait.html#sized-trait",
    "href": "docs/programming/rust/basic/trait.html#sized-trait",
    "title": "rust trait",
    "section": "10 Sized Trait",
    "text": "10 Sized Trait\n\n动态大小的类型 DST (Dynamically Sized Types)\n\n\n\n\n\n\n\nNote\n\n\n\n\n类型可以说是规定了你如何去使用一块内存: 占用多少空间, 怎么读写,比如给你弄了写方法, 方便读写\n在数组里, [1i32,2] 占用了8字节 [1i32,2,3] 12个字节, 这2个是不同的类型, 虽然我们都说他们是数组\n\n\n\n\nlet s1: str = \"Hello there!\";\nlet s2: str = \"How's it going?\";\n\n// 这个就ok了, 因为这个 &str 类型的 占用空间是确定的,\n// 可以说动态类型的数据的一种通用使用方式, 就是一个指针去指向它的实际数据,其他比如长度等信息\nlet s3: &str = \"Hello there!\";\n\n\n\n\n\n\n上面报错了, 我们分析一下\n\n\n\n\n前面2行报错了, 你可能会疑惑? s1和s2的占用多少空间是很确定的样子,好像没问题?\ns1 s2 两个变量是同一个str类型,但是看起来他们占用的空间却不一样, 这就有问题了\nrust 需要在栈上为变量分配固定大小的内存空间, 这需要在编译期就知道类型的大小, 而该str类型大小不确定\n\n\n\n\n为了处理这种动态大小的类型,rust提供了Sized trait 来去确定一个类型的大小在编译器是否是已知的.\n在编译期知道大小的类型, rust会为其自动的实现一个trait (Sized)\nfn generic&lt;T&gt;(t: T) {\n    // --snip--\n}\n上面的代码实际上 等同与, rust 会为 每个泛型函数隐式添加 Sized trait约束\nfn generic&lt;T: Sized&gt;(t: T) {\n    // --snip--\n}\n默认情况下, 泛型函数只能在编译期知道其类型大小的情况下工作。但是, 你可以使用以下特殊语法来放宽这一限制:\n// ?Sized 表示 T的大小可能是不确定的\nfn generic&lt;T: ?Sized&gt;(t: &T) {\n    // --snip--\n}",
    "crumbs": [
      "基础篇",
      "trait"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/trait.html#一些trait",
    "href": "docs/programming/rust/basic/trait.html#一些trait",
    "title": "rust trait",
    "section": "11 一些trait",
    "text": "11 一些trait\n\n11.1 类型转换相关\n\nFrom & IntoTryFrom & TryIntoToString & FromStr\n\n\nFrom trait 让你可以从另外一个B类型的数据,创建一个A类型的数据\nlet my_str = \"hello\";\n// 我们常用到的 String::from  就是String 类型 实现了 From trait\nlet my_string = String::from(my_str);\n\n\n自定义实现From\n\nuse std::convert::From;\n\n#[derive(Debug)]\nstruct Number {\n    value: i32,\n}\n\nimpl From&lt;i32&gt; for Number {\n    fn from(item: i32) -&gt; Self {\n        Number { value: item  }\n    }\n}\n\nfn main() {\n    let num = Number::from(30);\n    println!(\"My number is {:?}\", num);\n\n    // 如果你实现了from , 那么对方也自动实现了into\n    let int = 5;\n    // 试试删除类型说明\n    let num: Number = int.into();\n    println!(\"My number is {:?}\", num);\n}\n\n\n\n自定义实现into\n\nuse std::convert::Into;\n\n#[derive(Debug)]\nstruct Number {\n    value: i32,\n}\n\nimpl Into&lt;Number&gt; for i32 {\n    fn into(self) -&gt; Number {\n        Number { value: self }\n    }\n}\n\nfn main() {\n    let int = 5;\n    // Try removing the type annotation\n    let num: Number = int.into();\n    println!(\"My number is {:?}\", num);\n}\n\n\n\n\n\n\n\n\n\nCaution\n\n\n\n\n用于易出错的转换, 所以它的返回值是 Result 型\n\n\n\nuse std::convert::TryFrom;\nuse std::convert::TryInto;\n\n#[derive(Debug, PartialEq)]\nstruct EvenNumber(i32);\n\nimpl TryFrom&lt;i32&gt; for EvenNumber {\n    type Error = ();\n\n    fn try_from(value: i32) -&gt; Result&lt;Self, Self::Error&gt; {\n        if value % 2 == 0 {\n            Ok(EvenNumber(value))\n        } else {\n            Err(())\n        }\n    }\n}\n\nfn main() {\n    // TryFrom\n\n    assert_eq!(EvenNumber::try_from(8), Ok(EvenNumber(8)));\n    assert_eq!(EvenNumber::try_from(5), Err(()));\n\n    // TryInto\n\n    let result: Result&lt;EvenNumber, ()&gt; = 8i32.try_into();\n    assert_eq!(result, Ok(EvenNumber(8)));\n    let result: Result&lt;EvenNumber, ()&gt; = 5i32.try_into();\n    assert_eq!(result, Err(()));\n}\n\n\n\n\n\n\n\n\nCaution\n\n\n\n\n要把任何类型转换成 String, 只需要实现那个类型的 ToString trait. 然而不要直接这么做, 您应该实现fmt::Display trait,它会自动提供 ToString\n\n\n\nuse std::fmt;\n\nstruct Circle {\n    radius: i32\n}\n\nimpl fmt::Display for Circle {\n    fn fmt(&self, f: &mut fmt::Formatter) -&gt; fmt::Result {\n        write!(f, \"Circle of radius {}\", self.radius)\n    }\n}\n\nfn main() {\n    let circle = Circle { radius: 6 };\n    println!(\"{}\", circle.to_string());\n}\n\n\n\n\n\n\nTip\n\n\n\n只要对目标类型实现了 FromStr trait, 就可以用 parse 把字符串转换成目标类型\n\n\n\n\nFromStr定义一个类型如何从字符串转换而来\n\nuse std::str::FromStr;\n\n// 定义一个简单的结构体，它包含一个 u32 类型的值\nstruct MyNumber {\n    value: u32,\n}\n\n// 为 MyNumber 实现 FromStr trait\nimpl FromStr for MyNumber {\n    type Err = &'static str; // 定义错误类型为 &'static str\n\n    // from_str 方法尝试将字符串解析为 MyNumber\n    fn from_str(s: &str) -&gt; Result&lt;Self, Self::Err&gt; {\n        // 尝试将字符串转换为 u32\n        let value = s.parse::&lt;u32&gt;().map_err(|_| \"Parse error\")?;\n        // 如果成功，创建并返回 MyNumber 实例\n        Ok(Self { value })\n    }\n}\n\nfn main() {\n    // 使用 parse::&lt;MyNumber&gt;() 方法将字符串转换为 MyNumber\n    // 如果不实现 MyNumber 类型的from_str 方法, 是不能 parse的\n    let number = \"42\".parse::&lt;MyNumber&gt;().unwrap();\n    println!(\"Parsed value: {}\", number.value);\n\n    // 如果解析失败，会返回一个错误\n    if let Err(e) = \"not a number\".parse::&lt;MyNumber&gt;() {\n        println!(\"Failed to parse: {}\", e);\n    }\n\n    let parsed: i32 = \"5\".parse().unwrap();\n    let turbo_parsed = \"10\".parse::&lt;i32&gt;().unwrap();\n}\n\n\n\n\n\n\n11.2 打印相关\n\n11.2.1 Display\n\n\n\n\n\n\nNote\n\n\n\n\n实现了该trait, 类型就有了to_string方法\n只有实现了该trait , 才能使用 println!(\"{}\",x) 打印\n\n\n\nuse std::fmt;\n\nstruct Circle {\n    radius: i32\n}\n// 实现这个trait ,就有了 to_string 方法\nimpl fmt::Display for Circle {\n    fn fmt(&self, f: &mut fmt::Formatter) -&gt; fmt::Result {\n        write!(f, \"Circle of radius {}\", self.radius)\n    }\n}\n\nfn main() {\n    let circle = Circle { radius: 6 };\n    let c=circle.to_string();\n    println!(\"{}\", c);\n}\n\n\n\n11.3 index 索引操作 trait\nuse std::ops::{Index, IndexMut};\n\n// 定义一个简单的 Collection 类型\nstruct Collection&lt;T&gt; {\n    items: Vec&lt;T&gt;,\n}\n\n// 为 Collection 实现 Index trait（只读操作）\nimpl&lt;T&gt; Index&lt;usize&gt; for Collection&lt;T&gt; {\n    type Output = T;\n\n    fn index(&self, index: usize) -&gt; &Self::Output {\n        &self.items[index]\n    }\n}\n\n// 为 Collection 实现 IndexMut trait（可变操作）\nimpl&lt;T&gt; IndexMut&lt;usize&gt; for Collection&lt;T&gt; {\n    fn index_mut(&mut self, index: usize) -&gt; &mut Self::Output {\n        &mut self.items[index]\n    }\n}\n\nfn main() {\n    // 创建一个可变的 Collection 实例\n    let mut collection = Collection {\n        items: vec![10, 20, 30, 40, 50],\n    };\n\n    // 使用索引操作读取元素\n    println!(\"原始第一个元素: {}\", collection[0]);\n    println!(\"原始第三个元素: {}\", collection[2]);\n\n    // 使用索引操作修改元素\n    collection[0] = 100;\n    collection[2] = 300;\n\n    // 再次读取修改后的元素\n    println!(\"修改后第一个元素: {}\", collection[0]);\n    println!(\"修改后第三个元素: {}\", collection[2]);\n}",
    "crumbs": [
      "基础篇",
      "trait"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/trait.html#derive-自动派生",
    "href": "docs/programming/rust/basic/trait.html#derive-自动派生",
    "title": "rust trait",
    "section": "12 derive 自动派生",
    "text": "12 derive 自动派生\n\n\n\n\n\n\nTip\n\n\n\n\n设计缘由\n\nrust 为某些类型实现某些trait时, 代码基本是固定的,重复的,是一件麻烦的事情, 不难想到应该实现自动化处理.\n\n使用方法\n\n因此rust设计一个属性, 就是在你想要实现名为XXX的trait的类型前面写#[derive(XXX)], 它可以自动为你的结构体或枚举实现某些 trait, 也就是rust 编译器会自动为你生成这些 traits 的实现代码\n\n以下是一些常用的可以通过 derive 自动实现的 trait:\n\nDebug: 用于格式化输出，使得结构体或枚举在调试时可以打印其字段\nClone: 允许创建一个值的副本\nCopy: 使得类型可以按位复制,而不是移动\nPartialEq 和 Eq: 用于比较两个值是否相等\nPartialOrd 和 Ord: 用于比较两个值的顺序\nDefault: 提供一个类型的默认值\nHash: 允许类型被用作哈希表中的键\n\n\n\n\n\n12.1 Debug\n派生Debug trait后, 才能使用println!(“{:?}”)中{:?}或{:#?}这种打印方式\n\n\n#[derive(Debug)]\n\nstruct Cat(i32);\n// 添加这个就自动实现了Debug trait\n/*\n编译器会自动为你 加上\nimpl Debug for Dog {\n  // ...\n}\n*/\n#[derive(Debug)] \nstruct Dog(i32);\nfn main() {\n    println!(\"Cat: {:?} \", Cat(5)); // 报错了\n    println!(\"Dog: {:?} \", Dog(5)); // ok\n}\n\n\n\n12.2 Default\n\n\n\n\n\n\nCaution\n\n\n\n\n一般我们也不用, 首先它相当于一个构造函数, 但是我们都会自己定义一个 名字可能是new 的 静态方法\n\n\n\n// 添加Default 派生宏\n#[derive(Debug, Default)]\nstruct Rectangle {\n    width: u32,\n    height: u32,\n}\nfn main() {\n    // 可以使用这种方式来创建一个实例\n    // 使用方式1\n    let rect1: Rectangle = Default::default();\n    println!(\"{:?}\", rect1); //\n    // 使用方式2\n    let rect2 = Rectangle::default();\n    println!(\"{:?}\", rect2);\n}",
    "crumbs": [
      "基础篇",
      "trait"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/macro.html",
    "href": "docs/programming/rust/basic/macro.html",
    "title": "rust 宏",
    "section": "",
    "text": "Caution\n\n\n\ntodo…\n宏是用来编写可以生成其他代码的 代码 (metaprogramming)\n编译器编译时会将宏进行展开,就是会替换成具体的rust代码",
    "crumbs": [
      "基础篇",
      "宏"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/macro.html#println",
    "href": "docs/programming/rust/basic/macro.html#println",
    "title": "rust 宏",
    "section": "1 println!",
    "text": "1 println!\n我们之前一直用这个宏来打印信息, 因为这个标准输出宏可以在编译期进行格式检查,这样更安全",
    "crumbs": [
      "基础篇",
      "宏"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/share_code/modify_static_var.html",
    "href": "docs/programming/rust/basic/share_code/modify_static_var.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "可变的静态变量,修改需要unsafe\n\nstatic mut COUNTER: u32 = 0;\nfn add_to_count(inc: u32) {\n    unsafe {\n        COUNTER += inc;\n    }\n}\n\nfn main() {\n    add_to_count(3);\n\n    println!(\"COUNTER: {}\", unsafe { COUNTER });\n}\n\n\n\n\n Back to top"
  },
  {
    "objectID": "docs/programming/rust/basic/closure.html",
    "href": "docs/programming/rust/basic/closure.html",
    "title": "rust 闭包",
    "section": "",
    "text": "Tip\n\n\n\n\n闭包是可以捕获其定义所在的作用域的匿名函数\n闭包底层实际上是一个匿名的结构体,且实现了Fn,FnMut,FnOnce这三个trait中的一个或多个\n闭包会根据对捕获的变量的使用情况,推断出实现了哪些 trait\n\n\n\n我们先来看看下面的代码\n\n\n我们需要切换到nightly版本\n\n# 在 项目目录下执行, 只更换当前目录的rust版本\nrustup override set nightly\n\n\n例子1看底层结构例子2看什么叫只能实现FnOnce例子3看三个trait全部实现会执行哪个\n\n\n\n\n运行即可, 不会报错的\n\n#![feature(unboxed_closures)]\n#![feature(fn_traits)]\n\nstruct Adder {\n    a: u32\n}\n\n// Adder 只实现了FnOnce (后面我们还会提到什么叫只实现了)\nimpl FnOnce&lt;(u32, )&gt; for Adder {\n    type Output = u32;\n    extern \"rust-call\" fn call_once(self, b: (u32, )) -&gt; Self::Output {\n        // 相当于闭包的\"函数体\"\n        self.a + b.0\n    }\n}\n\nfn main() {\n    let x=3;\n    let adder = Adder { a: x }; // 相当于闭包将捕获的外部变量x存到结构体中的a\n    // adder 结构体实现了上面的FnOnce trait, 这里变成可以用函数的方式()去调用自身了\n    let res=adder(2);\n    // 提示错误, adder 被move掉了, 原因看最后\n    // adder(2);\n    println!(\"{}\",res);// 5\n\n    let adder = Adder { a: 3 };\n    // adder()是一种简写方式, 其实相当于调用如下\n    let res=adder.call_once((2,));\n    println!(\"{}\",res);// 5\n\n    let adder = Adder { a: 3 };\n    // adder.call_once 也是语法糖,这个我们在结构体章节中已经说到,\n    // 所以实际是这样调用 ,adder 作为参数传递给call_once 方法\n    let res=FnOnce::call_once(adder,(2,));\n    println!(\"{}\",res);// 5\n    // 提示adder已经被move了, 因为call_once 传递的是self\n    // println!(\"{:p}\",&adder);\n\n}\n\n\n\n\n\n\n\n\n\nImportant\n\n\n\n可以将2个trait方法里的 {self.a;} 代码注释,再执行看看\n\n\n#![feature(unboxed_closures)]\n#![feature(fn_traits)]\n\nstruct Adder&lt;'a&gt; {\n    a: String,\n    b: &'a str,\n    c: &'a mut u32,\n}\nimpl&lt;'a&gt; FnOnce&lt;(u32,)&gt; for Adder&lt;'a&gt; {\n    type Output = (); // 看你闭包实际的返回情况, 这里进行修改\n    extern \"rust-call\" fn call_once(self, b: (u32,)) -&gt; Self::Output{\n        println!(\"{}\",self.a);\n        println!(\"{}\",self.b);\n        *self.c=22;\n        {\n            self.a;\n        }\n    }\n}\nimpl&lt;'a&gt; FnMut&lt;(u32,)&gt; for Adder&lt;'a&gt; {\n    extern \"rust-call\" fn call_mut(&mut self, b: (u32,)) -&gt; Self::Output{\n        println!(\"{}\",self.a);\n        println!(\"{}\",self.b);\n        *self.c=22;\n        {\n            // 首先捕获 外部变量的所有权,模拟闭包捕获外部变量所有权\n                // 捕获变量的方式不是重点, 重要的是闭包内部对该变量的使用方式,才影响闭包实现了哪个trait的原因\n            // 如果闭包里想要将捕获的所有权变量 给弄失效,那么你就必须只能传递 self\n            // 所以这里你就实现不了FnMut trait,因为它传递的是&mut,是无法将a失效化的\n            // 这里当然报错了.\n            self.a;\n        }\n    }\n}\n\nfn main() {\n    let a = \"abc\".to_string();\n    let b = \"abc\";\n    let mut c = 11;\n    let mut adder = Adder {\n        a: a, // 模拟闭包捕获所有权\n        b: b,  // 模拟闭包捕获不可变借用\n        c: &mut c  // 模拟闭包捕获可变借用\n    };\n    // println!(\"{}\",a);\n    let res = adder(2);\n    println!(\"{}\",c);\n\n}\n\n\n\n\n\n\n\n\nCaution\n\n\n\n\n其实好理解,使用fn trait的方法是最好的, 因为FnOnce 那个没必要执行完就让结构体失效了, 也没必要用FnMut,它需要mut.\n看 一个闭包到底实现了 哪个trait,只要想象将闭包体放入3个trait的要实现的方法里看能否执行成功, 成功就表明实现了这个trait\n\n\n\n#![feature(unboxed_closures)]\n#![feature(fn_traits)]\n\nstruct Adder&lt;'a&gt; {\n    a: String,\n    b: &'a str,\n    c: &'a mut u32,\n}\nimpl&lt;'a&gt; FnOnce&lt;(u32,)&gt; for Adder&lt;'a&gt; {\n    type Output = (); // 看你闭包实际的返回情况, 这里进行修改\n    extern \"rust-call\" fn call_once(self, b: (u32,)) -&gt; Self::Output{\n        println!(\"{}\",self.a);\n        println!(\"{} call_once\",self.b);\n    }\n}\nimpl&lt;'a&gt; FnMut&lt;(u32,)&gt; for Adder&lt;'a&gt; {\n    extern \"rust-call\" fn call_mut(&mut self, b: (u32,)) -&gt; Self::Output{\n        println!(\"{}\",self.a);\n        println!(\"{} call_mut\",self.b);\n    }\n}\nimpl&lt;'a&gt; Fn&lt;(u32,)&gt; for Adder&lt;'a&gt; {\n    extern \"rust-call\" fn call(&self, b: (u32,)) -&gt; Self::Output{\n        println!(\"{}\",self.a);\n        println!(\"{} call\",self.b);\n    }\n}\nfn main() {\n    let a = \"abc\".to_string();\n    let b = \"abc\";\n    let mut c = 11;\n    // 这里其实不用mut, 因为最后实际是执行的 Fn trait\n    let mut adder = Adder {\n        a: a, // 捕获所有权\n        b: b,  // 捕获不可变借用\n        c: &mut c  // 捕获可变借用\n    };\n    // 实现全部trait的\"闭包\" ,执行看看是执行哪个trait的方法\n    let res = adder(2);\n    adder(2);\n}",
    "crumbs": [
      "基础篇",
      "闭包"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/closure.html#底层原理",
    "href": "docs/programming/rust/basic/closure.html#底层原理",
    "title": "rust 闭包",
    "section": "",
    "text": "Tip\n\n\n\n\n闭包是可以捕获其定义所在的作用域的匿名函数\n闭包底层实际上是一个匿名的结构体,且实现了Fn,FnMut,FnOnce这三个trait中的一个或多个\n闭包会根据对捕获的变量的使用情况,推断出实现了哪些 trait\n\n\n\n我们先来看看下面的代码\n\n\n我们需要切换到nightly版本\n\n# 在 项目目录下执行, 只更换当前目录的rust版本\nrustup override set nightly\n\n\n例子1看底层结构例子2看什么叫只能实现FnOnce例子3看三个trait全部实现会执行哪个\n\n\n\n\n运行即可, 不会报错的\n\n#![feature(unboxed_closures)]\n#![feature(fn_traits)]\n\nstruct Adder {\n    a: u32\n}\n\n// Adder 只实现了FnOnce (后面我们还会提到什么叫只实现了)\nimpl FnOnce&lt;(u32, )&gt; for Adder {\n    type Output = u32;\n    extern \"rust-call\" fn call_once(self, b: (u32, )) -&gt; Self::Output {\n        // 相当于闭包的\"函数体\"\n        self.a + b.0\n    }\n}\n\nfn main() {\n    let x=3;\n    let adder = Adder { a: x }; // 相当于闭包将捕获的外部变量x存到结构体中的a\n    // adder 结构体实现了上面的FnOnce trait, 这里变成可以用函数的方式()去调用自身了\n    let res=adder(2);\n    // 提示错误, adder 被move掉了, 原因看最后\n    // adder(2);\n    println!(\"{}\",res);// 5\n\n    let adder = Adder { a: 3 };\n    // adder()是一种简写方式, 其实相当于调用如下\n    let res=adder.call_once((2,));\n    println!(\"{}\",res);// 5\n\n    let adder = Adder { a: 3 };\n    // adder.call_once 也是语法糖,这个我们在结构体章节中已经说到,\n    // 所以实际是这样调用 ,adder 作为参数传递给call_once 方法\n    let res=FnOnce::call_once(adder,(2,));\n    println!(\"{}\",res);// 5\n    // 提示adder已经被move了, 因为call_once 传递的是self\n    // println!(\"{:p}\",&adder);\n\n}\n\n\n\n\n\n\n\n\n\nImportant\n\n\n\n可以将2个trait方法里的 {self.a;} 代码注释,再执行看看\n\n\n#![feature(unboxed_closures)]\n#![feature(fn_traits)]\n\nstruct Adder&lt;'a&gt; {\n    a: String,\n    b: &'a str,\n    c: &'a mut u32,\n}\nimpl&lt;'a&gt; FnOnce&lt;(u32,)&gt; for Adder&lt;'a&gt; {\n    type Output = (); // 看你闭包实际的返回情况, 这里进行修改\n    extern \"rust-call\" fn call_once(self, b: (u32,)) -&gt; Self::Output{\n        println!(\"{}\",self.a);\n        println!(\"{}\",self.b);\n        *self.c=22;\n        {\n            self.a;\n        }\n    }\n}\nimpl&lt;'a&gt; FnMut&lt;(u32,)&gt; for Adder&lt;'a&gt; {\n    extern \"rust-call\" fn call_mut(&mut self, b: (u32,)) -&gt; Self::Output{\n        println!(\"{}\",self.a);\n        println!(\"{}\",self.b);\n        *self.c=22;\n        {\n            // 首先捕获 外部变量的所有权,模拟闭包捕获外部变量所有权\n                // 捕获变量的方式不是重点, 重要的是闭包内部对该变量的使用方式,才影响闭包实现了哪个trait的原因\n            // 如果闭包里想要将捕获的所有权变量 给弄失效,那么你就必须只能传递 self\n            // 所以这里你就实现不了FnMut trait,因为它传递的是&mut,是无法将a失效化的\n            // 这里当然报错了.\n            self.a;\n        }\n    }\n}\n\nfn main() {\n    let a = \"abc\".to_string();\n    let b = \"abc\";\n    let mut c = 11;\n    let mut adder = Adder {\n        a: a, // 模拟闭包捕获所有权\n        b: b,  // 模拟闭包捕获不可变借用\n        c: &mut c  // 模拟闭包捕获可变借用\n    };\n    // println!(\"{}\",a);\n    let res = adder(2);\n    println!(\"{}\",c);\n\n}\n\n\n\n\n\n\n\n\nCaution\n\n\n\n\n其实好理解,使用fn trait的方法是最好的, 因为FnOnce 那个没必要执行完就让结构体失效了, 也没必要用FnMut,它需要mut.\n看 一个闭包到底实现了 哪个trait,只要想象将闭包体放入3个trait的要实现的方法里看能否执行成功, 成功就表明实现了这个trait\n\n\n\n#![feature(unboxed_closures)]\n#![feature(fn_traits)]\n\nstruct Adder&lt;'a&gt; {\n    a: String,\n    b: &'a str,\n    c: &'a mut u32,\n}\nimpl&lt;'a&gt; FnOnce&lt;(u32,)&gt; for Adder&lt;'a&gt; {\n    type Output = (); // 看你闭包实际的返回情况, 这里进行修改\n    extern \"rust-call\" fn call_once(self, b: (u32,)) -&gt; Self::Output{\n        println!(\"{}\",self.a);\n        println!(\"{} call_once\",self.b);\n    }\n}\nimpl&lt;'a&gt; FnMut&lt;(u32,)&gt; for Adder&lt;'a&gt; {\n    extern \"rust-call\" fn call_mut(&mut self, b: (u32,)) -&gt; Self::Output{\n        println!(\"{}\",self.a);\n        println!(\"{} call_mut\",self.b);\n    }\n}\nimpl&lt;'a&gt; Fn&lt;(u32,)&gt; for Adder&lt;'a&gt; {\n    extern \"rust-call\" fn call(&self, b: (u32,)) -&gt; Self::Output{\n        println!(\"{}\",self.a);\n        println!(\"{} call\",self.b);\n    }\n}\nfn main() {\n    let a = \"abc\".to_string();\n    let b = \"abc\";\n    let mut c = 11;\n    // 这里其实不用mut, 因为最后实际是执行的 Fn trait\n    let mut adder = Adder {\n        a: a, // 捕获所有权\n        b: b,  // 捕获不可变借用\n        c: &mut c  // 捕获可变借用\n    };\n    // 实现全部trait的\"闭包\" ,执行看看是执行哪个trait的方法\n    let res = adder(2);\n    adder(2);\n}",
    "crumbs": [
      "基础篇",
      "闭包"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/closure.html#简单使用",
    "href": "docs/programming/rust/basic/closure.html#简单使用",
    "title": "rust 闭包",
    "section": "2 简单使用",
    "text": "2 简单使用\nfn main() {\n    fn add_one_v1(x: u32) -&gt; u32 {\n        x + 1\n    }\n    // 闭包,匿名函数, |参数| -&gt; 返回值 { 函数体}\n    let add_one_v2 = |x: u32| -&gt; u32 { x + 1 };\n    // 等价与 |x| {x + 1}  因为只有一个表达式, 所以 {} 可以省略\n    let add_one_v3 = |x| x + 1;\n    // 上面的定义没有类型, 如果没有的调用语句, 是会报错的, 因为函数没有类型,内存占用无法确定\n    // 调用后, 编译器推断出参数类型,这个时候类型就确定了\n    let r = add_one_v3(1);\n    println!(\"{}\", r);\n    // 后续如果你用其他类型,就会报错的\n    // let r2 = add_one_v3(\"a\");\n}",
    "crumbs": [
      "基础篇",
      "闭包"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/closure.html#捕获值的方式",
    "href": "docs/programming/rust/basic/closure.html#捕获值的方式",
    "title": "rust 闭包",
    "section": "3 捕获值的方式",
    "text": "3 捕获值的方式\n\n3.1 捕获逻辑\n\n\n\n\n\n\nImportant\n\n\n\n\n在没有使用move 的情况下\n\n如果使用不可变借用就可以的, 那么就使用不可变借用(既然只要不可变就OK,何必搞其他的”权限”更多的捕获,很简单的道理)\n其次是需要修改的情况下,如果用可变借用就能完成逻辑,那就用可变借用\n最后没有办法,只能通过获取所有权来完成逻辑, 那么就只能获取所有权\n\nmove 关键字\n\n强制获取外部变量的所有权, 即使你本身可能不需要\n当然还有本身copy类型的变量, 不会让外部的变量失效\n\n\n\n\n\n\n3.2 不可变借用\n\n\n简单的明显的例子\n\nfn main() {\n    let list = vec![1, 2, 3];\n    println!(\"Before defining closure: {:?}\", list);\n    // 捕获了闭包所在环境, 变量list\n    let only_borrows = || {\n        // println!使用了 list的不可变借用\n        println!(\"From closure: {:?}\", list);\n    }\n\n    println!(\"Before calling closure: {:?}\", list);\n    only_borrows();\n    println!(\"After calling closure: {:?}\", list);\n}\n\n\n\n\n看起来有点不那么明显的例子\n\nfn main() {\n    let mut x = 1;\n    let f = |y: i32| x + y;\n    x = 3;  //报错了\n    let r = f(2);\n    let mut x = 1;\n    // 这里同样也是使用x的不可变借用\n    let f = Box::new(|y: i32| x + y);\n}\n\n\n\n\n\n\n\n结果可以发现是不可变借用\n\n\n\n\n运行根据提示的错误信息, 闭包里捕获的x 是 不可变借用\n根据前面的判断逻辑, 该闭包只要不可变借用就能完成它的逻辑,所以使用不可变借用\n\nfn main(){\n    let a = 1;\n    let b = 2;\n    let c = &a + b;  // 这种是ok的.会自动解引用的\n    println!(\"{c}\");\n}\n\n\n\nfn t&lt;'a&gt;(x: i32) -&gt; &'a i32 {\n    &x\n    // 执行完t(x) x就失效了, 而你返回了x的不可变借用,所以有问题\n}\n// 问题同上, 会报错\nfn ret_closure(x: i32) -&gt; Box&lt;dyn Fn(i32) -&gt; i32&gt; {\n    // 传来的x, 再调用完 ret_closure(x) 后, x 就失效了,\n    // 而这里返回的 ,使用了x的不可变借用\n    Box::new(|y: i32| x + y)\n}\n// 正确的写法\nfn ret_closure2(x: i32) -&gt; Box&lt;dyn Fn(i32) -&gt; i32&gt; {\n    // x的所有权转移 就OK了\n    Box::new(move |y: i32| x + y)\n}\n\n\n3.3 可变借用\nfn main() {\n    let mut list = vec![1, 2, 3];\n    println!(\"Before defining closure: {:?}\", list);\n    // 需要mut, 看闭包体里如何使用捕获的变量\n    let mut borrows_mutably = || list.push(7);\n\n    borrows_mutably();\n    println!(\"After calling closure: {:?}\", list); // [1, 2, 3, 7]\n}\n\n\n3.4 所有权\n\n\nmove 种类的类型\n\n#[derive(Debug)]\nstruct Foo;\nfn main() {\n    let a = Foo;\n    println!(\" {:p}\", &a);\n    // 整体去看闭包体{} 里是如何使用捕获的变量的.\n    // 一旦需要使用所有权这样的权限, 那么就 只能实现FnOnce 那个trait了.\n    let f =  || {\n        // a 最后被move掉了,那么就需要有它的所有权\n        // 那么首先 就是获取a的所有权\n        // 所以这里的a就已经是从外部转移所有权后的a, 那么就和外部的地址不一样\n        println!(\" {:p}\", &a);\n        // 最后转移了a的所有权了.\n        let b = a;\n    };\n    f();\n    // 报错,a已经在闭包内被b获取所有权了\n    // println!(\"{:?}\", a);\n}\n\n\n\n同上,例子2\n\nfn main() {\n    let mut farewell = \"goodbye\".to_owned();\n    let diary = || {\n        println!(\"I said {}.\", farewell);\n        {\n            farewell;\n        } // farewell 被drop掉了,\n    };\n    // println!(\"{}\", farewell);\n}\n\n\n\n使用move强制获取所有权,即使里面使用的只是不可变借用\n\nuse std::thread;\n\nfn main() {\n    let list = vec![1, 2, 3];\n    println!(\"Before defining closure: {:?}\", list);\n    // 指定move, 所有权移动\n    thread::spawn(move || println!(\"From thread: {:?}\", list))\n        .join()\n        .unwrap();\n    // println!(\"after defining closure: {:?}\", list); // 被move了,报错\n}\n\n\n\ncopy 种类的类型 使用move\n\nfn main() {\n    let x = 7;\n    println!(\"外部x变量地址: {:p}\", &x);\n    let f = move || {\n        // 虽然内部是用的 x 的不可变借用, 但是使用了move\n        // move 后, 这里的x 就已经是新的x ,而不是外部x的借用了\n        println!(\"move后 闭包内x变量地址: {:p}\", &x);\n        println!(\"{}\", x);\n    };\n    f();\n    println!(\"{}\", x); // copy 类型, 值还有效\n}\n\n\n\nMove 种类的类型 使用move,但是闭包内部没有使用到所有权的权限\n\nfn main() {\n    let x = \"abc\".to_string();\n    println!(\"外部x变量地址: {:p}\", &x);\n    let f = move || {\n        println!(\"move后 闭包内x变量地址: {:p}\", &x);\n        println!(\"{}\", x);\n    };\n    f();\n    // ok 说明其实 Fn trait也实现了\n    // 也说明了前面我们提到的, 将3个traint 都实现一遍, 看哪个能实现来判断\n    f();\n    // println!(\"{}\", x); // 报错了.\n}",
    "crumbs": [
      "基础篇",
      "闭包"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/closure.html#trait",
    "href": "docs/programming/rust/basic/closure.html#trait",
    "title": "rust 闭包",
    "section": "4 trait",
    "text": "4 trait\n\n4.1 FnOnce\n\n\n\n\n\n\nTip\n\n\n\n\nFnOnce表示可以被调用一次,很显然我们编写的闭包肯定是要能被调用至少一次的.只要能调用至少一次,那么它就实现了FnOnce trait\n如果只实现了 FnOnce这个trait, 其他trait没有实现,那么表示该闭包只能被调用一次, 反之亦然.\n当你闭包被调用一次后,里面的捕获的值如果就失效了,就能推断它 只实现了 FnOnce trait,因为它被调用一次后,里面变量值无效了,再调用就报错了]{.txt-highlight}\n\n\n\n\n\n\n源码定义\n\npub trait FnOnce&lt;Args: Tuple&gt; {\n    /// The returned type after the call operator is used.\n    #[lang = \"fn_once_output\"]\n    #[stable(feature = \"fn_once_output\", since = \"1.12.0\")]\n    type Output;\n\n    /// Performs the call operation.\n    #[unstable(feature = \"fn_traits\", issue = \"29625\")]\n    extern \"rust-call\" fn call_once(self, args: Args) -&gt; Self::Output;\n}\n\n\n\n\n\n\n\n得出结论\n\n\n\n\n当我们调用了只实现了 FnOnce trait的闭包比如 my_closure() 后, 它相当于调用 my_closure.call_once(),前面我们说过 闭包底层实际是一个结构体, 那么这里🈶转换为 相当于执行FnOnce::call_once(my_closure,args),转移所有权了, 所以只能调用一次\n结合底层原理章节看看\n所以很好理解, 为什么说只实现了 FnOnce trait的闭包 ,就只能调用一次\n这里再次强调: 具体实现了哪些trait,看底层原理将三个trait都套进去看能否成功执行\n\n\n\n\n\n\n有捕获可变借用,不可变借用和所有权, 最后是只实现了FnOnce trait的闭包\n\nfn main() {\n    let farewell = \"goodbye\".to_owned();\n    let mut b = 11;\n    let c = \"abc\".to_string();\n    println!(\"inner {:p}.\", &farewell);\n    let diary = || {\n        // farewell move给了diary(作为返回值),那么就需要有它的所有权\n        // 这个时候的farewell 就已经是获取了外部farewell所有权的新farewell\n        println!(\"inner farewell {:p}.\", &farewell);\n        println!(\"inner  {}.\", &mut b);\n        println!(\"inner  {}.\", &c);\n        farewell\n    };\n    diary();\n    // diary(); //报错\n    // println!(\"{}\", farewell); //报错\n}\n\n\n\n使用move但是实际可以被调用多次\n\nfn main() {\n    let farewell = \"goodbye\".to_owned();\n    let diary = move || {\n        println!(\"I said {}.\", farewell);\n    };\n    diary();\n    diary();\n}\n\n\n\n\n4.2 FnMut\n\n\n\n源码\n\npub trait FnMut&lt;Args: Tuple&gt;: FnOnce&lt;Args&gt; {\n    /// Performs the call operation.\n    #[unstable(feature = \"fn_traits\", issue = \"29625\")]\n    extern \"rust-call\" fn call_mut(&mut self, args: Args) -&gt; Self::Output;\n}\n\n\n\n\n\n\n\n得出结论\n\n\n\n\n我们可以看到,实现了FnMut trait的闭包,肯定也实现FnOnce trait\n只实现 FnMut和FnOnce2个trait 的闭包,调用时 相当于 FnMut::call_mut(&mut self,args)\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\n\n只要闭包最终只使用了捕获的值的可变借用,不管它是否真的进行修改,都说明只实现了FnMut+FnOnce\n\n\n\n\nfn apply&lt;F&gt;(mut f: F)\nwhere\n    F: FnMut(),\n{\n    f();\n    f();\n}\nfn main() {\n    let mut farewell = \"goodbye\".to_owned();\n    let mut diary = || {\n        // 可变借用 String::push_str(&mut self,string: &str)\n        farewell.push_str(\"hello\");\n    };\n    // 根据底层原理, 看 FnMut::call_mut(&mut self)\n    // 所以diary本身需要 let mut diary\n    diary();\n    apply(diary);\n}\n\n大概的底层结构相关可能需要了解的知识点\n\n\nfn main(){\n    struct Diary&lt;'a&gt; {\n       tmp: &'a mut String,\n    }\n    let mut s=\"goodbye\".to_string();\n    let mut diary=Diary{tmp:&mut s};\n    impl&lt;'a&gt; FnOnce&lt;(u32,)&gt; for Diary&lt;'a&gt; {\n        type Output = ();\n        extern \"rust-call\" fn call_once(self, b: (u32,)) -&gt; Self::Output{\n            self.tmp.push_str(\"hello\");\n            println!(\"{} call_once\",self.tmp);\n        }\n    }\n    impl&lt;'a&gt; FnMut&lt;(u32,)&gt; for Diary&lt;'a&gt; {\n        extern \"rust-call\" fn call_mut(&mut self, b: (u32,)) -&gt; Self::Output{\n            self.tmp.push_str(\"hello\");\n            println!(\"{} call_mut\",self.tmp);\n        }\n    }\n    // 实现不了该trait\n    // impl&lt;'a&gt; Fn&lt;(u32,)&gt; for Diary&lt;'a&gt; {\n    //     extern \"rust-call\" fn call(&self, b: (u32,)) -&gt; Self::Output{\n    //         /* \n    //         如果有些知识点不知道, 可能会觉得 这个好像也OK\n    //         String::push_str(&mut Self,&str)\n    //         因为self.tmp 是 &mut farewell,将它传递给String::push_str好像很符合\n    //         而实际上 会将&mut (*self.tmp)作为参数传递, self 是不可变借用, 这里又使用了可变借用,所以报错\n    //         */ \n    //         self.tmp.push_str(\"hello\");\n    //         println!(\"{} call_mut\",self.tmp);\n    //     }\n    // }\n    diary(1);\n}\n\n\n可变借用函数传参 reborrow\n\n\n下面的代码关注一下高亮行即可\n\nfn main() {\nstruct Adder&lt;'a&gt; {\n        a: String,\n        b: &'a str,\n        c: &'a mut u32,\n    }\n    let a = \"abc\".to_string();\n    let b = \"abc\";\n    let mut d = 11;\n    println!(\"{:p}\", &d);\n    let adder = Adder {\n        a: a,\n        b: b,\n        c: &mut d,\n    };\n    // *adder.c 是 *(adder.c)\n    let f = &(*adder.c);\n    print_type_of(f); //表示*adder.c 是d 就是 u32 类型\n    // 这是对 d的可变reborrow, 所以 后面的2个可变借用实际对d的修改操作 是ok的\n    let f = &mut (*adder.c);\n    print_type_of(&f); //表示&mut (*adder.c) 是 &mut u32 类型\n    *f = 22; // ok\n    *adder.c = 33;  // ok\n    println!(\"{}\", d);\n    println!(\"=============\");\n    //========================\n    let a = \"abc\".to_string();\n    let b = \"abc\";\n    let mut d = 11; \n    let adder = &Adder {\n        a: a,\n        b: b,\n        c: &mut d,\n    };\n    let f=&(adder.c);\n    //结果表示 adder.c是 &mut u32 类型\n    print_type_of(f); //&mut u32\n    let f=&(*adder.c);\n    // 结果表示 *adder.c 是 u32类型\n    print_type_of(f); // u32\n    //报错, 无法borrow 一个 &引用\n    // let f = &mut (*adder.c);\n}\nuse std::any::type_name;\n\nfn print_type_of&lt;T&gt;(_: &T) {\n    println!(\"{}\", type_name::&lt;T&gt;());\n}\n\n\n\n\n\nfn main() {\n    let mut farewell = \"goodbye\".to_owned();\n    // 需要 mut, 否则调用diary() 失败, 所以这里可以推断出只实现FnMut(含FnOnce)\n    let mut diary = || {\n        // fnMut trait call_mut(&mut self)\n        // 使用了可变借用\n        &mut farewell;\n        // 相当于 看drop 是 drop&lt;T&gt;(_x:T)\n        // 所以这里也是传递 &mut String 类型,同理 ,无法实现Fn trait\n        // drop( &mut farewell );\n    };\n    diary();\n    diary();\n}\n\n\n4.3 Fn\n\n\n\n源码定义\n\npub trait Fn&lt;Args: Tuple&gt;: FnMut&lt;Args&gt; {\n    /// Performs the call operation.\n    #[unstable(feature = \"fn_traits\", issue = \"29625\")]\n    extern \"rust-call\" fn call(&self, args: Args) -&gt; Self::Output;\n}\n\n\n\n\n\n\n\n得出结论\n\n\n\n\n我们可以看到,实现了Fn trait的闭包,肯定也实现FnMut, FnOnce 这2个trait\n实现了Fn trait的闭包(实际就是三个trait全部实现)的闭包,调用时相当于FnMut::call(&self,args)\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\n\n那种不捕获任何值的闭包或最终只使用捕获变量的不可变借用的闭包,就是实现Fn trait的闭包\n\n\n\nfn main() {\n    let farewell = \"goodbye\".to_owned();\n    let diary = move || {\n        println!(\"I said {}.\", farewell);\n    };\n    diary(); // ok\n    diary(); // ok\n}\nfn apply&lt;F&gt;(f: F)\nwhere\n    F: Fn(),\n{\n    f();\n}\n// 也是实现了 Fn() trait\nfn function() {\n    println!(\"I'm a function!\");\n}\nfn main() {\n    let x = 7;\n    let print = || {\n        // 对x的不可变借用\n        println!(\"{}\", x);\n    };\n    apply(print);\n    apply(function);\n    println!(\"{}\", x);\n}",
    "crumbs": [
      "基础篇",
      "闭包"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/closure.html#trait-bound",
    "href": "docs/programming/rust/basic/closure.html#trait-bound",
    "title": "rust 闭包",
    "section": "5 trait bound",
    "text": "5 trait bound\n\n\n实现了 FnMut trait的闭包用FnOnce() 做约束\n\n// trait 是FnOnce , 表示传递的参数必须是实现了FnOnce的闭包\n// 这里的写法 和一般的trait 不太一样\nfn apply&lt;F&gt;(f: F)\nwhere\n    F: FnOnce(),\n{\n    f();\n    // f(); 再次调用就报错了.\n}\nfn main() {\n    let mut farewell = \"goodbye\".to_owned();\n    let mut diary = || {\n        farewell.push_str(\" world\");\n        println!(\"{}\", farewell);\n    };\n    diary(); // diary 实现FnMut (也实现了 FnOnce)\n    apply(diary); // 可以传递给参数是闭包,类型为 FnOnce() 的函数\n\n\n\n实现了 Fn trait的闭包用FnMut() 做约束\n\nfn apply&lt;F&gt;(mut f: F)\nwhere\n    F: FnMut(),\n{\n    f();\n}\nfn main() {\n    let x = \"goodbye\".to_owned();\n    let diary = || {\n        // 对x 不可变借用的捕获\n        println!(\"{}\", x);\n    };\n    // diary 闭包实现了全部trait\n    diary();\n    // 可以传递给 参数是闭包, 类型是 FnMut() 的函数\n    apply(diary);\n}\n\n指定闭包的参数类型\n\n指定具体类型使用泛型\n\n\nfn apply&lt;F&gt;(f: F, v: i32)\nwhere\n    // 表示 传递的参数是闭包,然后必须携带一个i32的参数\n    F: FnOnce(i32),\n{\n    f(v);\n}\n\nfn main() {\n    let mut farewell = \"goodbye\".to_owned();\n    let mut diary = |x| {\n        println!(\"param: {}\", x);\n        farewell.push_str(\" hello\");\n    };\n    diary(22);\n    diary(21);\n    apply(diary, 33);\n    println!(\"{}\", farewell);\n}\n\n\n增加闭包的返回值\n\nfn apply&lt;F&gt;(f: F, v: i32)\nwhere\n    // 表示 传递的参数是闭包,然后必须携带一个i32的参数,有返回值且类型是i32\n    F: Fn(i32) -&gt; i32,\n{\n    f(v);\n}\n\nfn main() {\n    let diary = |x| {\n        println!(\"{x}\");\n        x + 1\n    };\n    diary(22);\n    diary(21);\n    apply(diary, 33);\n}\n\n\n\nfn apply&lt;F, T&gt;(f: F, v: T)\nwhere\n    // 表示 传递的参数是闭包,然后必须携带一个类型是T的参数\n    F: FnOnce(T),\n{\n    f(v);\n}\n\nfn main() {\n    let mut farewell = \"goodbye\".to_owned();\n    let mut diary = |x| {\n        println!(\"param: {}\", x);\n        farewell.push_str(\" hello\");\n    };\n    //如果这里调用这个一下, 会将闭包的参数进行推断,变成&str了,\n    diary(\"abc\");\n    apply(diary, \" world\");\n    println!(\"{}\", farewell);\n}",
    "crumbs": [
      "基础篇",
      "闭包"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/closure.html#闭包作为返回值",
    "href": "docs/programming/rust/basic/closure.html#闭包作为返回值",
    "title": "rust 闭包",
    "section": "6 闭包作为返回值",
    "text": "6 闭包作为返回值\nfn create_fn() -&gt; impl Fn() {\n    let text = \"Fn\".to_owned();\n    // move 必须要有,要不然最后 text 会被 drop\n    move || println!(\"This is a: {}\", text)\n}\n\nfn create_fnmut() -&gt; impl FnMut() {\n    let text = \"FnMut\".to_owned();\n    // 同样move\n    move || println!(\"This is a: {}\", text)\n}\n\nfn create_fnonce() -&gt; impl FnOnce() {\n    let text = \"FnOnce\".to_owned();\n\n    move || println!(\"This is a: {}\", text)\n}\n\nfn main() {\n    let fn_plain = create_fn();\n    let mut fn_mut = create_fnmut();\n    let fn_once = create_fnonce();\n\n    fn_plain();\n    fn_mut();\n    fn_once();\n}",
    "crumbs": [
      "基础篇",
      "闭包"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/closure.html#闭包的类型",
    "href": "docs/programming/rust/basic/closure.html#闭包的类型",
    "title": "rust 闭包",
    "section": "7 闭包的类型?",
    "text": "7 闭包的类型?\nfn main() {\n    let mut f = |x: i32| x + 1;\n    // 会报错, 前面说过, 编译器会给闭包生成一个匿名的结构体\n    // 就算闭包的参数和返回值一样, 也是不同的结构体, 所以是不同的类型\n    f = |x: i32| x + 1;\n}",
    "crumbs": [
      "基础篇",
      "闭包"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/trait_advanced.html",
    "href": "docs/programming/rust/basic/trait_advanced.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "use std::ops::Add;\n\n#[derive(Debug, Copy, Clone, PartialEq)]\nstruct Point {\n    x: i32,\n    y: i32,\n}\n// 给Point 实现Add trait, Add trait 定义了+加法 会如何操作\nimpl Add for Point {\n    type Output = Point;\n\n    fn add(self, other: Point) -&gt; Point {\n        Point {\n            x: self.x + other.x,\n            y: self.y + other.y,\n        }\n    }\n}\n\nfn main() {\n    assert_eq!(\n        Point { x: 1, y: 0 } + Point { x: 2, y: 3 },\n        Point { x: 3, y: 3 }\n    );\n}\n我们看下Add trait的定义,发现实际带有类型参数,默认值是Self\npub trait Add&lt;Rhs = Self&gt; {\n    // ...\n}\n不同类型的+ 加法重载\nuse std::ops::Add;\n\nstruct Millimeters(u32);\nstruct Meters(u32);\n\nimpl Add&lt;Meters&gt; for Millimeters {\n    type Output = Millimeters;\n\n    fn add(self, other: Meters) -&gt; Millimeters {\n        Millimeters(self.0 + (other.0 * 1000))\n    }\n}\n\nfn main() {\n    let mm = Millimeters(10);\n    let m = Meters(1);\n\n    let sum = mm + m;\n    // sum is of type Millimeters\n    println!(\"sum is {}\", sum.0); // 1010\n    // 注意这样是不行的, 顺序是有关系的\n    // let sum2 = m + mm;\n}"
  },
  {
    "objectID": "docs/programming/rust/basic/trait_advanced.html#运算符重载",
    "href": "docs/programming/rust/basic/trait_advanced.html#运算符重载",
    "title": "斯巴拉稀",
    "section": "",
    "text": "use std::ops::Add;\n\n#[derive(Debug, Copy, Clone, PartialEq)]\nstruct Point {\n    x: i32,\n    y: i32,\n}\n// 给Point 实现Add trait, Add trait 定义了+加法 会如何操作\nimpl Add for Point {\n    type Output = Point;\n\n    fn add(self, other: Point) -&gt; Point {\n        Point {\n            x: self.x + other.x,\n            y: self.y + other.y,\n        }\n    }\n}\n\nfn main() {\n    assert_eq!(\n        Point { x: 1, y: 0 } + Point { x: 2, y: 3 },\n        Point { x: 3, y: 3 }\n    );\n}\n我们看下Add trait的定义,发现实际带有类型参数,默认值是Self\npub trait Add&lt;Rhs = Self&gt; {\n    // ...\n}\n不同类型的+ 加法重载\nuse std::ops::Add;\n\nstruct Millimeters(u32);\nstruct Meters(u32);\n\nimpl Add&lt;Meters&gt; for Millimeters {\n    type Output = Millimeters;\n\n    fn add(self, other: Meters) -&gt; Millimeters {\n        Millimeters(self.0 + (other.0 * 1000))\n    }\n}\n\nfn main() {\n    let mm = Millimeters(10);\n    let m = Meters(1);\n\n    let sum = mm + m;\n    // sum is of type Millimeters\n    println!(\"sum is {}\", sum.0); // 1010\n    // 注意这样是不行的, 顺序是有关系的\n    // let sum2 = m + mm;\n}"
  },
  {
    "objectID": "docs/programming/rust/basic/trait_advanced.html#trait-object",
    "href": "docs/programming/rust/basic/trait_advanced.html#trait-object",
    "title": "斯巴拉稀",
    "section": "2 trait object",
    "text": "2 trait object\n\n2.1 使用\n我们有这样一个需求, 创建一个GUI 工具, 会遍历一个列表, 调用每个元素的draw方法\n我们很快就能想到使用泛型,试试看\npub trait Draw {\n    fn draw(&self);\n}\npub struct ScreenWithGeneric&lt;T: Draw&gt; {\n    pub components: Vec&lt;T&gt;,\n}\n\nimpl&lt;T&gt; ScreenWithGeneric&lt;T&gt;\nwhere\n    T: Draw,\n{\n    pub fn run(&self) {\n        for component in self.components.iter() {\n            component.draw();\n        }\n    }\n}\n\npub struct Button {}\n\nimpl Draw for Button {\n    fn draw(&self) {\n        println!(\"Button\");\n    }\n}\nstruct SelectBox {}\nimpl Draw for SelectBox {\n    fn draw(&self) {\n        println!(\"SelectBox\");\n    }\n}\n\nfn main() {\n    let botton = Button {};\n    let botton2 = Button {};\n    let select_box = SelectBox {};\n    let s = ScreenWithGeneric {\n        // 报错了, 类型不一致了\n        components: vec![botton, select_box],\n    };\n    s.run();\n}\n结果发现行不通, 问题的关键是我们只要列表里的元素能够执行 draw 方法就行, 不管它是什么类型. 有什么办法呢? trait object 可以解决这个问题\n\npub trait Draw {\n    fn draw(&self);\n}\npub struct Screen {\n    // Box&lt;dyn Draw&gt; : 定义了一个 trait object\n    // 表示 Box里的元素必须都实现了 Draw 这个trait 就行, 不管它是什么类型\n1    pub components: Vec&lt;Box&lt;dyn Draw&gt;&gt;,\n}\nimpl Screen {\n    pub fn run(&self) {\n        for component in self.components.iter() {\n            component.draw();\n        }\n    }\n}\npub struct Button {}\n\nimpl Draw for Button {\n    fn draw(&self) {\n        println!(\"Button\");\n    }\n}\nstruct SelectBox {}\nimpl Draw for SelectBox {\n    fn draw(&self) {\n        println!(\"SelectBox\");\n    }\n}\nfn main() {\n    let button = Button {};\n\n    let select_box = SelectBox {};\n    let s = Screen {\n        // 这里ok了\n        components: vec![Box::new(button), Box::new(select_box)],\n    };\n    s.run();\n}\n\n1\n\n使用Box 包起来很好理解, 因为实现了Draw 这个trait的类型的大小不知道,直接用指针指向,所以用Box装箱\n\n\n\n\n2.2 动态派发\n\n\n\n\n\n\nTip\n\n\n\n\n当你使用泛型函数或方法时，编译器会为每个具体使用的数据类型生成专门的代码。这种机制称为单态化（Monomorphization）,单态化后的代码 会执行静态派发\n\n\n\n// 使用trait约束泛型T，这里T必须实现了Summary trait\nfn notify&lt;T: Summary&gt;(item: T) {\n    println!(\"Breaking news! {}\", item.summarize());\n}\n\n// 编译器会为每个具体使用的数据类型生成专门的代码,这样，当调用notify(tweet)和notify(article)时，直接调用的就是针对Tweet和NewsArticle预先生成好的、类型特定的函数，这就是静态派发的过程\n\n// 为Tweet类型特化生成的notify函数\nfn notify_Tweet(item: Tweet) {\n    println!(\"Breaking news! {}\", item.summarize());\n}\n\n// 为NewsArticle类型特化生成的notify函数\nfn notify_NewsArticle(item: NewsArticle) {\n    println!(\"Breaking news! {}\", item.summarize());\n}\n动态派发 ,使用dyn trait会用动态派发, 无法在编译期确定你调用的是哪个方法,会在运行时确定\n\n\n\n2.3 对象安全\n只能把满足对象安全的trait 转为 trait object\n\n安全的标准\n\n方法返回类型不是Self\n方法中没有泛型类型参数"
  },
  {
    "objectID": "docs/programming/rust/basic/trait_advanced.html#sized-trait",
    "href": "docs/programming/rust/basic/trait_advanced.html#sized-trait",
    "title": "斯巴拉稀",
    "section": "3 Sized Trait",
    "text": "3 Sized Trait\n\n动态大小的类型 DST (Dynamically Sized Types)\n\n\n\n\n\n\n\nNote\n\n\n\n\n类型可以说是规定了你如何去使用一块内存: 占用多少空间, 怎么读写,比如给你弄了写方法, 方便读写\n在数组里, [1i32,2] 占用了8字节 [1i32,2,3] 12个字节, 这2个是不同的类型, 虽然我们都说他们是数组\n\n\n\n\nlet s1: str = \"Hello there!\";\nlet s2: str = \"How's it going?\";\n\n// 这个就ok了, 因为这个 &str 类型的 占用空间是确定的,\n// 可以说动态类型的数据的一种通用使用方式, 就是一个指针去指向它的实际数据,其他比如长度等信息\nlet s3: &str = \"Hello there!\";\n\n\n\n\n\n\n上面报错了, 我们分析一下\n\n\n\n\n前面2行报错了, 你可能会疑惑? s1和s2的占用多少空间是很确定的样子,好像没问题?\ns1 s2 两个变量是同一个str类型,但是看起来他们占用的空间却不一样, 这就有问题了\nrust 需要在栈上为变量分配固定大小的内存空间, 这需要在编译期就知道类型的大小, 而该str类型大小不确定\n\n\n\n\n为了处理这种动态大小的类型,rust提供了Sized trait 来去确定一个类型的大小在编译器是否是已知的.\n在编译期知道大小的类型, rust会为其自动的实现一个trait (Sized)\nfn generic&lt;T&gt;(t: T) {\n    // --snip--\n}\n上面的代码实际上 等同与, rust 会为 每个泛型函数隐式添加 Sized trait约束\nfn generic&lt;T: Sized&gt;(t: T) {\n    // --snip--\n}\n默认情况下, 泛型函数只能在编译期知道其类型大小的情况下工作。但是, 你可以使用以下特殊语法来放宽这一限制:\n// ?Sized 表示 T的大小可能是不确定的\nfn generic&lt;T: ?Sized&gt;(t: &T) {\n    // --snip--\n}"
  },
  {
    "objectID": "docs/programming/rust/basic/trait_advanced.html#一些trait",
    "href": "docs/programming/rust/basic/trait_advanced.html#一些trait",
    "title": "斯巴拉稀",
    "section": "4 一些trait",
    "text": "4 一些trait\n\n4.1 类型转换相关\n\nFrom & IntoTryFrom & TryIntoToString & FromStr\n\n\nFrom trait 让你可以从另外一个B类型的数据,创建一个A类型的数据\nlet my_str = \"hello\";\n// 我们常用到的 String::from  就是String 类型 实现了 From trait\nlet my_string = String::from(my_str);\n\n\n自定义实现From\n\nuse std::convert::From;\n\n#[derive(Debug)]\nstruct Number {\n    value: i32,\n}\n\nimpl From&lt;i32&gt; for Number {\n    fn from(item: i32) -&gt; Self {\n        Number { value: item  }\n    }\n}\n\nfn main() {\n    let num = Number::from(30);\n    println!(\"My number is {:?}\", num);\n\n    // 如果你实现了from , 那么对方也自动实现了into\n    let int = 5;\n    // 试试删除类型说明\n    let num: Number = int.into();\n    println!(\"My number is {:?}\", num);\n}\n\n\n\n自定义实现into\n\nuse std::convert::Into;\n\n#[derive(Debug)]\nstruct Number {\n    value: i32,\n}\n\nimpl Into&lt;Number&gt; for i32 {\n    fn into(self) -&gt; Number {\n        Number { value: self }\n    }\n}\n\nfn main() {\n    let int = 5;\n    // Try removing the type annotation\n    let num: Number = int.into();\n    println!(\"My number is {:?}\", num);\n}\n\n\n\n\n\n\n\n\n\nCaution\n\n\n\n\n用于易出错的转换, 所以它的返回值是 Result 型\n\n\n\nuse std::convert::TryFrom;\nuse std::convert::TryInto;\n\n#[derive(Debug, PartialEq)]\nstruct EvenNumber(i32);\n\nimpl TryFrom&lt;i32&gt; for EvenNumber {\n    type Error = ();\n\n    fn try_from(value: i32) -&gt; Result&lt;Self, Self::Error&gt; {\n        if value % 2 == 0 {\n            Ok(EvenNumber(value))\n        } else {\n            Err(())\n        }\n    }\n}\n\nfn main() {\n    // TryFrom\n\n    assert_eq!(EvenNumber::try_from(8), Ok(EvenNumber(8)));\n    assert_eq!(EvenNumber::try_from(5), Err(()));\n\n    // TryInto\n\n    let result: Result&lt;EvenNumber, ()&gt; = 8i32.try_into();\n    assert_eq!(result, Ok(EvenNumber(8)));\n    let result: Result&lt;EvenNumber, ()&gt; = 5i32.try_into();\n    assert_eq!(result, Err(()));\n}\n\n\n\n\n\n\n\n\nCaution\n\n\n\n\n要把任何类型转换成 String, 只需要实现那个类型的 ToString trait. 然而不要直接这么做, 您应该实现fmt::Display trait,它会自动提供 ToString\n\n\n\nuse std::fmt;\n\nstruct Circle {\n    radius: i32\n}\n\nimpl fmt::Display for Circle {\n    fn fmt(&self, f: &mut fmt::Formatter) -&gt; fmt::Result {\n        write!(f, \"Circle of radius {}\", self.radius)\n    }\n}\n\nfn main() {\n    let circle = Circle { radius: 6 };\n    println!(\"{}\", circle.to_string());\n}\n\n\n\n\n\n\nTip\n\n\n\n只要对目标类型实现了 FromStr trait, 就可以用 parse 把字符串转换成目标类型\n\n\n\n\nFromStr定义一个类型如何从字符串转换而来\n\nuse std::str::FromStr;\n\n// 定义一个简单的结构体，它包含一个 u32 类型的值\nstruct MyNumber {\n    value: u32,\n}\n\n// 为 MyNumber 实现 FromStr trait\nimpl FromStr for MyNumber {\n    type Err = &'static str; // 定义错误类型为 &'static str\n\n    // from_str 方法尝试将字符串解析为 MyNumber\n    fn from_str(s: &str) -&gt; Result&lt;Self, Self::Err&gt; {\n        // 尝试将字符串转换为 u32\n        let value = s.parse::&lt;u32&gt;().map_err(|_| \"Parse error\")?;\n        // 如果成功，创建并返回 MyNumber 实例\n        Ok(Self { value })\n    }\n}\n\nfn main() {\n    // 使用 parse::&lt;MyNumber&gt;() 方法将字符串转换为 MyNumber\n    // 如果不实现 MyNumber 类型的from_str 方法, 是不能 parse的\n    let number = \"42\".parse::&lt;MyNumber&gt;().unwrap();\n    println!(\"Parsed value: {}\", number.value);\n\n    // 如果解析失败，会返回一个错误\n    if let Err(e) = \"not a number\".parse::&lt;MyNumber&gt;() {\n        println!(\"Failed to parse: {}\", e);\n    }\n\n    let parsed: i32 = \"5\".parse().unwrap();\n    let turbo_parsed = \"10\".parse::&lt;i32&gt;().unwrap();\n}\n\n\n\n\n\n\n4.2 打印相关\n\n4.2.1 Display\n\n\n\n\n\n\nNote\n\n\n\n\n实现了该trait, 类型就有了to_string方法\n只有实现了该trait , 才能使用 println!(\"{}\",x) 打印\n\n\n\nuse std::fmt;\n\nstruct Circle {\n    radius: i32\n}\n// 实现这个trait ,就有了 to_string 方法\nimpl fmt::Display for Circle {\n    fn fmt(&self, f: &mut fmt::Formatter) -&gt; fmt::Result {\n        write!(f, \"Circle of radius {}\", self.radius)\n    }\n}\n\nfn main() {\n    let circle = Circle { radius: 6 };\n    let c=circle.to_string();\n    println!(\"{}\", c);\n}\n\n\n\n4.3 index 索引操作 trait\nuse std::ops::{Index, IndexMut};\n\n// 定义一个简单的 Collection 类型\nstruct Collection&lt;T&gt; {\n    items: Vec&lt;T&gt;,\n}\n\n// 为 Collection 实现 Index trait（只读操作）\nimpl&lt;T&gt; Index&lt;usize&gt; for Collection&lt;T&gt; {\n    type Output = T;\n\n    fn index(&self, index: usize) -&gt; &Self::Output {\n        &self.items[index]\n    }\n}\n\n// 为 Collection 实现 IndexMut trait（可变操作）\nimpl&lt;T&gt; IndexMut&lt;usize&gt; for Collection&lt;T&gt; {\n    fn index_mut(&mut self, index: usize) -&gt; &mut Self::Output {\n        &mut self.items[index]\n    }\n}\n\nfn main() {\n    // 创建一个可变的 Collection 实例\n    let mut collection = Collection {\n        items: vec![10, 20, 30, 40, 50],\n    };\n\n    // 使用索引操作读取元素\n    println!(\"原始第一个元素: {}\", collection[0]);\n    println!(\"原始第三个元素: {}\", collection[2]);\n\n    // 使用索引操作修改元素\n    collection[0] = 100;\n    collection[2] = 300;\n\n    // 再次读取修改后的元素\n    println!(\"修改后第一个元素: {}\", collection[0]);\n    println!(\"修改后第三个元素: {}\", collection[2]);\n}"
  },
  {
    "objectID": "docs/programming/rust/basic/trait_advanced.html#derive-自动派生",
    "href": "docs/programming/rust/basic/trait_advanced.html#derive-自动派生",
    "title": "斯巴拉稀",
    "section": "5 derive 自动派生",
    "text": "5 derive 自动派生\n\n\n\n\n\n\nTip\n\n\n\n\n设计缘由\n\nrust 为某些类型实现某些trait时, 代码基本是固定的,重复的,是一件麻烦的事情, 不难想到应该实现自动化处理.\n\n使用方法\n\n因此rust设计一个属性, 就是在你想要实现名为XXX的trait的类型前面写#[derive(XXX)], 它可以自动为你的结构体或枚举实现某些 trait, 也就是rust 编译器会自动为你生成这些 traits 的实现代码\n\n以下是一些常用的可以通过 derive 自动实现的 trait:\n\nDebug: 用于格式化输出，使得结构体或枚举在调试时可以打印其字段\nClone: 允许创建一个值的副本\nCopy: 使得类型可以按位复制,而不是移动\nPartialEq 和 Eq: 用于比较两个值是否相等\nPartialOrd 和 Ord: 用于比较两个值的顺序\nDefault: 提供一个类型的默认值\nHash: 允许类型被用作哈希表中的键\n\n\n\n\n\n5.1 Debug\n派生Debug trait后, 才能使用println!(“{:?}”)中{:?}或{:#?}这种打印方式\n\n\n#[derive(Debug)]\n\nstruct Cat(i32);\n// 添加这个就自动实现了Debug trait\n/*\n编译器会自动为你 加上\nimpl Debug for Dog {\n  // ...\n}\n*/\n#[derive(Debug)] \nstruct Dog(i32);\nfn main() {\n    println!(\"Cat: {:?} \", Cat(5)); // 报错了\n    println!(\"Dog: {:?} \", Dog(5)); // ok\n}\n\n\n\n5.2 Default\n\n\n\n\n\n\nCaution\n\n\n\n\n一般我们也不用, 首先它相当于一个构造函数, 但是我们都会自己定义一个 名字可能是new 的 静态方法\n\n\n\n// 添加Default 派生宏\n#[derive(Debug, Default)]\nstruct Rectangle {\n    width: u32,\n    height: u32,\n}\nfn main() {\n    // 可以使用这种方式来创建一个实例\n    // 使用方式1\n    let rect1: Rectangle = Default::default();\n    println!(\"{:?}\", rect1); //\n    // 使用方式2\n    let rect2 = Rectangle::default();\n    println!(\"{:?}\", rect2);\n}"
  },
  {
    "objectID": "docs/programming/rust/basic/quick-start.html",
    "href": "docs/programming/rust/basic/quick-start.html",
    "title": "rust 快速入门",
    "section": "",
    "text": "hello.rs\n\n// fn : function\nfn main() {\n    // rust的缩进是4个空格\n    // println! 是一个 rust macro 宏, 不是函数, 如果结尾没有! 则是函数\n    println!(\"hello\"); // 结尾 要有 ;\n    /* let 定义变量及初始化 */\n    // : i32 这种表示 变量x的类型\n    let x: i32 =6;\n    println!(\"{:?}\", x);\n    let y: i32;\n    println!(\"{:?}\", y); // 报错, 没有初始化会报错\n\n    // 定义了变量,但是没有使用它,rust会警告你,_开头的 rust不会警告\n    let _z = 5;\n\n    let a: i32;\n    // println!(\"{a}\");  使用之前必须初始化,否则报错\n    // 但是如果不使用的话,  是不会报错的\n\n    // _ 表示忽略这个变量绑定\n    let _ = 4;\n    // println!(\"{}\", _); 报错, _ 不是变量名\n}\n\nrustc 这个只适合编译简单的程序,大型程序 用cargo\n# -o 输出的名字, 没有则默认文件名\nrustc hello.rs -o main\n\n\n\n\n\n\nCaution\n\n\n\n将类型放到变量的后面的设计, 是考虑了rust想要类型自动推导.",
    "crumbs": [
      "基础篇",
      "快速入门"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/quick-start.html#入门例子",
    "href": "docs/programming/rust/basic/quick-start.html#入门例子",
    "title": "rust 快速入门",
    "section": "",
    "text": "hello.rs\n\n// fn : function\nfn main() {\n    // rust的缩进是4个空格\n    // println! 是一个 rust macro 宏, 不是函数, 如果结尾没有! 则是函数\n    println!(\"hello\"); // 结尾 要有 ;\n    /* let 定义变量及初始化 */\n    // : i32 这种表示 变量x的类型\n    let x: i32 =6;\n    println!(\"{:?}\", x);\n    let y: i32;\n    println!(\"{:?}\", y); // 报错, 没有初始化会报错\n\n    // 定义了变量,但是没有使用它,rust会警告你,_开头的 rust不会警告\n    let _z = 5;\n\n    let a: i32;\n    // println!(\"{a}\");  使用之前必须初始化,否则报错\n    // 但是如果不使用的话,  是不会报错的\n\n    // _ 表示忽略这个变量绑定\n    let _ = 4;\n    // println!(\"{}\", _); 报错, _ 不是变量名\n}\n\nrustc 这个只适合编译简单的程序,大型程序 用cargo\n# -o 输出的名字, 没有则默认文件名\nrustc hello.rs -o main\n\n\n\n\n\n\nCaution\n\n\n\n将类型放到变量的后面的设计, 是考虑了rust想要类型自动推导.",
    "crumbs": [
      "基础篇",
      "快速入门"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/quick-start.html#immutable",
    "href": "docs/programming/rust/basic/quick-start.html#immutable",
    "title": "rust 快速入门",
    "section": "2 immutable",
    "text": "2 immutable\nfn main() {\n    // 变量默认不可变\n    let a: i32 = 5;\n    // a=2;  会直接报错,提示不能修改 不可变的变量\n    println!(\"{:p}\", &a);\n\n    // 申明可变变量\n    let mut c: i32 = 5;\n    c = 7;\n    println!(\"{c}\");\n}",
    "crumbs": [
      "基础篇",
      "快速入门"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/quick-start.html#shadowing",
    "href": "docs/programming/rust/basic/quick-start.html#shadowing",
    "title": "rust 快速入门",
    "section": "3 shadowing",
    "text": "3 shadowing\nfn main() {\n    let a: i32 = 5;\n    // a=2;  会直接报错,提示不能修改 不可变的变量\n    println!(\"{:p}\", &a);\n    // shadowing  隐藏了上面的变量a\n    let a: i32 = 5;\n    // 与上面的地址不同, 已经是一个不同的变量了,只是用了相同的变量名\n    // 一开始申明的a 被隐藏了\n    println!(\"重新申明的a变量地址: {:p}\", &a);\n\n    let b = 5i32;\n    {\n        // 在这个作用域中, b 也确实shadowing 了外面的b\n        let b = 8i32;\n        println!(\"b 在作用域中的值: {b}\"); // 是8\n    }\n    // 但是在退出块作用域后, b还是5\n    println!(\"作用域外,b的值:{b}\");\n\n    // shadowing 可以使用完全不同的类型, 因为实际就是2个完全不同的变量\n    let b = \"abc\";\n    println!(\"{b}\");\n}\n一个变量转换类型后,想要用原来的变量名, 就用shadowing方式使用同名变量即可\n\n\n希望变量一开始可读写,之后想要弄成只读\n\nfn main() {\n    let mut a = vec![1, 2, 3];\n    a.push(4);\n    // 这以后就是只读的了. 可以称为冻结\n    let a = a;\n}\n\nfn main() {\n    // 不可变\n    let a = vec![1, 2, 3];\n    // 通过获取所有权, 这里又可以变成可变\n    let mut a = a;\n    a.push(4);\n}",
    "crumbs": [
      "基础篇",
      "快速入门"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/quick-start.html#原生类型",
    "href": "docs/programming/rust/basic/quick-start.html#原生类型",
    "title": "rust 快速入门",
    "section": "4 原生类型",
    "text": "4 原生类型\n\nprimitive type\n\n\n4.1 标量类型\n\nscalar type\n\n\n\n\n\n\n\nTip\n\n\n\n标量类型是指那些不可再分的、基本的、单个值的数据类型。 标量类型通常用于存储单一的数据项，如一个数字、一个字符或一个布尔值。 与标量类型相对的是复合数据类型，如数组、列表、对象和结构体，这些类型可以包含多个值\n\n\n\n4.1.1 整型\n\n介绍一些方法\n\n\nuse std::mem;\nfn main() {\n    // 有符号 i8 i16 i32 i64 i128 isize(根据系统架构决定)\n    // 无符号 u8 u16 u32 u64 u128 usize(根据系统架构决定)\n    let a=6;  // 不写类型,默认就是i32\n    // 打印i32类型的大小\n    println!(\"{}\",mem::size_of::&lt;i32&gt;());\n    // 打印变量占用的内存大小\n    println!(\"{}\",mem::size_of_val(&a));\n    let mut inferred_type = 12; // 根据下一行的赋值推断为 i64 类型\n    inferred_type = 4294967296i64;\n    // 十进制 2_100  下划线只是为了增加可读性, 这里相当于美国的千位加,的意思\n    let b:i32=2_100;\n    println!(\"{}\",b);\n    // hex 16进制 0x 开头\n    let c:i32=0xff;\n    println!(\"{}\",c);\n    // 八进制 0o 开头\n    let d:i32=0o12;\n    println!(\"{}\",d);\n    // 二进制\n    let e:i32=0b1111_0000;\n    println!(\"{}\",e);\n    // byte \n    let f:u8=b'A';\n    println!(\"{}\",f);  \n    // 可以使用类型后缀, 在值后边写上\n    let g=5i16;\n    println!(\"{}\",g);\n}\n\n\nfn main() {\n    println!(\"{}\", i32::MAX); // i32最大值\n    println!(\"{}\", 2_u16.pow(4)); // 求指数幂\n    println!(\"{}\", (-4_i32).abs()); // 求绝对值\n    println!(\"{}\", 0b0011_1101_u8.count_ones()); // 位计数(多少个1)\n    // 可以使用这种方式来调用方法\n    println!(\"{}\", i32::abs(-4));\n    println!(\"{}\", i8::count_zeros(0b0011_1101));\n\n    // Checked_ 操作返回一个结果的 Option 值：如果运算结果可以被结果类型正确表示就返\n    // 回 Some(v)，否则返回 None\n    assert_eq!((10_u8).checked_add(20), Some(30));\n    assert_eq!((100_u8).checked_add(200), None);\n\n    // wrapping_ 的结果是对 2的8次方 256的取模得到的余数\n    assert_eq!(16_u8.wrapping_mul(15), 240);\n    assert_eq!(18_u8.wrapping_mul(15), 14);\n\n    // 有符号数的操作可能会回环成负数。\n    // 0111 1111 + 1  =&gt;1000 0000 补码的 -128\n    assert_eq!(127_i8.wrapping_add(1), -128);\n    // 0111 1111 + 1+1  =&gt; 补码 1000 0001 =&gt; 反码:1000 0000 ==&gt; 1111 1111 原码\n    assert_eq!(127_i8.wrapping_add(2), -127);\n\n    // 在移位操作中，移动的位数会回环到该类型的位数之内\n    // 因此对 8位的数字移动 9位等于移动 1位\n    // 0000 0101 相当于左移 1位=&gt; 0000 1010\n    assert_eq!(5_i8.wrapping_shl(9), 10);\n\n    // Saturating_ 操作会返回最接近正确结果的表示,结果被“截断”到这个类型能表示的最大或最小值\n    assert_eq!(127_i8.saturating_add(1), 127);\n\n    // Overflowing_ 操作返回一个 tuple (result, overflowed)，其中result 是回环版本的方法\n    // 返回的结果，而 overflowed 是一个指示是否发生溢出的 bool 值：\n    assert_eq!(255_u8.overflowing_sub(2), (253, false));\n    assert_eq!(255_u8.overflowing_add(2), (1, true));\n    // 只有当位移距离大于等 于类型的位宽度时 overflowed 才为 true\n    // 实际的移位距离等于要求的距离对位宽度取余后的结果\n    // 0000 0101 相当于左移1位 (9%8)=&gt; 0000 1010\n    assert_eq!(5_u8.overflowing_shl(9), (10, true));\n    // 0000 0101 左移6位=&gt; 1 0100 0000: 64\n    assert_eq!(5_u8.overflowing_shl(6), (64, false));\n    // is_numeric 数字,字符0-9 , 还有这以外,也有是数字的\n    println!(\"{}\", '①'.is_numeric());  //true\n}\n\n\n\n\n\n4.1.2 浮点数\n\n介绍一些方法提供的一些常量\n\n\nfn main() {\n    let x = 2.0; // 不写类型,默认就是f64\n    let y: f32 = 3.0; // f32\n    // 科学计数法\n    let a = 1e6; // f64类型\n    let b = 7.6e-4; // f64类型\n    println!(\"a is {}\", a);\n    println!(\"a is {}\", b);\n}\n\n\nfn main() {\n    // 平方根\n    println!(\"{}\", 8f32.sqrt());\n    println!(\"{}\", 8.2f32.floor()); // 8\n    println!(\"{}\", 8.9f32.floor()); // 8\n    println!(\"{}\", (-8.9f32).floor()); // -9\n    // 方法调用的优先级高于前缀运算符，因此对负数调用方法时确保要用括号括起来\n    println!(\"{}\", -8.9f32.floor()); // -8\n    println!(\"{}\", 8.2f32.round()); // 8\n    println!(\"{}\", 8.5f32.round()); // 9\n}\n\n\nuse std::f32::consts;\nfn main() {\n    // rust 提供了一些常量, 比如 PI\n    println!(\"{}\", consts::PI);\n}\n\n\n\n\n\n4.1.3 bool\nfn main() {\n    let t = true;\n    println!(\"{t}\");\n    // 同样必须初始化,否则报错\n    let f: bool = false;\n    println!(\"{f}\"); // false\n    // bool 可以转 整型\n    let d = false as i8;\n    println!(\"{d}\"); // 0\n    // 整型不能转 bool\n    //    let c = 1i8 as bool;\n}\n\n\n4.1.4 char\n\n\n\n\n\n\nTip\n\n\n\nchar 设计的目的是用来存储任何一个unicode 字符, 所以它的大小是4个字节\n\n\nuse std::mem;\n\nfn main() {\n    let c = 'z'; // 这个是字符, 和前面 b'z' 是整型不同哦\n    println!(\"{}\", mem::size_of_val(&c)); // 4\n    let z: char = 'ℤ';\n    println!(\"{c}-{z}\");\n    // rust 中的char 是 4个字节,Unicode, 可以表示表情\n    let heart_eyed_cat = '😻';\n    println!(\"{heart_eyed_cat}\");\n\n    let a = 'a';\n    println!(\"{}\", a as u8); // 97\n    // 标准库提供了函数 std::char::from_u32 接受\n    // 任何 u32 值，并返回 Option&lt;char&gt;：\n        // 如果 u32 的值不是合法的 Unicode 码点，from_u32 会返回 None；\n        // 否则，它会返回 Some(c)，c 就是作为转换结果的 char\n    let hex_char = char::from_u32(97);\n    println!(\"{:?}\", hex_char);\n\n    let tr = '\\n';  // 换行\n    let good = '\\u{597D}'; // 好 unicode\n    println!(\"world {} {}\", tr, good);\n\n    let a = 'c';\n    println!(\"{}\", a.is_alphabetic()); // 是否为字母\n    let b = 'ß'; // 这个是非 ASCII 字符, 很多也被认为是字母\n    println!(\"{}\", b.is_alphabetic()); // true\n}\n\n\n\n4.2 复合类型\n\ncompound type\n\n\n4.2.1 tuple\nfn main() {\n    // 元素可以是多个,且可以是不同的类型, 确定后, \n    // 该元组tup 的类型是(i32, f64, u8),它的大小就固定了\n    let tup: (i32, f64, u8) = (100, 3.14, 2);\n    println!(\"{},{},{}\", tup.0, tup.1, tup.2);\n    let (x, y, z) = tup;\n    println!(\"{},{},{}\", x, y, z);\n}\nuse std::any::type_name;\n\nfn print_type_of&lt;T&gt;(_: &T) {\n    println!(\"{}\", type_name::&lt;T&gt;());\n}\nfn main() {\n    let a = (1,);\n    println!(\"{}\", a.0);\n    let b = (1);\n    print_type_of(&b);\n    // 单元类型,虽然是个元组, 一般会认为它不是复合类型\n    // 函数那里会讲到\n    let c = ();\n}\n\n\n4.2.2 数组\n\n\n\n\n\n\nTip\n\n\n\n\n元素类型必须一致\n长度是固定的,运行时不能修改, 长度是类型的一部分\n表示方法: [T;n] T表示泛型,后面会说, 这里就理解为数组元素的类型, n 表示元素个数\n数组是在栈上分配的单个块的内存\n常用于开辟一个固定大小的Buffer作为缓冲区,比如接收IO输入输出等\n等学了所有权之后,我们知道把数组作为参数传递给函数,是直接复制一份给函数参数,而不是我们某些其他语言里传递指针\n\n\n\nfn main() {\n    let x = [1, 2, 3, 4];  // 默认类型是[i32; 4]\n    println!(\"{}\", x[1]);\n    // [i32;5] 表示每个元素是i32,一共有5个元素\n    let x: [i32; 5] = [1, 2, 3, 4, 5];\n    println!(\"{}\", x.len());\n    // 相当于 let x=[3,3,3,3,3];\n    let x = [3; 5];\n    // 下标读取\n    println!(\"{}\", x[2]);\n\n    // 空数组\n    let x: [i8; 0] = [];\n    println!(\"{}\", std::mem::size_of_val(&x)); // 0\n    // is_empty() 源码就是 判断 self.len() == 0\n    println!(\"{}\", x.is_empty()); // true\n\n    // 数组长度是类型的一部分, 只有元素类型和元素个数一样的才是同一种数组类型\n    let mut a=[1,2,3,4];\n    let b=[2,3,4,5];\n    a=b; // ok\n\n    unsafe {\n        // 可以去看unsafe 章节\n        // 数组的裸指针,类型是数组元素类型 这里是i32\n        let ptr = a.as_ptr();\n        println!(\"{:p}-{:p}\", a.as_ptr(), &a);\n        println!(\"{}-{}\", *ptr, *ptr.wrapping_add(1))\n    }\n}\n\n\n\n\n\n\nCaution\n\n\n\n\n数组不鼓励用索引进行操作, 因为我们知道每次索引操作都会进行边界检查,看不是是溢出了,效率略有影响\n推荐后面说到的迭代器\n\n\n\n\n\n多维数组\n\nfn main() {\n    let x: [[i32; 2]; 5] = [[1, 11], [2, 22], [3, 33], [4, 44], [5, 55]];\n    for i in &x {\n        println!(\"x {:?}\", i);\n    }\n}\n\n\n\n4.2.3 切片\n\n\n\n\n\n\nNote\n\n\n\n\n医学上切片的意思是将组织样本切成薄片以便于在显微镜下观察,可以说切片是原物品的一部分\n编程上切片的意思: 原数据一段连续部分的引用,不难推断出它的数据结构是一个原数据的地址和引用的长度\n\n\n\nuse std::mem;\nfn main() {\n    let mut x = [1, 2, 3];\n    println!(\"{}\", mem::size_of_val(&x));  // 12\n    println!(\"{:p}\", x.as_ptr());\n    // 切片是对一块连续内存数据的引用\n    // 由2个部分组成, 一个是data指向数据,一个len 表示长度\n    // 这种比一般指针要多出一些信息的叫 胖指针\n    let y = &mut x[1..3];\n    println!(\"{:p}\", y.as_ptr());\n    println!(\"{}\", y.len());\n    println!(\"{}\", mem::size_of_val(&y));  // 16\n\n    let x = [1, 2, 3, 4, 5];\n    let (a, b) = x.split_at(2);\n    println!(\"{:?}\", a); // [1,2]\n    println!(\"{:?}\", b); // [3,4,5]\n}\n// &[T] 切片的表示方式\nfn analyze_slice(slice: &[i32]) {\n    println!(\"First element of the slice: {}\", slice[0]);\n    println!(\"The slice has {} elements\", slice.len());\n}\nfn main() {\n    let x: [i32; 5] = [2, 1, 4, 3, 5];\n    let y = &x[1..3];\n    analyze_slice(&y);\n\n    let mut chaos = [3, 5, 4, 1, 2];\n    //这里会隐式的把数组的引用转换为切片\n    chaos.sort();\n    println!(\"{:?}\", chaos);\n    chaos.reverse();\n    println!(\"{:?}\", chaos);\n\n    let x: [i32; 5] = [2, 1, 4, 3, 5];\n    // 也是隐式地转换为切片类型,才会可以for 循环\n    for i in &x {\n        println!(\"x {}\", i);\n    }\n}",
    "crumbs": [
      "基础篇",
      "快速入门"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/quick-start.html#类型转换",
    "href": "docs/programming/rust/basic/quick-start.html#类型转换",
    "title": "rust 快速入门",
    "section": "5 类型转换",
    "text": "5 类型转换\n\n\n\n\n\n\nImportant\n\n\n\n\nRust 不提供原生类型 之间的隐式类型转换(coercion),但可以使用 as 关键字进行显式类型转换(casting)\nrust 是静态强类型, 需要显示表明你要转换的类型\n\n\n\n\n5.1 as\nfn main() {\n    let a: i8 = 9;\n    // 需要加上 as, 否则报错\n    let b: i32 = a as i32;\n    println!(\"{}\",b);\n}\n\n\n5.2 transmute\n\n\n\n\n\n\nCaution\n\n\n\n不安全的转换, 需要 unsafe\n\n\n\nuse std::mem;\nuse std::any::type_name;\n\nfn print_type_of&lt;T&gt;(_: &T) {\n    println!(\"{}\", type_name::&lt;T&gt;());\n}\nfn main() {\n    // 这个元素的类型会根据你后面的transmute 里的src-type 来推断\n    // 之前在数组那里我们了解到  let x = [1, 2, 3, 4]; =&gt; 默认类型是[i32; 4]\n    let raw_bytes = [1, 2, 3, 4];\n    print_type_of(&raw_bytes);\n    // transmute::&lt;src-type, dst-type&gt;(src:src-type)\n    let num = unsafe { std::mem::transmute::&lt;[u8; 4], u32&gt;(raw_bytes) };\n    // 100 00000011 00000010 00000001\n    println!(\"{:b}\", num);\n    println!(\"{}\", num); // 67305985\n    let num = 67305985u32;\n    let r = unsafe { std::mem::transmute::&lt;u32, [u8; 4]&gt;(num) };\n    println!(\"{:?}\", r);  // [1, 2, 3, 4]\n}\n指针类型转换\nfn main() {\n    let a = 67109377;\n    // 将变量a的地址 转换为一个指针 ,指针类型是i32,这个就是a原来的内存读取方式\n    // 然后再将这个指针 进行类型转换, 转换为 数组的方式来读取 a 所在的那块内存\n    let r1 = &a as *const i32 as *mut [i8; 4];\n    unsafe {\n        println!(\"{:?}\", (*r1));\n        (*r1)[0] = 5;\n        println!(\"{:?}\", (*r1));\n        println!(\"{}\", a);\n    }\n}\n\n\n\n\n\n\nWarning\n\n\n\n下面这个操作, 没有得到你想要的结果, 元组可能因为内存对齐的原因, a的前2个字节组成元组的第二个元素, 看看就好.\n\n\nfn main() {\n    let a = 67244033i32;\n    //用 元组的形式区读取原本 a的那块内存\n    let d = unsafe { std::mem::transmute::&lt;&i32, &(i8, i16, i8)&gt;(&a) };\n    println!(\"{:?}\", d);\n}\n\n\n可变转换,然后可如此这般修改原来的数据\n\nfn main() {\n    let mut a = 67244033i32;\n    //用 元组的形式区读取原本 a的那块内存\n    let d = unsafe { std::mem::transmute::&lt;&mut i32, &mut [i8; 4]&gt;(&mut a) };\n    println!(\"{:?}\", d); // [1, 16, 2, 4]\n    d[0] = 3;\n    println!(\"{:?}\", d); // [3, 16, 2, 4]\n    println!(\"{}\", a); //67244035\n}\n\n\n\n5.3 使用trait\n直接看 类型转换相关trait",
    "crumbs": [
      "基础篇",
      "快速入门"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/quick-start.html#类型别名",
    "href": "docs/programming/rust/basic/quick-start.html#类型别名",
    "title": "rust 快速入门",
    "section": "6 类型别名",
    "text": "6 类型别名\n// 定义一个类型别名\n// 这使得代码更加简洁,更具可读性, 因为 Coordinates 比 (f64, f64) 更能表达其用途\ntype Coordinates = (f64, f64);\n\n// 使用类型别名\nfn calculate_distance(point1: Coordinates, point2: Coordinates) -&gt; f64 {\n    let (x1, y1) = point1;\n    let (x2, y2) = point2;\n    ((x2 - x1).powi(2) + (y2 - y1).powi(2)).sqrt()\n}\n\nfn main() {\n    let point_a: Coordinates = (0.0, 0.0);\n    let point_b: Coordinates = (3.0, 4.0);\n    let distance = calculate_distance(point_a, point_b);\n    println!(\"距离: {}\", distance);\n}\nfn main() {\n    // 类型别名\n    // 让类型含义更加的有意义\n    type Kilometers = i32;\n\n    let x: i32 = 5;\n    let y: Kilometers = 5;\n    // 实际还是是i32 所以可以 +\n    println!(\"x + y = {}\", x + y);\n}\n\n\n\n\n\n\nCaution\n\n\n\n下面几个例子,有些知识点在后续介绍\n\n\n减少重复代码, 让代码更简洁\n    type Thunk = Box&lt;dyn Fn() + Send + 'static&gt;;\n\n    let f: Thunk = Box::new(|| println!(\"hi\"));\n\n    fn takes_long_type(f: Thunk) {\n        // --snip--\n    }\n\n    fn returns_long_type() -&gt; Thunk {\n        // --snip--\n    }\n我们可以看到 Result&lt;usize, Error&gt; 类似这样的很多, 都要写Error\nuse std::fmt;\nuse std::io::Error;\n\npub trait Write {\n    fn write(&mut self, buf: &[u8]) -&gt; Result&lt;usize, Error&gt;;\n    fn flush(&mut self) -&gt; Result&lt;(), Error&gt;;\n\n    fn write_all(&mut self, buf: &[u8]) -&gt; Result&lt;(), Error&gt;;\n    fn write_fmt(&mut self, fmt: fmt::Arguments) -&gt; Result&lt;(), Error&gt;;\n}\nfn main() {}\n使用别名后的情况\nuse std::fmt;\n// std::io 中有这样一个别名\n// 标准库中类似这样的别名设计有还多\n// type Result&lt;T&gt; = std::result::Result&lt;T, std::io::Error&gt;;\n\n// 我们本地这样设计一个别名, 就不用每次 都写上Error\ntype Result&lt;T&gt; = std::io::Result&lt;T&gt;;\npub trait Write {\n    fn write(&mut self, buf: &[u8]) -&gt; Result&lt;usize&gt;;\n    fn flush(&mut self) -&gt; Result&lt;()&gt;;\n\n    fn write_all(&mut self, buf: &[u8]) -&gt; Result&lt;()&gt;;\n    fn write_fmt(&mut self, fmt: fmt::Arguments) -&gt; Result&lt;()&gt;;\n}\nfn main() {}",
    "crumbs": [
      "基础篇",
      "快速入门"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/quick-start.html#静态变量",
    "href": "docs/programming/rust/basic/quick-start.html#静态变量",
    "title": "rust 快速入门",
    "section": "7 静态变量",
    "text": "7 静态变量\n\n\n\n\n\n\nImportant\n\n\n\n\n使用 static ,一般在所有其他作用域之外声明, 作为全局变量\n\n\n\n\n\n不可变静态变量\n\nstruct Animal {\n    age: i32,\n}\nimpl Drop for Animal {\n    fn drop(&mut self) {\n        println!(\"animal 离开作用域了...{}\", self.age);\n    }\n}\nfn main() {\n    let a = 22;\n    {\n        // 申明时必须初始化,必须指定类型\n        static b: Animal = Animal { age: 11 };\n    }  // 不会调用 drop , 虽然无法访问b, 但是它不会被释放内存\n    let c = 11;\n    println!(\"{}\", a);\n    {\n        let d = Animal { age: 100 };\n    } // 这个会调用drop\n    println!(\"{}\", c);\n}\n\n\n\n可变的静态变量,修改需要unsafe\n\nstatic mut COUNTER: u32 = 0;\nfn add_to_count(inc: u32) {\n    unsafe {\n        COUNTER += inc;\n    }\n}\n\nfn main() {\n    add_to_count(3);\n\n    println!(\"COUNTER: {}\", unsafe { COUNTER });\n}\n\nstatic mut COUNTER: u32 = 22;\nconst COUNTER2: i32 = 11;\nstatic mut S1: &str = \"hello\";\nconst S2: &str = \"world\";\n\nfn main() {\n    println!(\"{:p}\", &COUNTER2);\n    unsafe {\n        println!(\"{:p}\", &COUNTER);\n    }\n    unsafe {\n        let s11 = S1.as_ptr(); // *const u8\n        println!(\"S1 指向的字符所在内存地址: {:p}\", s11);\n        println!(\"{}\", *s11); // 第一个h 字符\n        S1 = \"world\";\n        let s11 = S1.as_ptr();\n        // let s11 = S1.as_ptr() as *mut u8;\n        println!(\"S1 新指向的字符所在内存地址: {:p}\", s11);\n        println!(\"{}\", *s11);\n        let s22 = S2.as_ptr();\n        println!(\"S2 指向的字符所在内存地址:{:p}\", s22);\n    }\n}\n如果需要第一次使用才去初始化的静态变量 ,可以使用库once_cell,lazy_static",
    "crumbs": [
      "基础篇",
      "快速入门"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/quick-start.html#常量",
    "href": "docs/programming/rust/basic/quick-start.html#常量",
    "title": "rust 快速入门",
    "section": "8 常量",
    "text": "8 常量\n\n\n\n\n\n\nImportant\n\n\n\n\n常量是在编译期就进行求值的. 所以常量 = 的右边是可以使用表达式的\n常量在编译过程中会被内联优化,这个表示每个使用常量的地方都会直接替换为常量的值(如果没记错的话, 可类比汇编中的立即数..),不会占用内存\n因此修改常量的值本身就没有意思\n\n\n\nconst A: u32 = 60 * 60 * 3;\n\nfn main() {\n    // 一般用大写并且下划线来申明常量\n    // 不可修改, 不可shadowing\n    // 不可以使用mut,永远不可变\n    // 可以在任何作用域申明\n    const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;\n    println!(\"{}\", THREE_HOURS_IN_SECONDS);\n}\n\n\nconst fn\n\n// 编译期执行\nconst fn g() -&gt; i32 {\n    // 返回值视为常量\n    10 * 20\n}\nconst A: i32 = g();\nfn main() {\n    println!(\"{}\", A);\n}",
    "crumbs": [
      "基础篇",
      "快速入门"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/quick-start.html#函数",
    "href": "docs/programming/rust/basic/quick-start.html#函数",
    "title": "rust 快速入门",
    "section": "9 函数",
    "text": "9 函数\n\n\n\n\n\n\nTip\n\n\n\n\n语句: 执行动作, 没有返回值\n表达式: 是有一个值的\n函数体是由一系列语句和一个结尾(可以是语句或者表达式)组成\nunit type 单元类型 () 表示一种类型. 表示没有什么特殊的价值, 它的值就是它本身 也是()\n\n\n\n\n9.1 返回值\nfn five() -&gt; i32 {\n    // 表达式 ,值为5\n    5\n}\n\nfn main() {\n    let x = five();\n\n    println!(\"The value of x is: {x}\");\n}\n添加;号试试, 会直接报错提示 期望i32, 而实际发现是the unit type ()\n// -&gt; i32 , 表示返回值类型\nfn five() -&gt; i32 {\n    5;\n}\n我们将上面的返回值类型改成 () , 这样就不会报错了\nfn five() -&gt; () {\n    5;\n}\n实际上就是不用写返回值 的类型\n// 没有指明返回值的, 那么返回值类型就是 unit type :()\nfn five(){\n    5;\n}\nfn main() {\n    // 单元值判断\n    if five() == () {\n        // ok的\n        println!(\"ok\");\n    }\n}\nfn t() {\n    // 这里返回了5, 要求的是(),所以会提示错误\n    5\n}\n\n\n9.2 函数作为参数\nfn calc(m: fn(u32, u32) -&gt; u32, a: u32, b: u32) {\n    println!(\"add result: {}\", m(a, b));\n}\nfn add(a: u32, b: u32) -&gt; u32 {\n    a + b\n}\nfn main() {\n    calc(add, 1, 2);\n}\n\n\n9.3 函数作为返回值\n\n// 传入字符串:函数名,获取函数\nfn calc(m: &str) -&gt; fn(u32, u32) -&gt; u32 {\n    match m {\n        \"add\" =&gt; add,\n        _ =&gt; unimplemented!(),\n    }\n}\nfn add(a: u32, b: u32) -&gt; u32 {\n    a + b\n}\n\nfn main() {\n    let f = calc(\"add\");\n    let r = f(1, 2);\n    println!(\"{}\", r);\n}\n\n\n9.4 函数内部创建函数\nfn main() {\n    // 函数内部可以定义函数\n    fn add(t1: i32, t2: i32) -&gt; i32 {\n        t1 + t2\n    }\n    let r = add(1, 2);\n    print!(\"{}\", r);\n}\n\n\n9.5 函数的类型\nfn add1(t: (i32, i32)) -&gt; i32 {\n    t.0 + t.1\n}\n// 实际看来 与add1 参数一样\nfn add2((t1, t2): (i32, i32)) -&gt; i32 {\n    t1 + t2\n}\nfn main() {\n    let a = 1;\n    let b = 2;\n    let c = (1, 2);\n    println!(\"{}\", add1(c));\n    println!(\"{}\", add2((a, b)));\n\n    // f1的类型是 fn (t: (i32, i32)) -&gt; i32\n    let f1 = add1;\n    // 报错了 expected fn item, found a different fn item\n    // 不同的类型, 所以报错了.\n    // f1 = add2;\n\n    // 正确的方式是 定义变量时将 他的类型转换为 fn item 通用的fn 类型\n    let f1 = add1 as fn((i32, i32)) -&gt; i32;\n    println!(\"{}\", f1((1, 2)));\n\n    // 这样定义也可以\n    let mut f1: fn((i32, i32)) -&gt; i32 = add1;\n    f1 = add2; // 不会报错了\n    println!(\"{}\", f1((a, b)));\n}\n\n\n9.6 发散函数\n\ndiverging functions\n\n返回值是 ! ,被称为 The Never Type\n我们知道前面提到的函数其实都是有返回值, 即使是没有返回值的函数, 也会返回一个 () 单元类型的值:()\n那么一个 永远不会返回的函数它有返回值吗? 还有 panic 这种函数呢?\nfn main() {\n    let a = bar();\n    a=2;// 虽然不会执行到这里, 但是编译器不会报错\n    println!(\"{}\", a);\n}\n// 返回 ! never type\nfn bar() -&gt; ! {\n    // 永远不会返回,但是有rust 设计它有返回值, 类型是!\n    loop {\n        print!(\"and ever \");\n    }\n}\n\nfn foo() -&gt;!{\n    panic!(\"error\");\n}\n\n9.6.1 为什么需要发散类型\n下面我们都知道会报错\nfn main() {\n    let guess = \"42\";\n    let guess = match guess.trim().parse() {\n        Ok(_) =&gt; 5,\n        Err(_) =&gt; \"hello\", // 报错了\n    };\n}\n下面这个没有报错\nfn main() {\n    let r = bar();\n}\nfn bar() -&gt; ! {\n    let guess = \"42\";\n    loop {\n        let guess = match guess.trim().parse::&lt;i32&gt;() {\n            Ok(_) =&gt; 5,\n            // ! 发散类型可以被转换为任何类型\n            Err(_) =&gt; continue, \n        };\n    }\n}\nfn main() {\n    let r = bar(0);\n    println!(\"{:?}\", r);\n}\nfn bar(x: i32) -&gt; i32 {\n    if x == 0 {\n        // 这里panic 了, 但是函数没有报错\n        panic!(\"no 0\");\n    } else {\n        x * 2\n    }\n}",
    "crumbs": [
      "基础篇",
      "快速入门"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/quick-start.html#控制流程",
    "href": "docs/programming/rust/basic/quick-start.html#控制流程",
    "title": "rust 快速入门",
    "section": "10 控制流程",
    "text": "10 控制流程\n\n10.1 if\nfn main() {\n    let number = 3;\n    // 报错的, 需要bool类型\n    if number {\n        println!(\"number was three\");\n    }\n\n    let condition = true;\n    // 当成 三元 运算, 实际上这里的表达更加清晰,一看就明白\n    // 而三元运算你是需要稍微学习或者说记一下\n    // 这也是有些语言它不去支持三元运算的原因\n    let number = if condition { 5 } else { 6 };\n\n    println!(\"The value of number is: {number}\");\n    let number2 = if condition {\n        5;\n        7  // 还是看的返回值\n    } else {\n        6\n    };\n\n    println!(\"The value of number is: {number2}\");\n\n    // 报错\n    let number3 = if condition { 5 } else { \"six\" };\n}\n\n\n10.2 loop\nfn main() {\n    let mut i = 0;\n    let ret = loop {\n        i += 1;\n        if i &gt; 10 {\n            break i; // 返回值, 就是loop的返回值\n        }\n    };\n    println!(\"{}\", ret)\n\n    let y: i32;\n    // 编译器是能够判断出 后面的打印时, y肯定已经赋值了.\n    let x = loop {\n        y = 1;\n        break;\n    };\n    println!(\"{:?}\", x);\n    println!(\"{:?}\", y);\n}\n跳出多层 loop\n#![allow(unreachable_code, unused_labels)]\nfn main() {\n    'outer: loop {\n        println!(\"Entered the outer loop\");\n\n        'inner: loop {\n            println!(\"Entered the inner loop\");\n            // This would break only the inner loop\n            //break;\n            // This breaks the outer loop\n            break 'outer;\n        }\n        println!(\"This point will never be reached\");\n    }\n    println!(\"Exited the outer loop\");\n}\n\n\n10.3 for\n\n\n\n\n\n\nCaution\n\n\n\n\nfor 循环是利用迭代器对数据进行遍历的,参考后面迭代器章节\n标签 label的使用方式与loop一样\n\n\n\nfn main() {\n    // label 前面有个 ' 单引号\n    'outer: for i in 0..5 {\n        println!(\"Outer loop value: {}\", i);\n\n        for j in 0..5 {\n            println!(\"Inner loop value: {}\", j);\n\n            if i == 2 && j == 3 {\n                break 'outer;\n            }\n        }\n    }\n\n    let a = [10, 20, 30, 40, 50];\n\n    for element in a {\n        println!(\"the value is: {element}\");\n    }\n\n    // (1..4)  1 2 3\n    // 会提示不需要 用 () 将1..4 阔气来\n    for number in (1..4) {\n        println!(\"{number}!\");\n    }\n    // 不包含4\n    for number in 1..4 {\n        println!(\"{number}!\");\n    }\n    // =4 包含4\n    for number in 1..=4 {\n        println!(\"{number}\");\n    }\n\n    for number in 1.. {\n        if number == 10 {\n            break;\n        }\n        println!(\"{}\", number);\n    }\n\n    use std::ops::Range;\n    let a = Range { start: 1, end: 10 };\n    for j in a {\n        println!(\"{}\", j);\n    }\n    // x 实际上是一个RangeFrom&lt;i32&gt; 类型\n    // 0..5 这种实际就是一个语法糖\n    let x = (0..);\n    // x 实际为Range类型\n    let x = (0..5);\n}\n数组来测试 range\n\n#[cfg(test)] //配置测试模块\nmod abc {\n    #[test] //单元测试用例\n    fn it_works() {\n        let result = 2 + 2;\n        assert_eq!(result, 4);\n    }\n    #[test]\n    fn arr_range() {\n        let arr = [0, 1, 2, 3, 4];\n        assert_eq!(arr[..], [0, 1, 2, 3, 4]);\n        assert_eq!(arr[..3], [0, 1, 2]);\n        assert_eq!(arr[..=3], [0, 1, 2, 3]);\n        assert_eq!(arr[1..], [1, 2, 3, 4]);\n        assert_eq!(arr[1..3], [1, 2]); // This is a `Range`\n        assert_eq!(arr[1..=3], [1, 2, 3]);\n        assert_eq!((3..5), std::ops::Range { start: 3, end: 5 });\n    }\n}\n\n\n10.4 while\nfn main() {\n    let z: i32;\n    while true {\n        z = 1;\n        break;\n    }\n    // 打印这个的时候, 编译器无法直到 z到底是不是赋值了,\n    // 因为他认为while 能否进去是要判断的,\n    // 当然我们一看就知道是true 能进去,但是编译器不行\n    // 相比while loop 肯定是能进去的.\n    println!(\"{}\", z); //报错了\n}",
    "crumbs": [
      "基础篇",
      "快速入门"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/quick-start.html#测试",
    "href": "docs/programming/rust/basic/quick-start.html#测试",
    "title": "rust 快速入门",
    "section": "11 测试",
    "text": "11 测试\n#[cfg(test)]  //配置测试模块\nmod tests {\n    #[test]  //单元测试用例\n    fn it_works() {\n        let result = 2 + 2;\n        assert_eq!(result, 4);\n    }\n    // 再来一个测试用例\n    #[test]\n    fn it_works2() {\n        let result = 2 + 2;\n        assert_eq!(result, 4);\n    }\n}\ncargo test",
    "crumbs": [
      "基础篇",
      "快速入门"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/quick-start.html#查看汇编",
    "href": "docs/programming/rust/basic/quick-start.html#查看汇编",
    "title": "rust 快速入门",
    "section": "12 查看汇编",
    "text": "12 查看汇编\nrustc --emit=asm main.rs\nrustc -C debuginfo=1 -o output.s --emit asm -Cllvm-args=--x86-asm-syntax=intel --crate-type rlib  --edition 2021 src/main.rs\nrust-lang playground里可以选择asm 查看  godbolt",
    "crumbs": [
      "基础篇",
      "快速入门"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/quick-start.html#打印信息",
    "href": "docs/programming/rust/basic/quick-start.html#打印信息",
    "title": "rust 快速入门",
    "section": "13 打印信息",
    "text": "13 打印信息\n\n13.1 打印变量大小\nfn main() {\n    let a = 6;\n    println!(\"{}\", std::mem::size_of::&lt;i32&gt;());\n    // 打印变量占用的内存大小\n    println!(\"{}\", std::mem::size_of_val(&a));\n}\n\n\n13.2 打印变量类型名\nuse std::any::type_name;\n\nfn print_type_of&lt;T&gt;(_: &T) {\n    println!(\"{}\", type_name::&lt;T&gt;());\n}\n\nfn main() {\n    let x = 42;\n    print_type_of(&x); // 输出: i32\n\n    let y = 3.14;\n    print_type_of(&y); // 输出: f64\n\n    let z = \"hello\";\n    print_type_of(&z); // 输出: &str\n}\n\n\n13.3 常用打印\n\nformat!: 格式化文本到 String\nprint!: 同format! 只不过输出到 (io::stdout).\nprintln!: 同print! 但是换行\neprint!: 同 print! 只不过输出到 (io::stderr).\neprintln!: 同eprint! 但是换行\n\nfn main() {\n    println!(\"{} days\", 31);\n    // 多个可以使用 0 1 指定\n    println!(\"{0}, this is {1}. {1}, this is {0}\", \"Alice\", \"Bob\");\n    let x = \"Alice\";\n    let y = \"Bob\";\n    println!(\"{x}, this is {y}. {y}, this is {x}\");\n    println!(\"{a}, this is {b}. {b}, this is {a}\", a = \"Alice\", b = \"Bob\");\n    println!(\"Base 10:               {}\", 69420); // 69420\n    println!(\"Base 2 (binary):       {:b}\", 69420); // 10000111100101100\n    println!(\"Base 8 (octal):        {:o}\", 69420); //八进制: 207454\n    println!(\"Base 16 (hexadecimal): 0x{:x}\", 69420); //16进制: 10f2c\n    println!(\"Base 16 (hexadecimal): 0x{:X}\", 69420); //大写16进制: 10F2C\n    println!(\"科学计数法: {:e}\", 10000i32); // 1e4\n    println!(\"科学计数法 大写: {:E}\", 10000i32); // 1E4\n    println!(\"带换行和缩进的debug打印: {:#?}\", [1, 2, 3]);\n    println!(\"debug打印: {:?}\", [1, 2, 3]);\n    // &gt; 表示往右对齐,那么就是左边填充\n    println!(\"|{number:&gt;5}|\", number = 1); // 没写表示用空格填充, 4个空格 和一个1\n    println!(\"{number:0&gt;5}\", number = 1); // 用0填充 :   00001\n    println!(\"{number:0&lt;5}\", number = 1); // 用0填充 :   10000\n    // 注意 需要 $\n    println!(\"{number:0&gt;width$}\", number = 1, width = 5);\n\n\n    let number: f64 = 1.0;\n    let width: usize = 5;\n    println!(\"{number:&gt;width$}\");\n\n    // 浮点数 四舍五入\n    println!(\"Dog: {:.3} \", 1.12385); // 1.124\n}\n\n\n13.4 Debug\n\n\n\n\n\n\nTip\n\n\n\n\n所有实现了fmt::Debug这个trait(暂时不用管这个概念)的类型,才能使用println!(\"{:?}\")中{:?}或{:#?}这种打印方式\n可自动推导,使用 #[derive(Debug)]\n\n\n\nstruct Cat(i32);\n\n#[derive(Debug)] // 添加这个就自动实现了Debug trait\nstruct Dog(i32);\nfn main() {\n    println!(\"Cat: {:?} \", Cat(5)); // 报错了\n    println!(\"Dog: {:?} \", Dog(5)); // ok\n    // 使用这种 {0:?}  {dog:?}\n    println!(\"Dog: {0:?} {dog:?}\", Dog(5), dog = Dog(8));\n}\n\n\n13.5 Display\n\n\n\n\n\n\nTip\n\n\n\n\n所有实现了fmt::Display这个trait(暂时不用管这个概念)的类型,才能使用println!(\"{}\")中{}这种打印方式\n必须手动实现\n\n\n\nuse std::fmt;\nstruct Point2D {\n    x: f64,\n    y: f64,\n}\n\n// implement `Display` for `Point2D`.\nimpl fmt::Display for Point2D {\n    fn fmt(&self, f: &mut fmt::Formatter) -&gt; fmt::Result {\n        // 这里的写法类似 println! ,根据需要自定义输出信息\n        write!(f, \"x: {}, y: {}\", self.x, self.y)\n    }\n}\nfn main() {\n    let p = Point2D { x: 3.3, y: 7.2 };\n    println!(\"p: {}\", p);\n    // 实现了Display, 就能.to_string() 获取字符串 String\n    println!(\"{}\", p.to_string());\n}",
    "crumbs": [
      "基础篇",
      "快速入门"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/quick-start.html#main",
    "href": "docs/programming/rust/basic/quick-start.html#main",
    "title": "rust 快速入门",
    "section": "14 main()",
    "text": "14 main()\n\n14.1 返回值\n\n\n\n\n\n\nImportant\n\n\n\nrust main 入口函数返回值必须实现了Termination trait, trait后面章节讲, 先理解为接口.\n\n\n\n\nstd::process::Termination\n\npub trait Termination {\n    // Required method\n    fn report(self) -&gt; ExitCode;\n}\n\n// 返回值是 (), () 是实现了Termination trait\nfn main(){\n    // 编译运行后, echo $? 结果是0\n}\nfn main() -&gt; ! {\n    // 编译运行后, echo $? 结果是1\n    std::process::exit(1);\n}\nfn main() -&gt; impl std::process::Termination {\n    std::process::ExitCode::SUCCESS\n}\n// 或者返回类型是 Result&lt;T, E&gt; where T: Termination, E: Debug \n其他实现了Termination的 : Infallible.\n\n\n从外部导入作为main方法\n\nmod foo {\n    pub fn bar() {\n        println!(\"Hello, world! rust\");\n    }\n}\n// 从外部crate 或者本地 import 为 main 方法\nuse foo::bar as main;\n// 报错, 这里会提示已经定义了main函数\n// fn main() {}\n\n\n\n14.2 命令行参数\nfn main() {\n    // ./main ac -ver 1.2\n    let args_struct = std::env::args();\n    println!(\"{:?}\", args_struct);\n    let args: Vec&lt;_&gt; = args_struct.collect();\n    println!(\"程序名: {}\", &args[0]);\n    println!(\"命令行参数: {:?}\", &args[1..]); // [\"ac\", \"-ver\", \"1.2\"]\n\n    let first_arg = match args.get(1) {\n        Some(arg) =&gt; arg,\n        None =&gt; {\n            println!(\"没有提供足够的参数\");\n            return;\n        }\n    };\n\n    let number = match first_arg.parse::&lt;i32&gt;() {\n        Ok(num) =&gt; num,\n        Err(_) =&gt; {\n            println!(\"无法将第一个参数解析为整数\");\n            return;\n        }\n    };\n\n    println!(\"第一个参数作为整数是: {}\", number);\n}\n\n\n14.3 环境变量\nfn main() {\n    // 尝试获取环境变量，如果不存在则返回错误\n    match std::env::var(\"HOME\") {\n        Ok(value) =&gt; println!(\"环境变量 HOME 的值是: {}\", value),\n        Err(e) =&gt; println!(\"无法获取环境变量 HOME: {}\", e),\n    }\n\n    // 获取所有环境变量\n    for (key, value) in std::env::vars() {\n        println!(\"{}: {}\", key, value);\n    }\n}",
    "crumbs": [
      "基础篇",
      "快速入门"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/quick-start.html#属性",
    "href": "docs/programming/rust/basic/quick-start.html#属性",
    "title": "rust 快速入门",
    "section": "15 属性",
    "text": "15 属性\n\n15.1 dead_code\n\n\n\n\n\n\nTip\n\n\n\n\n编译器 默认会对 dead_code(死代码, 无效代码) 进行检查, 这会对未使用的函数产生警告. 可以用一个属性来禁用这个检查项\n\n\n\n// 代码头部使用\n// #! 开头的 作用于整个crate\n#![allow(dead_code)]\nfn used_function() {}\n\n// # 开头的 用于模块或项, 这里是只作用于该函数\n// `#[allow(dead_code)]` 属性可以禁用 `dead_code` 检查\n#[allow(dead_code)]\nfn unused_function() {}\n\nfn noisy_unused_function() {}\n\nfn main() {\n    used_function();\n}",
    "crumbs": [
      "基础篇",
      "快速入门"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/env.html",
    "href": "docs/programming/rust/basic/env.html",
    "title": "rust 环境准备",
    "section": "",
    "text": "配置国内源2\n\n\nzshbash\n\n\necho 'export RUSTUP_UPDATE_ROOT=https://mirrors.tuna.tsinghua.edu.cn/rustup/rustup' &gt;&gt; ~/.zshrc\necho 'export RUSTUP_DIST_SERVER=https://mirrors.tuna.tsinghua.edu.cn/rustup' &gt;&gt; ~/.zshrc\n. ~/.zshrc\n\n\necho 'export RUSTUP_UPDATE_ROOT=https://mirrors.tuna.tsinghua.edu.cn/rustup/rustup' &gt;&gt; ~/.bash_profile\necho 'export RUSTUP_DIST_SERVER=https://mirrors.tuna.tsinghua.edu.cn/rustup' &gt;&gt; ~/.bash_profile\n. ~/.bash_profile\n\n\n\n\n然后查看官方安装教程3\n\n\n\n\n安装\n\ncurl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n\n\n\n会提示出下列信息\n\n2   default host triple: x86_64-apple-darwin\n1     default toolchain: stable (default)\n3               profile: default\n  modify PATH variable: yes\n\n\n1\n\n指定toolchain 从 stable channel 中下载最新的工具链\n\n2\n\n很显然工具链是有系统区分的,所以系统会默认给你添加上这个信息(rustup target list命令查看),和指定的stable channel名一起真正构成 toolchain的名字\n\n3\n\n配置下载哪些 components\n\n\n\n安装过程我们可以看到 info: installing component 'rust-docs' 这类信息,说明安装了不少组件\n所有组件的代理程序都安装到 ~/.cargo/bin 这个目录 (看设计思路中图2说明)\ntree ~/.cargo/bin\n~/.cargo/bin\n├── cargo # Rust 的编译工具,包管理器,可以帮助你编译代码,运行,测试...\n├── cargo-clippy\n├── cargo-fmt\n├── cargo-miri\n├── clippy-driver\n1├── rls\n├── rust-analyzer\n├── rust-gdb\n├── rust-gdbgui\n├── rust-lldb\n├── rustc # rust 编译器\n├── rustdoc\n├── rustfmt\n└── rustup\n\n1\n\n由于我们用的profile是default配置, 根据前面的设计思路, 这里的2个是代理程序,实际对应的可执行程序还没有安装, 需要我们额外去安装\n\n\n\n\n\n\n\n\nImportant\n\n\n\n\nrls (需要rust-analysis 配合使用) 已经被 rust-analyzer 取代了 ,所以我们安装 rust-analyzer 即可\nrust-analyzer4, vscode中去安装\n\n\n\n\n\n安装额外需要的组件\n\n# RLS的全称是:'Rust Language Server',是一个守护进程\n# 用于和开发时使用的IDE进行IPC通信,完成代码提示、跳转到定义、显示变量类型等功能\n# rustup component add rls           --toolchain stable    # RLS\n# rustup component add rust-analysis --toolchain stable    # 分析工具\nrustup component add rust-analyzer --toolchain stable\n\n#std是Rust的标准库. 默认情况下,Rust安装的是标准库的二进制码,而添加源码后容易方便我们查询部分标准库的实现\nrustup component add rust-src      --toolchain stable    # std源码\n\n\n环境变量配置\n\n\nzsh\n\n\necho 'source \"$HOME/.cargo/env\"' &gt;&gt; ~/.zshrc\n\n\n\n\n命令自动补全\n\n\n\n用这个命令看如何配置\n\nrustup help completions\n\n\nzsh\n\n\n\n\n\n\n\n\nWarning\n\n\n\n不知道啥情况, 设置后 有一点自动补全,但是 效果很烂\n\n\nmkdir ~/.zfunc\nrustup completions zsh &gt; ~/.zfunc/_rustup\nrustup completions zsh cargo &gt; ~/.zfunc/_cargo\necho 'fpath+=~/.zfunc' &gt;&gt; ~/.zshrc\necho 'autoload -U compinit && compinit' &gt;&gt; ~/.zshrc\n. ~/.zshrc\n\n\n\n\n\n\n\n\nrustup show\n    # Default host: x86_64-apple-darwin\n    # rustup home:  ~/.rustup\n\n    # stable-x86_64-apple-darwin (default)\n    # rustc 1.80.1 (3f5fd8dd4 2024-08-06)\n\n\n查看支持的平台(上面的host)\n\nrustup target list\n\n\n\n\n\n安装查看执行指定工具链里的命令切换查看命令的真实路径更新卸载\n\n\n\n\n\n\n\n\nImportant\n\n\n\nrustup install 命令等同于 rustup toolchain install, 所以可以省略toolchain\n\n\nnightly版本发布情况 stable版本发布情况\n\n直接通过channel 方式安装\n\n1rustup toolchain install beta --profile minimal\n\n1\n\n--profile minimal 前面说过, 配置下载哪些components, 这里表示下载最少的组件\n\n\n\n使用[channel]-[data]的方式安装\n\nrustup toolchain install nightly-2024-07-25 --profile minimal\n国内源资源情况\n\n使用 版本号 &lt;major.minor&gt;或&lt;major.minor.patch&gt;的方式安装\n\n# 临时取消国内源(有些国内源可能没有保留的), 使用官方源下载\nRUSTUP_DIST_SERVER=  rustup toolchain install 1.77 --profile minimal\n\n\n\n\n\n查看安装的toolchain\n\nrustup toolchain list\n\n\n\n结果\n\n1stable-x86_64-apple-darwin (default)\nbeta-x86_64-apple-darwin\nnightly-2024-07-25-x86_64-apple-darwin\nnightly-2024-07-26-x86_64-apple-darwin\nnightly-x86_64-apple-darwin\n1.64-x86_64-apple-darwin\n1.77-x86_64-apple-darwin\n\n\n1\n\ndefault 表示当前我们默认使用的toolchain  我们可以看到现实的toolchain名字都带有 -x86_64-apple-darwin,系统会自动检测,你也可以自己install时加上\n\n\n\n\n\n\n# 指定 toolchain工具链 来执行它里面的 工具\nrustup run stable rustc --version\n# 同上\nrustup run stable-x86_64-apple-darwin rustc --version\n# 因为默认 使用 stable , 所以这里是调用 stable 里的, 同上\nrustc --version\n\n\n\n\n\n\n点击查看执行结果\n\n\n\n\n\nrustc 1.80.1 (3f5fd8dd4 2024-08-06)\n\n\n\n\n\n\n\n\n全局切换\n\n# 看看有哪些 toolchain\nrustup toolchain list\n#   stable/nightly/beta\nrustup default stable\n\n\n\n工作目录切换版本\n\ncd rust项目代码目录\nrustup override set 1.77.2\n# 取消当前工作目录的版本, 重新设置为默认的全局版本\nrustup override unset\n\n\n\n\nrustup which rustc\n\n\n查看结果\n\n~/.rustup/toolchains/stable-x86_64-apple-darwin/bin/rustc\n\n\n\n\n指定toolchain\n\n#  看看指定命令 实际的可执行的位置\nrustup which rustc  --toolchain=nightly-2024-07-25-x86_64-apple-darwin\n\n\n\n\n\n更新rustup 自身\n\nrustup self update\n\n\n\n更新所有toolchain\n\nrustup update\n\n\n\n更新指定toolchain\n\nrustup update nightly\n\n\n\n# 会删除所有的工具链\n# 注意, 卸载后, rustup 本身也没了,需要重新安装\nrustup self uninstall\n\n\n卸载指定toolchain\n\nrustup toolchain uninstall nightly\n\n\n\n\n\n\n\n\n查看添加\n\n\n# 查看默认toolchain下已经安装的组件\nrustup component list --installed\n# 查看指定toolchain下已经安装的组件\nrustup component list --installed --toolchain nightly\n\n\nrustup component add rust-analyzer\n# 指定toolchain\nrustup component add rust-analyzer --toolchain stable",
    "crumbs": [
      "基础篇",
      "环境准备"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/env.html#rustup8",
    "href": "docs/programming/rust/basic/env.html#rustup8",
    "title": "rust 环境准备",
    "section": "",
    "text": "配置国内源2\n\n\nzshbash\n\n\necho 'export RUSTUP_UPDATE_ROOT=https://mirrors.tuna.tsinghua.edu.cn/rustup/rustup' &gt;&gt; ~/.zshrc\necho 'export RUSTUP_DIST_SERVER=https://mirrors.tuna.tsinghua.edu.cn/rustup' &gt;&gt; ~/.zshrc\n. ~/.zshrc\n\n\necho 'export RUSTUP_UPDATE_ROOT=https://mirrors.tuna.tsinghua.edu.cn/rustup/rustup' &gt;&gt; ~/.bash_profile\necho 'export RUSTUP_DIST_SERVER=https://mirrors.tuna.tsinghua.edu.cn/rustup' &gt;&gt; ~/.bash_profile\n. ~/.bash_profile\n\n\n\n\n然后查看官方安装教程3\n\n\n\n\n安装\n\ncurl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n\n\n\n会提示出下列信息\n\n2   default host triple: x86_64-apple-darwin\n1     default toolchain: stable (default)\n3               profile: default\n  modify PATH variable: yes\n\n\n1\n\n指定toolchain 从 stable channel 中下载最新的工具链\n\n2\n\n很显然工具链是有系统区分的,所以系统会默认给你添加上这个信息(rustup target list命令查看),和指定的stable channel名一起真正构成 toolchain的名字\n\n3\n\n配置下载哪些 components\n\n\n\n安装过程我们可以看到 info: installing component 'rust-docs' 这类信息,说明安装了不少组件\n所有组件的代理程序都安装到 ~/.cargo/bin 这个目录 (看设计思路中图2说明)\ntree ~/.cargo/bin\n~/.cargo/bin\n├── cargo # Rust 的编译工具,包管理器,可以帮助你编译代码,运行,测试...\n├── cargo-clippy\n├── cargo-fmt\n├── cargo-miri\n├── clippy-driver\n1├── rls\n├── rust-analyzer\n├── rust-gdb\n├── rust-gdbgui\n├── rust-lldb\n├── rustc # rust 编译器\n├── rustdoc\n├── rustfmt\n└── rustup\n\n1\n\n由于我们用的profile是default配置, 根据前面的设计思路, 这里的2个是代理程序,实际对应的可执行程序还没有安装, 需要我们额外去安装\n\n\n\n\n\n\n\n\nImportant\n\n\n\n\nrls (需要rust-analysis 配合使用) 已经被 rust-analyzer 取代了 ,所以我们安装 rust-analyzer 即可\nrust-analyzer4, vscode中去安装\n\n\n\n\n\n安装额外需要的组件\n\n# RLS的全称是:'Rust Language Server',是一个守护进程\n# 用于和开发时使用的IDE进行IPC通信,完成代码提示、跳转到定义、显示变量类型等功能\n# rustup component add rls           --toolchain stable    # RLS\n# rustup component add rust-analysis --toolchain stable    # 分析工具\nrustup component add rust-analyzer --toolchain stable\n\n#std是Rust的标准库. 默认情况下,Rust安装的是标准库的二进制码,而添加源码后容易方便我们查询部分标准库的实现\nrustup component add rust-src      --toolchain stable    # std源码\n\n\n环境变量配置\n\n\nzsh\n\n\necho 'source \"$HOME/.cargo/env\"' &gt;&gt; ~/.zshrc\n\n\n\n\n命令自动补全\n\n\n\n用这个命令看如何配置\n\nrustup help completions\n\n\nzsh\n\n\n\n\n\n\n\n\nWarning\n\n\n\n不知道啥情况, 设置后 有一点自动补全,但是 效果很烂\n\n\nmkdir ~/.zfunc\nrustup completions zsh &gt; ~/.zfunc/_rustup\nrustup completions zsh cargo &gt; ~/.zfunc/_cargo\necho 'fpath+=~/.zfunc' &gt;&gt; ~/.zshrc\necho 'autoload -U compinit && compinit' &gt;&gt; ~/.zshrc\n. ~/.zshrc\n\n\n\n\n\n\n\n\nrustup show\n    # Default host: x86_64-apple-darwin\n    # rustup home:  ~/.rustup\n\n    # stable-x86_64-apple-darwin (default)\n    # rustc 1.80.1 (3f5fd8dd4 2024-08-06)\n\n\n查看支持的平台(上面的host)\n\nrustup target list\n\n\n\n\n\n安装查看执行指定工具链里的命令切换查看命令的真实路径更新卸载\n\n\n\n\n\n\n\n\nImportant\n\n\n\nrustup install 命令等同于 rustup toolchain install, 所以可以省略toolchain\n\n\nnightly版本发布情况 stable版本发布情况\n\n直接通过channel 方式安装\n\n1rustup toolchain install beta --profile minimal\n\n1\n\n--profile minimal 前面说过, 配置下载哪些components, 这里表示下载最少的组件\n\n\n\n使用[channel]-[data]的方式安装\n\nrustup toolchain install nightly-2024-07-25 --profile minimal\n国内源资源情况\n\n使用 版本号 &lt;major.minor&gt;或&lt;major.minor.patch&gt;的方式安装\n\n# 临时取消国内源(有些国内源可能没有保留的), 使用官方源下载\nRUSTUP_DIST_SERVER=  rustup toolchain install 1.77 --profile minimal\n\n\n\n\n\n查看安装的toolchain\n\nrustup toolchain list\n\n\n\n结果\n\n1stable-x86_64-apple-darwin (default)\nbeta-x86_64-apple-darwin\nnightly-2024-07-25-x86_64-apple-darwin\nnightly-2024-07-26-x86_64-apple-darwin\nnightly-x86_64-apple-darwin\n1.64-x86_64-apple-darwin\n1.77-x86_64-apple-darwin\n\n\n1\n\ndefault 表示当前我们默认使用的toolchain  我们可以看到现实的toolchain名字都带有 -x86_64-apple-darwin,系统会自动检测,你也可以自己install时加上\n\n\n\n\n\n\n# 指定 toolchain工具链 来执行它里面的 工具\nrustup run stable rustc --version\n# 同上\nrustup run stable-x86_64-apple-darwin rustc --version\n# 因为默认 使用 stable , 所以这里是调用 stable 里的, 同上\nrustc --version\n\n\n\n\n\n\n点击查看执行结果\n\n\n\n\n\nrustc 1.80.1 (3f5fd8dd4 2024-08-06)\n\n\n\n\n\n\n\n\n全局切换\n\n# 看看有哪些 toolchain\nrustup toolchain list\n#   stable/nightly/beta\nrustup default stable\n\n\n\n工作目录切换版本\n\ncd rust项目代码目录\nrustup override set 1.77.2\n# 取消当前工作目录的版本, 重新设置为默认的全局版本\nrustup override unset\n\n\n\n\nrustup which rustc\n\n\n查看结果\n\n~/.rustup/toolchains/stable-x86_64-apple-darwin/bin/rustc\n\n\n\n\n指定toolchain\n\n#  看看指定命令 实际的可执行的位置\nrustup which rustc  --toolchain=nightly-2024-07-25-x86_64-apple-darwin\n\n\n\n\n\n更新rustup 自身\n\nrustup self update\n\n\n\n更新所有toolchain\n\nrustup update\n\n\n\n更新指定toolchain\n\nrustup update nightly\n\n\n\n# 会删除所有的工具链\n# 注意, 卸载后, rustup 本身也没了,需要重新安装\nrustup self uninstall\n\n\n卸载指定toolchain\n\nrustup toolchain uninstall nightly\n\n\n\n\n\n\n\n\n查看添加\n\n\n# 查看默认toolchain下已经安装的组件\nrustup component list --installed\n# 查看指定toolchain下已经安装的组件\nrustup component list --installed --toolchain nightly\n\n\nrustup component add rust-analyzer\n# 指定toolchain\nrustup component add rust-analyzer --toolchain stable",
    "crumbs": [
      "基础篇",
      "环境准备"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/env.html#其他准备",
    "href": "docs/programming/rust/basic/env.html#其他准备",
    "title": "rust 环境准备",
    "section": "2 其他准备",
    "text": "2 其他准备\n\n2.1 cargo generate5\n\n\n安装\n\n# 用于根据模板生成代码\n# 安装后,会在~/.cargo/bin下看到 cargo-generate可执行文件(这个不是代理程序)\n# 现在可以这样 cargo generate xxx/yyy (github 模板仓库 url)  创建项目\ncargo install cargo-generate\n\n或者 直接下载可执行文件 https://github.com/cargo-generate/cargo-generate/releases 放到 ~/.cargo/bin/\n\n\n使用\n\n# templates on github\ncargo generate --git https://github.com/username-on-github/mytemplate.git\n# 同上\ncargo generate username-on-github/mytemplate\n# 同上\ncargo generate gh:username-on-github/mytemplate\n\n# 其他平台的 templates\n# translates to https://gitlab.com/username-on-gitlab/mytemplate.git\ncargo generate gl:username-on-gitlab/mytemplate\n# translates to https://bitbucket.org/username-on-bitbucket/\ncargo generate bb:username-on-bitbucket/mytemplate mytemplate.git\n# translates to https://git.sr.ht/~username-on-sourcehut/mytemplate (主意有波浪号)\ncargo generate sr:username-on-sourcehut/mytemplate\n\ncargo help generate\n\n\n\n2.2 cargo deny6\n# 安装 Cargo deny 用于检查依赖的安全性\n# 替代 cargo-audit 这个同类型工具\ncargo install --locked cargo-deny\n# 在项目目录下 初始化, 会生成一个deny.toml 文件\ncargo deny init\n\n\ndeny.toml\n\n\n\n\n\n2.3 typos7\n# 英文单词拼写检查工具\ncargo install typos-cli\n\n\n_typos.toml 配置文件放到项目下\n\n[default]\nextend-ignore-identifiers-re = [\n    # *sigh* this just isn't worth the cost of fixing\n    \"AttributeID.*Supress.*\",\n]\n\n[default.extend-identifiers]\n# *sigh* this just isn't worth the cost of fixing\nAttributeIDSupressMenu = \"AttributeIDSupressMenu\"\n\n[default.extend-words]\n# Don't correct the surname \"Teh\"\nteh = \"teh\"\n\n[files]\n# 排除该目录下的所有的*.po文件,不用检查\nextend-exclude = [\"localized/*.po\"]\n\n\n\n2.4 cargo-nextest8\n# 安装 rust test 增强工具\ncargo install cargo-nextest --locked\n\n\n2.5 pre-commit 配置\n\n\n代码仓库中添加 .pre-commit-config.yaml\n\nfail_fast: false\nrepos:\n1  - repo: https://github.com/pre-commit/pre-commit-hooks\n    rev: v4.3.0\n    hooks:\n      - id: check-byte-order-marker\n      - id: check-case-conflict\n      - id: check-merge-conflict\n      - id: check-symlinks\n      - id: check-yaml\n      - id: end-of-file-fixer\n      - id: mixed-line-ending\n      - id: trailing-whitespace\n  - repo: https://github.com/psf/black\n    rev: 22.10.0\n    hooks:\n      - id: black\n  - repo: https://github.com/crate-ci/typos  \n    rev: v1.8.1\n    hooks:\n      - id: typos\n2  - repo: local\n    hooks:\n      - id: cargo-fmt\n        name: cargo fmt\n        description: Format files with rustfmt.\n        entry: bash -c 'cargo fmt -- --check'\n        language: rust\n        files: \\.rs$\n        args: []\n      - id: cargo-deny\n        name: cargo deny check\n        description: Check cargo dependencies 检查依赖的安全性\n        entry: bash -c 'cargo deny check -d'\n        language: rust\n        files: \\.rs$\n        args: []\n      - id: cargo-check\n        name: cargo check\n        description: Check the package for errors.\n        entry: bash -c 'cargo check --all'\n        language: rust\n        files: \\.rs$\n        pass_filenames: false\n      - id: cargo-clippy\n        name: cargo clippy\n        description: Lint rust sources\n        entry: bash -c 'cargo clippy --all-targets --all-features --tests --benches -- -D warnings'\n        language: rust\n        files: \\.rs$\n        pass_filenames: false\n      - id: cargo-test\n        name: cargo test\n        description: unit test for the project\n        entry: bash -c 'cargo nextest run --all-features'\n        language: rust\n        files: \\.rs$\n        pass_filenames: false\n\n\n1\n\n使用网络上别人提供的hook 脚本\n\n2\n\n自己本地自定义, 可以在下面看到自己写的脚本\n\n\n\n\n\n更新上面配置里设置的repos的版本\n\n# 在项目目录下执行\npre-commit autoupdate\n\n\n\n\n\n\n\n点击查看执行结果\n\n\n\n\n\n[https://github.com/pre-commit/pre-commit-hooks] updating v4.3.0 -&gt; v4.6.0\n[https://github.com/psf/black] updating 22.10.0 -&gt; 24.8.0\n[https://github.com/crate-ci/typos] updating v1.8.1 -&gt; v1.24.6",
    "crumbs": [
      "基础篇",
      "环境准备"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/env.html#查看文档",
    "href": "docs/programming/rust/basic/env.html#查看文档",
    "title": "rust 环境准备",
    "section": "3 查看文档",
    "text": "3 查看文档\n查看本地离线的rust文档,浏览器会自动打开文档, 可以看到好多教程可以点击查看\nrustup doc\n这个会打开 The Rust Programming Language 这本教程\nrustup docs --book\n# 查看帮助,可以看到其他book的 命令\nrustup docs --help\n# 直接打开 rust-by-example 这本书\nrustup docs --rust-by-example",
    "crumbs": [
      "基础篇",
      "环境准备"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/env.html#cargo简单介绍",
    "href": "docs/programming/rust/basic/env.html#cargo简单介绍",
    "title": "rust 环境准备",
    "section": "4 cargo简单介绍",
    "text": "4 cargo简单介绍\ncargo new hello \ncd hello\ntree -a\n# 会创建目录world, 并且 直接有 .git 纳入git管理\n.\n├── .git\n├── .gitignore\n1├── Cargo.toml\n└── src\n    └── main.rs\n\n1\n\ncargo.toml package的一些基本信息 toml参考\n\n\n\n\nCargo.toml\n\n[package]\nname = \"hello\"\n# 注意开发时第一个 version 一般是用0.1.0 不是0.0.1\nversion = \"0.1.0\"\nedition = \"2021\"\n\n\n\nsrc/main.rs\n\nfn main() {\n    println!(\"Hello, world!\");\n}\n\n\n\n执行命令\n\ncargo run\n\n\n\n运行打印的信息\n\n1       Fresh hello v0.1.0 (~/rust2024/hello)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.00s\n2     Running `target/debug/hello`\n3Hello, world!\n\n\n1\n\ncargo 调用 rust编译器 rustc来编译代码,生成可执行文件,会放到 target/debug 目录下\n\n2\n\n运行 可执行文件\n\n3\n\n输出结果\n\n\n配置crates国内源9, 下载依赖包就快了\n\n\n\n\n\n\nWarning\n\n\n\ncargo 1.68 及以上版本 使用 config.toml 文件名,而不是config\n\n\n\n\n这个好像更快...\n\nmkdir -vp ${CARGO_HOME:-$HOME/.cargo}\n\ncat &lt;&lt; EOF | tee -a ${CARGO_HOME:-$HOME/.cargo}/config.toml\n[source.crates-io]\nreplace-with = 'ustc'\n\n[source.ustc]\nregistry = \"sparse+https://mirrors.ustc.edu.cn/crates.io-index/\"\nEOF\n\n或者\nmkdir -vp ${CARGO_HOME:-$HOME/.cargo}\n\ncat &lt;&lt; EOF | tee -a ${CARGO_HOME:-$HOME/.cargo}/config.toml\n[source.crates-io]\nreplace-with = 'mirror'\n\n[source.mirror]\nregistry = \"sparse+https://mirrors.tuna.tsinghua.edu.cn/crates.io-index/\"\nEOF",
    "crumbs": [
      "基础篇",
      "环境准备"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/env.html#其他说明",
    "href": "docs/programming/rust/basic/env.html#其他说明",
    "title": "rust 环境准备",
    "section": "5 其他说明",
    "text": "5 其他说明\n源码和rust语言需求讨论10\n\nnightly版本使用实验性功能的方法, 需要讲rust版本切换到nightly, 然后在代码中添加feature语句\n等到这个功能稳定了,就是用了新版本的编译器,它就会提示你不需要这个feature语句了\n\n#![feature(unboxed_closures)]\n#![feature(fn_traits)]\n//.....",
    "crumbs": [
      "基础篇",
      "环境准备"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/env.html#footnotes",
    "href": "docs/programming/rust/basic/env.html#footnotes",
    "title": "rust 环境准备",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nrustup教程↩︎\nrustup国内源↩︎\n官方安装教程↩︎\nrust-analyzer↩︎\ncargo-generate  点击搜索别人开源的一些template  文档↩︎\ncargo deny\n\ngithub\nbook\nrust-ecosystem\n\n↩︎\ntypos↩︎\ncargo nextest  https://nexte.st/↩︎\n中科大开源镜像站 清华大学开源软件镜像站↩︎\nrust源码 RFC(需求讨论)↩︎",
    "crumbs": [
      "基础篇",
      "环境准备"
    ]
  },
  {
    "objectID": "docs/programming/rust/async/future.html",
    "href": "docs/programming/rust/async/future.html",
    "title": "rust future",
    "section": "",
    "text": "async-std tokio https://tokio.rs/tokio/tutorial\n\n\n\n Back to top"
  },
  {
    "objectID": "docs/programming/rust/web/net.html",
    "href": "docs/programming/rust/web/net.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "hello.html\n\n&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n  &lt;head&gt;\n    &lt;meta charset=\"utf-8\"&gt;\n    &lt;title&gt;Hello!&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;h1&gt;Hello!&lt;/h1&gt;\n    &lt;p&gt;Hi from Rust&lt;/p&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n\n\n\nsrc/main.rs\n\nuse std::{\n    fs,\n    io::{prelude::*, BufReader},\n    net::{TcpListener, TcpStream},\n};\nfn main() {\n    let listener = TcpListener::bind(\"127.0.0.1:7878\").unwrap();\n\n    for stream in listener.incoming() {\n        // 每一个stream 表示 客户端和服务端之间的链接\n        // 包含客户端发送来的数据\n        let stream = stream.unwrap();\n\n        handle_connection(stream);\n    }\n}\n\nfn handle_connection(mut stream: TcpStream) {\n    let buf_reader = BufReader::new(&mut stream);\n    let http_request: Vec&lt;_&gt; = buf_reader\n        .lines()\n        .map(|result| result.unwrap())\n        .take_while(|line| !line.is_empty())\n        .collect();\n\n    println!(\"Request: {:#?}\", http_request);\n\n    // response\n    let status_line = \"HTTP/1.1 200 OK\";\n    let contents = fs::read_to_string(\"hello.html\").unwrap();\n    let length = contents.len();\n\n    let response = format!(\"{status_line}\\r\\nContent-Length: {length}\\r\\n\\r\\n{contents}\");\n\n    stream.write_all(response.as_bytes()).unwrap();\n}\n\nfn handle_connection2(mut stream: TcpStream) {\n    let buf_reader = BufReader::new(&mut stream);\n    let request_line = buf_reader.lines().next().unwrap().unwrap();\n\n    if request_line == \"GET / HTTP/1.1\" {\n        let status_line = \"HTTP/1.1 200 OK\";\n        let contents = fs::read_to_string(\"hello.html\").unwrap();\n        let length = contents.len();\n\n        let response = format!(\n            \"{status_line}\\r\\nContent-Length: {length}\\r\\n\\r\\n{contents}\"\n        );\n\n        stream.write_all(response.as_bytes()).unwrap();\n    } else {\n        let status_line = \"HTTP/1.1 404 NOT FOUND\";\n        // 再弄个 404.html \n        let contents = fs::read_to_string(\"404.html\").unwrap();\n        let length = contents.len();\n\n        let response = format!(\n            \"{status_line}\\r\\nContent-Length: {length}\\r\\n\\r\\n{contents}\"\n        );\n\n        stream.write_all(response.as_bytes()).unwrap();\n    }\n}\n\n运行后,"
  },
  {
    "objectID": "docs/programming/rust/web/net.html#单线程",
    "href": "docs/programming/rust/web/net.html#单线程",
    "title": "斯巴拉稀",
    "section": "",
    "text": "hello.html\n\n&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n  &lt;head&gt;\n    &lt;meta charset=\"utf-8\"&gt;\n    &lt;title&gt;Hello!&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;h1&gt;Hello!&lt;/h1&gt;\n    &lt;p&gt;Hi from Rust&lt;/p&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n\n\n\nsrc/main.rs\n\nuse std::{\n    fs,\n    io::{prelude::*, BufReader},\n    net::{TcpListener, TcpStream},\n};\nfn main() {\n    let listener = TcpListener::bind(\"127.0.0.1:7878\").unwrap();\n\n    for stream in listener.incoming() {\n        // 每一个stream 表示 客户端和服务端之间的链接\n        // 包含客户端发送来的数据\n        let stream = stream.unwrap();\n\n        handle_connection(stream);\n    }\n}\n\nfn handle_connection(mut stream: TcpStream) {\n    let buf_reader = BufReader::new(&mut stream);\n    let http_request: Vec&lt;_&gt; = buf_reader\n        .lines()\n        .map(|result| result.unwrap())\n        .take_while(|line| !line.is_empty())\n        .collect();\n\n    println!(\"Request: {:#?}\", http_request);\n\n    // response\n    let status_line = \"HTTP/1.1 200 OK\";\n    let contents = fs::read_to_string(\"hello.html\").unwrap();\n    let length = contents.len();\n\n    let response = format!(\"{status_line}\\r\\nContent-Length: {length}\\r\\n\\r\\n{contents}\");\n\n    stream.write_all(response.as_bytes()).unwrap();\n}\n\nfn handle_connection2(mut stream: TcpStream) {\n    let buf_reader = BufReader::new(&mut stream);\n    let request_line = buf_reader.lines().next().unwrap().unwrap();\n\n    if request_line == \"GET / HTTP/1.1\" {\n        let status_line = \"HTTP/1.1 200 OK\";\n        let contents = fs::read_to_string(\"hello.html\").unwrap();\n        let length = contents.len();\n\n        let response = format!(\n            \"{status_line}\\r\\nContent-Length: {length}\\r\\n\\r\\n{contents}\"\n        );\n\n        stream.write_all(response.as_bytes()).unwrap();\n    } else {\n        let status_line = \"HTTP/1.1 404 NOT FOUND\";\n        // 再弄个 404.html \n        let contents = fs::read_to_string(\"404.html\").unwrap();\n        let length = contents.len();\n\n        let response = format!(\n            \"{status_line}\\r\\nContent-Length: {length}\\r\\n\\r\\n{contents}\"\n        );\n\n        stream.write_all(response.as_bytes()).unwrap();\n    }\n}\n\n运行后,"
  },
  {
    "objectID": "docs/programming/rust/web/net.html#多线程版本",
    "href": "docs/programming/rust/web/net.html#多线程版本",
    "title": "斯巴拉稀",
    "section": "2 多线程版本",
    "text": "2 多线程版本\n这个版本, 每一个请求, 都会开启一个线程,没有限制了, 不断访问,可就产生很多的线程,服务器要完\nuse std::net::{TcpListener, TcpStream};\nuse std::thread;\nfn main() {\n    let listener = TcpListener::bind(\"127.0.0.1:7878\").unwrap();\n\n    for stream in listener.incoming() {\n        let stream = stream.unwrap();\n\n        thread::spawn(|| {\n            handle_connection(stream);\n        });\n    }\n}\n\nfn handle_connection(mut stream: TcpStream) {}\n使用线程池,设计了一个线程池\n\n\nsrc/main.rs\n\nuse hello::ThreadPool;\nuse std::fs;\nuse std::io::prelude::*;\nuse std::net::TcpListener;\nuse std::net::TcpStream;\nuse std::thread;\nuse std::time::Duration;\n\nfn main() {\n    let listener = TcpListener::bind(\"127.0.0.1:7878\").unwrap();\n    let pool = ThreadPool::new(4);\n\n    for stream in listener.incoming().take(2) {\n        let stream = stream.unwrap();\n\n        pool.execute(|| {\n            handle_connection(stream);\n        });\n    }\n\n    println!(\"Shutting down.\");\n}\n\nfn handle_connection(mut stream: TcpStream) {\n    let mut buffer = [0; 1024];\n    stream.read(&mut buffer).unwrap();\n\n    let get = b\"GET / HTTP/1.1\\r\\n\";\n    let sleep = b\"GET /sleep HTTP/1.1\\r\\n\";\n\n    let (status_line, filename) = if buffer.starts_with(get) {\n        (\"HTTP/1.1 200 OK\", \"hello.html\")\n    } else if buffer.starts_with(sleep) {\n        thread::sleep(Duration::from_secs(5));\n        (\"HTTP/1.1 200 OK\", \"hello.html\")\n    } else {\n        (\"HTTP/1.1 404 NOT FOUND\", \"404.html\")\n    };\n\n    let contents = fs::read_to_string(filename).unwrap();\n\n    let response = format!(\n        \"{}\\r\\nContent-Length: {}\\r\\n\\r\\n{}\",\n        status_line,\n        contents.len(),\n        contents\n    );\n\n    stream.write_all(response.as_bytes()).unwrap();\n    stream.flush().unwrap();\n}\n\n\n\nsrc/lib.rs\n\nuse std::{\n    sync::{mpsc, Arc, Mutex},\n    thread,\n};\n\npub struct ThreadPool {\n    workers: Vec&lt;Worker&gt;,\n    sender: Option&lt;mpsc::Sender&lt;Job&gt;&gt;,\n}\n\ntype Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;\n\nimpl ThreadPool {\n    /// Create a new ThreadPool.\n    ///\n    /// The size is the number of threads in the pool.\n    ///\n    /// # Panics\n    ///\n    /// The `new` function will panic if the size is zero.\n    pub fn new(size: usize) -&gt; ThreadPool {\n        assert!(size &gt; 0);\n\n        let (sender, receiver) = mpsc::channel();\n\n        let receiver = Arc::new(Mutex::new(receiver));\n\n        let mut workers = Vec::with_capacity(size);\n\n        for id in 0..size {\n            workers.push(Worker::new(id, Arc::clone(&receiver)));\n        }\n\n        ThreadPool {\n            workers,\n            sender: Some(sender),\n        }\n    }\n    // 模拟 thread spawn\n    pub fn execute&lt;F&gt;(&self, f: F)\n    where\n        F: FnOnce() + Send + 'static,\n    {\n        let job = Box::new(f);\n\n        self.sender.as_ref().unwrap().send(job).unwrap();\n    }\n}\n// 优雅退出\nimpl Drop for ThreadPool {\n    fn drop(&mut self) {\n        drop(self.sender.take());\n\n        for worker in &mut self.workers {\n            println!(\"Shutting down worker {}\", worker.id);\n\n            if let Some(thread) = worker.thread.take() {\n                thread.join().unwrap();\n            }\n        }\n    }\n}\n\nstruct Worker {\n    id: usize,\n    thread: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,\n}\n\nimpl Worker {\n    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {\n        let thread = thread::spawn(move || loop {\n            let message = receiver.lock().unwrap().recv();\n\n            match message {\n                Ok(job) =&gt; {\n                    println!(\"Worker {id} got a job; executing.\");\n\n                    job();\n                }\n                Err(_) =&gt; {\n                    println!(\"Worker {id} disconnected; shutting down.\");\n                    break;\n                }\n            }\n        });\n\n        Worker {\n            id,\n            thread: Some(thread),\n        }\n    }\n}"
  },
  {
    "objectID": "docs/programming/rust/web/axum/index.html",
    "href": "docs/programming/rust/web/axum/index.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "TODO"
  },
  {
    "objectID": "docs/programming/rust/web/axum/index.html#环境准备",
    "href": "docs/programming/rust/web/axum/index.html#环境准备",
    "title": "斯巴拉稀",
    "section": "1 环境准备",
    "text": "1 环境准备\ncargo add axum\n# cargo add tokio --features macros,rt-multi-thread\ncargo add tokio  --features full\ncargo add serde_json"
  },
  {
    "objectID": "docs/programming/rust/web/axum/index.html#样例",
    "href": "docs/programming/rust/web/axum/index.html#样例",
    "title": "斯巴拉稀",
    "section": "2 样例",
    "text": "2 样例\nuse axum::{response::Html, routing::get, Json, Router};\nuse serde_json::{json, Value};\n#[tokio::main]\nasync fn main() {\n    // build our application with a single route\n    // get 请求\n    let app = Router::new().route(\"/\", get(index_handler)).route(\n        \"/foo\",\n        // get post 2个请求都设置\n        get(|| async { \"Hello, Foo!\" }).post(json_handler),\n    );\n\n    // run our app with hyper, listening globally on port 3000\n    let listener = tokio::net::TcpListener::bind(\"0.0.0.0:3000\").await.unwrap();\n    axum::serve(listener, app).await.unwrap();\n}\nasync fn index_handler() -&gt; Html&lt;&'static str&gt; {\n    Html(\"&lt;h1&gt;Hello, World!&lt;/h1&gt;\")\n}\n\n// `&'static str` becomes a `200 OK` with `content-type: text/plain;charset=utf-8`\nasync fn plain_text() -&gt; &'static str {\n    \"foo\"\n}\n// `Json` gives a content-type of `application/json` and works with any type\n// that implements `serde::Serialize`\nasync fn json_handler() -&gt; Json&lt;Value&gt; {\n    Json(json!({ \"data\": 42 }))\n}\ngithub1 github2"
  },
  {
    "objectID": "docs/programming/rust/web/axum/index.html#footnotes",
    "href": "docs/programming/rust/web/axum/index.html#footnotes",
    "title": "斯巴拉稀",
    "section": "Footnotes",
    "text": "Footnotes\n\n\naxum: https://github.com/tokio-rs/axum↩︎\naxum生态: https://github.com/tokio-rs/axum/blob/main/ECOSYSTEM.md#tutorials↩︎"
  },
  {
    "objectID": "docs/programming/rust/advanced/02.type.html",
    "href": "docs/programming/rust/advanced/02.type.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "Important\n\n\n\n会合并到基础篇",
    "crumbs": [
      "并发与异步",
      "奇异的类型"
    ]
  },
  {
    "objectID": "docs/programming/rust/advanced/02.type.html#dst",
    "href": "docs/programming/rust/advanced/02.type.html#dst",
    "title": "斯巴拉稀",
    "section": "1 DST",
    "text": "1 DST\nuse std::mem;\ntrait Summary {\n    fn summarize(&self) -&gt; String;\n    fn hello(&self) {\n        println!(\"hello\");\n    }\n}\nfn main() {\n    // 报错, 无法获取大小\n    println!(\"{}\", mem::size_of::&lt;Summary&gt;());\n}",
    "crumbs": [
      "并发与异步",
      "奇异的类型"
    ]
  },
  {
    "objectID": "docs/programming/rust/advanced/02.type.html#zst",
    "href": "docs/programming/rust/advanced/02.type.html#zst",
    "title": "斯巴拉稀",
    "section": "2 ZST",
    "text": "2 ZST\nuse std::mem;\nstruct Nothing; // No fields = no size\n                // All fields have no size = no size\nstruct LotsOfNothing {\n    foo: Nothing,\n    qux: (),      // empty tuple has no size\n    baz: [u8; 0], // empty array has no size\n}\n\nfn main() {\n    println!(\"{}\", mem::size_of::&lt;Nothing&gt;());\n    println!(\"{}\", mem::size_of::&lt;LotsOfNothing&gt;());\n    let a = Nothing {};\n    let b = &a;\n    println!(\"{}\", mem::size_of_val(&a)); // 0\n    println!(\"{:p}\", &a); // 0x7ff7b1bacf4f\n    println!(\"{:p}\", &b); // 0x7ff7b1bacf50\n    println!(\"{}\", mem::size_of_val(&b)); // 8\n}",
    "crumbs": [
      "并发与异步",
      "奇异的类型"
    ]
  },
  {
    "objectID": "docs/programming/rust/advanced/02.type.html#空类型",
    "href": "docs/programming/rust/advanced/02.type.html#空类型",
    "title": "斯巴拉稀",
    "section": "3 空类型",
    "text": "3 空类型\nuse std::mem;\nenum NoVariants {} // No variants = no size\nfn main() {\n    // 无法实例化\n    // let a = NoVariants;\n    println!(\"{}\", mem::size_of::&lt;NoVariants&gt;());\n}",
    "crumbs": [
      "并发与异步",
      "奇异的类型"
    ]
  },
  {
    "objectID": "docs/programming/rust/advanced/02.type.html#repr",
    "href": "docs/programming/rust/advanced/02.type.html#repr",
    "title": "斯巴拉稀",
    "section": "4 repr",
    "text": "4 repr\n\n4.1 repr(C)\n它的目的很简单, 就是和 C 保持一致. 数据的顺序,大小,对齐方式都和你在C 或C++中见到的一摸一样.\n我们前面在内存对齐看对Struct A的对齐方式和它的大小,这里我们使用repr(C)来定义Struct A\n#[repr(C)]\nstruct A {\n    a: u8,\n    b: u32,\n    c: u16,\n}\n\nuse std::mem;\nfn main() {\n    let x = A { a: 1, b: 2, c: 3 };\n    // 12\n    println!(\"{}\", mem::size_of_val(&x));\n    println!(\"0x{:p}-0x{:p}-0x{:p}\", &x.a, &x.b, &x.c);\n}\nTODO 特殊情况\n\nZSTs are still zero-sized …\n…\n\n\n\n4.2 repr(transparent)\n\n\n4.3 repr(u) repr(i)\n\n\n4.4 repr(packed)",
    "crumbs": [
      "并发与异步",
      "奇异的类型"
    ]
  },
  {
    "objectID": "docs/programming/python/pandas/analysis-diagram.html",
    "href": "docs/programming/python/pandas/analysis-diagram.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "Back to top"
  },
  {
    "objectID": "docs/programming/python/basic/env.html",
    "href": "docs/programming/python/basic/env.html",
    "title": "python 环境准备",
    "section": "",
    "text": "Caution\n\n\n\ntodo…",
    "crumbs": [
      "基础",
      "环境准备"
    ]
  },
  {
    "objectID": "docs/programming/python/basic/env.html#安装",
    "href": "docs/programming/python/basic/env.html#安装",
    "title": "python 环境准备",
    "section": "1 安装",
    "text": "1 安装\npython conda 一键安装脚本",
    "crumbs": [
      "基础",
      "环境准备"
    ]
  },
  {
    "objectID": "docs/programming/python/basic/env.html#pip",
    "href": "docs/programming/python/basic/env.html#pip",
    "title": "python 环境准备",
    "section": "2 pip",
    "text": "2 pip\n\n2.1 修改源\n\n\n~/.pip/pip.conf  中添加或修改\n\n[global]\nindex-url = https://mirrors.aliyun.com/pypi/simple/\n\n[install]\ntrusted-host=mirrors.aliyun.com\n\n\n\n2.2 常用命令\npip install django==1.8.2 #指定版本\n# 显示安装的包\npip list\n# 输出所有在本地已经安装的包(不包括 pip,wheel,setuptools等自带包)\npip freeze\npip freeze &gt; requirements.txt\n# 这个则输出的内容与pip list的包 一样\npip freeze --all&gt; requirements.txt\n# 如果看到 显示内容有 file:/// 这种包 路径\n# 不过这个命令会输出 setuptools,pip 等自带的包, 要手动删除\npip list --format=freeze &gt; requirements.txt\n\n# 安装依赖\npip install -r requirements.txt\n\n# 查看使用pip安装的库 在系统中的位置\n\npip show django",
    "crumbs": [
      "基础",
      "环境准备"
    ]
  },
  {
    "objectID": "docs/programming/python/basic/env.html#conda1",
    "href": "docs/programming/python/basic/env.html#conda1",
    "title": "python 环境准备",
    "section": "3 conda1",
    "text": "3 conda1\n\n\n\n\n\n\nImportant\n\n\n\n\npyenv 这个工具已经不推荐\nAnaconda2 是一个用于科学计算的 Python 发行版，支持 Linux, Mac, Windows, 包含了众多流行的科学计算和数据分析的 Python 包\nMiniconda3 是一个 Anaconda 的轻量级替代,默认只包含了 python 和 conda,但是可以通过 pip 和 conda 来安装所需要的包\n\n\n\nconda config --help\n# 查看根目录\nconda info --root\n\nconda info -e  #查看已安装的环境\n#添加国内镜像\nconda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/\nconda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/\n\n# 使用过conda config 命令后 会生成一个配置文件 cat ~/.condarc, 默认是没有的\n#设置搜索时显示通道地址，这个可以不加，只是为了看一下是否从镜像站下载\nconda config --set show_channel_urls yes\n#基于 python3.6 创建一个名为python36的环境\nconda  create --name python36 python=3.6\n#激活环境\n# 默认环境里 已经安装了 各种科学库什么的,,jupyter note 之类的,所以没什么特殊情况,默认就用这个\nconda activate # 激活默认的base 环境, 通过conda env list 能查看\nconda activate python36\n#离开当前环境\nconda deactivate\n#查看安装了的环境情况,带* 的表示当前环境\nconda env list\n# 移除一个名称python36叫做环境\nconda env remove --name python36\n\nconda search 包名\n#删除指定环境中的指定包\nconda remove -n python36 numpy\nconda remove 包名  # 删除当前环境中的指定包\n\n# 安装包\nconda install --name myenv scipy # 安装包到指定环境中\nconda install scipy # 安装包到当前环境中\nconda install scipy=0.15.0  # 安装指定版本的包，到当前环境\nconda install scipy curl # 安装多个包\nconda install -c anaconda django # -c是指定渠道名称，也就是用哪个渠道安装django。\n# 安装不在conda或者 anaconda 的包，当你安装的包不在conda管理范围的时候可以使用pip来安装\nconda install pip  # 首先在当前环境中安装pip\npip install 包名   # 其次在通过PIP命令在当前环境中安装包\n\nconda update 包名  # 更新当前环境指定的包\nconda update -n python36 numpy # 更新指定环境中的指定包\n\nconda list\nconda list -n python36 # 查看指定环境中安装的所有包",
    "crumbs": [
      "基础",
      "环境准备"
    ]
  },
  {
    "objectID": "docs/programming/python/basic/env.html#uv4",
    "href": "docs/programming/python/basic/env.html#uv4",
    "title": "python 环境准备",
    "section": "4 uv4",
    "text": "4 uv4\n\nA single tool to replace pip, pip-tools, pipx, poetry, pyenv, virtualenv, and more. 还有一些其他工具 pdm, rye等",
    "crumbs": [
      "基础",
      "环境准备"
    ]
  },
  {
    "objectID": "docs/programming/python/basic/env.html#footnotes",
    "href": "docs/programming/python/basic/env.html#footnotes",
    "title": "python 环境准备",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nconda国内源↩︎\nanaconda官方↩︎\nminiconda官方↩︎\nuv  doc  rye↩︎",
    "crumbs": [
      "基础",
      "环境准备"
    ]
  },
  {
    "objectID": "docs/programming/go/pkg/net.html",
    "href": "docs/programming/go/pkg/net.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "0.1 获取ip地址\nfunc TestA(t *testing.T) {\n    netInterfaces, err := net.Interfaces()\n    if err != nil {\n        panic(err.Error())\n    }\n\n    for i := 0; i &lt; len(netInterfaces); i++ {\n        if (netInterfaces[i].Flags & net.FlagUp) != 0 {\n            addrs, _ := netInterfaces[i].Addrs()\n            for _, address := range addrs {\n                if ipNet, ok := address.(*net.IPNet); ok && !ipNet.IP.IsLoopback() {\n                    //获取IPv6\n                    /*if ipNet.IP.To16() != nil {\n                        fmt.Println(ipNet.IP.String())\n\n                    }*/\n                    //获取IPv4\n                    if ipNet.IP.To4() != nil {\n                        fmt.Println(ipNet.IP.String())\n\n                    }\n                }\n            }\n        }\n    }\n\n}\n\n\n\n\n Back to top"
  },
  {
    "objectID": "docs/programming/go/pkg/cobra.html",
    "href": "docs/programming/go/pkg/cobra.html",
    "title": "go cobra",
    "section": "",
    "text": "例子说明\n\n# server 是 command(action),  'port' 是 一个flag,改变暴露的端口,对行为的修饰\n# hugo 是 应用程序的名称\nhugo server --port=1313\n# git 是应用程序, clone 是command(action), URL 是Args, --bare是 flag\ngit clone URL --bare",
    "crumbs": [
      "工具与实用库",
      "cobra"
    ]
  },
  {
    "objectID": "docs/programming/go/pkg/cobra.html#概念",
    "href": "docs/programming/go/pkg/cobra.html#概念",
    "title": "go cobra",
    "section": "",
    "text": "例子说明\n\n# server 是 command(action),  'port' 是 一个flag,改变暴露的端口,对行为的修饰\n# hugo 是 应用程序的名称\nhugo server --port=1313\n# git 是应用程序, clone 是command(action), URL 是Args, --bare是 flag\ngit clone URL --bare",
    "crumbs": [
      "工具与实用库",
      "cobra"
    ]
  },
  {
    "objectID": "docs/programming/go/pkg/cobra.html#实战",
    "href": "docs/programming/go/pkg/cobra.html#实战",
    "title": "go cobra",
    "section": "2 实战",
    "text": "2 实战\ncobra github 文档 cobra-cli\n# 安装cobra-cli 用于代码生成\ngo install github.com/spf13/cobra-cli@latest\n\nmkdir my-app && cd my-app && cobra-cli init\n# 或者\ncobra-cli init my-app && cd my-app\ntree\n.\n├── LICENSE\n├── cmd\n│   └── root.go\n├── go.mod\n├── go.sum\n└── main.go\n\n2.1 根命令\n\n\ncmd/root.go\n\n--8&lt;-- \"go/.code/cobra/cmd/root.go\"\n\ngo build .\n./my-app -h\n\n\n2.2 添加命令\n# 接下来添加一个命令\ncobra-cli add serve\n# 会在 cmd目录下创建一个 serve.go 文件\n\n\ncmd/serve.go 做相关修改\n\n/*\nCopyright © 2023 NAME HERE &lt;EMAIL ADDRESS&gt;\n\n*/\npackage cmd\n\nimport (\n    \"errors\"\n    \"fmt\"\n\n    \"github.com/spf13/cobra\"\n)\n\nvar serveCmd = &cobra.Command{\n    Use:     \"serve\",                //  ./my-app -h 帮助信息显示的命令名\n    Short:   \"short serve\",          //  ./my-app -h 会看到\n    Long:    `A longer description`, //  ./my-app serve -h 会看到\n    Aliases: []string{\"s\"},          //   命令别名 ./my-app s 等同于 ./my-app serve\n    // 如果有错误, 就不要再显示 使用帮助了.\n    // 默认没设置是 false , 命令执行有错误, 会显示帮助\n    SilenceUsage: true,\n    PersistentPreRun: func(cmd *cobra.Command, args []string) {\n        fmt.Printf(\"serve PersistentPreRun run运行前 执行, 这个会被子命令继承,除非子命令自己写了自己的: %v\\n\", args)\n    },\n    PreRun: func(cmd *cobra.Command, args []string) {\n        fmt.Printf(\"run 运行前执行, 不会被子命令继承: %v\\n\", args)\n    },\n\n    Run: func(cmd *cobra.Command, args []string) {\n        fmt.Println(\"执行了 serve  子命令\")\n        // rootCmd 里设置的 全局config\n        config := cmd.Flags().Lookup(\"config\").Value\n        // cmd.Flags() 包含所有的flag\n        dirtyReload0 := cmd.Flags().Lookup(\"dirtyreload\").Value\n        // 获取 local flags\n        dirtyReload := cmd.LocalFlags().Lookup(\"dirtyreload\").Value\n        fmt.Println(dirtyReload0, dirtyReload)\n        // cmd.PersistentFlags()\n        fmt.Println(config)\n        // 参数\n        fmt.Println(\"args:\", args)\n    },\n    PostRun: func(cmd *cobra.Command, args []string) {\n        fmt.Printf(\"run 运行后执行, 不会被子命令继承: %v\\n\", args)\n    },\n    PersistentPostRun: func(cmd *cobra.Command, args []string) {\n        fmt.Printf(\"serve PersistentPostRun run运行后执行, 这个会被子命令继承,除非子命令自己写了自己的: %v\\n\", args)\n    },\n    // 如果不写这个 ,表示接收任意参数\n    Args: func(cmd *cobra.Command, args []string) error {\n        fmt.Println(\"所有 pre post run 之前执行\")\n        // 参数自定义验证\n        if len(args) &lt; 1 {\n            return errors.New(\"至少一个参数\")\n        }\n        fmt.Println(\"args:\", args)\n        // 返回nil 才会执行后续的run方法\n        return nil\n    },\n}\n\nfunc init() {\n    rootCmd.AddCommand(serveCmd)\n    serveCmd.Flags().Bool(\"dirtyreload\", false, \"Help message for dirty\")\n}\n\ngo build .\n./my-app s\n\n\n执行结果\n\n执行了 serve  命令\nfalse\n~/.my-app.yaml\n\n# 代码里 bool 类型的, 这里执行是 只要带上 就表示true\n# 当然也可以 --dirtyreload=true\n./my-app s --dirtyreload --config=./debug.yaml\n\n\n2.3 命令添加子命令\n\n\n给命令添加子命令\n\n# 默认 没有-p 指明的话, 就是给rootCmd添加命令\ncobra-cli add image -p 'serveCmd'\n\n\n\ncmd/image.go\n\n/*\nCopyright © 2023 NAME HERE &lt;EMAIL ADDRESS&gt;\n\n*/\npackage cmd\n\nimport (\n    \"fmt\"\n\n    \"github.com/spf13/cobra\"\n)\n\n// imageCmd represents the image command\nvar imageCmd = &cobra.Command{\n    Use:   \"image\",\n    Short: \"image A brief \",\n    Long:  `image A longer description.`,\n    RunE: func(cmd *cobra.Command, args []string) error {\n        fmt.Println(\"image called\")\n        // return errors.New(\"eeee\")\n        return nil\n\n    },\n    PersistentPostRun: func(cmd *cobra.Command, args []string) {\n        fmt.Printf(\"image PersistentPostRun: %v\\n\", args)\n    },\n    // 用cobra 提供的方法, 之前我们在serve 命令中用的自定义\n    Args: cobra.ExactArgs(1),\n\n    /*\n        这里的表示 只接收 这样的参数\n        Args:      cobra.OnlyValidArgs,\n        ValidArgs: []string{\"abc\", \"efg\"},\n    */\n}\n\nfunc init() {\n    serveCmd.AddCommand(imageCmd)\n}\n\ngo build .\n./my-app s image # 报错\n./my-app s image abc",
    "crumbs": [
      "工具与实用库",
      "cobra"
    ]
  },
  {
    "objectID": "docs/programming/go/pkg/go-cache.html",
    "href": "docs/programming/go/pkg/go-cache.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "import  \"github.com/patrickmn/go-cache\"\n\nfunc main() {\n    //c的items (map结构) 过期key清理时间 = DefaultExpiration + CleanupInterval\n    c := cache.New(time.Duration(100)*time.Second, time.Duration(10)*time.Second)\n    fmt.Println(c)\n    // 某个key过期被删除的时候会触发\n    c.OnEvicted(func(a string, b interface{}) {\n        fmt.Println(a, b)\n    })\n    // 这个key x的过期时间是 5+ cache.New里设置的cleanupInterval 时间\n    // 如果key 设置的 过期时间 =0 , 则使用默认的New里设置的过期时间\n    // -1的话 ,永不过期\n    c.Set(\"x\", \"y\", 0*time.Second)\n    select {}\n}\n\n\n\n Back to top"
  },
  {
    "objectID": "docs/programming/go/pkg/gocron.html",
    "href": "docs/programming/go/pkg/gocron.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "0.1 gocron\nimport \"github.com/go-co-op/gocron\"\nfunc sync() {\n    fmt.Println(1111)\n}\nfunc main() {\n\n    s := gocron.NewScheduler(time.Local)\n\n    s.Every(1).Seconds().Do(sync)\n    s.StartBlocking()\n    s.StartAsync()\n    test()\n\n}\n\n\n\n\n Back to top"
  },
  {
    "objectID": "docs/programming/go/pkg/go-generate.html",
    "href": "docs/programming/go/pkg/go-generate.html",
    "title": "go generate",
    "section": "",
    "text": "todo…",
    "crumbs": [
      "工具与实用库",
      "generate"
    ]
  },
  {
    "objectID": "docs/programming/go/pkg/go-generate.html#介绍",
    "href": "docs/programming/go/pkg/go-generate.html#介绍",
    "title": "go generate",
    "section": "1 介绍",
    "text": "1 介绍\n\n\n\n\n\n\nTip\n\n\n\n\nGo 语言的标准库中的 cmd/go/internal/generate\ngo generate 命令会遍历指定的包路径下的所有 Go 源文件,并解析这些源文件中的 //go:generate 注释,这些注释包含了代码生成指令\n//go:generate 后面就是会执行的命令,比如 //go:generate echo hello 执行go generate 会显示 hello",
    "crumbs": [
      "工具与实用库",
      "generate"
    ]
  },
  {
    "objectID": "docs/programming/go/pkg/go-generate.html#例子",
    "href": "docs/programming/go/pkg/go-generate.html#例子",
    "title": "go generate",
    "section": "2 例子",
    "text": "2 例子\n\n\n\n\n\n\n提醒\n\n\n\n早期笔记, 下面的例子粗糙,{==给struct类型生成getset方法==}, 等整理了ast后, 我会再完善一下.  建议去学习 ==stringer==\n\n\ntree\n.\n├── abc.go\n├── codegen\n│   └── gen.go\n├── go.mod\n└── pkg\n    └── cat.go\n//go:generate echo 123\n\n// goto hell\n\n// xyz\npackage main\n\n//go:generate go run codegen/gen.go\n//go:generate echo hello--world\n\n//helloworld33\ntype Person struct { // this is person\n    Name string // this is name\n    Age  int32\n}\n\n//go:generate echo 99\ntype Cup struct {\n    Price  float64\n    Origin string\n}\n\n\ncodegen/gen.go\n\npackage main\n\nimport (\n    \"fmt\"\n    \"go/ast\"\n    \"go/parser\"\n    \"go/printer\"\n    \"go/token\"\n    \"os\"\n    \"strings\"\n    \"text/template\"\n)\n\ntype Field struct {\n    Name string\n    Type string\n}\n\ntype StructInfo struct {\n    Name        string\n    Fields      []Field\n    PackageName string\n}\n\nfunc generateCode() {\n    fset := token.NewFileSet()\n\n    // 解析当前目录下所有的 Go 源文件,不会递归解析子目录里的文件的.\n    pkgs, err := parser.ParseDir(fset, \".\", nil, parser.ParseComments)\n    if err != nil {\n        fmt.Fprintf(os.Stderr, \"Failed to parse directory: %v\\n\", err)\n        os.Exit(1)\n    }\n\n    for _, pkg := range pkgs {\n        for _, file := range pkg.Files {\n            packageName := file.Name.Name\n            // for _, l := range file.Doc.List {\n            //  fmt.Println(\"file-doc\", l.Text)\n            // }\n            // fmt.Println(\"---\", packageName, file.Doc.Text(), \"===\")\n            // for _, c := range file.Comments {\n            //  // 挨在一起的2行注释算一个file的Comment\n            //  fmt.Print(\"[\")\n            //  for _, l := range c.List {\n            //      fmt.Println(\"cc\", l.Text)\n            //  }\n            //  fmt.Println(\"]\")\n            // }\n            // for _, d := range file.Decls {\n            //  x := d.(*ast.GenDecl)\n            //  if x.Doc != nil {\n            //      fmt.Println(len(x.Doc.List))\n            //      for _, l := range x.Doc.List {\n            //          fmt.Println(\"ooo\", l.Text)\n            //      }\n            //      fmt.Println(\"gg\", x.Doc.Text(), \"--\")\n            //  }\n            //  ts := x.Specs[0].(*ast.TypeSpec)\n            //  fmt.Println(ts.Name)\n\n            // }\n            // continue\n            ast.Inspect(file, func(n ast.Node) bool {\n\n                switch x := n.(type) {\n                // 注释写在type struct 上面的注释 是算一个节点. 不是属于type struct的内部东西\n                case *ast.GenDecl:\n                    // fmt.Println(\"注释内容2:\", x.Doc.Text())\n                case *ast.CommentGroup:\n                    // fmt.Println(\"注释内容:\", x.Text())\n                case *ast.TypeSpec:\n                    if structType, ok := x.Type.(*ast.StructType); ok {\n                        fmt.Println(\"结构体名称:\", x.Name.Name)\n                        structInfo := StructInfo{\n                            Name:        x.Name.Name,\n                            PackageName: packageName,\n                        }\n\n                        // 提取结构体字段信息\n                        for _, field := range structType.Fields.List {\n                            for _, ident := range field.Names {\n                                structInfo.Fields = append(structInfo.Fields, Field{\n                                    Name: ident.Name,\n                                    Type: fileSetToString(fset, field.Type),\n                                })\n                            }\n                        }\n\n                        // 生成 Get 和 Set 方法的代码\n                        generateGetSetMethods(structInfo)\n\n                    }\n                }\n                // ast.Print(fset, n)\n                return true\n            })\n        }\n    }\n}\n\nfunc generateGetSetMethods(structInfo StructInfo) {\n    tmpl := template.Must(template.New(\"\").Parse(getSetMethodsTemplate))\n\n    fileName := structInfo.Name + \"_getset.go\"\n    fmt.Println(fileName)\n    file, err := os.Create(fileName)\n    if err != nil {\n        fmt.Fprintf(os.Stderr, \"Failed to create file: %v\\n\", err)\n        os.Exit(1)\n    }\n    defer file.Close()\n\n    err = tmpl.Execute(file, structInfo)\n    if err != nil {\n        fmt.Fprintf(os.Stderr, \"Failed to generate code: %v\\n\", err)\n        os.Exit(1)\n    }\n\n    fmt.Printf(\"生成的文件 %s\\n\", fileName)\n}\n\nfunc fileSetToString(fset *token.FileSet, node ast.Node) string {\n    var buf strings.Builder\n    if err := printer.Fprint(&buf, fset, node); err != nil {\n        return \"\"\n    }\n    return buf.String()\n}\n\nconst getSetMethodsTemplate = `\n// Code generated by go generate; DO NOT EDIT.\n\npackage {{.PackageName}}\n\n{{range .Fields}}\nfunc (s *{{$.Name}}) Get{{.Name}}() {{.Type}} {\n    return s.{{.Name}}\n}\n\nfunc (s *{{$.Name}}) Set{{.Name}}(value {{.Type}}) {\n    s.{{.Name}} = value\n}\n{{end}}\n`\n\nfunc main() {\n    fmt.Println(111)\n    generateCode()\n}\n\n# 只会解析当前目录下的所有go文件\ngo generate # 会创建struct类型的 getset 方法 的go文件\n\n# 或者\ncd codegen\ngo build .\nmv codegen /usr/local/bin\n然后在注释中 这样写 也是ok的\n//go:generate codegen\n\n# 解析子目录 pkg 需要进去目录?\ncd pkg\ngo generate",
    "crumbs": [
      "工具与实用库",
      "generate"
    ]
  },
  {
    "objectID": "docs/programming/go/pkg/go-generate.html#stringer",
    "href": "docs/programming/go/pkg/go-generate.html#stringer",
    "title": "go generate",
    "section": "3 stringer",
    "text": "3 stringer",
    "crumbs": [
      "工具与实用库",
      "generate"
    ]
  },
  {
    "objectID": "docs/programming/go/infrastructure/directory.html",
    "href": "docs/programming/go/infrastructure/directory.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "Back to top",
    "crumbs": [
      "工程设计",
      "目录结构"
    ]
  },
  {
    "objectID": "docs/programming/go/infrastructure/error.html",
    "href": "docs/programming/go/infrastructure/error.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "Back to top",
    "crumbs": [
      "工程设计",
      "错误处理"
    ]
  },
  {
    "objectID": "docs/programming/go/infrastructure/limit.html",
    "href": "docs/programming/go/infrastructure/limit.html",
    "title": "go 限流",
    "section": "",
    "text": "Back to top"
  },
  {
    "objectID": "docs/programming/go/concurrency/sync.html",
    "href": "docs/programming/go/concurrency/sync.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "Back to top"
  },
  {
    "objectID": "docs/programming/go/concurrency/channel.html",
    "href": "docs/programming/go/concurrency/channel.html",
    "title": "go channel",
    "section": "",
    "text": "Tip\n\n\n\n\n无缓冲:假设快递, 在没有蜂巢的情况下, 快递员带着包裹来了, 你人不在, GG, 阻塞了,等待\n有缓冲:有蜂巢后, 包裹到了, 快递员直接将包裹放到蜂巢就行, 但是如果蜂巢满了, GG,阻塞了,等待\n\n当然如果 客户在的话, 那么直接交给客户就是了\n\n上面2点已经说明了,什么情况下是不阻塞的\n\n\n\nfunc TestChan(t *testing.T) {\n    //定义\n    var intChan chan int\n    // 指针,引用类型\n    intChan = make(chan int, 3)\n    fmt.Printf(\"intChar的值=%v intChan本身的地址=%p\\n\", intChan, &intChan)\n    go func() {\n        // 元素个数为空时读 会阻塞等待\n        fmt.Println(\"读取管道等待中...\")\n        num2 := &lt;-intChan\n        fmt.Println(\"读取完毕...\", num2)\n    }()\n    time.Sleep(2 * time.Second)\n    // 向管道写入数据\n    intChan &lt;- 1\n    intChan &lt;- 2\n    intChan &lt;- 3\n    // 打印管道的长度和容量\n    // 容量是不变的,长度根据管道里面存放着多少个数据\n    fmt.Printf(\"intChan len=%d cap=%d\\n\", len(intChan), cap(intChan))\n    intChan &lt;- 4\n    go func() {\n        // 数据写入,满了,再写 会阻塞等待\n        fmt.Println(\"写入管道等待中...\")\n        intChan &lt;- 5\n        fmt.Println(\"写入管道完毕...\")\n    }()\n\n    time.Sleep(3 * time.Second)\n    //读取管道数据\n    // 无变量接收\n    &lt;-intChan\n    // 有变量接收\n    num, ok := &lt;-intChan\n    fmt.Println(\"读取:\",ok, num)\n\n    time.Sleep(5 * time.Second)\n    // 关闭管道后,不能写入数据,但是可以读取\n    close(intChan)\n\n    num = &lt;-intChan\n    fmt.Println(num)\n    num = &lt;-intChan\n    fmt.Println(num)\n    // 已经没有元素了, 但是还是可以读取操作, 值是0\n    num, ok = &lt;-intChan\n    fmt.Println(num,ok) // 0 false\n}\nfunc main() {\n    // 无缓冲\n    ch := make(chan int)\n    // 没有消费者, 运行会直接报错\n    ch &lt;- 1\n}\nfunc main() {\n    ch := make(chan int)\n    // 启动一个goroutine将数据发送到通道中\n    go func() {\n        for i := 1; i &lt;= 5; i++ {\n            ch &lt;- i // 发送数据到通道\n            time.Sleep(time.Second)\n\n        }\n        close(ch) // 关闭通道\n    }()\n\n    // 使用for range迭代读取通道中的值\n    // 如果没有 close 会超时退出\n    for num := range ch {\n        fmt.Println(num)\n    }\n}\n\nselect",
    "crumbs": [
      "并发",
      "channel"
    ]
  },
  {
    "objectID": "docs/programming/go/concurrency/channel.html#基本操作",
    "href": "docs/programming/go/concurrency/channel.html#基本操作",
    "title": "go channel",
    "section": "",
    "text": "Tip\n\n\n\n\n无缓冲:假设快递, 在没有蜂巢的情况下, 快递员带着包裹来了, 你人不在, GG, 阻塞了,等待\n有缓冲:有蜂巢后, 包裹到了, 快递员直接将包裹放到蜂巢就行, 但是如果蜂巢满了, GG,阻塞了,等待\n\n当然如果 客户在的话, 那么直接交给客户就是了\n\n上面2点已经说明了,什么情况下是不阻塞的\n\n\n\nfunc TestChan(t *testing.T) {\n    //定义\n    var intChan chan int\n    // 指针,引用类型\n    intChan = make(chan int, 3)\n    fmt.Printf(\"intChar的值=%v intChan本身的地址=%p\\n\", intChan, &intChan)\n    go func() {\n        // 元素个数为空时读 会阻塞等待\n        fmt.Println(\"读取管道等待中...\")\n        num2 := &lt;-intChan\n        fmt.Println(\"读取完毕...\", num2)\n    }()\n    time.Sleep(2 * time.Second)\n    // 向管道写入数据\n    intChan &lt;- 1\n    intChan &lt;- 2\n    intChan &lt;- 3\n    // 打印管道的长度和容量\n    // 容量是不变的,长度根据管道里面存放着多少个数据\n    fmt.Printf(\"intChan len=%d cap=%d\\n\", len(intChan), cap(intChan))\n    intChan &lt;- 4\n    go func() {\n        // 数据写入,满了,再写 会阻塞等待\n        fmt.Println(\"写入管道等待中...\")\n        intChan &lt;- 5\n        fmt.Println(\"写入管道完毕...\")\n    }()\n\n    time.Sleep(3 * time.Second)\n    //读取管道数据\n    // 无变量接收\n    &lt;-intChan\n    // 有变量接收\n    num, ok := &lt;-intChan\n    fmt.Println(\"读取:\",ok, num)\n\n    time.Sleep(5 * time.Second)\n    // 关闭管道后,不能写入数据,但是可以读取\n    close(intChan)\n\n    num = &lt;-intChan\n    fmt.Println(num)\n    num = &lt;-intChan\n    fmt.Println(num)\n    // 已经没有元素了, 但是还是可以读取操作, 值是0\n    num, ok = &lt;-intChan\n    fmt.Println(num,ok) // 0 false\n}\nfunc main() {\n    // 无缓冲\n    ch := make(chan int)\n    // 没有消费者, 运行会直接报错\n    ch &lt;- 1\n}\nfunc main() {\n    ch := make(chan int)\n    // 启动一个goroutine将数据发送到通道中\n    go func() {\n        for i := 1; i &lt;= 5; i++ {\n            ch &lt;- i // 发送数据到通道\n            time.Sleep(time.Second)\n\n        }\n        close(ch) // 关闭通道\n    }()\n\n    // 使用for range迭代读取通道中的值\n    // 如果没有 close 会超时退出\n    for num := range ch {\n        fmt.Println(num)\n    }\n}\n\nselect",
    "crumbs": [
      "并发",
      "channel"
    ]
  },
  {
    "objectID": "docs/programming/go/concurrency/channel.html#底层原理",
    "href": "docs/programming/go/concurrency/channel.html#底层原理",
    "title": "go channel",
    "section": "2 底层原理",
    "text": "2 底层原理\n\n2.1 hchan数据结构\n\n\n\n\n\n\n思考 (以有缓冲为例)\n\n\n\n\nchannel 可能占用的内存空间比较大, 那么将实际数据存放在堆上\n操作上FIFO,那么 使用一个数组来存数据 ,环形的\n\n需要一个索引指出下一个读的下标位置\n需要一个索引指出下一个写的下标位置\n\n需要存储的元素的类型信息\n线程安全的, 那么肯定有锁这样的东西\n缓冲区为空时,在读这个chan的goroutine会阻塞, 当chan 有数据时,会开始读取数据,所以chan需要知道谁在等待读自己\n当缓冲区满了后,往chan写数据的goroutine 就会阻塞,等空出位置了, 之前阻塞的goroutine 会重新开始写数据,所以需要知道谁在等待写该chan\nclose 操作后, 不能写入数据了, 需要记录 是否close的信息\n\n\n\n\n\n查看汇编知道 runtime.makechan\n\ntype hchan struct {\n    qcount   uint           // 当前存放的元素个数\n    dataqsiz uint           // 数组的容量\n    buf      unsafe.Pointer // 数组的地址\n    elemsize uint16 \n    closed   uint32  // \n    elemtype *_type // element type\n    sendx    uint   // 下一个写的下标\n    recvx    uint   // 下一个读的下标\n    recvq    waitq  // 读等待队列\n    sendq    waitq  // 写等待队列\n    lock mutex  // 锁\n}\n\n\n\n2.2 recvq和sendq何时有数据\n\n\n\n\n\n\nTip\n\n\n\n\n有缓冲chan,缓冲区满了,还往里写的goroutine 会加入 sendq 队列\n有缓冲chan,缓冲区空的,从ch里读的goroutine 会加入 recvq 队列\n无缓冲chan,无人接收时,往里写的goroutine 会加入 sendq 队列\n无缓冲chan,无人写入时,从ch里读的goroutine 会加入 recvq 队列\n\n\n\n\n\n用于检验sendq和recvq的demo\n\npackage test\n\nimport (\n    \"bytes\"\n    \"fmt\"\n    \"runtime\"\n    \"strconv\"\n    \"testing\"\n    \"time\"\n    \"unsafe\"\n)\n\ntype hchan struct {\n    qcount   uint\n    dataqsiz uint\n    buf      unsafe.Pointer\n    elemsize uint16\n    closed   uint32\n    elemtype *int64\n    sendx    uint \n    recvx    uint\n    recvq    waitq \n    sendq    waitq\n}\ntype waitq struct {\n    first *sudog\n    last  *sudog\n}\ntype sudog struct {\n    g    *g\n    next *sudog\n    prev *sudog\n}\ntype g struct {\n    // 通过源码g 的结构, 前面字段占用的字节.\n    // 版本不一样可能 这里也会不一样.\n    tmp  [19]uint64\n    goid uint64\n}\n\n// 获取 goroutine 的id\nfunc GetGID() uint64 {\n    b := make([]byte, 64)\n    b = b[:runtime.Stack(b, false)]\n    b = bytes.TrimPrefix(b, []byte(\"goroutine \"))\n    b = b[:bytes.IndexByte(b, ' ')]\n    n, _ := strconv.ParseUint(string(b), 10, 64)\n    return n\n}\n\nfunc TestMain(t *testing.T) {\n    fmt.Println(\"主 goroutine:\", GetGID())\n    // ch := make(chan int) 无缓冲验证\n    ch := make(chan int, 5)\n    chAddr := *(*uintptr)(unsafe.Pointer(&ch))\n    go func() {\n\n        fmt.Println(\"这个goroutine A的 id:\", GetGID())\n        for i := 0; i &lt; 10; i++ {\n            time.Sleep(50 * time.Millisecond)\n            ch &lt;- i\n        }\n\n    }()\n    go func() {\n\n        time.Sleep(1 * time.Second)\n        fmt.Println(\"这个goroutine B的 id:\", GetGID())\n        for i := 11; i &lt; 20; i++ {\n            time.Sleep(50 * time.Millisecond)\n            ch &lt;- i\n        }\n    }()\n    go func() {\n\n        for {\n            hchanData := *(*hchan)(unsafe.Pointer(chAddr))\n            fmt.Println(hchanData)\n            if hchanData.sendq.first != nil {\n                fmt.Println(\"hchan结构里sendq存的 first goroutine id: \", hchanData.sendq.first.g.goid)\n                if hchanData.sendq.first.next != nil {\n                    fmt.Println(\"hchan结构里sendq存的first goroutine id -&gt;next: \", hchanData.sendq.first.next.g.goid)\n                }\n            }\n            if hchanData.sendq.last != nil {\n                fmt.Println(\"hchan结构里sendq存的last goroutine id: \", hchanData.sendq.last.g.goid)\n                if hchanData.sendq.last.prev != nil {\n                    fmt.Println(\"hchan结构里sendq存的last goroutine id -&gt;prev: \", hchanData.sendq.last.prev.g.goid)\n                }\n\n            }\n            // for select case 处读取chan, 到没有元素了,就会在recvq添加读取它goroutine\n            if hchanData.recvq.first != nil {\n                fmt.Println(\"当前ch 的元素个数:\", len(ch))\n                // 主协程 最后一直等待读取 chan\n                fmt.Println(\"hchan结构里 recvq 存的first goroutine id: \", hchanData.recvq.first.g.goid)\n                close(ch)\n            }\n            time.Sleep(1 * time.Second)\n        }\n    }()\n\n    time.Sleep(5 * time.Second)\n\nLoop:\n    for {\n        select {\n        case c, ok := &lt;-ch:\n            if !ok {\n                break Loop\n            }\n            fmt.Println(c)\n        }\n        time.Sleep(500 * time.Millisecond)\n    }\n}\n\n\n\n2.3 写 runtime.chansend1\nfunc chansend1(c *hchan, elem unsafe.Pointer) {\n    chansend(c, elem, true, getcallerpc())\n}\n\nfunc chansend(c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool {\n    if c == nil {\n        if !block {\n            return false\n        }\n\n        //chan是nil的情况, 直接 阻塞\n        gopark(nil, nil, waitReasonChanSendNilChan, traceEvGoStop, 2)\n        throw(\"unreachable\")\n    }\n\n    // ...\n\n    if !block && c.closed == 0 && full(c) {\n        return false\n    }\n\n    var t0 int64\n    if blockprofilerate &gt; 0 {\n        t0 = cputicks()\n    }\n    // 准备开始发送数据,先加锁\n    lock(&c.lock)\n\n    if c.closed != 0 {\n        unlock(&c.lock)\n        panic(plainError(\"send on closed channel\"))  // (1)\n    }\n    // 如果这个时候有接收者在等待数据,那么直接发给它,不用写入缓冲区\n    // 接收者在等待意味着缓冲区里本身是没数据的\n    if sg := c.recvq.dequeue(); sg != nil {\n        send(c, sg, ep, func() { unlock(&c.lock) }, 3)\n        return true\n    }\n    // 如果缓冲区有空余的情况\n    if c.qcount &lt; c.dataqsiz {\n        qp := chanbuf(c, c.sendx)\n        if raceenabled {\n            racenotify(c, c.sendx, nil)\n        }\n        typedmemmove(c.elemtype, qp, ep)\n        c.sendx++\n        if c.sendx == c.dataqsiz {\n            c.sendx = 0\n        }\n        c.qcount++\n        unlock(&c.lock)\n        return true\n    }\n\n    if !block {\n        unlock(&c.lock)\n        return false\n    }\n    // 走到这里的话, 意味着缓冲没空余且无接收者,这个时候就是 添加到sendq\n    gp := getg()\n    mysg := acquireSudog()\n    mysg.releasetime = 0\n    if t0 != 0 {\n        mysg.releasetime = -1\n    }\n    mysg.elem = ep\n    mysg.waitlink = nil\n    mysg.g = gp\n    mysg.isSelect = false\n    mysg.c = c\n    gp.waiting = mysg\n    gp.param = nil\n    c.sendq.enqueue(mysg)\n    gp.parkingOnChan.Store(true)\n    gopark(chanparkcommit, unsafe.Pointer(&c.lock), waitReasonChanSend, traceEvGoBlockSend, 2)\n    KeepAlive(ep)\n\n    // someone woke us up.\n    if mysg != gp.waiting {\n        throw(\"G waiting list is corrupted\")\n    }\n    gp.waiting = nil\n    gp.activeStackChans = false\n    closed := !mysg.success\n    gp.param = nil\n    if mysg.releasetime &gt; 0 {\n        blockevent(mysg.releasetime-t0, 2)\n    }\n    mysg.c = nil\n    releaseSudog(mysg)\n    if closed {\n        if c.closed == 0 {\n            throw(\"chansend: spurious wakeup\")\n        }\n        panic(plainError(\"send on closed channel\"))\n    }\n    return true\n}\n\n测试代码 go     // 执行会报错 panic: send on closed channel     func TestSendToCloseChan(t *testing.T) {         ch := make(chan int, 2)         ch &lt;- 1         close(ch)         ch &lt;- 2     }\n\n\n\n2.4 读 runtime.chanrecv1",
    "crumbs": [
      "并发",
      "channel"
    ]
  },
  {
    "objectID": "docs/programming/go/concurrency/goroutine.html",
    "href": "docs/programming/go/concurrency/goroutine.html",
    "title": "go goroutine",
    "section": "",
    "text": "TODO"
  },
  {
    "objectID": "docs/programming/go/concurrency/goroutine.html#goroutine与线程",
    "href": "docs/programming/go/concurrency/goroutine.html#goroutine与线程",
    "title": "go goroutine",
    "section": "1 goroutine与线程",
    "text": "1 goroutine与线程\n\ngoroutine 是用户态线程, 需要由go runtime来调度\n内核态线程由操作系统调度\n\n协程的底层结构\n\n\nsrc/runtime2.go\n\ntype g struct {\n    stack       stack   // (1)\n    stackguard0 uintptr // offset known to liblink\n    stackguard1 uintptr // offset known to liblink\n\n    _panic    *_panic // innermost panic - offset known to liblink\n    _defer    *_defer // innermost defer\n    m         *m      // current m; offset known to arm liblink\n    sched     gobuf  // goroutine 运行情况\n    syscallsp uintptr // if status==Gsyscall, syscallsp = sched.sp to use during gc\n    syscallpc uintptr // if status==Gsyscall, syscallpc = sched.pc to use during gc\n    stktopsp  uintptr // expected sp at top of stack, to check in traceback\n    param        unsafe.Pointer\n    atomicstatus atomic.Uint32  // goroutine的状态\n    stackLock    uint32 // sigprof/scang lock; TODO: fold in to atomicstatus\n    goid         uint64\n    schedlink    guintptr\n    waitsince    int64      // approx time when the g become blocked\n    waitreason   waitReason // if status==Gwaiting\n\n    preempt       bool // preemption signal, duplicates stackguard0 = stackpreempt\n    preemptStop   bool // transition to _Gpreempted on preemption; otherwise, just deschedule\n    preemptShrink bool // shrink stack at synchronous safe point\n    asyncSafePoint bool\n\n    paniconfault bool // panic (instead of crash) on unexpected fault address\n    gcscandone   bool // g has scanned stack; protected by _Gscan bit in status\n    throwsplit   bool // must not split stack\n    activeStackChans bool\n    parkingOnChan atomic.Bool\n    raceignore     int8     // ignore race detection events\n    sysblocktraced bool     // StartTrace has emitted EvGoInSyscall about this goroutine\n    tracking       bool     // whether we're tracking this G for sched latency statistics\n    trackingSeq    uint8    // used to decide whether to track this G\n    trackingStamp  int64    // timestamp of when the G last started being tracked\n    runnableTime   int64    // the amount of time spent runnable, cleared when running, only used when tracking\n    sysexitticks   int64    // cputicks when syscall has returned (for tracing)\n    traceseq       uint64   // trace event sequencer\n    tracelastp     puintptr // last P emitted an event for this goroutine\n    lockedm        muintptr\n    sig            uint32\n    writebuf       []byte\n    sigcode0       uintptr\n    sigcode1       uintptr\n    sigpc          uintptr\n    gopc           uintptr         // pc of go statement that created this goroutine\n    ancestors      *[]ancestorInfo \n    startpc        uintptr         // pc of goroutine function\n    racectx        uintptr\n    cgoCtxt        []uintptr      // cgo traceback context\n    labels         unsafe.Pointer // profiler labels\n    timer          *timer         // cached timer for time.Sleep\n    selectDone     atomic.Uint32  // are we participating in a select and did someone win the race?\n    goroutineProfiled goroutineProfileStateHolder\n    gcAssistBytes int64\n}\n\n\nstack go     type stack struct {         lo uintptr  // goroutine栈的下限         hi uintptr  // goroutine栈的上限     }\ngobuf go     type gobuf struct {         sp   uintptr  // 运行这个goroutine 时的栈指针         pc   uintptr  // 下一个要执行的指令的地址         g    guintptr         ctxt unsafe.Pointer         ret  uintptr         lr   uintptr         bp   uintptr     }\n\nM 的底层结构, 记录 操作系统线程的信息, 线程的抽象 runtime将底层的操作系统线程 抽象为 M 结构 ```go title=“runtime2.go” type m struct { g0 *g // 第一个 goroutine,调度用,启动其他goroutine morebuf gobuf // gobuf arg to morestack divmod uint32 // div/mod denominator for arm - known to liblink _ uint32 // align next field to 8 bytes\n// Fields not known to debuggers.\nprocid        uint64            // for debuggers, but offset not hard-coded\ngsignal       *g                // signal-handling g\ngoSigStack    gsignalStack      // Go-allocated signal handling stack\nsigmask       sigset            // storage for saved signal mask\ntls           [tlsSlots]uintptr // thread-local storage (for x86 extern register)\nmstartfn      func()\ncurg          *g       // 当前正在运行的goroutine\ncaughtsig     guintptr // goroutine running during fatal signal\np             puintptr // attached p for executing go code (nil if not executing go code)\nnextp         puintptr\noldp          puintptr // the p that was attached before executing a syscall\nid            int64\nmallocing     int32\nthrowing      throwType\npreemptoff    string // if != \"\", keep curg running on this m\nlocks         int32\ndying         int32\nprofilehz     int32\nspinning      bool // m is out of work and is actively looking for work\nblocked       bool // m is blocked on a note\nnewSigstack   bool // minit on C thread called sigaltstack\nprintlock     int8\nincgo         bool          // m is executing a cgo call\nisextra       bool          // m is an extra m\nfreeWait      atomic.Uint32 // Whether it is safe to free g0 and delete m (one of freeMRef, freeMStack, freeMWait)\nfastrand      uint64\nneedextram    bool\ntraceback     uint8\nncgocall      uint64        // number of cgo calls in total\nncgo          int32         // number of cgo calls currently in progress\ncgoCallersUse atomic.Uint32 // if non-zero, cgoCallers in use temporarily\ncgoCallers    *cgoCallers   // cgo traceback if crashing in cgo call\npark          note\nalllink       *m // on allm\nschedlink     muintptr\nlockedg       guintptr\ncreatestack   [32]uintptr // stack that created this thread.\nlockedExt     uint32      // tracking for external LockOSThread\nlockedInt     uint32      // tracking for internal lockOSThread\nnextwaitm     muintptr    // next m waiting for lock\nwaitunlockf   func(*g, unsafe.Pointer) bool\nwaitlock      unsafe.Pointer\nwaittraceev   byte\nwaittraceskip int\nstartingtrace bool\nsyscalltick   uint32\nfreelink      *m // on sched.freem\n\n// these are here because they are too large to be on the stack\n// of low-level NOSPLIT functions.\nlibcall   libcall\nlibcallpc uintptr // for cpu profiler\nlibcallsp uintptr\nlibcallg  guintptr\nsyscall   libcall // stores syscall parameters on windows\n\nvdsoSP uintptr // SP for traceback while in VDSO call (0 if not in call)\nvdsoPC uintptr // PC for traceback while in VDSO call\n\n// preemptGen counts the number of completed preemption\n// signals. This is used to detect when a preemption is\n// requested, but fails.\npreemptGen atomic.Uint32\n\n// Whether this is a pending preemption signal on this M.\nsignalPending atomic.Uint32\n\ndlogPerM\n\nmOS\n\n// Up to 10 locks held by this m, maintained by the lock ranking code.\nlocksHeldLen int\nlocksHeld    [10]heldLockInfo\n}\n\n## GPM\n\n\n\n\n```bash\ngo build -o main -gcflags \"-N -l\" main.go\nobjdump -t  main|grep -v '.text'| grep -E 'g0|m0'"
  },
  {
    "objectID": "docs/programming/go/basic/unsafe.html",
    "href": "docs/programming/go/basic/unsafe.html",
    "title": "go unsafe",
    "section": "",
    "text": "Tip\n\n\n\nGo 1.17 新增 unsafe.Slice\n\n\n// 等价于  (*[len]ArbitraryType)(unsafe.Pointer(ptr))[:]\nfunc TestSlice(t *testing.T) {\n    st := struct {\n        a int8  // 内存对齐, 导致补一个字节\n        b int16 // 516 ==&gt; 高位字节是 2, 低位字节是4  0x204\n        c int32\n    }{1, 516, 3}\n    // unsafe.Slice  把任何指针变成一个切片\n    // 切片元素类型是 转递的参数指针的类型 , 这里就是 int8\n    // 比如 如果你传递  &st 虽然地址与&st.a 一样, 但是结果就不一样了.\n    slice := unsafe.Slice(&st.a, 5)\n    println(len(slice), cap(slice))\n    // 1 ?(不确定的污染数据) 4 2\n    println(slice[0], slice[1], slice[2], slice[3])\n\n}\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nGo 1.20 新增 unsafe.SliceData\n\n\nfunc TestSliceData(t *testing.T) {\n    slice := []int64{1, 2, 3, 4}\n    // unsafe.SliceData 返回指向 切片数据(数组)的指针\n    sliceDataPtr := unsafe.SliceData(slice)\n    reflSlice := *(*reflect.SliceHeader)(unsafe.Pointer(&slice))\n    println(sliceDataPtr, unsafe.Pointer(reflSlice.Data))\n}\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nuintptr的+ 的操作的简便方式\n\n\ntype MyStruct struct {\n    age    int16\n    height int16\n}\n\nfunc TestUnsafeAdd(t *testing.T) {\n    var ms MyStruct\n    ms.age = 32\n    ms.height = 182\n\n    ptr := unsafe.Pointer(&ms)\n    offset := unsafe.Offsetof(ms.height)\n    fmt.Println(offset)\n    newPtr := unsafe.Add(ptr, offset)\n\n    // 访问新的地址处的值\n    fmt.Println(*(*int16)(newPtr)) // 输出 182\n}\n\n\n\nfunc TestUnsafe(t *testing.T) {\n    slice := []byte{'h', 'e', 'l', 'l', 'o'}\n    // 参数1: 字符数组的地址, 参数2: 字符数组长度\n    // 是字符串的2个组成部分\n    s := unsafe.String(&slice[0], 3)\n    println(s)\n    ss := *(*reflect.StringHeader)(unsafe.Pointer(&s))\n    // 相同的, 所以是直接转为 字符串 (将字符串的字符数组地址设置为 上面切片的数组地址)\n    println(unsafe.Pointer(ss.Data), &slice[0])\n}",
    "crumbs": [
      "基础篇",
      "unsafe"
    ]
  },
  {
    "objectID": "docs/programming/go/basic/unsafe.html#一些方法",
    "href": "docs/programming/go/basic/unsafe.html#一些方法",
    "title": "go unsafe",
    "section": "",
    "text": "Tip\n\n\n\nGo 1.17 新增 unsafe.Slice\n\n\n// 等价于  (*[len]ArbitraryType)(unsafe.Pointer(ptr))[:]\nfunc TestSlice(t *testing.T) {\n    st := struct {\n        a int8  // 内存对齐, 导致补一个字节\n        b int16 // 516 ==&gt; 高位字节是 2, 低位字节是4  0x204\n        c int32\n    }{1, 516, 3}\n    // unsafe.Slice  把任何指针变成一个切片\n    // 切片元素类型是 转递的参数指针的类型 , 这里就是 int8\n    // 比如 如果你传递  &st 虽然地址与&st.a 一样, 但是结果就不一样了.\n    slice := unsafe.Slice(&st.a, 5)\n    println(len(slice), cap(slice))\n    // 1 ?(不确定的污染数据) 4 2\n    println(slice[0], slice[1], slice[2], slice[3])\n\n}\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nGo 1.20 新增 unsafe.SliceData\n\n\nfunc TestSliceData(t *testing.T) {\n    slice := []int64{1, 2, 3, 4}\n    // unsafe.SliceData 返回指向 切片数据(数组)的指针\n    sliceDataPtr := unsafe.SliceData(slice)\n    reflSlice := *(*reflect.SliceHeader)(unsafe.Pointer(&slice))\n    println(sliceDataPtr, unsafe.Pointer(reflSlice.Data))\n}\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nuintptr的+ 的操作的简便方式\n\n\ntype MyStruct struct {\n    age    int16\n    height int16\n}\n\nfunc TestUnsafeAdd(t *testing.T) {\n    var ms MyStruct\n    ms.age = 32\n    ms.height = 182\n\n    ptr := unsafe.Pointer(&ms)\n    offset := unsafe.Offsetof(ms.height)\n    fmt.Println(offset)\n    newPtr := unsafe.Add(ptr, offset)\n\n    // 访问新的地址处的值\n    fmt.Println(*(*int16)(newPtr)) // 输出 182\n}\n\n\n\nfunc TestUnsafe(t *testing.T) {\n    slice := []byte{'h', 'e', 'l', 'l', 'o'}\n    // 参数1: 字符数组的地址, 参数2: 字符数组长度\n    // 是字符串的2个组成部分\n    s := unsafe.String(&slice[0], 3)\n    println(s)\n    ss := *(*reflect.StringHeader)(unsafe.Pointer(&s))\n    // 相同的, 所以是直接转为 字符串 (将字符串的字符数组地址设置为 上面切片的数组地址)\n    println(unsafe.Pointer(ss.Data), &slice[0])\n}",
    "crumbs": [
      "基础篇",
      "unsafe"
    ]
  },
  {
    "objectID": "docs/programming/go/basic/unsafe.html#unsafe.pointer-uintptr",
    "href": "docs/programming/go/basic/unsafe.html#unsafe.pointer-uintptr",
    "title": "go unsafe",
    "section": "2 unsafe.Pointer & uintptr",
    "text": "2 unsafe.Pointer & uintptr\nGC 会管理 unsafe.Pointer uintptr 则不会",
    "crumbs": [
      "基础篇",
      "unsafe"
    ]
  },
  {
    "objectID": "docs/programming/go/basic/slice.html",
    "href": "docs/programming/go/basic/slice.html",
    "title": "go 切片",
    "section": "",
    "text": "type SliceHeader struct {\n    Data uintptr // 引用的数组的地址\n    Len  int     // 切片长度\n    Cap  int     // 引用的数组的长度\n}\n\nfunc TestSlice(t *testing.T) {\n    // 方式1\n    slice1 := []int{11, 22, 33, 44, 55}\n    b := (*reflect.SliceHeader)(unsafe.Pointer(&slice1))\n    fmt.Println(b.Cap, b.Len) // 5 5\n    fmt.Println(len(slice1), cap(slice1))\n    // 方式2\n    arr := [5]int{11, 22, 33, 44, 55}\n    slice2 := arr[1:3]\n    c := (*reflect.SliceHeader)(unsafe.Pointer(&slice2))\n    // 指向的数组是 arr 从1下标开始的. 所以cap 是4\n    fmt.Println(c.Cap, c.Len) // 4 2\n    // slice2[2]  越界了,len是可以访问的范围\n    // 方式3\n    slice3 := make([]int, 5)\n    d := (*reflect.SliceHeader)(unsafe.Pointer(&slice3))\n    // 5,5,824634322544   data 初始化了, 分配了内存,对应的字节数组元素都是0\n    fmt.Println(d.Cap, d.Len, d.Data)\n    slice33 := make([]int, 1, 5)\n    dd := (*reflect.SliceHeader)(unsafe.Pointer(&slice33))\n    // cap =5, len=1\n    fmt.Println(dd.Cap, dd.Len, slice33[0])\n    // 方式4\n    var slice4 []int\n    e := (*reflect.SliceHeader)(unsafe.Pointer(&slice4))\n    // data 还没有初始化的 ,相比 slice4:=[]int{} 初始化推荐这种\n    fmt.Println(e.Cap, e.Len, e.Data)\n\n    a := [10]int{1, 2, 3, 4, 5, 6, 7, 8, 9}\n    // 2个切片引用同一个底层数组\n    a1 := a[1:4]\n    a2 := a[2:5]\n    a1[1] = 111\n    fmt.Println(a) // 修改了底层数组元素\n    a2[0] = 222\n    fmt.Println(a, a1[1])\n    a1 = append(a1, 333)\n    fmt.Println(a) // 修改了底层数组元素\n\n}",
    "crumbs": [
      "基础篇",
      "切片"
    ]
  },
  {
    "objectID": "docs/programming/go/basic/slice.html#数据结构",
    "href": "docs/programming/go/basic/slice.html#数据结构",
    "title": "go 切片",
    "section": "",
    "text": "type SliceHeader struct {\n    Data uintptr // 引用的数组的地址\n    Len  int     // 切片长度\n    Cap  int     // 引用的数组的长度\n}\n\nfunc TestSlice(t *testing.T) {\n    // 方式1\n    slice1 := []int{11, 22, 33, 44, 55}\n    b := (*reflect.SliceHeader)(unsafe.Pointer(&slice1))\n    fmt.Println(b.Cap, b.Len) // 5 5\n    fmt.Println(len(slice1), cap(slice1))\n    // 方式2\n    arr := [5]int{11, 22, 33, 44, 55}\n    slice2 := arr[1:3]\n    c := (*reflect.SliceHeader)(unsafe.Pointer(&slice2))\n    // 指向的数组是 arr 从1下标开始的. 所以cap 是4\n    fmt.Println(c.Cap, c.Len) // 4 2\n    // slice2[2]  越界了,len是可以访问的范围\n    // 方式3\n    slice3 := make([]int, 5)\n    d := (*reflect.SliceHeader)(unsafe.Pointer(&slice3))\n    // 5,5,824634322544   data 初始化了, 分配了内存,对应的字节数组元素都是0\n    fmt.Println(d.Cap, d.Len, d.Data)\n    slice33 := make([]int, 1, 5)\n    dd := (*reflect.SliceHeader)(unsafe.Pointer(&slice33))\n    // cap =5, len=1\n    fmt.Println(dd.Cap, dd.Len, slice33[0])\n    // 方式4\n    var slice4 []int\n    e := (*reflect.SliceHeader)(unsafe.Pointer(&slice4))\n    // data 还没有初始化的 ,相比 slice4:=[]int{} 初始化推荐这种\n    fmt.Println(e.Cap, e.Len, e.Data)\n\n    a := [10]int{1, 2, 3, 4, 5, 6, 7, 8, 9}\n    // 2个切片引用同一个底层数组\n    a1 := a[1:4]\n    a2 := a[2:5]\n    a1[1] = 111\n    fmt.Println(a) // 修改了底层数组元素\n    a2[0] = 222\n    fmt.Println(a, a1[1])\n    a1 = append(a1, 333)\n    fmt.Println(a) // 修改了底层数组元素\n\n}",
    "crumbs": [
      "基础篇",
      "切片"
    ]
  },
  {
    "objectID": "docs/programming/go/basic/slice.html#append",
    "href": "docs/programming/go/basic/slice.html#append",
    "title": "go 切片",
    "section": "2 append",
    "text": "2 append\n\n\n\n\n\n\nTip\n\n\n\n\n由于真实的数据是通过引用数组,那么如果追加后长度超过了数组的cap,肯定需要重新分配一块内存,然后还需要将原来的数据复制到新的内存地址上\n新的内存要多大才好呢?\n\n\n\n\n\n哪个版本的go 已经忘记了. 后续更新最新版本的\n\nfunc growslice(et *_type, old slice, cap int) slice {\n    newcap := old.cap\n    doublecap := newcap + newcap\n    if cap &gt; doublecap {\n        //如果期望容量大于当前容量的两倍就会使用期望容量\n        newcap = cap\n    } else {\n        if old.len &lt; 1024 {\n            // 否则 如果当前切片的长度小于 1024 就会将容量设置为原先2倍大小\n            newcap = doublecap\n        } else {\n            //如果当前切片的长度大于 1024 就会每次增加 25% 的容量，直到新容量大于期望容量\n            for 0 &lt; newcap && newcap &lt; cap {\n                newcap += newcap / 4\n            }\n            if newcap &lt;= 0 {\n                newcap = cap\n            }\n        }\n    }\n}",
    "crumbs": [
      "基础篇",
      "切片"
    ]
  },
  {
    "objectID": "docs/programming/go/basic/slice.html#遍历-for-range",
    "href": "docs/programming/go/basic/slice.html#遍历-for-range",
    "title": "go 切片",
    "section": "3 遍历 for range",
    "text": "3 遍历 for range\nfunc TestSlice(t *testing.T) {\n    arr := []int{1, 2, 3}\n    var v2 *int\n    for _, v := range arr {\n        if v == 2 {\n            v2 = &v\n        }\n        fmt.Println(&v) // 同一个地址\n    }\n    fmt.Println(*v2) // 3\n}",
    "crumbs": [
      "基础篇",
      "切片"
    ]
  },
  {
    "objectID": "docs/programming/go/basic/slice.html#增加排序",
    "href": "docs/programming/go/basic/slice.html#增加排序",
    "title": "go 切片",
    "section": "4 增加排序",
    "text": "4 增加排序\npackage main\n\nimport (\n    \"fmt\"\n    \"math/rand\"\n    \"sort\"\n)\n\ntype Student struct {\n    Name string\n    Age  int\n    Id   string\n}\ntype StudentSlice []Student\n\n// 注意我们是给切片 排序,所以是让切片实现了接口\nfunc (p StudentSlice) Len() int {\n    return len(p)\n}\nfunc (p StudentSlice) Less(i, j int) bool {\n    return p[i].Name &gt; p[j].Name\n}\nfunc (p StudentSlice) Swap(i, j int) {\n    //这个彼此换,和python一样的写法\n    p[i], p[j] = p[j], p[i]\n}\nfunc main() {\n    var ss StudentSlice\n    for i := 0; i &lt; 10; i++ {\n        s := Student{\n            Name: fmt.Sprintf(\"stu%d\", rand.Intn(100)),\n            Id:   fmt.Sprintf(\"ID_%d\", rand.Intn(100)),\n            Age:  rand.Intn(100),\n        }\n        ss = append(ss, s)\n    }\n    for _, v := range ss {\n        fmt.Println(v)\n    }\n    sort.Sort(ss)\n    fmt.Println(\"=================\")\n    for _, v := range ss {\n        fmt.Println(v)\n    }\n}",
    "crumbs": [
      "基础篇",
      "切片"
    ]
  },
  {
    "objectID": "docs/programming/go/basic/plan9.html",
    "href": "docs/programming/go/basic/plan9.html",
    "title": "go 汇编",
    "section": "",
    "text": "Important\n\n\n\n\n查看go底层执行的代码时, 可以通过查看汇编来找到源码位置\n下面几个查看的方式,结果格式略有不同\n\n\n\n\n\n方式一\n\n# -l 禁止内联优化\n# -N Disable optimizations.\n# 编译的二进制文件 禁止内联优化\ngo build -o main -gcflags \"-N -l\" main.go\n# -S Print assembly listing to standard output (code only).\n# 编译成二进制文件,并打印汇编代码\ngo build -o main -gcflags=\"-N -l -S\" main.go\n\n# 从可执行文件 反编译出汇编代码\n# 表示只输出 main 包中相关的汇编\ngo tool objdump -s \"main.\" main\n# 如果使用 \"main.main\" 则表示 只输出 main.main方法相关的汇编\ngo tool objdump -s \"main.main\" main\n#  -S   print Go code alongside assembly\n# 会打印对应的go代码\ngo tool objdump -s \"main.main\" -S main\n\n\n\n方式二\n\n#  会生成main.o 文件, -S 输出汇编代码\ngo tool compile -S -N -l main.go\n# 直接看代码的第几行的汇编代码\ngo tool compile -S -N -l main.go |grep \"main.go:8\"\n\n\n\n方式三\n\n# dlv  disassemble\n# 查看汇编代码\n(dlv) disassemble -l main.main",
    "crumbs": [
      "基础篇",
      "汇编"
    ]
  },
  {
    "objectID": "docs/programming/go/basic/plan9.html#查看汇编代码1",
    "href": "docs/programming/go/basic/plan9.html#查看汇编代码1",
    "title": "go 汇编",
    "section": "",
    "text": "Important\n\n\n\n\n查看go底层执行的代码时, 可以通过查看汇编来找到源码位置\n下面几个查看的方式,结果格式略有不同\n\n\n\n\n\n方式一\n\n# -l 禁止内联优化\n# -N Disable optimizations.\n# 编译的二进制文件 禁止内联优化\ngo build -o main -gcflags \"-N -l\" main.go\n# -S Print assembly listing to standard output (code only).\n# 编译成二进制文件,并打印汇编代码\ngo build -o main -gcflags=\"-N -l -S\" main.go\n\n# 从可执行文件 反编译出汇编代码\n# 表示只输出 main 包中相关的汇编\ngo tool objdump -s \"main.\" main\n# 如果使用 \"main.main\" 则表示 只输出 main.main方法相关的汇编\ngo tool objdump -s \"main.main\" main\n#  -S   print Go code alongside assembly\n# 会打印对应的go代码\ngo tool objdump -s \"main.main\" -S main\n\n\n\n方式二\n\n#  会生成main.o 文件, -S 输出汇编代码\ngo tool compile -S -N -l main.go\n# 直接看代码的第几行的汇编代码\ngo tool compile -S -N -l main.go |grep \"main.go:8\"\n\n\n\n方式三\n\n# dlv  disassemble\n# 查看汇编代码\n(dlv) disassemble -l main.main",
    "crumbs": [
      "基础篇",
      "汇编"
    ]
  },
  {
    "objectID": "docs/programming/go/basic/plan9.html#汇编分析go代码",
    "href": "docs/programming/go/basic/plan9.html#汇编分析go代码",
    "title": "go 汇编",
    "section": "2 汇编分析go代码",
    "text": "2 汇编分析go代码\n\n\n\n\n\n\nTip\n\n\n\n更详细的汇编说明后续会专门写教程,有些很多都忘记了…,得重新花时间再看看\n\n\n\n2.1 函数调用为啥使用栈\npackage main\n\nfunc C() {\n    println(4)\n}\nfunc B() {\n    C()\n    println(3)\n}\nfunc A() {\n    B()\n    println(2)\n}\n\nfunc main() {\n    A()\n    println(1)\n}\n\n\n\n\n\n\n思考\n\n\n\n\n函数的执行是后来的先执行,这个和栈的后进先出特征一致\n执行一个函数需要的一些内存: 参数, 返回值, 自己的局部变量\n\n参数和返回值 由调用者分配 (理由后面讲)\n局部变量所在的内存, 如果在函数执行完毕后,没有用了,那直接在函数栈上即可,返回时,弹出,移动栈顶指针即可,(就是内存释放)\n局部变量所在的内存, 如果在函数执行完毕后,还要用到,就不能在函数栈上分配了,在其他地方分配,然后返回值返回它地址即可\n\n这样函数自己分配的栈空间在调用完毕后可以完全释放了,符合入栈出栈, 可以用来管理函数\n还有一点可以得出,就是在栈上分配内存的变量它的大小是必须确定的\n\n比如定义一个局部变量 是字符串, 然后在后续代码的执行过程中, 字符串做了增加, 这说明你的字符串占用的内存大小不固定,你肯定不能将它完全直接分配在栈上了\n所以这类型的变量,必定需要在其他地方分配 (堆上分配, 栈上存它的指针,指针大小是确定的)\n\n\n\n\n\n\n2.2 要分析的go代码\npackage main\n\nfunc add(c, d int64) (sum int64) {\n    var add_local_var int64 = 3\n    sum = c + d + add_local_var\n    return sum\n}\n\nfunc main() {\n    var r int64\n    var a, b int64 = 1, 2\n    r = add(a, b)\n    println(r)\n}\n\n\n\n\n\n\n注意\n\n\n\ngo 的版本不一样看到的结果可能不一样\n\n\n\n\n\nOS\ngo version\n\n\n\n\nUbuntu 20.04.3 LTS\ngo1.20.4\n\n\n\ngo tool compile -S -N -l main.go\n\n\n2.3 main.main\n\n\n\n\n\n\n\nitem\ndescription\n\n\n\n\ncaller\n调用者\n\n\ncallee\n被调用者\n\n\nSP\n栈顶指针\n\n\n$数字\n立即数: 就是直接是指令来进行数据赋值,而不是从哪块内存读取数据的操作\n\n\n\n\nargs: 参数+返回值, main()的调用者传递给main的参数,没有,显示 0\nlocals: 包含如下\n\nmain函数本地使用的局部变量\n调用其他所有函数时传递的参数以及它的返回值 (=callee 所有 args之和) ,参数和返回值由caller负责分配\n\n\n\n\n\n\n\n\n为什么callee的参数和返回值要由caller分配内存呢?\n\n\n\n\n如果在 callee 栈中分配, 那么每次调用 callee 都要进行内存分配和释放的操作,比如你在 main函数里多次 调用 add(),每次调用都要分配一次内存和释放\n如果在 caller 栈中分配内存，caller 调用多次 callee, 也只需要一次内存分配操作\n局部变量 a和b 申请的栈空间直接作为 add 的参数(c ,d)不行吗?\n\n如果add 里对 参数做修改, 汇编代码怎么处理?\n\n直接修改 caller的a,b 所在的栈内存吗? 那肯定不行\n在 callee 中申请内存? 那又变成多次分配释放的问题了,也不行的\n\n处理方式就是在 caller 栈中申请参数 ! ==&gt;可以说明函数是值转递的\n\n返回值的额外理由\n\ncallee 的返回值, 肯定是 caller 需要用到,所以 在caller直接申请内存空间就行了,callee 直接将结果写入caller的函数栈内存即可\n如果你callee申请 ,最后函数返回会释放内存, 你可能还需要将返回值复制到 caller 的函数栈内,这样会导致额外的内存拷贝操作\n\n\n\n\nmain.main STEXT size=109 args=0x0 locals=0x30 funcid=0x0 align=0x0\n    # SB  伪寄存器，保存静态基地址(static-base) 指针，即我们程序地址空间的开始地址\n    0x0000 00000 (main.go:9)    TEXT    main.main(SB), ABIInternal, $48-0 \n    0x0000 00000 (main.go:9)    CMPQ    SP, 16(R14)\n    # PCDATA  垃圾回收相关, 由go 编译器加入\n    0x0004 00004 (main.go:9)    PCDATA  $0, $-2\n    0x0004 00004 (main.go:9)    JLS 102\n    0x0006 00006 (main.go:9)    PCDATA  $0, $-1\n    # \"main 申请的48个字节\"\n    # `SUBQ $48, SP`  SP=SP-48 ,栈顶指针往下移动48个字节, 就是main函数 申请 48个字节的栈空间\n    # main的局部变量 a b 共16个字节\n    # 调用add ,需要 传递的参数 16个字节, r 接收add返回值 占8个字节  共 24个字节 都由caller(即main) 分配\n    # 保存BP  占8个字节\n    # 调用println()  传参 直接使用的r,我估计是编译器明确知道println 不会修改参数的原因?\n    0x0006 00006 (main.go:9)    SUBQ    $48, SP \n    # BP 伪寄存器, 调用者(这里就是main的调用者)函数栈的起始位置 仅作为一个指示作用\n    # 保存BP 伪寄存器 到栈 SP+40 的位置\n    0x000a 00010 (main.go:9)    MOVQ    BP, 40(SP)\n    # 将 SP+40 这个地址 (栈地址)  设置给 BP寄存器\n    # 现在 BP寄存器指向的栈内存 存储的是 原来BP的值\n    0x000f 00015 (main.go:9)    LEAQ    40(SP), BP\n    # FUNCDATA  垃圾回收相关, 由go 编译器加入\n    0x0014 00020 (main.go:9)    FUNCDATA    $0, gclocals·g2BeySu+wFnoycgXfElmcg==(SB)\n    0x0014 00020 (main.go:9)    FUNCDATA    $1, gclocals·g2BeySu+wFnoycgXfElmcg==(SB)\n    # 将 SP+16 的栈内存 设置 立即数 0 ==&gt; r变量\n    0x0014 00020 (main.go:10)   MOVQ    $0, main.r+16(SP)\n    # 将 SP+32 的栈内存 设置 立即数 1 ==&gt; a变量\n    0x001d 00029 (main.go:11)   MOVQ    $1, main.a+32(SP)\n    # 将 SP+24 的栈内存 设置 立即数 2 ==&gt; b变量\n    0x0026 00038 (main.go:11)   MOVQ    $2, main.b+24(SP)\n    # 将 立即数 1 设置到 寄存器 AX\n    0x002f 00047 (main.go:12)   MOVL    $1, AX\n    # 将 立即数 2 设置到 寄存器 BX\n    0x0034 00052 (main.go:12)   MOVL    $2, BX\n    0x0039 00057 (main.go:12)   PCDATA  $1, $0\n\n调用 add 函数, 去看main.add\nCALL 指令\n\n将ip 压栈 就是将下一条指令(调用函数后的下一个要执行的指令)的地址 压栈\n压栈: 先将栈顶指针下移, SP=SP-8 (内存地址占8个字节), 然后将ip设置到SP指向的栈上\n调用的add 函数 最后会有一个RET 操作, 是弹栈. (call 和 ret)\n\n\n    0x0039 00057 (main.go:12)   CALL    main.add(SB)\n\nCALL 的add 最后的RET后, SP又重新变成一开始的 SP-48的位置了. 将AX寄存器里的值设置到 r的栈内存位置\n    0x003e 00062 (main.go:12)   MOVQ    AX, main.r+16(SP)\n\n    0x0043 00067 (main.go:13)   CALL    runtime.printlock(SB)\n    0x0048 00072 (main.go:13)   MOVQ    main.r+16(SP), AX\n    0x004d 00077 (main.go:13)   CALL    runtime.printint(SB)\n    0x0052 00082 (main.go:13)   CALL    runtime.printnl(SB)\n    0x0057 00087 (main.go:13)   CALL    runtime.printunlock(SB)\n复原BP,SP\n    0x005c 00092 (main.go:14)   MOVQ    40(SP), BP\n    0x0061 00097 (main.go:14)   ADDQ    $48, SP\n    0x0065 00101 (main.go:14)   RET\n\n\n2.4 main.add\n\nargs = 0x10=16, 使用了caller的栈内存 (参数+返回值)\n$24-16\n\n24表示add 申请的栈内存空间,\n16表示 用到了 caller的栈内存空间大小 = args\n 你可能会觉得 不应该是 参数+返回值= 24个字节吗?? 怎么是16,后面说 \n\n\nmain.add STEXT nosplit size=63 args=0x10 locals=0x18 funcid=0x0 align=0x0\n    0x0000 00000 (main.go:3)    TEXT    main.add(SB), NOSPLIT|ABIInternal, $24-16\n\nBP+局部变量(sum+add_local_var) 共24个字节?\n 你可能又会觉得 这个sum 不就是 main栈空间的r吗? 不直接使用它而在add栈内分配了内存呢? 后面解答\n\n    0x0000 00000 (main.go:3)    SUBQ    $24, SP\n    0x0004 00004 (main.go:3)    MOVQ    BP, 16(SP)\n    0x0009 00009 (main.go:3)    LEAQ    16(SP), BP\n    0x000e 00014 (main.go:3)    FUNCDATA    $0, gclocals·g2BeySu+wFnoycgXfElmcg==(SB)\n    0x000e 00014 (main.go:3)    FUNCDATA    $1, gclocals·g2BeySu+wFnoycgXfElmcg==(SB)\n    0x000e 00014 (main.go:3)    FUNCDATA    $5, main.add.arginfo1(SB)\n\n将AX( 即 1) 设置到 SP+32 =SP+24(add申请的栈空间)+8(call add 压栈) 这个位置就是 main一开始申请栈内存后的 sp的位置, 参数c\n将BX( 即 2) 参数d\n\n    0x000e 00014 (main.go:3)    MOVQ    AX, main.c+32(SP)\n    0x0013 00019 (main.go:3)    MOVQ    BX, main.d+40(SP)\n\n初始化 sum变量设置为0\n设置 局部变量 add_local_var =3\n\n    0x0018 00024 (main.go:3)    MOVQ    $0, main.sum(SP)\n    0x0020 00032 (main.go:4)    MOVQ    $3, main.add_local_var+8(SP)\n\n计算后将结果设置到AX 以及sum变量,我们发现这里并没有操作main的栈内存分配的返回值r\n所以 $24-16 写的是16\n\n\n\n\n\n\n\n$24-16的问题, 知道即可,无需太过在意\n\n\n\n\n我在看笔记的时候,发现以前的显示的args是24, 以前的看起来符合我们前面说的.\n为什么不一样 我估计是go 版本的问题, 下面是我试了几个go版本后,一个符合的\n\n\n\ngo1.15.4版本的汇编情况\n\n\"\".add STEXT nosplit size=60 args=0x18 locals=0x10\n0x0000 00000 (main.go:3)    TEXT    \"\".add(SB), NOSPLIT|ABIInternal, $16-24\n0x0000 00000 (main.go:3)    SUBQ    $16, SP\n0x0004 00004 (main.go:3)    MOVQ    BP, 8(SP)\n0x0009 00009 (main.go:3)    LEAQ    8(SP), BP\n0x000e 00014 (main.go:3)    FUNCDATA    $0, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)\n0x000e 00014 (main.go:3)    FUNCDATA    $1, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)\n0x000e 00014 (main.go:3)    MOVQ    $0, \"\".sum+40(SP)\n0x0017 00023 (main.go:4)    MOVQ    $3, \"\".add_local_var(SP)\n0x001f 00031 (main.go:5)    MOVQ    \"\".c+24(SP), AX\n0x0024 00036 (main.go:5)    ADDQ    \"\".d+32(SP), AX\n0x0029 00041 (main.go:5)    ADDQ    $3, AX\n0x002d 00045 (main.go:5)    MOVQ    AX, \"\".sum+40(SP)\n0x0032 00050 (main.go:6)    MOVQ    8(SP), BP\n0x0037 00055 (main.go:6)    ADDQ    $16, SP\n0x003b 00059 (main.go:6)    RET\n\n我们可以发现 8行和13行, add函数是直接使用main的栈内存作为sum的,所以add它申请的栈内存只有16,而使用的caller的栈内存是24个字节\n\n\n    0x0029 00041 (main.go:5)    LEAQ    (AX)(BX*1), AX\n    0x002d 00045 (main.go:5)    LEAQ    3(AX), AX\n    0x0031 00049 (main.go:5)    MOVQ    AX, main.sum(SP)\n\nBP和SP归位\n    0x0035 00053 (main.go:6)    MOVQ    16(SP), BP\n    0x003a 00058 (main.go:6)    ADDQ    $24, SP\n\nRET\n\n=POP IP, 将之前main call add的时候 压栈的ip,弹出 写入到 ip寄存器,这样 cpu就知道重新执行哪一条指令了\n先读取栈数据 写入ip寄存器, 然后 SP=SP+8 往上移动, 这样就回到了 call add 之前的 sp位置了.\n\n\n    0x003e 00062 (main.go:6)    RET",
    "crumbs": [
      "基础篇",
      "汇编"
    ]
  },
  {
    "objectID": "docs/programming/go/basic/plan9.html#go调用汇编代码写的函数",
    "href": "docs/programming/go/basic/plan9.html#go调用汇编代码写的函数",
    "title": "go 汇编",
    "section": "3 go调用汇编代码写的函数",
    "text": "3 go调用汇编代码写的函数",
    "crumbs": [
      "基础篇",
      "汇编"
    ]
  },
  {
    "objectID": "docs/programming/go/basic/plan9.html#footnotes",
    "href": "docs/programming/go/basic/plan9.html#footnotes",
    "title": "go 汇编",
    "section": "Footnotes",
    "text": "Footnotes\n\n\ntool compile↩︎",
    "crumbs": [
      "基础篇",
      "汇编"
    ]
  },
  {
    "objectID": "docs/programming/go/basic/func-closure.html",
    "href": "docs/programming/go/basic/func-closure.html",
    "title": "go 函数和闭包",
    "section": "",
    "text": "main.go\n\npackage main\n\nimport (\n    \"fmt\"\n    \"unsafe\"\n)\n\nfunc add(a, b int) int {\n    sum := 0\n    sum = a + b\n    return sum\n}\n\nfunc main() {\n    println(add)\n    addFuncVar := add\n    println(addFuncVar)\n    // 这里由于println() 和 fmt.Printf(\"%p\") 打印 函数名, 处理上不同, 为了看函数名所代表直接内容\n    addFuncVarVal := *(*uint64)(unsafe.Pointer(&addFuncVar))\n    // 我们得到addFunc变量的值 与上面 println(add) 相同\n    fmt.Printf(\"函数名所表示的值: 0x%x\\n\", addFuncVarVal)\n    // 我们将这个值 作为内存地址, 将它转换为指针,找到它指向的内容\n    addFuncCodeRealAddr := *(*uint64)(unsafe.Pointer(uintptr(addFuncVarVal)))\n    fmt.Printf(\"把函数名表示的值作为地址,它指向的那块内存的内容 (即代码地址): 0x%x\\n\", addFuncCodeRealAddr)\n    // fmt.Printf 打印 函数名 地址 结果是 真正代码的地址\n    fmt.Printf(\"fmt.Printf(\\\"%%p\\\")打印的值: %p\\n\", add)\n    add(1, 2)\n    println(9999)\n}\n\n\n\n编译\n\ngo build -o main -gcflags \"-N -l\" main.go\n\n\n\n./main  执行结果\n\n0x10b1790\n0x10b1790\n函数名所表示的值: 0x10b1790\n把函数名表示的值作为地址,它指向的那块内存的内容 (即代码地址): 0x108f600\nfmt.Printf(\"%p\")打印的值: 0x108f600\n9999\n\n\n\ndlv调试查看 add代码实际地址\n\n# 断点打到 add(1,2) 那里\n(dlv) s #进入函数add ,我们可以看到 PC的值, 这里是add代码指令的内存地址\n&gt; main.add() ./main.go:8 (PC: 0x108f600)\n     3: import (\n     4:         \"fmt\"\n     5:         \"unsafe\"\n     6: )\n     7:\n=&gt;   8: func add(a, b int) int {\n\n\n\n直接查看汇编代码来看add代码内存地址\n\ngo tool objdump -s \"main.add\" main\nTEXT main.add(SB) main.go\n  main.go:8             0x108f600               4883ec18                SUBQ $0x18, SP\n  main.go:8             0x108f604               48896c2410              MOVQ BP, 0x10(SP)\n  main.go:8             0x108f609               488d6c2410              LEAQ 0x10(SP), BP\n  main.go:8             0x108f60e               4889442420              MOVQ AX, 0x20(SP)\n  #....\n\n\n\n你可以继续用代码获取 add 编译后的指令,与上面的 4883ec18 是否一致 (注意左边是低地址的内容)\n\n    addFuncCode := *(*uint32)(unsafe.Pointer(uintptr(addFuncCodeRealAddr)))\n    fmt.Printf(\"0x%x\\n\", addFuncCode)\n\n上面的操作可以说用代码来实现获取”代码内容”\n\n\n\n\n\n\n结论\n\n\n\n\n函数名是个二级指针!\n带着为什么函数名是个二级指针的疑问,我们继续看闭包",
    "crumbs": [
      "基础篇",
      "函数和闭包"
    ]
  },
  {
    "objectID": "docs/programming/go/basic/func-closure.html#函数名到底是个啥",
    "href": "docs/programming/go/basic/func-closure.html#函数名到底是个啥",
    "title": "go 函数和闭包",
    "section": "",
    "text": "main.go\n\npackage main\n\nimport (\n    \"fmt\"\n    \"unsafe\"\n)\n\nfunc add(a, b int) int {\n    sum := 0\n    sum = a + b\n    return sum\n}\n\nfunc main() {\n    println(add)\n    addFuncVar := add\n    println(addFuncVar)\n    // 这里由于println() 和 fmt.Printf(\"%p\") 打印 函数名, 处理上不同, 为了看函数名所代表直接内容\n    addFuncVarVal := *(*uint64)(unsafe.Pointer(&addFuncVar))\n    // 我们得到addFunc变量的值 与上面 println(add) 相同\n    fmt.Printf(\"函数名所表示的值: 0x%x\\n\", addFuncVarVal)\n    // 我们将这个值 作为内存地址, 将它转换为指针,找到它指向的内容\n    addFuncCodeRealAddr := *(*uint64)(unsafe.Pointer(uintptr(addFuncVarVal)))\n    fmt.Printf(\"把函数名表示的值作为地址,它指向的那块内存的内容 (即代码地址): 0x%x\\n\", addFuncCodeRealAddr)\n    // fmt.Printf 打印 函数名 地址 结果是 真正代码的地址\n    fmt.Printf(\"fmt.Printf(\\\"%%p\\\")打印的值: %p\\n\", add)\n    add(1, 2)\n    println(9999)\n}\n\n\n\n编译\n\ngo build -o main -gcflags \"-N -l\" main.go\n\n\n\n./main  执行结果\n\n0x10b1790\n0x10b1790\n函数名所表示的值: 0x10b1790\n把函数名表示的值作为地址,它指向的那块内存的内容 (即代码地址): 0x108f600\nfmt.Printf(\"%p\")打印的值: 0x108f600\n9999\n\n\n\ndlv调试查看 add代码实际地址\n\n# 断点打到 add(1,2) 那里\n(dlv) s #进入函数add ,我们可以看到 PC的值, 这里是add代码指令的内存地址\n&gt; main.add() ./main.go:8 (PC: 0x108f600)\n     3: import (\n     4:         \"fmt\"\n     5:         \"unsafe\"\n     6: )\n     7:\n=&gt;   8: func add(a, b int) int {\n\n\n\n直接查看汇编代码来看add代码内存地址\n\ngo tool objdump -s \"main.add\" main\nTEXT main.add(SB) main.go\n  main.go:8             0x108f600               4883ec18                SUBQ $0x18, SP\n  main.go:8             0x108f604               48896c2410              MOVQ BP, 0x10(SP)\n  main.go:8             0x108f609               488d6c2410              LEAQ 0x10(SP), BP\n  main.go:8             0x108f60e               4889442420              MOVQ AX, 0x20(SP)\n  #....\n\n\n\n你可以继续用代码获取 add 编译后的指令,与上面的 4883ec18 是否一致 (注意左边是低地址的内容)\n\n    addFuncCode := *(*uint32)(unsafe.Pointer(uintptr(addFuncCodeRealAddr)))\n    fmt.Printf(\"0x%x\\n\", addFuncCode)\n\n上面的操作可以说用代码来实现获取”代码内容”\n\n\n\n\n\n\n结论\n\n\n\n\n函数名是个二级指针!\n带着为什么函数名是个二级指针的疑问,我们继续看闭包",
    "crumbs": [
      "基础篇",
      "函数和闭包"
    ]
  },
  {
    "objectID": "docs/programming/go/basic/func-closure.html#闭包",
    "href": "docs/programming/go/basic/func-closure.html#闭包",
    "title": "go 函数和闭包",
    "section": "2 闭包",
    "text": "2 闭包\n\n\n\n\n\n\nCaution\n\n\n\n闭包（closure）是一个函数以及其捆绑的周边环境状态（lexical environment，词法环境）的引用的组合.\n换而言之,闭包让开发者可以从内部函数访问外部函数的作用域\n\n\n\n\n请看高亮的注释的思考\n\npackage main\n\n// 外部函数\nfunc outerFunc() func() int {\n    var x int=1\n    // 内部函数\n    innerFunc := func() int {\n        // x 属于 outerFunc的\n        // 如果x在栈上,执行完 outerFunc ,x 那么作为它的局部变量会被释放,这肯定不行\n        // 因为 我们这个 return的 innerFunc 还会操作x,所以逃逸到堆上\n        x = x + 1\n        return x\n    }\n    // 既然 innerFunc 会操作到x\n    // 那么 innerFunc 这个东西所在的内存除了它自己函数的信息(函数体)外\n    // 还必定含有x 这个数据的相关信息\n    /*\n    问: 为什么不直接将x 这个外部变量的信息编译到函数体内呢?\n    答: 如果直接在函数体内, 那么堆上申请内存,初始化x 的操作都在函数内,\n        然而这样你调用完函数后,没有任何东西再引用这个x了,x必定释放了,这与闭包本身的目的不一致了.\n        而且你重新调用一次函数, 重新初始化了,不行\n    */\n    // 把x作为innerFunc的参数? 这不行,首先这不跟传参的一样吗, 还是值传递不成.\n    // 值传递? 搞成传递指针 好像行得通? (这里只是一种思考)\n    //   闭包的调用者堆上申请x的内存,(注:不同的闭包对外部变量的使用情况可能会有不同)\n    //   然后在自己的栈帧上存地址,将地址传递给闭包函数\n\n    return innerFunc\n}\n\nfunc main() {\n    // 创建一个闭包函数\n    closure := outerFunc()\n\n    // 调用闭包函数\n    closure()\n}\n\n通过汇编来看看实际的情况\ngo build -o main -gcflags \"-N -l -S\" main.go\n会看到当前这个闭包的结构\nruntime.newobject\nLEAQ    type:noalg.struct { F uintptr; main.x *int }(SB), AX\n\n\n代码验证结构\n\npackage main\n\nimport (\n    \"unsafe\"\n)\n\nfunc outerFunc() func() int {\n    var x int = 1\n    innerFunc := func() int {\n        x = x + 1\n        return x\n    }\n    return innerFunc\n}\n\n//go:linkname inheap runtime.inheap\nfunc inheap(arg uintptr) bool\n\nfunc inHeapOrStack(b uintptr) bool\nfunc main() {\n    type closureStruct struct {\n        F uintptr // 闭包的函数的地址\n        x *int    // 闭包的外部变量 这里是指针\n    }\n    // 创建一个闭包函数\n    closure := outerFunc()\n    closureVal := *(*uint64)(unsafe.Pointer(&closure))\n    println(inheap(uintptr(closureVal))) //堆上\n    println(closure, closureVal)         // 0xc000090000\n    closureCodeRealAddrAndVar := *(*closureStruct)(unsafe.Pointer(uintptr(closureVal)))\n    println(*closureCodeRealAddrAndVar.x) // 1\n    println(closureCodeRealAddrAndVar.x)  // 0xc00008e000  堆上\n    println(closureCodeRealAddrAndVar.F)  // 闭包函数的地址 0x1057820  只读\n    // 调用闭包函数\n    println(closure()) // 2\n    println(closure()) // 3\n\n    closure2 := outerFunc()\n    closureVal2 := *(*uint64)(unsafe.Pointer(&closure2))\n    closureCodeRealAddrAndVar2 := *(*closureStruct)(unsafe.Pointer(uintptr(closureVal2)))\n    // 函数地址一样\n    println(closureCodeRealAddrAndVar2.F == closureCodeRealAddrAndVar.F) // true\n\n}\n\n\n我们看看下面这个例子的结构\n\n\n验证一下闭包结构\n\npackage main\n\nimport (\n    \"fmt\"\n    \"unsafe\"\n)\n\nfunc outerFunc(x int) func() int {\n    innerFunc := func() int {\n        return x\n    }\n    return innerFunc\n}\n\nfunc main() {\n    // 创建一个闭包函数\n    closure := outerFunc(10)\n    // 这个是针对 上面的闭包结构\n    type closureStruct struct {\n        F uintptr\n        x int //直接存就行了. 因为没做修改等操作,就打印的需求\n    }\n    closureVal := *(*uint64)(unsafe.Pointer(&closure))\n    println(closureVal)\n    closureCodeRealAddrAndVar := *(*closureStruct)(unsafe.Pointer(uintptr(closureVal)))\n    println(closureCodeRealAddrAndVar.x) //10\n    println(closureCodeRealAddrAndVar.F) //闭包函数的地址\n    // 调用闭包函数\n    closure()\n\n}",
    "crumbs": [
      "基础篇",
      "函数和闭包"
    ]
  },
  {
    "objectID": "docs/programming/go/basic/func-closure.html#println-fmt.print",
    "href": "docs/programming/go/basic/func-closure.html#println-fmt.print",
    "title": "go 函数和闭包",
    "section": "3 println & fmt.Print",
    "text": "3 println & fmt.Print\n\n\n\n\n\n\nTip\n\n\n\ntodo",
    "crumbs": [
      "基础篇",
      "函数和闭包"
    ]
  },
  {
    "objectID": "docs/programming/go/basic/variable-type.html",
    "href": "docs/programming/go/basic/variable-type.html",
    "title": "go 变量和类型",
    "section": "",
    "text": "一个变量就是一块内存(有的变量不占内存空间),变量的类型规定了你 如何从这块内存里读取数据和写入数据,且给这个类型的变量一些”操作方法”,比如 数组的下标操作",
    "crumbs": [
      "基础篇",
      "变量与类型的本质"
    ]
  },
  {
    "objectID": "docs/programming/go/basic/variable-type.html#大小端",
    "href": "docs/programming/go/basic/variable-type.html#大小端",
    "title": "go 变量和类型",
    "section": "1 大小端",
    "text": "1 大小端",
    "crumbs": [
      "基础篇",
      "变量与类型的本质"
    ]
  },
  {
    "objectID": "docs/programming/go/basic/variable-type.html#代码判断大小端",
    "href": "docs/programming/go/basic/variable-type.html#代码判断大小端",
    "title": "go 变量和类型",
    "section": "2 代码判断大小端",
    "text": "2 代码判断大小端\nvar val int32 = 1\nptr := unsafe.Pointer(&val)\nIsLittleEndian := *(*byte)(ptr) == 1\nprintln(IsLittleEndian) //true 就是小端模式",
    "crumbs": [
      "基础篇",
      "变量与类型的本质"
    ]
  },
  {
    "objectID": "docs/programming/go/basic/variable-type.html#变量类型与类型转换",
    "href": "docs/programming/go/basic/variable-type.html#变量类型与类型转换",
    "title": "go 变量和类型",
    "section": "3 变量类型与类型转换",
    "text": "3 变量类型与类型转换\n变量的类型规定了你如何从这块内存里读取数据和写入数据 类型的转换无非就是你换了一种读写数据的方式而已\nfunc main() {\n    // 1000 0011\n    var a uint8 = 131\n    println(a)\n    // 变成有符号的, 那么它的数据的读取方式就变了\n    // 1000 0011 负数的补码\n    // 反码 1000 0010\n    // 原码 1111 1101 = -125\n    b := int8(a)\n    println(b) // -125\n}\n\n3.1 一块可读写的内存,是不是可以按照我任意的方式来读写呢?\n是的, 你想怎么读写,就怎么读写\npackage main\n\nimport (\n    \"unsafe\"\n)\n\ntype FF struct {\n    i int32\n    j int8\n    k int8\n}\n\nfunc main() {\n    // 我们这里假定 z和 a 变量之间是连续的 (因为可能不一定是连续的!)\n    var z int32 = 1800\n    var a, b, c, d int8 = 2, 4, 3, 1\n\n    ptr := unsafe.Pointer(&d)\n    // 格式化(类型转换)  理解为 你想这么去读写这块内存上的数据\n    // 这里当然你可以就用 (*int32)(ptr) 来格式化 读取4个字节的测试\n    ff := (*FF)(ptr)\n    //0xc00004c753 0xc00004c752 0xc00004c751 0xc00004c750\n    println(&a, &b, &c, &d)\n    // 0xc00004c754\n    println(&z)\n    // 0xc00004c750 0xc00004c754\n    println(&ff.i, &ff.j)\n    // 33817345 8 7\n    println(ff.i, ff.j, ff.k)\n    // 直接修改了z 原来那块内存上某个字节上的数据了.\n    // 当然如果要去改变量的某个字节上的数据, 可以用位运算..\n    ff.j = 9\n    // 1801\n    println(z)\n    ff.k = 1\n    // 265\n    println(z)\n\n}\n\n\n再举个例子\n\npackage main\n\nimport (\n    \"unsafe\"\n)\n\ntype dd struct {\n    i1  int8\n    arr [3]int8\n}\n\nfunc main() {\n    d := 33817345\n    // 想怎么格式化就怎么格式化\n    // 想怎么读写数据就怎么格式化它\n    d2 := (*dd)(unsafe.Pointer(&d))\n    println(d2.i1, d2.arr[0], d2.arr[1], d2.arr[2])\n    d2.arr[0] = 6\n    println(d)\n}\n理解了类型,使用起 (unsafe.Pointer) 会变得更容易",
    "crumbs": [
      "基础篇",
      "变量与类型的本质"
    ]
  },
  {
    "objectID": "docs/programming/go/basic/variable-type.html#指针的类型",
    "href": "docs/programming/go/basic/variable-type.html#指针的类型",
    "title": "go 变量和类型",
    "section": "4 指针的类型",
    "text": "4 指针的类型\n\n\n\n\n\n\nTip\n\n\n\n\n指针: 它的值是一个地址, 一般说它指向一个内存地址\n指针类型: 说明了你用什么样的方式结构去读取它指向的那块内存\n\n\n\n// 新的结构= 新的内存读取方式\nnewPtr:=(*新的结构)(unsafe.Pointer(地址))",
    "crumbs": [
      "基础篇",
      "变量与类型的本质"
    ]
  },
  {
    "objectID": "docs/programming/go/basic/struct.html",
    "href": "docs/programming/go/basic/struct.html",
    "title": "go 结构体",
    "section": "",
    "text": "结构体和方法是通过方法集（method set）联系起来的.方法集是一个特殊的函数指针,它指向结构体类型的方法. 当定义一个结构体类型时,Go语言会为这个类型生成一个方法集\n\n\n反射来打印对象的方法\n\ntype Dog struct {\n    Age  int\n    Name string\n}\n\nfunc (d Dog) SetName(name string) {\n    fmt.Println(\"input::\", name)\n    d.Name = name\n}\n\nfunc (d *Dog) GetName() string {\n    fmt.Printf(\"方法内的地址: %p\\n\", d)\n    return d.Name\n}\n\nfunc TestStruct(t *testing.T) {\n    fmt.Println(\"Dog 类型的 方法\")\n    d := Dog{Age: 2}\n    v := reflect.TypeOf(d)\n    for i := 0; i &lt; v.NumMethod(); i++ {\n        // SetName == func(test.Dog, string) == func\n        fmt.Println(v.Method(i).Name, \"==\", v.Method(i).Type, \"==\", v.Method(i).Type.Kind())\n    }\n    fmt.Println(\"*Dog 类型的方法\")\n    d2 := &Dog{}\n    v2 := reflect.TypeOf(d2)\n    for i := 0; i &lt; v2.NumMethod(); i++ {\n        // 注意有2个func, SetName(*Dog,string) 方法 自动生成了\n        // 虽然我们只定义了 func SetName(Dog,string) 方法\n        // GetName == func(*test.Dog) string == func\n        // SetName == func(*test.Dog, string) == func\n        fmt.Println(v2.Method(i).Name, \"==\", v2.Method(i).Type, \"==\", v2.Method(i).Type.Kind())\n    }\n}\n\n\n\n\n\n\n\n重要结论\n\n\n\n注意 编译器为 Dog 类型的 Shout方法 生成了 对应 *Dog类型 的Shout方法\n\n\n\n\n命令查看实现的方法\n\ngo tool compile -S -N -l main.go\n# 查看有哪些函数\ngo tool nm -type  main.o|grep ' T '",
    "crumbs": [
      "基础篇",
      "结构体"
    ]
  },
  {
    "objectID": "docs/programming/go/basic/struct.html#结构体和方法是如何联系的",
    "href": "docs/programming/go/basic/struct.html#结构体和方法是如何联系的",
    "title": "go 结构体",
    "section": "",
    "text": "结构体和方法是通过方法集（method set）联系起来的.方法集是一个特殊的函数指针,它指向结构体类型的方法. 当定义一个结构体类型时,Go语言会为这个类型生成一个方法集\n\n\n反射来打印对象的方法\n\ntype Dog struct {\n    Age  int\n    Name string\n}\n\nfunc (d Dog) SetName(name string) {\n    fmt.Println(\"input::\", name)\n    d.Name = name\n}\n\nfunc (d *Dog) GetName() string {\n    fmt.Printf(\"方法内的地址: %p\\n\", d)\n    return d.Name\n}\n\nfunc TestStruct(t *testing.T) {\n    fmt.Println(\"Dog 类型的 方法\")\n    d := Dog{Age: 2}\n    v := reflect.TypeOf(d)\n    for i := 0; i &lt; v.NumMethod(); i++ {\n        // SetName == func(test.Dog, string) == func\n        fmt.Println(v.Method(i).Name, \"==\", v.Method(i).Type, \"==\", v.Method(i).Type.Kind())\n    }\n    fmt.Println(\"*Dog 类型的方法\")\n    d2 := &Dog{}\n    v2 := reflect.TypeOf(d2)\n    for i := 0; i &lt; v2.NumMethod(); i++ {\n        // 注意有2个func, SetName(*Dog,string) 方法 自动生成了\n        // 虽然我们只定义了 func SetName(Dog,string) 方法\n        // GetName == func(*test.Dog) string == func\n        // SetName == func(*test.Dog, string) == func\n        fmt.Println(v2.Method(i).Name, \"==\", v2.Method(i).Type, \"==\", v2.Method(i).Type.Kind())\n    }\n}\n\n\n\n\n\n\n\n重要结论\n\n\n\n注意 编译器为 Dog 类型的 Shout方法 生成了 对应 *Dog类型 的Shout方法\n\n\n\n\n命令查看实现的方法\n\ngo tool compile -S -N -l main.go\n# 查看有哪些函数\ngo tool nm -type  main.o|grep ' T '",
    "crumbs": [
      "基础篇",
      "结构体"
    ]
  },
  {
    "objectID": "docs/programming/go/basic/struct.html#结构体方法的实质与参数",
    "href": "docs/programming/go/basic/struct.html#结构体方法的实质与参数",
    "title": "go 结构体",
    "section": "2 结构体方法的实质与参数",
    "text": "2 结构体方法的实质与参数\n\n\n\n\n\n\nTip\n\n\n\n结构体调用方法实际上是函数的第一个参数是结构体\n\n\ntype Dog struct {\n    Age  int\n    Name string\n}\n\nfunc (d *Dog) GetName() string {\n    // 与TestStruct2的 &d  地址一样\n    fmt.Printf(\"方法内的地址: %p\\n\", d)\n    return d.Name\n}\n\nfunc (d Dog) SetName(name string) {\n    fmt.Println(\"input::\", name)\n    d.Name = name\n}\n\n\n// 前面通过反射我们看到实际上的方法是这样的\n/*\nfunc SetName(d Dog,name string) {\n    d.Name = name\n}\n\nfunc GetName(d *Dog) string{\n    return d.Name\n}\n\n结构体方法会自动生成一个结构体指针的方法\nfunc SetName(d *Dog,name string) {\n    d.Name = name\n}\n*/\n\n结构体调用方法结构体指针调用方法\n\n\nfunc TestStruct2(t *testing.T) {\n    d := Dog{Age: 3, Name: \"hello\"}\n    fmt.Printf(\"外部的  地址:%p\\n\", &d)\n    // 实际是将 &d 传递 给 GetName(&d)  ==&gt; (*Dog).GetName(&d)\n    println(d.GetName()) // hello\n    // 等价于 执行   Dog.SetName(d, \"abc\")\n    d.SetName(\"abc\")     // SetName(d) , 由于go 是值传递的 ,所以没有改变d的Name属性\n    println(d.Name)      // hello\n}\n\n\nfunc TestStruct2(t *testing.T) {\n    f := &Dog{Age: 3, Name: \"hello\"}\n    // 实际调用了 SetName(*f ,abc)\n    // 按照前面说到的反射 应该有 SetName(*Dog,string) 方法\n    // 但这里的调用还是用的  SetName(Dog,string) 方法!!!\n    // 那么自动生成的 SetName(*Dog,string) 方法有什么用呢?\n    f.SetName(\"abc\")\n    println(f.Name) // 还是 hello\n}\n\n\n\n\n\n\n\n\n\nTip\n\n\n\n编译器自动生成的 SetName(*Dog,string) 方法 用于接口,我们后续再说",
    "crumbs": [
      "基础篇",
      "结构体"
    ]
  },
  {
    "objectID": "docs/programming/go/basic/runtime.html",
    "href": "docs/programming/go/basic/runtime.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "运行时, 程序的运行环境, 就是支撑你程序运行的东西 好比你的程序要想运行起来 是需要 操作系统\n一封信+ 人 =&gt; 文字变成了声音\n比如java 需要java虚拟机(JVM), 需要你环境中有这个东西\n磁带需要录音机才能播放出音乐\ngo 的runtime 不太一样了, 它实际上是一坨代码, 编译后,会将这些作为程序的一部分打包, 从我们编译go代码变成一个二进制文件,可以直接运行,可以放到其他没安装go的系统运行,可以看出这点 你写的代码+runtime =&gt; 编译成程序\ngo的运行时的功能 (到时候重新命名目录)\n比如 内存管理分配 垃圾回收GC 并发能力 协程 是runtime来弄\ngo的一些关键字实际上是在 runtime 下的函数\n\n\n\n关键字\n编译后转换成runtime下的函数名\n\n\n\n\ngo\nnewproc\n\n\nnew\nnewobject\n\n\nmake\nmakechan makeslice makemap\n\n\n&lt;-\nchansend1 chanrecv1\n\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "docs/programming/go/basic/gc.html",
    "href": "docs/programming/go/basic/gc.html",
    "title": "go GC",
    "section": "",
    "text": "可以先看看汇编\n\n\n\n\n\n\nTip\n\n\n\ntodo\n\n\n\n\n\n\n Back to top",
    "crumbs": [
      "基础篇",
      "GC"
    ]
  },
  {
    "objectID": "docs/programming/go/basic/env.html",
    "href": "docs/programming/go/basic/env.html",
    "title": "go 环境准备",
    "section": "",
    "text": "go 一键安装脚本",
    "crumbs": [
      "基础篇",
      "环境准备"
    ]
  },
  {
    "objectID": "docs/programming/go/basic/env.html#安装1",
    "href": "docs/programming/go/basic/env.html#安装1",
    "title": "go 环境准备",
    "section": "",
    "text": "go 一键安装脚本",
    "crumbs": [
      "基础篇",
      "环境准备"
    ]
  },
  {
    "objectID": "docs/programming/go/basic/env.html#配置",
    "href": "docs/programming/go/basic/env.html#配置",
    "title": "go 环境准备",
    "section": "2 配置",
    "text": "2 配置\ngo env -w GOPROXY=https://goproxy.cn,http://mirrors.aliyun.com/goproxy/,https://goproxy.io,direct",
    "crumbs": [
      "基础篇",
      "环境准备"
    ]
  },
  {
    "objectID": "docs/programming/go/basic/env.html#常用指令",
    "href": "docs/programming/go/basic/env.html#常用指令",
    "title": "go 环境准备",
    "section": "3 常用指令",
    "text": "3 常用指令\n# 清理下载的mod(一般这个占用空间会很大), 一般情况下不会清理.  ~/go/pkg/mod\ngo clean -modcache\n\ngo mod tidy\n\ngo env\nGOPATH=\"/Users/your_name/go\"  # go install 安装的二进制文件放在 GOPATH/bin中\nGOMODCACHE=\"/Users/your_name/go/pkg/mod\"\nGOPRIVATE=\"\"\nGOPROXY=\"\"\nGOROOT=\"/usr/local/go\"",
    "crumbs": [
      "基础篇",
      "环境准备"
    ]
  },
  {
    "objectID": "docs/programming/go/basic/env.html#gvm-版本管理工具",
    "href": "docs/programming/go/basic/env.html#gvm-版本管理工具",
    "title": "go 环境准备",
    "section": "4 gvm 版本管理工具",
    "text": "4 gvm 版本管理工具",
    "crumbs": [
      "基础篇",
      "环境准备"
    ]
  },
  {
    "objectID": "docs/programming/go/basic/env.html#环境问题排查",
    "href": "docs/programming/go/basic/env.html#环境问题排查",
    "title": "go 环境准备",
    "section": "5 环境问题排查",
    "text": "5 环境问题排查",
    "crumbs": [
      "基础篇",
      "环境准备"
    ]
  },
  {
    "objectID": "docs/programming/go/basic/env.html#footnotes",
    "href": "docs/programming/go/basic/env.html#footnotes",
    "title": "go 环境准备",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nhttps://golang.google.cn/dl/↩︎",
    "crumbs": [
      "基础篇",
      "环境准备"
    ]
  },
  {
    "objectID": "docs/programming/go/basic/interface.html",
    "href": "docs/programming/go/basic/interface.html",
    "title": "go interface",
    "section": "",
    "text": "接口是一种协议, 一种规则, 规定了一些功能,具体怎么实现不关心\n比如我们需要将数据进行存储读取,我们规定了读取保存功能,怎么实现不关心.\n在现实中其实可以说我们很多时候经常说的都是”接口”\n\n说打车, 车是一种实现了4个轮子能移动的接口, 不管是比亚迪还是宝马都行\n说吃饭, 饭是一种实现了可以吃饱功能的接口,具体吃什么,还不清楚\n…\n\n所以实际上在开发中我们应当 面向接口开发(实际在设计阶段,沟通中一直说的都是”接口”), 接口是一种抽象, 不关心具体怎么实现,这样以后更换具体实现就会比较方便 ## 基本操作\n\n\n\n\n\n\n\nTip\n\n\n\n当我们定义一个新的类型时, 只要保证其方法集合与某个接口相同即可隐式实现该接口\n\n\ntype Animal interface {\n    Shout()\n}\n\ntype Cat struct {\n    Age  int\n    Name string\n}\n\n// 隐式地实现了Animal 接口\n// 结构体实现接口\nfunc (c Cat) Shout() {\n    fmt.Println(\"miao\")\n}\ntype Dog struct {\n    Age  int\n}\n// 结构体指针实现接口\n// 将结构体指针 当成一个整体, 这个东西实现了 方法Shout\nfunc (d *Dog) Shout() {\n    fmt.Println(\"wang\")\n}\nfunc TestSlice(t *testing.T) {\n    // 实际会做 类型是否实现接口 的检查\n    // 注意这个实际上就是一种类型转换\n    var a Animal = Cat{Age: 2, Name: \"tom\"}\n    a.Shout()\n    // 这样也是ok的,前面我们在结构体那里知道,编译器会自动给 Cat的同名方法生成一个*Cat的同名方法\n    // 这个同名方式 的作用就在这里\n    // 所以*Cat 实现了 Shout 方法,实现了 Animal接口\n    var a2 Animal = &Cat{Age: 3, Name: \"jjj\"}\n    a2.Shout()\n\n    // 结构体指针 *Dog 实现了Shout方法, 所以可以\n    var d Animal = &Dog{Age: 1}\n    d.Shout()\n    // 报错, 因为 Dog{Age: 1} 没有实现Shout() 方法\n    // var d2 Animal = Dog{Age: 1}\n\n    // 类型断言 方式一\n    cat, ok := a.(Cat)\n    if ok {\n        fmt.Println(cat.Age)\n    }\n    // 类型断言 方式二\n    switch a.(type) {\n    case Cat:\n        cat := a.(Cat)\n        fmt.Println(cat.Name)\n    }\n}",
    "crumbs": [
      "基础篇",
      "接口"
    ]
  },
  {
    "objectID": "docs/programming/go/basic/interface.html#什么是接口",
    "href": "docs/programming/go/basic/interface.html#什么是接口",
    "title": "go interface",
    "section": "",
    "text": "接口是一种协议, 一种规则, 规定了一些功能,具体怎么实现不关心\n比如我们需要将数据进行存储读取,我们规定了读取保存功能,怎么实现不关心.\n在现实中其实可以说我们很多时候经常说的都是”接口”\n\n说打车, 车是一种实现了4个轮子能移动的接口, 不管是比亚迪还是宝马都行\n说吃饭, 饭是一种实现了可以吃饱功能的接口,具体吃什么,还不清楚\n…\n\n所以实际上在开发中我们应当 面向接口开发(实际在设计阶段,沟通中一直说的都是”接口”), 接口是一种抽象, 不关心具体怎么实现,这样以后更换具体实现就会比较方便 ## 基本操作\n\n\n\n\n\n\n\nTip\n\n\n\n当我们定义一个新的类型时, 只要保证其方法集合与某个接口相同即可隐式实现该接口\n\n\ntype Animal interface {\n    Shout()\n}\n\ntype Cat struct {\n    Age  int\n    Name string\n}\n\n// 隐式地实现了Animal 接口\n// 结构体实现接口\nfunc (c Cat) Shout() {\n    fmt.Println(\"miao\")\n}\ntype Dog struct {\n    Age  int\n}\n// 结构体指针实现接口\n// 将结构体指针 当成一个整体, 这个东西实现了 方法Shout\nfunc (d *Dog) Shout() {\n    fmt.Println(\"wang\")\n}\nfunc TestSlice(t *testing.T) {\n    // 实际会做 类型是否实现接口 的检查\n    // 注意这个实际上就是一种类型转换\n    var a Animal = Cat{Age: 2, Name: \"tom\"}\n    a.Shout()\n    // 这样也是ok的,前面我们在结构体那里知道,编译器会自动给 Cat的同名方法生成一个*Cat的同名方法\n    // 这个同名方式 的作用就在这里\n    // 所以*Cat 实现了 Shout 方法,实现了 Animal接口\n    var a2 Animal = &Cat{Age: 3, Name: \"jjj\"}\n    a2.Shout()\n\n    // 结构体指针 *Dog 实现了Shout方法, 所以可以\n    var d Animal = &Dog{Age: 1}\n    d.Shout()\n    // 报错, 因为 Dog{Age: 1} 没有实现Shout() 方法\n    // var d2 Animal = Dog{Age: 1}\n\n    // 类型断言 方式一\n    cat, ok := a.(Cat)\n    if ok {\n        fmt.Println(cat.Age)\n    }\n    // 类型断言 方式二\n    switch a.(type) {\n    case Cat:\n        cat := a.(Cat)\n        fmt.Println(cat.Name)\n    }\n}",
    "crumbs": [
      "基础篇",
      "接口"
    ]
  },
  {
    "objectID": "docs/programming/go/basic/interface.html#数据结构",
    "href": "docs/programming/go/basic/interface.html#数据结构",
    "title": "go interface",
    "section": "2 数据结构",
    "text": "2 数据结构\n\n2.1 接口与元数据\n\n\n\n\n\n\n关于接口的思考\n\n\n\n\nvar animal Animal = Cat{Age: 2, Name: \"tom\"}\n\nanimal是一个类型为Animal接口的变量\n这是一个类型转换的操作, 这句话看起来是个废话\n\nCat 能否转换为 接口Animal, 是如何判断的?\n\nCat 结构体是否实现了接口的方法\n\nanimal可以转换为Cat 对象, 也就是说 接口变量animal必定存储了Cat对象数据的信息,以及Cat的类型信息\n接口有方法, ==接口变量animal 必定存储了 接口定义的方法==\n\n\n\n\n\n\n\n\n\n关于元数据的思考\n\n\n\n\n我们知道 当我们定义 一个 int64 类型的变量时, 编译时编译器最终会根据代码定义的 int64的 “类型信息” 来分配多少内存的\n这些 “类型信息” 我们能否得到呢?\n\n在关于接口的思考中,因为 接口变量和结构体可以互相转换,所以接口变量必定存储了 结构体实际数据以及类型的信息\n这个不就是我们想要的吗? 那么我们将变量转换成接口类型不就可以了吗!!! 这波推理可以!\n\n编译后的可执行文件里会有这些信息吗?\n\n没有, 通过二进制 的汇编指令 ,我们可以根据最终的一条条指令,得出指令里是没有所谓这些类型的概念\n\n\n\n\n\n\n2.2 空接口 interface\n\n\n\n\n\n\nTip\n\n\n\n\n前面我们说道只要实现了接口定义的方法, 就算实现了接口.\n空接口 可以认为是没有方法的接口, 那么所有类型可以说都实现了该接口\n那么所有的类型都可以转换为 空接口类型\n\n\n\n\n\n空接口数据结构\n\ntype eface struct {\n    _type *_type // 类型信息\n    data  unsafe.Pointer // 数据信息\n}\n\ntype _type struct {\n    size       uintptr // 这个类型需要占用的内存大小\n    ptrdata    uintptr // size of memory prefix holding all pointers\n    hash       uint32  // 类型的hash值, 用来类型比较和查找\n    tflag      tflag  // (1)\n    align      uint8  // 类型的对齐边界\n    fieldAlign uint8  // 类型字段的对齐边界\n    kind       uint8  //类型的分类 (2)\n    // 比较2个当前类型的变量是否相等\n    equal func(unsafe.Pointer, unsafe.Pointer) bool\n    gcdata    *byte   // gc 相关\n    str       nameOff // 偏移, 可以通过这个得到 类型的名称等信息\n    ptrToThis typeOff // 同上, 得到对应指针类型的信息\n}\n\n\ntflag\n\ntype tflag uint8\n\nconst (\n    tflagUncommon      tflag = 1 &lt;&lt; 0\n    tflagExtraStar     tflag = 1 &lt;&lt; 1\n    tflagNamed         tflag = 1 &lt;&lt; 2\n    tflagRegularMemory tflag = 1 &lt;&lt; 3 \n)\n\nkind\n\nconst (\n    Invalid Kind = iota\n    Bool\n    Int\n    Int8\n    Int16\n    Int32\n    Int64\n    Uint\n    Uint8\n    Uint16\n    Uint32\n    Uint64\n    Uintptr\n    Float32\n    Float64\n    Complex64\n    Complex128\n    Array\n    Chan\n    Func\n    Interface\n    Map\n    Pointer\n    Slice\n    String\n    Struct\n    UnsafePointer\n)\n\n\n\n\n\n\nCaution\n\n\n\n更多细节等,后续有时间再弄吧…\n\n\n\n\n代码验证结构\n\npackage main\n\nimport (\n    //  _ \"test/pkg\"\n    \"fmt\"\n    \"unsafe\"\n)\n\ntype eface struct {\n    _type *_type         // 类型信息\n    data  unsafe.Pointer // 数据信息\n}\n\ntype _type struct {\n    size       uintptr // 这个类型需要占用的内存大小\n    ptrdata    uintptr // size of memory prefix holding all pointers\n    hash       uint32  // 类型的hash值, 用来类型比较和查找\n    tflag      uint8   //\n    align      uint8   // 类型的对齐边界\n    fieldAlign uint8   // 类型字段的对齐边界\n    kind       uint8   //类型的分类\n    // 比较2个当前类型的变量是否相等\n    equal     func(unsafe.Pointer, unsafe.Pointer) bool\n    gcdata    *byte   // gc 相关\n    str       nameOff // 偏移, 可以通过这个得到 类型的名称等信息\n    ptrToThis int32   // 同上, 得到对应指针类型的信息\n}\n\n//go:linkname resolveNameOff runtime.resolveNameOff\nfunc resolveNameOff(ptrInModule unsafe.Pointer, off nameOff) name\n\ntype Cat struct {\n    Age  int\n    Name string\n}\n\nfunc (c Cat) Show() {\n    fmt.Println(11)\n}\nfunc (c Cat) pp() {\n    fmt.Println(11)\n}\nfunc main() {\n    var a int64 = 66\n    var b interface{} = a\n    c := *(*eface)(unsafe.Pointer(&b))\n    fmt.Println(*(*int64)(c.data)) // 66\n    fmt.Println(*c._type)\n    d := resolveNameOff(unsafe.Pointer(c._type), c._type.str)\n    fmt.Println(d.name())\n\n    fmt.Println(\"--自定义类型 (结构体) 的情况 呢?----\")\n    cat := Cat{3, \"tom\"}\n    var catAny interface{} = cat\n    catEface := *(*eface)(unsafe.Pointer(&catAny))\n    fmt.Println(*catEface._type)\n    dd := resolveNameOff(unsafe.Pointer(catEface._type), catEface._type.str)\n    fmt.Println(dd.name())\n\n    // 结构体中字段的信息呢? 好像仅从eface 中没有.\n    // 我们看源码中的 这个方法\n    // func (t *_type) uncommon() *uncommontype\n    // 从中知道 struct 类型 有额外的信息存储在 *_type 指针指向的内存\n    catStructUncommon := *(*structUncommon)(unsafe.Pointer(catEface._type))\n    // 可自行验证\n    fmt.Println(catStructUncommon.fields[1].name.name())\n    fmt.Println(catStructUncommon.u)\n}\n\ntype structUncommon struct {\n    structtype\n    u uncommontype\n}\ntype defaultUncommon struct {\n    _type\n    u uncommontype\n}\ntype uncommontype struct {\n    pkgpath nameOff\n    mcount  uint16 // number of methods\n    xcount  uint16 // number of exported methods\n    moff    uint32 // offset from this uncommontype to [mcount]method\n    _       uint32 // unused\n}\ntype structtype struct {\n    typ     _type\n    pkgPath name\n    fields  []structfield\n}\ntype structfield struct {\n    name   name\n    typ    *_type\n    offset uintptr\n}\ntype name struct {\n    bytes *byte\n}\ntype nameOff int32\n\nfunc (n name) name() string {\n    if n.bytes == nil {\n        return \"\"\n    }\n    i, l := n.readVarint(1)\n    return unsafe.String(n.data(1+i, \"non-empty string\"), l)\n}\nfunc (n name) readVarint(off int) (int, int) {\n    v := 0\n    for i := 0; ; i++ {\n        x := *n.data(off+i, \"read varint\")\n        v += int(x&0x7f) &lt;&lt; (7 * i)\n        if x&0x80 == 0 {\n            return i + 1, v\n        }\n    }\n}\nfunc (n name) data(off int, whySafe string) *byte {\n    return (*byte)(add(unsafe.Pointer(n.bytes), uintptr(off), whySafe))\n}\nfunc add(p unsafe.Pointer, x uintptr, whySafe string) unsafe.Pointer {\n    return unsafe.Pointer(uintptr(p) + x)\n}\n\n\n\n2.3 非空接口\ntype iface struct {\n    tab  *itab\n    data unsafe.Pointer\n}\ntype itab struct {\n    inter *interfacetype  // 接口的元数据\n    _type *_type   // 实际类型的元数据\n    hash  uint32 //  _type.hash的复制用来方便做类型断言\n    _     [4]byte\n    fun   [1]uintptr // variable sized. fun[0]==0 means _type does not implement inter.\n}\n\n\ntype interfacetype struct {\n    typ     _type\n    pkgpath name\n    mhdr    []imethod  // 方法列表\n}\ntype _type struct {\n    size       uintptr\n    ptrdata    uintptr // size of memory prefix holding all pointers\n    hash       uint32\n    tflag      tflag\n    align      uint8\n    fieldAlign uint8\n    kind       uint8\n    // function for comparing objects of this type\n    // (ptr to object A, ptr to object B) -&gt; ==?\n    equal func(unsafe.Pointer, unsafe.Pointer) bool\n    // gcdata stores the GC type data for the garbage collector.\n    // If the KindGCProg bit is set in kind, gcdata is a GC program.\n    // Otherwise it is a ptrmask bitmap. See mbitmap.go for details.\n    gcdata    *byte\n    str       nameOff\n    ptrToThis typeOff\n}",
    "crumbs": [
      "基础篇",
      "接口"
    ]
  },
  {
    "objectID": "docs/netprog/tcp.html",
    "href": "docs/netprog/tcp.html",
    "title": "tcp",
    "section": "",
    "text": "Warning\n\n\n\n未完待续",
    "crumbs": [
      "tcp"
    ]
  },
  {
    "objectID": "docs/netprog/tcp.html#socket",
    "href": "docs/netprog/tcp.html#socket",
    "title": "tcp",
    "section": "1 socket",
    "text": "1 socket\n\n与网络中的其他应用进行通信的函数接口\n封装了传输层的协议, tcp udp\n既然是与网络中的其他应用程序通信, 那么我们可以推断socket套接字肯定有ip(确定主机)和port(确定应用),用来明确是哪个应用",
    "crumbs": [
      "tcp"
    ]
  },
  {
    "objectID": "docs/netprog/tcp.html#代码",
    "href": "docs/netprog/tcp.html#代码",
    "title": "tcp",
    "section": "2 代码",
    "text": "2 代码\n\n客户端服务端\n\n\n\n\nclient.c\n\n#include &lt;stdio.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;sys/types.h&gt;\n#include &lt;sys/stat.h&gt;\n#include &lt;string.h&gt;\n#include &lt;arpa/inet.h&gt;\n#include &lt;fcntl.h&gt;\n\n// tcp client\nint main(int argc, const char* argv[])\n{\n    // 创建套接字\n    int fd = socket(AF_INET, SOCK_STREAM, 0);\n    if(fd == -1)\n    {\n        perror(\"socket error\");\n        exit(1);\n    }\n\n    // 连接服务器\n    struct sockaddr_in serv_addr;\n    // 将serv_addr 结构体 所占内存内容置为0, 等价于 bzero(&serv_addr, sizeof(serv_addr));\n    memset(&serv_addr, 0, sizeof(serv_addr));\n    serv_addr.sin_family = AF_INET;\n    //网络传输数据采用的是大端 ,所以这里端口要转换为大端\n    // h: host, to:to, n: net, s:short int (unsigned)\n    // 将主机字节序转为网络字节序(大端)\n    serv_addr.sin_port = htons(9999);\n    // 将ip转换为网络字节序, 是将字符串(ip) 转为int型(大端方式)\n    // 直接修改 &serv_addr.sin_addr.s_addr\n    // inet_pton转换成功则返回1,转换失败返回 0,如果指定的地址类型协议簇不合法,将返回-1\n    inet_pton(AF_INET, \"127.0.0.1\", &serv_addr.sin_addr.s_addr);\n    int ret = connect(fd, (struct sockaddr*)&serv_addr, sizeof(serv_addr));\n    if(ret == -1)\n    {\n        perror(\"connect error\");\n        exit(1);\n    }\n\n    // 通信\n    while(1)\n    {\n        // 写数据\n        // 接收键盘输入\n        char buf[512];\n        printf(\"input: \\n\");\n        fgets(buf, sizeof(buf), stdin);\n        // 这里如果输入的小于512 会就最后的回车符号也发送过去.(详情见fgets的说明)\n        // 你可以自己将最后的回车符处理掉...\n        // 发送给服务器, +1 是把最后的\\0 也发送过去.\n        write(fd, buf, strlen(buf)+1);\n\n        // 接收服务器端的数据\n        int len = read(fd, buf, sizeof(buf));\n        if(len == -1)\n        {\n            perror(\"read error\");\n            break;\n        }\n        else if( len == 0 )\n        {\n            printf(\"服务端关闭了连接 ...\\n\");\n            break;\n        } else if(len &gt; 0)\n        {\n            printf(\"read buf = %s, len = %d\\n\", buf, len);\n        }\n    }\n    close(fd);\n    return 0;\n}\n\n\n\n\n\nserver.c\n\n#include &lt;stdio.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;sys/types.h&gt;\n#include &lt;sys/stat.h&gt;\n#include &lt;string.h&gt;\n#include &lt;sys/socket.h&gt;\n#include &lt;arpa/inet.h&gt;\n#include &lt;ctype.h&gt;\n\n\nint main(int argc, const char* argv[])\n{\n    // 创建用于监听的套节字\n    int listen_fd = socket(AF_INET, SOCK_STREAM, 0);\n    if(listen_fd == -1)\n    {\n        perror(\"socket error\");\n        exit(1);\n    }\n\n    struct sockaddr_in serv_addr;\n    memset(&serv_addr, 0, sizeof(serv_addr));\n    serv_addr.sin_family = AF_INET;     // 地址族协议ipv4\n    serv_addr.sin_port = htons(9999);   // 本地端口需要转换为大端\n    // ip转为网络字节序(大端)\n    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);  // 0表示用本机的任意IP\n\n    int ret = bind(listen_fd, (struct sockaddr*)&serv_addr, sizeof(serv_addr));\n    if(ret == -1)\n    {\n        perror(\"bind error\");\n        exit(1);\n    }\n\n    // 设置监听\n    ret = listen(listen_fd, 64);\n    if(ret == -1)\n    {\n        perror(\"listen error\");\n        exit(1);\n    }\n\n    // 等待并接受连接请求\n    struct sockaddr_in client_addr;\n    socklen_t client_len = sizeof(client_addr);\n    int client_fd = accept(listen_fd, (struct sockaddr*)&client_addr, &client_len);\n    if(client_fd == -1)\n    {\n        perror(\"accept error\");\n        exit(1);\n    }\n    char client_ip_buf[64];\n    // 网络字节序 转换为 主机字节序, 结果存储到client_ip_buf\n    // 返回值是个指向client_ip_buf 的指针\n    const char* client_ip=inet_ntop(AF_INET, &client_addr.sin_addr.s_addr, client_ip_buf, sizeof(client_ip_buf));\n    printf(\"client ip: %s, port: %d\\n\", client_ip, ntohs(client_addr.sin_port));\n\n    // 通信\n    while(1)\n    {\n        // 先接收数据\n        char buf[1024] = {0};\n        int len = read(client_fd, buf, sizeof(buf));\n        if(len == -1)\n        {\n            perror(\"read error\");\n            break;\n        }\n        else if(len &gt; 0)\n        {\n            // 顺利读出了数据\n            printf(\"read buf = %s\\n\", buf);\n            for(int i=0; i&lt;len; ++i)\n            {\n                buf[i] = toupper(buf[i]);\n            }\n            printf(\" toupper: %s\\n\", buf);\n\n            // 数据发送给客户端\n            write(client_fd, buf, strlen(buf)+1);\n        }\n        else if( len == 0 )\n        {\n            printf(\"client disconnect ...\\n\");\n            break;\n        }\n    }\n\n    close(listen_fd);\n    close(client_fd);\n\n    return 0;\n}\n\n\n\n\ngcc client.c -o client\ngcc server.c -o server\n./server\n./client",
    "crumbs": [
      "tcp"
    ]
  },
  {
    "objectID": "docs/netprog/tcp.html#tcp-报文",
    "href": "docs/netprog/tcp.html#tcp-报文",
    "title": "tcp",
    "section": "3 tcp 报文",
    "text": "3 tcp 报文",
    "crumbs": [
      "tcp"
    ]
  },
  {
    "objectID": "docs/netprog/tcp.html#握手-传输-挥手",
    "href": "docs/netprog/tcp.html#握手-传输-挥手",
    "title": "tcp",
    "section": "4 握手-传输-挥手",
    "text": "4 握手-传输-挥手",
    "crumbs": [
      "tcp"
    ]
  },
  {
    "objectID": "docs/netprog/tcp.html#滑动窗口",
    "href": "docs/netprog/tcp.html#滑动窗口",
    "title": "tcp",
    "section": "5 滑动窗口",
    "text": "5 滑动窗口",
    "crumbs": [
      "tcp"
    ]
  },
  {
    "objectID": "docs/netprog/tcp.html#修改缓冲区大小",
    "href": "docs/netprog/tcp.html#修改缓冲区大小",
    "title": "tcp",
    "section": "6 修改缓冲区大小",
    "text": "6 修改缓冲区大小\n\n6.1 系统tcp缓冲设置\n\n\n查看配置\n\ncat /proc/sys/net/ipv4/tcp_rmem\n4096    87380   5369920\n# 4096 是说接收缓冲区(读缓冲区)的最小值\n# 87380 表示默认值 该值会覆盖rmem_default, 不是被覆盖, 网络上很多说被覆盖.. 真的服了\n# 5369920 接收缓冲区空间的最大字节数(该值会被rmem_max覆盖)\ncat /proc/sys/net/core/rmem_max  #一个socket的读缓冲区可由程序设置的最大值\n212992\ncat /proc/sys/net/core/rmem_default #一个socket的被创建出来时，默认的读缓冲区大小\n212992\n\n\n\n临时修改配置,重启后失效\n\nsysctl -w net.ipv4.tcp_wmem=\"1 1 1\"\nsysctl -w net.core.wmem_max=5000\n\n\n\n6.2 查看linux关于缓冲的源码\n\n\nlinux4.9源码 net/core/sock.h\n\n#define TCP_SKB_MIN_TRUESIZE    (2048 + SKB_DATA_ALIGN(sizeof(struct sk_buff)))\n\n#define SOCK_MIN_SNDBUF     (TCP_SKB_MIN_TRUESIZE * 2)\n#define SOCK_MIN_RCVBUF      TCP_SKB_MIN_TRUESIZE\n\n\n\nlinux4.9源码 net/core/sock.c\n\nswitch (optname) {\n    case SO_SNDBUF:\n        // 如果 val&gt; /proc/sys/net/core/wmem_max ,则设置成wmem_max 的值\n        val = min_t(u32, val, sysctl_wmem_max);\nset_sndbuf:\n        sk-&gt;sk_userlocks |= SOCK_SNDBUF_LOCK;\n        // 如果 val值的 2倍 还小于最小值, 那么 使用 最小值,否而就是 val值的2倍\n        sk-&gt;sk_sndbuf = max_t(int, val * 2, SOCK_MIN_SNDBUF);\n        sk-&gt;sk_write_space(sk);\n        break;\n    case SO_RCVBUF:\n        val = min_t(u32, val, sysctl_rmem_max);\nset_rcvbuf:\n        sk-&gt;sk_userlocks |= SOCK_RCVBUF_LOCK;\n        sk-&gt;sk_rcvbuf = max_t(int, val * 2, SOCK_MIN_RCVBUF);\n        break;\n}\n\n\n\n\n\n\n\n得出结论\n\n\n\n\n如果你设置的值 &gt; 最大值,则 设置为 最大值的2倍\n如果你设置的值的2倍 &lt; 最小值,则 设置为 最小值\n其他情况 ,则设置为 该值的2倍\n\n\n\n\n\n6.3 代码修改缓冲\n\n\nserver.c\n\n#include &lt;stdio.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;sys/types.h&gt;\n#include &lt;sys/stat.h&gt;\n#include &lt;string.h&gt;\n#include &lt;sys/socket.h&gt;\n#include &lt;arpa/inet.h&gt;\n#include &lt;ctype.h&gt;\n#include &lt;unistd.h&gt;\n\nvoid getsockopts(char* s ,int sockfd){\n    printf(\"===%s===\\n\",s);\n    int opt_val;\n    socklen_t opt_len=sizeof(opt_val);\n    if (getsockopt(sockfd,SOL_SOCKET, SO_SNDBUF, &opt_val, &opt_len)!=0){\n        perror(\"getsocketopt error\");\n        exit(1);\n    }\n    printf(\"写缓冲区大小: %d\\n\", opt_val);\n    opt_val=0;\n    if (getsockopt(sockfd,SOL_SOCKET, SO_RCVBUF, &opt_val, &opt_len)!=0){\n        perror(\"getsocketopt error\");\n        exit(1);\n    }\n    printf(\"读缓冲区大小: %d\\n\", opt_val);\n    opt_val=0;\n    if (getsockopt(sockfd,SOL_SOCKET, SO_SNDLOWAT, &opt_val, &opt_len)!=0){\n        perror(\"getsocketopt error\");\n        exit(1);\n    }\n    printf(\"发送低潮限度大小: %d\\n\", opt_val);\n\n}\n\nvoid setsockopts(int sockfd,int nRecvBuf,int nSendBuf){\n    // 接收缓冲区\n    int ret=setsockopt(sockfd,SOL_SOCKET,SO_RCVBUF,(const char*)&nRecvBuf,sizeof(int));\n    if (ret !=0){\n        perror(\"setsocketopt error\");\n    }\n    //发送缓冲区\n    ret =setsockopt(sockfd,SOL_SOCKET,SO_SNDBUF,(const char*)&nSendBuf,sizeof(int));\n    if (ret !=0){\n        perror(\"setsocketopt error\");\n    }\n}\nint main(int argc, const char* argv[])\n{\n    // printf(\"argcount: %d\\n\",argc);\n    if (argc!=3){\n    printf(\"请输入要设置的读缓冲和写缓冲\\n\");\n    printf(\"usage: %s 读缓冲值 写缓冲值\\n\",argv[0]);\n    exit(1);\n    }\n    // 创建用于监听的套节字\n    int listen_fd = socket(AF_INET, SOCK_STREAM, 0);\n    if(listen_fd == -1)\n    {\n        perror(\"socket error\");\n        exit(1);\n    }\n    getsockopts(\"before set\",listen_fd);\n    // 这里不严谨,随便用用\n    setsockopts(listen_fd,atoi(argv[1]),atoi(argv[2]));\n    getsockopts(\"after set\",listen_fd);\n    struct sockaddr_in serv_addr;\n    memset(&serv_addr, 0, sizeof(serv_addr));\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(9999);\n    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);\n    int ret = bind(listen_fd, (struct sockaddr*)&serv_addr, sizeof(serv_addr));\n    if(ret == -1)\n    {\n        perror(\"bind error\");\n        exit(1);\n    }\n\n    // 设置监听\n    ret = listen(listen_fd, 64);\n    if(ret == -1)\n    {\n        perror(\"listen error\");\n        exit(1);\n    }\n\n    // 等待并接受连接请求\n    struct sockaddr_in client_addr;\n    socklen_t client_len = sizeof(client_addr);\n    int client_fd = accept(listen_fd, (struct sockaddr*)&client_addr, &client_len);\n    if(client_fd == -1)\n    {\n        perror(\"accept error\");\n        exit(1);\n    }\n    char client_ip_buf[64];\n    const char* client_ip=inet_ntop(AF_INET, &client_addr.sin_addr.s_addr, client_ip_buf, sizeof(client_ip_buf));\n    printf(\"client ip: %s, port: %d\\n\", client_ip, ntohs(client_addr.sin_port));\n\n    // 通信\n    while(1)\n    {\n        sleep(3);\n    }\n    close(listen_fd);\n    close(client_fd);\n    return 0;\n}\n\n./server2 212993 1\n    argcount: 3\n    ===before set===\n    写缓冲区大小: 16384\n    读缓冲区大小: 87380\n    发送低潮限度大小: 1\n    ===after set===\n    写缓冲区大小: 4608 # 最小值\n    读缓冲区大小: 425984 # 最大值的2倍\n    发送低潮限度大小: 1\n\n./server2 212991 1\n    ===before set===\n    写缓冲区大小: 16384\n    读缓冲区大小: 87380\n    发送低潮限度大小: 1\n    ===after set===\n    写缓冲区大小: 4608\n    读缓冲区大小: 425982 # 设置的值的2倍\n    发送低潮限度大小: 1",
    "crumbs": [
      "tcp"
    ]
  },
  {
    "objectID": "docs/netprog/tcp.html#阻塞",
    "href": "docs/netprog/tcp.html#阻塞",
    "title": "tcp",
    "section": "7 阻塞",
    "text": "7 阻塞\n阻塞 ,阻塞, 啥是阻塞? 1. 假设快递, 在没有蜂巢的情况下, 快递员带着包裹来了, 你人不在, GG 2. 有蜂巢后, 包裹到了, 快递员发现蜂巢满了, GG",
    "crumbs": [
      "tcp"
    ]
  },
  {
    "objectID": "docs/netprog/https.html",
    "href": "docs/netprog/https.html",
    "title": "https",
    "section": "",
    "text": "HTTP 是明文传输的协议,数据在传输过程中不加密, 容易被窃听篡改和劫持",
    "crumbs": [
      "https"
    ]
  },
  {
    "objectID": "docs/netprog/https.html#http的问题",
    "href": "docs/netprog/https.html#http的问题",
    "title": "https",
    "section": "",
    "text": "HTTP 是明文传输的协议,数据在传输过程中不加密, 容易被窃听篡改和劫持",
    "crumbs": [
      "https"
    ]
  },
  {
    "objectID": "docs/netprog/https.html#解决方案",
    "href": "docs/netprog/https.html#解决方案",
    "title": "https",
    "section": "2 解决方案",
    "text": "2 解决方案\n\n2.1 1. 对称加密\n\n\n\n\n\n\n什么是对称加密\n\n\n\n\n能使用同一个密钥用来加密和解密\n这也是普通人立马就可以想到的方式\n举个随便设计的算法:\n\n发送 hello world, 加密方法是 将字符加上在单词上的索引*密钥,这里密钥=1\n\nh 索引是1 -&gt; h+1*1=i\ne 索引是2 -&gt; e+2*1=g\nhello world =&gt; igopt xqupi\n\n知道密钥就可以解密了\n\n\n\n\n\n\n\n\n\n\n\n结论\n\n\n\n加密算法和密钥都可能被拦截, 不安全.\n\n\n\n\n\n2.2 2. 非对称加密\n\n\n\n\n\n\n非对称加密\n\n\n\n\n它使用了一对密钥，分别是公钥（Public Key）和私钥(Private Key)\n浏览器发送数据时用公钥对数据进行加密, 服务端使用配对的私钥对数据进行解密\n服务端返回数据给浏览器时用私钥进行加密, 浏览器用公钥进行解密\n加密解密都相对比较耗时\n\n\n\n\n\n\n\n\n\n如何解决对称加密中密钥传输安全问题?\n\n\n\n\n使用非对称加密算法, 私钥放在服务器,被拦截黑客也无法获取,公钥在浏览器\n浏览器使用公钥加密对称加密用的密钥, 服务器使用私钥解密得到真实这个密钥.\n是不是觉得多此一举了, 直接用非对称加密算法加密数据不就得了??\n\n非对称加密解密耗时, 每次数据传输都这样 ,伤不起\n密钥由服务器生成, 只生成一对, 如果来一个客户端就生成一对,还是耗时.\n所以只要浏览器访问它就会得到这个公钥, 黑客也能得到, 如果它拦截了服务器返回给客户端的数据,可以解密\n所以我们使用结合2个算法,保证一开始对称加密的密钥(盐)传输安全就行了,对对称加密的密钥用公钥加密,黑客截取数据,因为它只有公钥,是无法解密的\n这样服务端知道了 对称加密的密钥, 这之后就用对称加密算法对数据进行加密来传输\n\n\n\n\n\n\n\n\n\n\n\n思考?\n\n\n\n事情好像完美解决了,真的安全了吗?\n\n\n\n\n\n2.3 3. 中间人攻击\n\n\n\n\n\n\n前面的问题\n\n\n\n\n黑客可以在浏览器获取服务器发送的公钥的阶段拦截,那它可以伪造成服务器,作为一个中间人\n浏览器发送到了 中间人, 中间人自己生成一对公钥私钥, 它将自己的这个公钥返回给浏览器,自己再向真正的服务器发起请求\n浏览器得到一个假的公钥, 然后它发送的数据全部被中间人截获,可以解密…\n问题的关键是, 浏览器确保得到服务端真正下发的公钥\n\n\n\n\n\n\n\n\n\n如何解决呢?\n\n\n\n\n现实的一个例子\n\n假设我去一家某某明星开的店买东西, 我要先确认这家店是不是真的, 我们就去看营业执照\n一看盖章是真的. 这就行了吗? 一个人想开个店 ,他自己去申请营业执照, 那这个章也是真的啊, 光看章这样还不行!!!\n那我看看营业执照上写的法人是谁不就行了吗? 对!\n审批人员, 盖章的时候看身份证和脸写上法人,而不是让申请者随便写,然后在名字上盖章,这样没法篡改了.\n\n现在我们改进我们之前的设计(仅仅是自己的思考过程,与实际https不一样):\n\n服务端将 它的公钥 发送给 值得信赖第三方证书颁发机构CA,CA用自己的一对密钥中的私钥对服务端公钥进行加密\n服务端 把从CA那里获取的密文发送给浏览器, 浏览器用 CA的公钥进行解密.这里的关键就是操作系统安装后就有一些CA的公钥,所以浏览器无需通过网络获取CA公钥,要不然又重复之前的问题了.只要浏览器能用这个CA公钥解密, 就说明数据是通过CA加密的.\n那中间人将自己的公钥发送给CA,CA用私钥加密后发送给中间人,中间人再转发给浏览器,这个时候浏览器是可以解密的,就以为是ok的了! 不行!!\n那CA给你公钥加密的时候, 再带上发起请求的网站的域名不就ok了. 这样即使中间人请求CA,CA加密会带上中间人的域名, 浏览器解密后发现域名不是自己想要访问的网站. 中间人向CA申请证书时,会递交个人信息, CA会审核真实性, 所以不会让它随便写域名,无法冒充原来我们真正请求的那个服务器\n\n\n\n\n\n\n\n\n\n\n问题\n\n\n\n\n中间人把自己当成CA 做证书发给浏览器行吗?\n\n这样浏览器查看证书颁发机构, 它操作系统就没有,因为只有内置的那些可靠的, 所以没有对应的公钥来解密\n当然如果你的系统被黑客安装了它自己生成的证书, 那么浏览器就会找到对应的公钥来解密了,不过这是你的问题\n\n\n\n\n\n\n2.4 4. https 最终方案",
    "crumbs": [
      "https"
    ]
  },
  {
    "objectID": "docs/netprog/https.html#证书相关",
    "href": "docs/netprog/https.html#证书相关",
    "title": "https",
    "section": "3 证书相关",
    "text": "3 证书相关\nRoot CA 会给二级 CA 颁发证书,\n一般用户网站的证书 由 二级CA颁发.\n操作系统默认就安装了很多Root CA\n\n\n\n\n\n\nTip\n\n\n\nX.509 是一种常用的数字证书格式标准,定义了证书的结构和内容\n\n\n\n3.1 openssl 相关操作\n\n# 私钥\n# 记得权限设置600最好\n# 非对称算法 使用rsa 生成\nopenssl genrsa -out server.key 2048\n# 表示会对生成的key 进行一次对称加密, 会提示你输入密码\n# 不过不推荐, 需要你输入密码解密.麻烦\nopenssl genrsa -out server-des.key -des 2048\n# 从私钥提取公钥 ,这里要对应的算法, rsa\nopenssl rsa -in server.key -pubout -out server.pub\n# 会提示你输入密码,才能提取公钥\nopenssl rsa -in server-des.key -pubout -out server-des.pub\n# 将加密过的私钥 转换为 不加密的\nopenssl rsa -in server-des.key -out server-des-remove.key\n\necho 123 &gt; tmp.txt\n# 使用公钥加密\nopenssl rsautl -encrypt -in  tmp.txt -inkey server.pub -pubin -out tmp.txt.encry\n\n# 使用私钥解密\n# 输出到文件\nopenssl rsautl -decrypt -in  tmp.txt.encry -inkey server.key  -out tmp.txt.dencry\n# 直接输出解密后的内容\nopenssl rsautl -decrypt -in  tmp.txt.encry -inkey server.key\n\n# 使用私钥加密(签名)\nopenssl rsautl -sign -in  tmp.txt -inkey server.key  -out tmp.txt.sign\n# 使用公钥解密(验签)\nopenssl rsautl -verify -in  tmp.txt.sign -inkey server.pub -pubin\n\n\n3.2 模拟CA颁发证书\n\n\n\n\n\n\nImportant\n\n\n\n注意这里是我们模拟CA机构, 所以步骤很多, 如果只是简单的为我们服务器生成一个证书, 不需要这样,见快速自签名证书\n\n\n\n3.2.1 配置CA\nopenssl ca # 会看到配置文件\n\n\n/etc/pki/tls/openssl.cnf\n\n[ ca ]\ndefault_ca      = CA_default    #默认CA的设置是哪个,  下面那个配置就是了.\n\n####################################################################\n[ CA_default ]\n\ndir             = /etc/pki/CA           # \ncerts           = $dir/certs            # 发布的证书放这个目录\ncrl_dir         = $dir/crl              # 证书吊销列表存放目录\ndatabase        = $dir/index.txt        # 颁发给谁等等信息数据的索引\n#unique_subject = no                    # 默认是yes ,表示 证书申请者主体 唯一, 不能用同一个csr申请多个证书\nnew_certs_dir   = $dir/newcerts         # 新颁发的证书存放目录,当然上面的certs 也会有新颁发的证书存放\ncertificate     = $dir/cacert.pem       # CA的证书 (我们自己测试就一个Root CA就行)\nserial          = $dir/serial           # 每个证书都有编号, 这里是下一个要颁发的证书的编号\ncrlnumber       = $dir/crlnumber        # 吊销的编号,同上\ncrl             = $dir/crl.pem          # 包含之前所有吊销证书的列表\nprivate_key     = $dir/private/cakey.pem# CA的私钥\nRANDFILE        = $dir/private/.rand    # private random number file\nx509_extensions = usr_cert              # The extentions to add to the cert\nname_opt        = ca_default            # Subject Name options\ncert_opt        = ca_default            # Certificate field options\n\ndefault_days    = 365                   # 证书默认有效期 天 ,可以改成3650\ndefault_crl_days= 30                    # how long before next CRL\ndefault_md      = sha256                # use SHA-256 by default\npreserve        = no                    # keep passed DN ordering\npolicy          = policy_match #匹配下面的 表示使用这个安全策略\n[ policy_match ] # 你在生成证书的时候会提示你输入这些信息\n# match 表示将来你用户网站申请证书时填写东西必须与CA的一致\n# 也就是说你网站申请时 国家 部门,公司必须和CA的一致\n# 我们自己 内部用, 可以用这个策略来\ncountryName             = match\nstateOrProvinceName     = match # 州名或省份名称，可以是中文或英文\norganizationName        = match   # 公司名称，可以是中文或英文\norganizationalUnitName  = optional # 部门名称，可以是中文或英文\ncommonName              = supplied #必须输入 申请 SSL 证书的具体网站域名\nemailAddress            = optional # optional 可写可不写\n\n[ policy_anything ] # 你可以选择这个策略\ncountryName             = optional\nstateOrProvinceName     = optional\nlocalityName            = optional\norganizationName        = optional\norganizationalUnitName  = optional\ncommonName              = supplied\nemailAddress            = optional\n\n\n\n3.2.2 CA生成根证书\n# 模拟CA,本地自定义CA,我们假设在一台服务器上 是专门弄CA的\n/etc/pki/CA\n├── certs\n├── crl\n├── newcerts\n└── private\ncd /etc/pki/CA\ntouch index.txt\n# 16进制\necho 01 &gt; serial\n# 生成CA的私钥\nopenssl genrsa -out ./private/cakey.pem 2048\n# 生成CA自签名证书 cacert.pem\n    # x509表示输出这种格式的证书\nopenssl req -x509 -new -key ./private/cakey.pem  \\\n    -days 5000 \\\n    -out cacert.pem\n    # 直接指定\nopenssl req -x509 -new -key ./private/cakey.pem \\\n    -subj \"/CN=example1.com/C=CN/O=taobao/ST=BJ\" \\\n    -days 5000 \\\n    -out cacert.pem\n\n# 验签, 用颁发证书的 x 去验证 被签发的 y\nopenssl verify -CAfile cacert.pem cacert.pem\n# 查看证书内容, 如果直接用base64 -d 解码会看到一些乱码.\n#  也可以将这个文件 打开 (在mac或windows上 会用默认的程序打开,可以看到相关信息)\nopenssl x509 -in cacert.pem -noout -text\n\n因为我们的配置文件里有 x509_extensions = v3_ca The extentions to add to the self signed cert\n\n\n所以这些相应的会在自签名证书里添加\n\n[ v3_ca ]\nsubjectKeyIdentifier=hash\nauthorityKeyIdentifier=keyid:always,issuer\nbasicConstraints = CA:true\n\nCertificate:\nData:\n    Version: 3 (0x2)\n    Serial Number:\n        ee:e1:85:de:8f:2a:00:76\nSignature Algorithm: sha256WithRSAEncryption\n    # 证书颁发者\n    Issuer: C=XX, L=Default City, O=Default Company Ltd, CN=example1.com\n    Validity\n        Not Before: Aug  1 16:51:52 2023 GMT\n        Not After : Apr  9 16:51:52 2037 GMT\n    # 证书申请者, 颁发给谁 ,这里和 颁发者一样, 自签名\n    Subject: C=XX, L=Default City, O=Default Company Ltd, CN=example1.com\n    Subject Public Key Info:\n        Public Key Algorithm: rsaEncryption\n            Public-Key: (2048 bit)\n            Modulus:\n                00:98:ad:ff:cc:a1:2d:2c:24:30:d4:87:14:02:06:\n                0f:50:60:ec:b2:0c:19:09:7c:96:74:82:46:c0:a3:\n                bc:86:77:7e:b2:fb:9e:a1:4f:fd:2b:3a:02:20:2b:\n                a1:94:d4:49:62:ce:36:1f:80:a8:71:fb:1e:3f:e3:\n                90:d3:78:f7:74:86:4f:3b:8c:85:d1:ae:4f:26:23:\n                15:29:f0:ed:0f:ee:a7:08:f5:3c:70:f2:b5:1c:f1:\n                71:e1:73:79:85:9d:11:64:2f:84:29:93:5b:df:d7:\n                a2:32:19:fe:c4:72:70:a9:d1:b3:54:22:6e:77:27:\n                2d:43:ec:5c:06:6a:7b:65:07:a9:ba:9a:35:db:2a:\n                7c:6f:f5:d6:27:59:15:d5:40:d3:94:dc:4c:7d:25:\n                8e:a3:3d:23:d1:5b:4e:6a:35:cf:ee:b4:0f:59:ec:\n                65:bb:b6:75:21:c5:6d:dd:a6:87:a7:15:af:bb:e1:\n                a5:75:6c:6c:36:da:60:13:41:f3:a8:11:b1:3f:8f:\n                bd:d4:03:c7:e0:f5:2f:68:76:7f:d0:67:45:eb:48:\n                8a:ad:70:34:3f:6b:fa:fc:bb:83:4f:e8:a0:3c:5c:\n                77:b5:c6:10:e0:b3:a8:fc:66:8c:56:e8:9d:64:6e:\n                8c:fe:42:65:02:c5:1d:81:66:e4:60:f2:5b:6d:e1:\n                cc:cb\n            Exponent: 65537 (0x10001)\n    X509v3 extensions:\n        X509v3 Subject Key Identifier:\n            3C:CE:32:F7:55:76:EB:E7:4D:CF:10:26:F0:35:D2:24:3B:89:6B:94\n        X509v3 Authority Key Identifier:\n            keyid:3C:CE:32:F7:55:76:EB:E7:4D:CF:10:26:F0:35:D2:24:3B:89:6B:94\n\n        X509v3 Basic Constraints:\n            CA:TRUE\nSignature Algorithm: sha256WithRSAEncryption\n        49:b0:f1:1b:58:06:be:02:e7:8a:7e:f0:59:d1:96:22:9f:62:\n        ba:e0:a3:09:5c:56:b3:2b:8c:a4:9d:6b:4f:dc:ea:af:39:b1:\n        05:01:78:ed:7d:c6:84:59:3b:a6:d4:c4:5f:ae:d9:d3:82:80:\n        be:41:e0:c5:ae:ff:40:89:c5:2a:bd:f3:5b:20:c6:c5:59:6d:\n        32:3c:19:b2:9b:4d:7f:c3:ef:a1:ab:51:6e:19:b7:88:45:91:\n        ef:ab:e7:c9:bd:c0:ca:c0:fa:48:58:cf:a0:e3:d2:bb:41:e8:\n        60:da:6b:0b:1f:91:fa:cb:08:9c:4f:4e:05:3b:80:2a:ad:63:\n        b1:75:c1:57:1a:08:27:a2:d6:06:52:00:d4:d2:41:3a:ad:27:\n        11:67:ba:de:85:57:24:d5:cf:77:d7:b7:a7:8a:9e:c2:29:e4:\n        41:ce:4a:37:8f:db:14:50:32:60:80:9a:92:f1:76:7e:73:80:\n        37:cc:6c:fb:ca:82:02:8b:8f:62:5c:91:b1:0a:ad:72:57:e0:\n        6d:a1:12:0b:c7:86:ef:9f:47:35:52:96:65:e0:cf:b2:65:d5:\n        45:a1:8f:db:12:2a:e8:ae:c6:f3:08:97:b5:1a:7a:4c:f9:92:\n        30:bd:ce:28:94:84:a9:67:f4:d5:2a:87:cc:da:6e:4c:ad:a6:\n        18:39:d5:32\n\n\n3.2.3 用户服务器提交申请\n# 现在扮演 用户网站申请证书, 假定在另外一台服务器\n# 先创建网站的私钥\nopenssl genrsa -out server.key 2048\n# 直接创建证书签名请求csr文件\n# 注意 由于我们配置了 policy_match ,所以几个 需要和CA的一致\n# 指定 server.key 是因为csr信息 需要包含服务端的公钥,公钥可以从私钥提取.\n#  说明这些是想说 写的时候 知道为啥需要这些参数\nopenssl req -new -key server.key -subj \"/CN=example1.com/C=CN/O=taobao/ST=BJ\" -out server.csr\n\n# 查看一下csr\nopenssl req -in server.csr -text -noout\n# 将它 发送给 CA服务器\n\n\n3.2.4 CA根据申请生成证书\n# 可以指定 -policy ,这样不用与ca 某些一致\n# openssl ca -in server.csr -policy policy_anything -out certs/server.crt -days 3650\n# 回到 CA 的服务器 ,拿到 用户网站的csr文件, 签署生成证书,最后你发送给申请者\nopenssl ca -in server.csr  -out certs/server.crt -days 3650 #(1)\n\n\n执行的提示信息\n\n...\nSerial Number: 1 (0x1) # 可以看到编号\nSign the certificate? [y/n]:  # 提示要签名了\n1 out of 1 certificate requests certified, commit? [y/n]y\nWrite out database with 1 new entries\nData Base Updated\n\n/etc/pki/CA\n├── newcerts # 这个目录下会自动有这次颁发的证书\n│   └── 01.pem # 里面的内容更多, 会增加解码后的内容\n# 验签\nopenssl verify -CAfile cacert.pem certs/server.crt\n\n# 查看证书, 查看部分内容, -text 会显示所有 -issuer  颁发者 -dates 有效期\nopenssl x509 -in certs/server.crt -noout -subject -issuer -dates\n# 查看证书状态,验证有效与否  01 是serial 证书编号\nopenssl ca -status 01\n# 默认不能使用同一个csr 申请 另外一个证书, 不过可以修改 使它可以\n# 除了 前面的配置文件, 我们可以 修改 index.txt.attr\n    unique_subject = yes # 改成no 就可以\n\n\n3.2.5 客户端安装证书\n\n客户端(浏览器的系统) 需要安装 上面创建的根证书 cacert.pem,这样你操作系统就有了CA的公钥了,就好像系统安装后默认的那些Root CA一样 \n访问 golang web https服务 https://example1.com, 会提示你安装证书\n\ntree\n├── go.mod\n├── main.go\n├── pki\n│   ├── server.crt # 上面我们创建的\n│   ├── server.key # 上面我们创建的\npackage main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"net/http\"\n)\n\nfunc main() {\n    http.HandleFunc(\"/\", handler)\n    log.Fatal(http.ListenAndServeTLS(\":443\", \"./pki/server.crt\", \"./pki/server.key\", nil))\n}\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n    fmt.Fprintln(w, \"Hello, HTTPS!\")\n}\ngo run main.go\n\n\n/etc/hosts\n\n192.168.1.100 example1.com\n\n# 将server.crt 发送到其他机器, 可以在这样的机器上 curl\ncurl --cacert server.crt --resolve example1.com:443:192.168.1.104 https://example1.com/\nHello, HTTPS!\n\n\n\n\n\n\nchrome/edge 浏览器问题\n\n\n\n\n访问网页会提示你 Subject Alternative Name Missing\n提示 net: cert_invalid\n\n\nCA解决步骤简单快速自签名方法\n\n\n\n\n/etc/pki/tls/openssl.cnf 添加\n\n# 这个表示添加到证书请求里的配置\nreq_extensions = v3_req # The extensions to add to a certificate request\n[ v3_req ]\nbasicConstraints = CA:FALSE\nkeyUsage = nonRepudiation, digitalSignature, keyEncipherment\nsubjectAltName = @alt_names # 添加这行\n[alt_names]  # 添加\nDNS.1   = example1.com # 添加我们访问的域名\n\n\n\n生成证书等步骤稍作变更\n\nopenssl genrsa -out ./private/cakey.pem 2048\n# 根证书 -extensions v3_req 需要显式指定\nopenssl req -x509 -new -key ./private/cakey.pem \\\n    -subj \"/CN=example1.com/C=CN/O=taobao/ST=BJ\" \\\n    -extensions v3_req -days 5000 \\\n    -out cacert.pem\n\nopenssl genrsa -out server.key 2048\n# csr  默认就会应用配置里的 req_extensions = v3_req ,因为就是req 生成csr 请求文件 的操作\n# 如果前面的 req_extensions = v3_req 被注释了, 则需要 显式指定-extensions v3_req\nopenssl req -new -key server.key -subj \"/CN=example1.com/C=CN/O=taobao/ST=BJ\" -out server.csr\n# 生成证书\n# 如果不指定 -extensions v3_req 则会使用配置文件里  user_cert 指定的配置.\n# x509_extensions = usr_cert  # The extentions to add to the cert\n# [ usr_cert ]\n# These extensions are added when 'ca' signs a request.\nopenssl ca -in server.csr -extensions v3_req  -out /etc/pki/CA/certs/server.crt -days 3650\n# 查看一下, 会看到版本是3 等信息\n\n\n\nopenssl genrsa -out server.key 2048\n# 实际上就是使用临时的openssl.cnf (多包含了我们设置的[SAN] 扩展,名字随便起, -extensions 指定就行)\n# 生成的 server.crt 里  X509v3 extensions: 就只会有 subjectAltName\nopenssl req -x509 -new \\\n    -key server.key \\\n    -subj \"/CN=example1.com/C=CN/O=taobao/ST=BJ\" \\\n    -extensions SAN \\\n    -config &lt;(cat /etc/pki/tls/openssl.cnf &lt;(echo [SAN];echo subjectAltName=DNS.1:example1.com)) \\\n    -days 1000 \\\n    -out server.crt\n\n\n\n最后好像除了ca根证书安装, 网站服务器的证书还是要手动安装?\n\n\n\n\n3.2.6 99.吊销证书\n# 吊销证书, 指定证书路径即可, 结果看 index.txt  证书状态变成 R 表示revoke\nopenssl ca -revoke  newcerts/01.pem\n# 更新吊销列表\n# 指定要吊销的证书编号,第一次需要这样,\necho 01 &gt; /etc/pki/CA/crlnumber\nopenssl ca -gencrl -out /etc/pki/CA/crl.pem\n# 查看吊销列表\nopenssl crl -in /etc/pki/CA/crl.pem -noout -text\n\n\n\n3.3 快速生成证书\n\n\n\n\n\n\nTip\n\n\n\n不用模拟ca那样\n\n\n# 不需要ca根证书的, 自签名证书, 自己给自己签名,\n# 客户端直接安装这个,里面有公钥,然后服务端也是发送这个证书\n# 客户端发送操作系统有这个证书的颁发机构, 其实就是它自己\nopenssl genrsa -out server.key 2048\nopenssl req -x509 -new -key server.key -subj \"/CN=example1.com/C=CN/O=taobao/ST=BJ\" -days 5000 -out server.crt\n\n# centos 7有自带的Makefile\ncd /etc/pki/tls/certs/\nmake # 会提示使用方法\n\n# 需要根证书的\n # 根 私钥\nopenssl genrsa  -out ca.key 2048\n# 根证书\nopenssl req -x509 -nodes -new -key ca.key -subj \"/CN=example1.com/C=CN/O=tb/ST=BJ\" -days 5000 -out ca.crt\n# 服务器 私钥\nopenssl genrsa -out server.key 2048\n# csr\nopenssl req -new -key server.key -subj \"/CN=example1.com/C=CN/O=tb/ST=BJ\" -out server.csr\n# 之前的这个操作,会去找配置中的 ca私钥\n# openssl ca -in server.csr  -out server.crt -days 3650\n# 这里我们直接指定  -CAcreateserial 加上这个表示会创建编号文件 ca.srl\n# -extfile        - configuration file with X509V3 extensions to add\n# -extensions     - section from config file with X509V3 extensions to add\n# 前面我们提到chrome 提示有问题, 应该 只要服务器证书 设置 subjectAltName 就行了.\n# 指定ca.crt 那是因为 生成的证书需要颁发机构的信息.\nopenssl x509 -req -CA ca.crt \\\n    -CAkey ca.key -CAcreateserial \\\n    -in server.csr -out server.crt \\\n    -extensions v3_req \\\n    -extfile &lt;(cat /etc/pki/tls/openssl.cnf &lt;(cat &lt;&lt;EOF\n[ v3_req ]\nbasicConstraints = CA:FALSE\nkeyUsage = nonRepudiation, digitalSignature, keyEncipherment\nsubjectAltName = @alt_names\n[alt_names]\nDNS.1 = example1.com\nEOF\n))\n# 查看\nopenssl x509 -in server.crt -noout -text #(1)\n\n\nopenssl x509 -in server.crt -noout -text 扩展的一些信息\n\nX509v3 extensions:\n    X509v3 Basic Constraints:\n        CA:FALSE\n    X509v3 Key Usage:\n        Digital Signature, Non Repudiation, Key Encipherment\n    X509v3 Subject Alternative Name:\n        DNS:example1.com\n\n\n\n3.4 关于证书的总结\n\n\n\n\n\n\nTip\n\n\n\n客户端安装根证书(自签名证书也一样)是为了解密服务端传过来的证书内容,以获取服务端的公钥, 然后使用公钥加密随机密钥(用来对称加密用),将这密钥安全发送给服务端,最后用这个密钥加密传输的数据,以达到安全的目的",
    "crumbs": [
      "https"
    ]
  },
  {
    "objectID": "docs/netprog/https.html#抓包分析https",
    "href": "docs/netprog/https.html#抓包分析https",
    "title": "https",
    "section": "4 抓包分析https",
    "text": "4 抓包分析https\n\n\n\n\n\n\nNote\n\n\n\ngo web程序在虚拟机中, 在宿主机浏览器访问\n\n\n\n\n虚拟机中运行\n\ngo run main.go\n# 抓包\ntcpdump -i eth1 -nn -X -S  tcp port 443 -w go.pcap\n\n宿主机中用safari访问 https://example1.com, 等一段时间,将虚拟机中的抓取的包go.pcap 在宿主机中用wireshark 打开这个\n\n\n\n\n\n\nCaution\n\n\n\nTODO",
    "crumbs": [
      "https"
    ]
  },
  {
    "objectID": "docs/netprog/https.html#其他安全相关",
    "href": "docs/netprog/https.html#其他安全相关",
    "title": "https",
    "section": "5 其他安全相关",
    "text": "5 其他安全相关\n\n5.1 摘要算法\n\n\n\n\n\n\nTip\n\n\n\n\n摘要算法（Hash Algorithm）也叫哈希算法、散列算法, 它是一种将任意长度的数据映射为固定长度摘要（哈希值）的算法.摘要算法常用于验证数据的完整性和唯一性,以及密码学中的数字签名、密码校验等应用\n任意长度–&gt; 固定长度, 很显然不可能从映射后的摘要值推导出原来的数据.",
    "crumbs": [
      "https"
    ]
  },
  {
    "objectID": "docs/devops/linux/service/nginx.html",
    "href": "docs/devops/linux/service/nginx.html",
    "title": "nginx",
    "section": "",
    "text": "nginx -V | grep  abc  # 你发现grep 任何东西都会输出...\nnginx -V # 实际上这个是错误信息输出到终端\n\n\n可以看到配置文件的位置\n\nnginx -V 2&gt;&1 |grep nginx.conf\n\n\n\n配置相关信息输出重定向到文件\n\nnginx -V 2&gt;&1 1&gt;tmp.txt",
    "crumbs": [
      "service",
      "nginx"
    ]
  },
  {
    "objectID": "docs/devops/linux/service/nginx.html#查看配置",
    "href": "docs/devops/linux/service/nginx.html#查看配置",
    "title": "nginx",
    "section": "",
    "text": "nginx -V | grep  abc  # 你发现grep 任何东西都会输出...\nnginx -V # 实际上这个是错误信息输出到终端\n\n\n可以看到配置文件的位置\n\nnginx -V 2&gt;&1 |grep nginx.conf\n\n\n\n配置相关信息输出重定向到文件\n\nnginx -V 2&gt;&1 1&gt;tmp.txt",
    "crumbs": [
      "service",
      "nginx"
    ]
  },
  {
    "objectID": "docs/devops/linux/bash/sed.html",
    "href": "docs/devops/linux/bash/sed.html",
    "title": "bash sed",
    "section": "",
    "text": "env\nversion\n\n\n\n\nsed\nsed (GNU sed) 4.7",
    "crumbs": [
      "bash",
      "sed"
    ]
  },
  {
    "objectID": "docs/devops/linux/bash/sed.html#工作原理",
    "href": "docs/devops/linux/bash/sed.html#工作原理",
    "title": "bash sed",
    "section": "1 工作原理",
    "text": "1 工作原理\n\nsed = stream editor 可以对标准输出和文件进行逐行处理 ### 命令结构\n\n\n\n1.1 流程图\n\n\n\n1.2 –debug 分析流程\n\n1.2.1 p 打印操作分析\n\nexample.txt”执行命令debug分析\n\n\nhello cat\nhello world\nhot dog\n\n\n# = 的行为是打印匹配的行的行号\nsed '/hello/=;p' example.txt\n\n\n执行结果\n\n1\nhello cat\nhello cat\n2\nhello world\nhello world\nhot dog\nhot dog\n\n\n\nsed --debug '/hello/=;p' example.txt\n\n\n执行结果\n\nSED PROGRAM:\n/hello/ =\np\nINPUT:   'example.txt' line 1\nPATTERN: hello cat\nCOMMAND: /hello/ =\n1\nCOMMAND: p\nhello cat\nEND-OF-CYCLE:\nhello cat\nINPUT:   'example.txt' line 2\nPATTERN: hello world\nCOMMAND: /hello/ =\n2\nCOMMAND: p\nhello world\nEND-OF-CYCLE:\nhello world\nINPUT:   'example.txt' line 3\nPATTERN: hot dog\nCOMMAND: /hello/ =\nCOMMAND: p\nhot dog\nEND-OF-CYCLE:\nhot dog\n\n\n第5行, 显示 pattern space buffer的内容,就是行内容\n显示结果里的第6行COMMAND: /hello/ = 判断pattern space是否包含hello,是的话就打印它的行号\n第8行 COMMAND: p [addr]是空,就是直接匹配了,直接p操作打印pattern space的内容.\n第11行是 不带-n的 默认行为 打印了pattern space的内容 hello cat\n\n\n\n\n\n\n1.2.2 s 替换操作分析\n\n执行命令debug分析\n\n\nsed  's/hello/xxxx/gp' example.txt\n\n\n执行结果\n\nxxxx cat\nxxxx cat\nxxxx world\nxxxx world\nhot dog\n\n\n\nsed --debug 's/hello/xxxx/gp' example.txt\n\n\n执行结果\n\nSED PROGRAM:\ns/hello/xxxx/gp\nINPUT:   'example.txt' line 1\nPATTERN: hello cat\nCOMMAND: s/hello/xxxx/gp\nMATCHED REGEX REGISTERS\nregex[0] = 0-5 'hello'\nxxxx cat\nPATTERN: xxxx cat\nEND-OF-CYCLE:\nxxxx cat\nINPUT:   'example.txt' line 2\nPATTERN: hello world\nCOMMAND: s/hello/xxxx/gp\nMATCHED REGEX REGISTERS\nregex[0] = 0-5 'hello'\nxxxx world\nPATTERN: xxxx world\nEND-OF-CYCLE:\nxxxx world\nINPUT:   'example.txt' line 3\nPATTERN: hot dog\nCOMMAND: s/hello/xxxx/gp\nPATTERN: hot dog\nEND-OF-CYCLE:\nhot dog\n\n\n第8行 是 s/hello/xxxx/gp中p这个s的flag的行为(打印pattern space). 注意它其实并不是X,s是X,这个p只是它的flag,只不过行为与身为X的p操作一样.后续再说\n第9行 显示变化后的 pattern space 的内容给我们看. 这个时候已经被替换了相关的字符串. 如果patttern space 内容有变化会在这里重新显示一次\n不带-n的默认操作, 打印 pattern space\n\n\n\n\n\n\n1.2.3 a 行后插入操作分析\n\n执行命令debug分析\n\n\nsed -n '/world/a python' example.txt\n\n\n执行结果\n\npython\n\n从执行结果看, a操作默认会打印你插入的内容\n\n\n# 我们debug 一下不带 -n 参数的 流程.\nsed --debug '/world/a python' example.txt\n\n\n执行结果\n\nSED PROGRAM:\n/world/ a\\python\n\nINPUT:   'example.txt' line 1\nPATTERN: hello cat\nCOMMAND: /world/ a\\python\n\nEND-OF-CYCLE:\nhello cat\nINPUT:   'example.txt' line 2\nPATTERN: hello world\nCOMMAND: /world/ a\\python\n\nEND-OF-CYCLE:\nhello world\npython\nINPUT:   'example.txt' line 3\nPATTERN: hot dog\nCOMMAND: /world/ a\\python\n\nEND-OF-CYCLE:\nhot dog\n\n\n从11-16行可以看到 Pattern space并没有发生变化. (有变化会重新显示一次)\n15行是 没有-n 的默认行为, 打印Pattern space\n16行是a 的行为. 它发生在 默认打印pattern space行为的后面\na的行为: 不改变pattern space , 它会把在该命令后面的文本,在当前CYCLE结束或读取下一行时输出.\n注意上面的空行3,7,13,20这几行,这是COMMAND本身的一部分. 就是说我们a python后面实际跟着一个换行符,要不然也不会是插入一行了. 所以SED PROGRAM:后面显示的是2行,包含了一个换行符\n\n\n\n\n\n\n1.2.4 i 行前插入操作分析\n\n执行命令debug分析\n\n\nsed '/world/i python' example.txt\n\n\n执行结果\n\nhello cat\npython\nhello world\nhot dog\n\n\n\nsed  --debug '/world/i python' example.txt\n\n\n执行结果\n\nSED PROGRAM:\n/world/ i\\python\n\nINPUT:   'example.txt' line 1\nPATTERN: hello cat\nCOMMAND: /world/ i\\python\n\nEND-OF-CYCLE:\nhello cat\nINPUT:   'example.txt' line 2\nPATTERN: hello world\nCOMMAND: /world/ i\\python\n\npython\nEND-OF-CYCLE:\nhello world\nINPUT:   'example.txt' line 3\nPATTERN: hot dog\nCOMMAND: /world/ i\\python\n\nEND-OF-CYCLE:\nhot dog\n\n\n第14行直接打印了, 可以与a操作 做个对比\n官方原话: Immediately output the lines of text which follow this command\n\n\n\n\n\n\n1.2.5 H和x操作 与hold space\n\ninput.txt执行指令分析\n\n\n官方例子, 我内容稍微变下\njs\nvue\nreact\n\npython\nphp\n\njava\ngolang\nrust\n\n\nsed '/./{H;$!d} ; x ; s/^/\\nSTART--&gt;/ ; s/$/\\n&lt;--END/' input.txt\n# 上面的命令会在最开头增加一个空行. 这里这个将这个去掉了.\n# sed '/./{H;$!d} ; x ; s/^/START--&gt;/; $!s/$/\\n&lt;--END\\n/;$s/$/\\n&lt;--END/' input.txt\n\n\n执行结果\n\n                    \nSTART--&gt;\njs\nvue\nreact\n&lt;--END\n\nSTART--&gt;\npython\nphp\n&lt;--END\n\nSTART--&gt;\njava\ngolang\nrust\n&lt;--END\n\n\n\n\n\n\nX\nDescription\n\n\n\n\nH1\n添加一个换行符到hold space,然后将pattern space 的内容追加到hold space\n\n\nx2\n互相hold space和pattern space的内容\n\n\nd\n删除 pattern space的内容,立刻开始下一次cycle,后续的命令不再执行哦\n\n\n\nsed --debug '/./{H;$!d} ; x ; s/^/\\nSTART--&gt;/ ; s/$/\\n&lt;--END/' input.txt\n\n\n执行结果\n\nSED PROGRAM:\n/./ {\n    H\n    $! d\n}\nx\ns/^/\nSTART--&gt;/\ns/$/\n&lt;--END/\nINPUT:   'input.txt' line 1\nPATTERN: js\nCOMMAND: /./ {\nCOMMAND:   H\nHOLD:    \\njs\nCOMMAND:   $! d\nEND-OF-CYCLE:\nINPUT:   'input.txt' line 2\nPATTERN: vue\nCOMMAND:   /./ {\nCOMMAND:     H\nHOLD:    \\njs\\nvue\nCOMMAND:     $! d\nEND-OF-CYCLE:\nINPUT:   'input.txt' line 3\nPATTERN: react\nCOMMAND:     /./ {\nCOMMAND:       H\nHOLD:    \\njs\\nvue\\nreact\nCOMMAND:       $! d\nEND-OF-CYCLE:\nINPUT:   'input.txt' line 4\nPATTERN:\nCOMMAND:       /./ {\nCOMMAND:       }\nCOMMAND:       x\nPATTERN: \\njs\\nvue\\nreact\nHOLD:\nCOMMAND:       s/^/\nSTART--&gt;/\nMATCHED REGEX REGISTERS\nregex[0] = 0-0 ''\nPATTERN: \\nSTART--&gt;\\njs\\nvue\\nreact\nCOMMAND:       s/$/\n&lt;--END/\nMATCHED REGEX REGISTERS\nregex[0] = 22-22 ''\nPATTERN: \\nSTART--&gt;\\njs\\nvue\\nreact\\n&lt;--END\nEND-OF-CYCLE:\n\nSTART--&gt;\njs\nvue\nreact\n&lt;--END\nINPUT:   'input.txt' line 5\nPATTERN: python\nCOMMAND:       /./ {\nCOMMAND:         H\nHOLD:    \\npython\nCOMMAND:         $! d\nEND-OF-CYCLE:\nINPUT:   'input.txt' line 6\nPATTERN: php\nCOMMAND:         /./ {\nCOMMAND:           H\nHOLD:    \\npython\\nphp\nCOMMAND:           $! d\nEND-OF-CYCLE:\nINPUT:   'input.txt' line 7\nPATTERN:\nCOMMAND:           /./ {\nCOMMAND:           }\nCOMMAND:           x\nPATTERN: \\npython\\nphp\nHOLD:\nCOMMAND:           s/^/\nSTART--&gt;/\nMATCHED REGEX REGISTERS\nregex[0] = 0-0 ''\nPATTERN: \\nSTART--&gt;\\npython\\nphp\nCOMMAND:           s/$/\n&lt;--END/\nMATCHED REGEX REGISTERS\nregex[0] = 20-20 ''\nPATTERN: \\nSTART--&gt;\\npython\\nphp\\n&lt;--END\nEND-OF-CYCLE:\n\nSTART--&gt;\npython\nphp\n&lt;--END\nINPUT:   'input.txt' line 8\nPATTERN: java\nCOMMAND:           /./ {\nCOMMAND:             H\nHOLD:    \\njava\nCOMMAND:             $! d\nEND-OF-CYCLE:\nINPUT:   'input.txt' line 9\nPATTERN: golang\nCOMMAND:             /./ {\nCOMMAND:               H\nHOLD:    \\njava\\ngolang\nCOMMAND:               $! d\nEND-OF-CYCLE:\nINPUT:   'input.txt' line 10\nPATTERN: rust\nCOMMAND:               /./ {\nCOMMAND:                 H\nHOLD:    \\njava\\ngolang\\nrust\nCOMMAND:                 $! d\nCOMMAND:               }\nCOMMAND:               x\nPATTERN: \\njava\\ngolang\\nrust\nHOLD:    rust\nCOMMAND:               s/^/\nSTART--&gt;/\nMATCHED REGEX REGISTERS\nregex[0] = 0-0 ''\nPATTERN: \\nSTART--&gt;\\njava\\ngolang\\nrust\nCOMMAND:               s/$/\n&lt;--END/\nMATCHED REGEX REGISTERS\nregex[0] = 26-26 ''\nPATTERN: \\nSTART--&gt;\\njava\\ngolang\\nrust\\n&lt;--END\nEND-OF-CYCLE:\n\nSTART--&gt;\njava\ngolang\nrust\n&lt;--END\n\n\n第13行, /./匹配非空行\n第14行, H指令, 将换行符+pattern space追加到 hold space\n第15行, 可以看到hold space的内容\n第16行, d 操作 ,然后17行直接 去下一次 cycle,后续 命令不再执行.\n第32行, input.txt 第4行是空行, 所以/./ 不匹配, 没有做{}里面的d操作, 则继续后面的指令 x,将hold space和pattern space 互换了.\n后面是s 替换操作. 最后 不带-n的默认 打印pattern space 操作.",
    "crumbs": [
      "bash",
      "sed"
    ]
  },
  {
    "objectID": "docs/devops/linux/bash/sed.html#option-参数",
    "href": "docs/devops/linux/bash/sed.html#option-参数",
    "title": "bash sed",
    "section": "2 OPTION 参数",
    "text": "2 OPTION 参数\n\n\n\n\n\n\n\nOPTION\nDescription\n\n\n\n\n-n\n 仅显示 script 处理后的结果\n\n\n-e\n 以指定的 script 来处理输入的文本文件,默认就有这个参数\n\n\n-f\n: 以指定的文件的内容来作为 script 来处理 input-file\n\n\n-E/-r\n 支持扩展正则 (推荐用-E 可移植性)  带-E与不带-E的区别 1. 不带的时候 那么{}()|+? 没有特别含义,就是它本身,如果想要变成特殊含义则前面加上\\2. 带上-E与之相反\n\n\n-i\n 直接修改 input-file 的内容\n\n\n-s\n 放到input-file章节说明\n\n\n--debug\n 显示 sed 的执行过程,低版本的sed可能没有\n\n\n\n\n example.txt -n -e -f -E/-r -i\n\n\nhello cat\nhello world\nhot dog\n\n\n\n不带-n带 -n\n\n\n下面这个,匹配则打印处理后的行(/hello/p的行为),然后不管匹配与否再打印处理后的行(不带-n的默认行为).\nsed '/hello/p' example.txt\n\n\n执行结果\n\nhello cat\nhello cat\nhello world\nhello world\nhot dog\n\n\n\n只打印匹配的行\nsed -n '/hello/p' example.txt\n\n\n执行结果\n\nhello cat\nhello world\n\n\n\n\n\n\n指定多个-e, 就是对读取的行,按顺序进行 script1,然后script2 操作\nsed -n -e '/hello/p' -e '/world/p' example.txt\n\n\n执行结果\n\nhello cat\nhello world\nhello world\n\n\n\n将 /hello/p 这样的 script 写到文件中去,执行如下命令\nsed -n -f script.sed example.txt\n\n\n|无特殊含义,就是它本身,所以没有找到匹配的行.\nsed  -n '/hello|world/p' example.txt\n这里的|表示特殊含义或 ,所以可以正确匹配.\nsed  -n -E '/hello|world/p' example.txt\n\n\nsed -n 's/cat/dog/g;p' example.txt\n# 直接修改源文件了, 注意这里就不能再加上;p了. 否则你文件里就重复行了.\nsed -i 's/cat/dog/g' example.txt\n\n==使用-i后面直接带上.bak 来修改文件的同时进行备份.==\n\n# 会先将example.txt 做个备份, 文件名是\nsed -i.bak 's/cat/dog/g' example.txt.bak\n# 所以 写-i 和其他 -E这种参数时要注意, 不要放在i的后面 , \n# 写成 -Ei而不是-iE 后者是做了备份了.E成了备份文件的后缀名\n\n\n\n\n\n\n关于-i的底层逻辑\n\n\n\n\n实际是创建了一个临时文件, 将输出写入到该临时文件而不是终端.\n等到文件读完,会将临时文件rename 为 我们 原本的文件名\n\n# 我们使用strace来跟踪我们的sed操作里与文件有关的系统调用\nstrace -e trace=file sed -i 's/cat/dog/g' example.txt\n\n\n执行结果\n\n...\n...\nopenat(AT_FDCWD, \"example.txt\", O_RDONLY)  = 3\nopenat(AT_FDCWD, \"./sedE5aURA\", O_RDWR|O_CREAT|O_EXCL, 0600) = 4\nrename(\"./sedE5aURA\", \"example.txt\")       = 0",
    "crumbs": [
      "bash",
      "sed"
    ]
  },
  {
    "objectID": "docs/devops/linux/bash/sed.html#input-file",
    "href": "docs/devops/linux/bash/sed.html#input-file",
    "title": "bash sed",
    "section": "3 input-file",
    "text": "3 input-file\n\n text.txt 指定多个文件 -s\n\n\ntomcat\nhello cat\ngoogle\n\n\nsed  -n '/cat/{p;=}' example.txt text.txt\n\n\n执行结果\n\nhello cat\n1\ntomcat\n4\nhello cat\n5\n\n\n看行号,我们可以知道sed是将2个文件当成一个文件来处理\n使用 -s 参数, 会将每个文件作为一个单独的来处理\n\n\n\nsed  -ns '/cat/{p;=}' example.txt text.txt\n\n\n执行结果\n\nhello cat\n1\ntomcat\n1\nhello cat\n2",
    "crumbs": [
      "bash",
      "sed"
    ]
  },
  {
    "objectID": "docs/devops/linux/bash/sed.html#script",
    "href": "docs/devops/linux/bash/sed.html#script",
    "title": "bash sed",
    "section": "4 script",
    "text": "4 script\n\n4.1 [addr] 匹配行\n\n example.txt 所有行: 指定行号 : 正则3 区间 取反 最后一行\n\n\nhello one\nhello two\ntree\nfour\nfive\nspace\nblank\nworld one\nxxx two\nyyy\nworld five\nzzz\n\n\n# 会打印所有行 这个时候 [addr] 可以说是空的.\nsed -n \"p\" example.txt\nsed -n \"s/hello/world/g\" example.txt\n\n\n# 匹配到第二行\nsed -n '2p' example.txt\n\n\n执行结果\n\nhello two\n\n\n\n# 包含hello的行\nsed -n '/hello/p' example.txt\n# 大写的I 表示忽略大小写, 如果写成 i ,是 行前插入的操作. 是X类别\nsed -n '/hello/Ip' example.txt\n\n\n\n行号指定区间,多行\n\n# 匹配到第2到4行\nsed -n '2,4p' example.txt\n# 第2行, 再加2行, 也就是2-4行, 一共3行\nsed -n '2,+2p' example.txt\n\n\n执行结果\n\nhello two\ntree\nfour\n\n\n正则区间 /pattern1/,/pattern2/\n\n\n匹配到pattern1的行开始到匹配到pattern2的行结束\n如果开始的行没有匹配到,那么就没有匹配到行\n而到哪一行为止呢? 稍微思考下, 可以得出这样的结论 :\n\n如果到哪行为止没有匹配到, 就意味着一直匹配到最后一行\n到哪行为止 有多行都能匹配到, 肯定是首先匹配的那一行.\n\n\n# 含有two的行到  含有five的行\nsed -n '/two/,/five/p' example.txt\n多个符合的区间, 就会都匹配上的\n\n\n执行结果\n\nhello two\ntree\nfour\nfive\nxxx two\nyyy\nworld five\n\n# 第一个区间匹配到了. 第二个区间只匹配到开始的行. 那么第二个区间就是匹配行到最后一行\nsed -n '/two/,/four/p' example.txt\n\n\n执行结果\n\nhello two\ntree\nfour\nxxx two\nyyy\nworld five\nzzz\n\n\n行号正则混合使用\n\n#/four/ 如果没匹配到行,那么从第 1 行一直匹配到最后,会都打印.\nsed -n '1,/four/p' example.txt\n#如果匹配到行号大于 后面的具体行数, 那么就只会显示 /four/ 匹配到的行\nsed -n '/four/,6p' example.txt\n\n\n# 排除1-2 行,其他行进行s操作\nsed -n '1,2!s/one/111/p' example.txt\n# 打印不保护hello的行\nsed -n '/hello/!p' example.txt\n\n\n# 打印最后一行\nsed -n '$p'  text.txt example.txt\n# 打印各自文件的最后一行.\nsed -ns '$p'  text.txt example.txt\n\n\n\n\n\n4.2 X 指令\n\n4.2.1 查 (p)\n\n\n\n\n\n\n\nX\nDescription\n\n\n\n\np\n 打印处理后的匹配行 (打印pattern space + 换行符)\n\n\n=\n 打印匹配行的行号 + 换行符\n\n\n\n\np\n\nseq 3|sed -n '2p'\n\n=\n\n# 显示匹配到的行的行号\nsed -n '/hello/=' example.txt\n\nseq -f \"line%g\" 1 3|sed '='\n\n\n执行结果\n\n1\nline1\n2\nline2\n3\nline3\n\n\n\n4.2.2 增 (a i r w)\n\n\n\n\n\n\n\nX\nDescription\n\n\n\n\na\n 行后追加\n\n\ni\n 行前追加\n\n\nr\n 外部文件读入, 行后追加\n\n\nw\n 匹配行写入外部文件\n\n\n\n\n# 在匹配到的hello 行下一行 ,添加 NIHAO 这样一行\n# a后面 空格 再跟上你要添加的内容\nsed -i '/hello/a NIHAO' example.txt\n# 匹配到的每一个行 后都添加一行 内容是hi\nsed -i '/hello/,/world/a hi'\n# 插入多行.\nsed -i '/hello/a\\\nhi\\\nhow are your' example.txt\n\n# 行前\nsed -i '/hello/i NIHAO' example.txt\n# 将new.txt 里的内容添加到 包含hello 的行后\nsed -i '/hello/r new.txt' example.txt\nsed -n '/hello/w new.txt' out.txt\n\n\n4.2.3 删 (d)\n\n\n\n\n\n\n\nX\nDescription\n\n\n\n\nd\n 删除 pattern space的内容,立刻开始下一次cycle,后续的命令不再执行且默认不带-n时的打印处理后的行(pattern space+换行符) 的行为也不会执行. 如果这个默认行为没有取消,那么你不带-n时每次d,都会打印一行空行了 \n\n\n\nseq -f \"line%g\" 1 3 | sed '2d;='\n\n\n执行结果\n\n1\nline1\n3\nline3\n\n# 删除包含hello的行到包含world的行, 有多个就执行删除多个区间\nsed '/hello/,/world/d' example.txt\n\n\n4.2.4 改 (s)\n\n\n\n\n\n\n\n\nX\nDescription\n\n\n\n\ns\n: 替换操作\n\n\n\n\n\n\nflags\nDescription\n\n\n\n\ni/I\n匹配时忽略大小写\n\n\n\n\nexample.txt例子反向引用 &与&\\n\n\n\nHEllo cat\nxx hello yyy hello\nhot dog HELLO\n\n\n#每一行的第一个 hello 替换为 world\nsed 's/hello/world/' example.txt\n# 全部hello替换为world\nsed 's/hello/world/g' example.txt \n#忽略大小写,全部替换 i/I 大写的I也是一个意思\nsed 's/hello/world/ig' example.txt \n# 将行内第 2 个匹配的 hello 到后面所有匹配到的 hello 替换为 world\nsed 's/hello/world/2g' example.txt\n\n\nsed 's/hello/world/2g' example.txt 执行结果\n\nHEllo cat\nxx hello yyy world\nhot dog HELLO\n\n# \\U 将匹配到的内容 转为大写 (\\u 是第一个字符大写)\nsed 's/hello/\\U&/g' example.txt\n# 将xx转为大写, yyy转为大写 \\E表示停止前面\\U 的行为,就是\\E后面的不会继续转大写了.\nsed -E 's/(xx)\\shello\\s(yyy)/\\U\\1\\E hello \\U\\2/g' example.txt\n# 同理 \\L 是将匹配到的内容 转为小写, \\l 是将第一个字符转小写\nsed -E 's/hello/\\L&/ig' example.txt\n\n\n\n\n\nregex\nDescription\n\n\n\n\n&\n正则表达式匹配到的所有内容\n\n\n\\n (n值为1-9)\n正则表达式里\\(\\)里匹配到的内容\n\n\n\n\n\n# 将两行的eat/EAT 改成==&gt; don't eat/EAT\n# & 表示/eat/正则匹配到的具体内容\nsed \"s/eat/don't &/i\" &lt;&lt;EOF\ncats eat fish\ndogs EAT fish\nEOF\n\n\n执行结果\n\ncats don't eat fish\ndogs don't EAT fish\n\n\n\n# \\S 非空白字符\n# 按顺序 第一个() 就是 \\1...\nsed -E \"s/(\\S+)\\s(eat)\\s(\\S+)/\\3 \\2 \\1/i\" &lt;&lt;EOF\ncats eat fish\ndogs EAT fish\nEOF\n\n\n执行结果\n\nfish eat cats\nfish EAT dogs\n\n\n\n\n\n\n4.2.5 n/N\n\n\n\n\n\n\n\nX\nDescription\n\n\n\n\nn\n如果没有使用参数-n, 则立刻打印处理后的行(pattern space+换行符),然后不管是否使用-n,都将pattern space 替换为下一行的内容,如果没有下一行了,则立刻结束,后续指令不操作.\n\n\nN\n追加换行符到pattern space,继续追加下一行的内容 ,如果没有下一行了,则立刻结束,后续指令不操作.\n\n\n\n\nnN\n\n\nseq 1 3 | sed  'n;p'\n\n\n执行结果\n\n1\n2\n2\n3\n\n\n\ndebug\n\nSED PROGRAM:\nn\np\nINPUT:   'STDIN' line 1\nPATTERN: 1\nCOMMAND: n\n1\nPATTERN: 2\nCOMMAND: p\n2\nEND-OF-CYCLE:\n2\nINPUT:   'STDIN' line 3\nPATTERN: 3\nCOMMAND: n\n3\nEND-OF-CYCLE:\n\n\n第6-7行,由于这里 不带-n,则立刻打印 pattern space,然后 将pattern space 替换为下一行\n第8行显示为替换后的 pattern space\n第9-10行 是p的操作, 打印了 pattern space\n第13行说明直接读取了文件的第3行, 第15行的n 操作 发现没有下一行了.立刻结束了. 不做后续的p操作.\n\n#  比如偶数行 做些操作\nseq 6 | sed -n 'n;p'\n# 匹配到的行后面第2行\nseq 7 |sed -n '/3/{n;n;p}' # 显示5\n\n\n# 将第3行和第3行 合成一行.\nsed  '2N;s/\\n/--/' example.txt\n\n\n执行结果\n\nHEllo cat\nxx hello yyy hello--hot dog HELLO\n\n\n\ndebug\n\nSED PROGRAM:\n2 N\ns/\\n/--/\nINPUT:   '2.txt' line 1\nPATTERN: HEllo cat\nCOMMAND: 2 N\nCOMMAND: s/\\n/--/\nPATTERN: HEllo cat\nEND-OF-CYCLE:\nHEllo cat\nINPUT:   '2.txt' line 2\nPATTERN: xx hello yyy hello\nCOMMAND: 2 N\nPATTERN: xx hello yyy hello\\nhot dog HELLO\nCOMMAND: s/\\n/--/\nMATCHED REGEX REGISTERS\nregex[0] = 18-19 '\n'\nPATTERN: xx hello yyy hello--hot dog HELLO\nEND-OF-CYCLE:\nxx hello yyy hello--hot dog HELLO\n\n\n\n\n\n\n4.2.6 ; 和 {;}\n;可以有多个\n{}里还可以有{}\n\n;{;}\n\n\n# = 表示打印匹配的行的行号\nsed -n  '/hello/=;p' &lt;&lt;EOF\nhello cat\nhot dog\nworld hello\nEOF\n\n\n执行结果\n\n1\nhello cat\nhot dog\n3\nworld hello\n\n/hello/=;p 对与匹配到hello的行执行=指令, p与前面的无关, 它会重新看该行是否匹配它自己的规则.\n\n\nsed -n  '/hello/{=;p}' &lt;&lt;EOF\nhello cat\nhot dog\nworld hello\nEOF\n\n\n执行结果\n\n1\nhello cat\n3\nworld hello\n\n/hello/{=;p} 对于匹配到hello的行 执行 =指令,再执行p指令. {}里的指令是一个整体\n# 多个操作 可以这样写 ,不用;号\nsed  '/hello/{\n/world/a  python\n=\n}' &lt;&lt;EOF\nhello xx\nhello world\ngolang\nEOF\n\n\n\n\n\n4.2.7 使用变量\npattern=\"he..o\"\n# 这样. pattern里的. 在下面还是表示 任意字符哦.\n# 使用双引号\nsed -n \"s/$pattern/world/g\" example.txt\n#或者 单引号\nsed -n 's/'$pattern'/world/g' example.txt",
    "crumbs": [
      "bash",
      "sed"
    ]
  },
  {
    "objectID": "docs/devops/linux/bash/sed.html#footnotes",
    "href": "docs/devops/linux/bash/sed.html#footnotes",
    "title": "bash sed",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nhttps://www.gnu.org/software/sed/manual/sed.html#Multiline-techniques↩︎\nhttps://www.gnu.org/software/sed/manual/sed.html#Other-Commands↩︎\nhttps://www.gnu.org/software/sed/manual/sed.html#Regular-Expressions-Overview↩︎",
    "crumbs": [
      "bash",
      "sed"
    ]
  },
  {
    "objectID": "docs/devops/linux/bash/example.html",
    "href": "docs/devops/linux/bash/example.html",
    "title": "bash 综合例子",
    "section": "",
    "text": "看无注释的配置文件\n\n# 过滤掉空行和注释, 这里以# 作为注释符号的例子\n# [:blank:] 表示 空格和tab\n# 1. 首先以空格或tab开头的 (0个或多个,0就表示可以不是以这个为开头)\n# 2. [^#[:blank:]] 反向字符集 ,表示接着的字符是 不能是# 空格和tab, 就是说匹配非(#空格tab)的字符\n#    过滤了空行, 过滤了 #开头的行, 过滤了 空格/tab+# 的行\nsed -n '/^[[:blank:]]*[^#[:blank:]]/p' my.cnf\n\n\n\n修改配置文件并做备份\n\n# 修改文件 my.cnf, 并做将源文件生成一个备份,文件名是my.cnf.bak\nsed -i.bak 's/hello/world/g' my.cnf\n\n\n\n统计英语单词次数\n\n# (网上随便找到的例子基本都不太严谨.)\n# 这里我排除了 各种符号. 比如标点符号. &lt;&gt; 等等\n# 会将 don't 和 xxx's 这种 看成一个单词. (具体看实际的需求)\n# \\L 表示都转成小写\nsed -nE \"s/[^a-zA-Z]*([a-zA-Z]+'[a-zA-Z]|[a-zA-Z]+)[^a-zA-Z]*/\\L\\1\\n/gp\" book.txt \\\n |sed '/^$/d' \\\n |sort \\\n |uniq -c \\\n |sort -n -r -t \" \" -k 1 \\\n |head -10\n\n\n\n处理空行空格\n\n\n\n#删除行首的空格和行尾的空格\nsed 's/^ *//;s/ *$//' example.txt\n\n# 制表符 tab 转为空格\nsed 's/\\t/  /g' example.txt\n\n# 删除空行\nsed  '/^$/d' example.txt\n\n\n\n指定行号,正则匹配,区间,非!,最后一行$\n\n# 打印第5行\nsed -n '5p' example.txt\n# 打印5-10行\nsed -n '5,10p' example.txt\n# 删除 第2-4行, 7-10行\nseq 1 15 |sed '2,4d;7,+3d'\n# 打印不包含hello的行, I表示 忽略大小写, 要放到!的前面\nsed -En '/hello/I!p' example.txt\n# 首行不打印\nsed -n '1!p' example.txt\n# 打印最后一行\nsed -n '$p' example.txt\n\n# 匹配包含python的行到 包含java的行\n# macos和linux下的都会匹配上,2个区间\nsed -n '/python/,/java/p' &lt;&lt;EOF\nmacos\n    python url1\n    golang url2\n    java url3\nlinux\n    python url4\n    golang  url5\n    java url6\nEOF\n\n# 只打印macos下的 ,可以这样\nsed -n '/^macos/,/^linux/{/python/,/java/p}' &lt;&lt;EOF\nmacos\n    python url1\n    golang url2\n    java url3\nlinux\n    python url4\n    golang  url5\n    java url6\nEOF\n\n# 将第2行和第3行合成一行\nsed  '2N;s/\\n/ /' example.txt\n\n\n整理中...\n\n#将 文件里所有的换行符去掉. 这个命令不支持mac\n# :label 定位标签, 后面的b label 表示跳转到标签label\n# N 表示读取下一行, 然后追加到当前行\n# s/\\n//g 表示将所有的换行符替换为空\nsed -i ':label ;N;s/\\n//g;b label' b.txt\n# $!ba 表示如果还没有到文件末尾,就跳转到标签label\n# 这里的意思是,如果文件还有内容,就继续执行, 直到文件内容为空\nsed -i -e ':a;N;$!ba;s/\\n//g' b.txt\n\n# mac\nsed -n 'H;${x;s/\\n//g;p;}' b.txt\n\n\n\n批量重命名\n\n# 将后缀名 md改成qmd\nfor name in `ls *.md`; do  mv $name  ${name%.md}.qmd; done",
    "crumbs": [
      "bash",
      "综合例子"
    ]
  },
  {
    "objectID": "docs/devops/linux/bash/example.html#实用脚本",
    "href": "docs/devops/linux/bash/example.html#实用脚本",
    "title": "bash 综合例子",
    "section": "",
    "text": "看无注释的配置文件\n\n# 过滤掉空行和注释, 这里以# 作为注释符号的例子\n# [:blank:] 表示 空格和tab\n# 1. 首先以空格或tab开头的 (0个或多个,0就表示可以不是以这个为开头)\n# 2. [^#[:blank:]] 反向字符集 ,表示接着的字符是 不能是# 空格和tab, 就是说匹配非(#空格tab)的字符\n#    过滤了空行, 过滤了 #开头的行, 过滤了 空格/tab+# 的行\nsed -n '/^[[:blank:]]*[^#[:blank:]]/p' my.cnf\n\n\n\n修改配置文件并做备份\n\n# 修改文件 my.cnf, 并做将源文件生成一个备份,文件名是my.cnf.bak\nsed -i.bak 's/hello/world/g' my.cnf\n\n\n\n统计英语单词次数\n\n# (网上随便找到的例子基本都不太严谨.)\n# 这里我排除了 各种符号. 比如标点符号. &lt;&gt; 等等\n# 会将 don't 和 xxx's 这种 看成一个单词. (具体看实际的需求)\n# \\L 表示都转成小写\nsed -nE \"s/[^a-zA-Z]*([a-zA-Z]+'[a-zA-Z]|[a-zA-Z]+)[^a-zA-Z]*/\\L\\1\\n/gp\" book.txt \\\n |sed '/^$/d' \\\n |sort \\\n |uniq -c \\\n |sort -n -r -t \" \" -k 1 \\\n |head -10\n\n\n\n处理空行空格\n\n\n\n#删除行首的空格和行尾的空格\nsed 's/^ *//;s/ *$//' example.txt\n\n# 制表符 tab 转为空格\nsed 's/\\t/  /g' example.txt\n\n# 删除空行\nsed  '/^$/d' example.txt\n\n\n\n指定行号,正则匹配,区间,非!,最后一行$\n\n# 打印第5行\nsed -n '5p' example.txt\n# 打印5-10行\nsed -n '5,10p' example.txt\n# 删除 第2-4行, 7-10行\nseq 1 15 |sed '2,4d;7,+3d'\n# 打印不包含hello的行, I表示 忽略大小写, 要放到!的前面\nsed -En '/hello/I!p' example.txt\n# 首行不打印\nsed -n '1!p' example.txt\n# 打印最后一行\nsed -n '$p' example.txt\n\n# 匹配包含python的行到 包含java的行\n# macos和linux下的都会匹配上,2个区间\nsed -n '/python/,/java/p' &lt;&lt;EOF\nmacos\n    python url1\n    golang url2\n    java url3\nlinux\n    python url4\n    golang  url5\n    java url6\nEOF\n\n# 只打印macos下的 ,可以这样\nsed -n '/^macos/,/^linux/{/python/,/java/p}' &lt;&lt;EOF\nmacos\n    python url1\n    golang url2\n    java url3\nlinux\n    python url4\n    golang  url5\n    java url6\nEOF\n\n# 将第2行和第3行合成一行\nsed  '2N;s/\\n/ /' example.txt\n\n\n整理中...\n\n#将 文件里所有的换行符去掉. 这个命令不支持mac\n# :label 定位标签, 后面的b label 表示跳转到标签label\n# N 表示读取下一行, 然后追加到当前行\n# s/\\n//g 表示将所有的换行符替换为空\nsed -i ':label ;N;s/\\n//g;b label' b.txt\n# $!ba 表示如果还没有到文件末尾,就跳转到标签label\n# 这里的意思是,如果文件还有内容,就继续执行, 直到文件内容为空\nsed -i -e ':a;N;$!ba;s/\\n//g' b.txt\n\n# mac\nsed -n 'H;${x;s/\\n//g;p;}' b.txt\n\n\n\n批量重命名\n\n# 将后缀名 md改成qmd\nfor name in `ls *.md`; do  mv $name  ${name%.md}.qmd; done",
    "crumbs": [
      "bash",
      "综合例子"
    ]
  },
  {
    "objectID": "docs/devops/linux/bash/example.html#python-conda-一键安装脚本",
    "href": "docs/devops/linux/bash/example.html#python-conda-一键安装脚本",
    "title": "bash 综合例子",
    "section": "2 python conda 一键安装脚本",
    "text": "2 python conda 一键安装脚本\n\n\n\n\n\n\nCaution\n\n\n\n这里只支持ubuntu和mac, 我只暂时测试了 ubuntu 下的安装,后续会再优化测试.\n\n\nos=$(uname -s|tr '[:upper:]' '[:lower:]')\n\ninstall_python(){\n    #/Linux installers/,/Installing/ 表示找 这2个之间的文本\n    if [ $os == \"linux\" ];then\n        os_begin=\"Linux installers\"\n        os_end=\"Installing\"\n    else\n        os_begin=\"macOS installers\"\n        os_end=\"Linux installers\"\n    fi\n    pyversion=($(curl -Ss https://docs.conda.io/en/latest/miniconda.html | sed -n  '/'\"${os_begin}\"'/,/'\"${os_end}\"'/s#.*&lt;td&gt;Python \\([0-9.]*\\)&lt;/td&gt;#\\1#p'))\n    echo \"选择你的python版本\"\n    for j in ${!pyversion[@]}\n    do\n        echo $(expr $j + 1): ${pyversion[$j]}\n    done\n    echo -n \"请输入编号:\"\n    read python_version_no\n    # 将. 转义\n    python_version=${pyversion[$(expr $python_version_no-1)]/./\\\\.}\n    python_next_version=${pyversion[$python_version_no]/./\\\\.}\n    between_begin=\"Python \"${python_version}\n    between_end=\"Python \"${python_next_version}\n    if [ -z ${python_next_version} ];then\n        between_end=\"Installing\"\n    fi\n    # 使用//,//{//,//} 来范围内找范围\n    cpuverurl=($(curl -Ss https://docs.conda.io/en/latest/miniconda.html | sed -n '/'\"${os_begin}\"'/,/'\"${os_end}\"'/{/'\"${between_begin}\"'/,/'\"${between_end}\"'/s/.* class=\"reference external\" href=\"\\(.*Linux-\\(.*\\)\\.sh\\)\"&gt;.*/\\2 \\1/p}'))\n\n    declare conda_url\n    declare cpu_ver\n\n    echo \"选择你的cpu架构\"\n    for j in ${!cpuverurl[@]}\n    do\n        if [ $(($j%2)) == 0 ];then\n            i=$(expr $j / 2 + 1)\n            echo $i: ${cpuverurl[$j]}\n            cpu_ver[$i]=${cpuverurl[$j]}\n            conda_url[$i]=${cpuverurl[$(expr $j + 1)]}\n        fi\n    done\n    echo -n \"输入编号:\"\n    read chosen_cpu\n    echo \"你选择的是:\" ${cpu_ver[${chosen_cpu}]}\n    miniconda_url=${conda_url[${chosen_cpu}]}\n    execfile=${conda_url[${chosen_cpu}]##*/}\n    wget ${miniconda_url}\n    chmod +x $execfile\n    # -p 安装的目录.\n    bash $execfile -b -p $HOME/miniconda\n    $HOME/miniconda/bin/conda init zsh\n    . ~/.zshrc\n    # 如果你在bash 环境下 安装的. 想要用zsh\n    # conda init zsh \n    # 在zsh 环境下安装 默认就会修改.zshrc的. \n}\ninstall_python",
    "crumbs": [
      "bash",
      "综合例子"
    ]
  },
  {
    "objectID": "docs/devops/linux/bash/example.html#go-一键安装脚本",
    "href": "docs/devops/linux/bash/example.html#go-一键安装脚本",
    "title": "bash 综合例子",
    "section": "3 go 一键安装脚本",
    "text": "3 go 一键安装脚本\nos=$(uname -s|tr '[:upper:]' '[:lower:]')\ninstall_go(){\n    echo  \"暂时只写了 amd64版本的下载.\"\n    echo \" 输入你要的go版本\"\n    curl -Ss https://golang.google.cn/dl/ | sed -n 's/.*class=\"toggle\" id=\"go\\([.0-9]*\\)\"&gt;/\\1/p'| head -20\n    read go_version\n    wget https://golang.google.cn/dl/go${go_version}.${os}-amd64.tar.gz\n    # 这里我直接删除了旧的, 后续再完善 , 可以用 软链接之类的.\n    rm -rf /usr/local/go && tar -C /usr/local -xzf go${go_version}.${os}-amd64.tar.gz\n    echo 'export PATH=$PATH:/usr/local/go/bin' &gt;&gt; ~/.zshrc\n    . ~/.zshrc\n    go env -w GOPROXY=https://goproxy.cn,http://mirrors.aliyun.com/goproxy/,https://goproxy.io,direct\n}\ninstall_go",
    "crumbs": [
      "bash",
      "综合例子"
    ]
  },
  {
    "objectID": "docs/devops/linux/bash/quick-start.html",
    "href": "docs/devops/linux/bash/quick-start.html",
    "title": "linux 基础命令",
    "section": "",
    "text": "Warning\n\n\n\n待整理…",
    "crumbs": [
      "bash",
      "基础"
    ]
  },
  {
    "objectID": "docs/devops/linux/bash/quick-start.html#常用命令",
    "href": "docs/devops/linux/bash/quick-start.html#常用命令",
    "title": "linux 基础命令",
    "section": "1 常用命令",
    "text": "1 常用命令\n\n帮助cdmkdirlscatdaterenamecphistory查看用户\n\n\n\n\n几个都试试\n\nman sed\nhelp cd\ncd --help\ncd -h\n\n\n\ncd   # 直接什么也不加 会cd 到 家目录\ncd ~ # 同上\ncd - # 返回上一次的目录\n\n\n关于cd建议设置一些这样的别名\n\ncat &gt;&gt; /etc/profile &lt;&lt;EOF\nalias ..=\"cd ..\"\nalias ...=\"cd ../..\"\nEOF\n\n\n\n# -v 显示创建信息\n# -p 多级目录可以自动创建\nmkdir -pv a/b/c\nmkdir -pv a/{a1,a2} #(1)\n    a\n    ├── a1\n    └── a2\n\n\n#如何只列出目录\nls -p #可以给文件夹后面加上/,其实实际上就是有/\nls -d */ #就可以说明 实际上有/ ,这样就只列出目录了\nls -p |egrep \"/$\"\n\n#给文件名加上引号\nls -Q\n#删除目录\nls -Qd */|xargs rm -fr\n\n# 查看文件的inode信息\nls -i\n# 查看文件的读取时间,默认是修改时间\nls --time=atime\nll -t # 按修改时间排序, 降序\nll -rt #反着.  新的在最后.\n\n#使用ll的话 前面多了一行 total\n# 比如在目录中是备份文件,  这里的命令便是删除旧的10个备份\nls -rt | head -10 |xargs rm\n设置显示时间的格式\n\nlinuxmac\n\n\nexport TIME_STYLE='+%Y-%m-%d %H:%M:%S'\nls -l\n    -rw-r--r--  1 root root       140 2023-11-02 04:36:08 1.txt\n\n\ngls --full-time\ngls --time-style='+%Y-%m-%d %H:%M:%S' -l\n\n\n\n\n\n# 显示行号\ncat -n a.txt\n\ncat &gt; 2.txt &lt;&lt;EOF\nhello world\nEOF\n\ncat &gt;&gt; 2.txt &lt;&lt;EOF\nhello shell\nEOF\n\n# 2.txt 的内容 加上  echo hello python 命令显示的内容\ncat 2.txt &lt;(echo hello python)\n# 结果输出\n    hello world\n    hello shell\n    hello python\n# 重定向到3.txt\ncat &gt;3.txt  2.txt &lt;(echo hello python)\n\ncat &gt;3.txt 2.txt &lt;(cat &lt;&lt;EOF\ngo to hell\ngood night\nEOF)\necho 111 &gt; 1.txt\ncat 1.txt &lt;(cat 2.txt &lt;(cat  &lt;&lt;EOF\nxyz\nabc\nEOF\n))\n\n\n# 时间戳\ndate +%s\n# 一天前的时间戳\ndate -d \"1 day ago\" +%s\n\ndate +\"%Y/%m/%d %H:%M:%S\"\n\n\n# 没有这个命令的话,需要安装\napt install rename\n# 如果后缀名匹配到, 也会修改\n# 不同的linux版本 可能使用的方式不一样\nrename txt mp3 `ls` #把文件名里的txt替换为mp3\nrename txt mp3 *\n# 这个是ubuntu的 与sed 一个德行..\nrename \"s/txt/mp3/g\" *\n\n\n\n\n\n\n\n\nWarning\n\n\n\n\n实际上cp默认是会覆盖的，出现你这种情况是因为cp被alias成cp -i了，可以通过alias命令查看。\n\\cp则是告诉shell不要去查alias，直接执行原本的cp\n\n\n\n# 这个命令来查看一下\nalias\n# -r 递归目录 -p 保持文件和目录属性不变\n# 将 ../a/b 目录下的所有文件和目录复制到 当前目录\ncp -rp ../a/b/. ./\n\n\nhistory -c  # 清空history\nhistory -a  # 表示把当前session的history立即写入到history文件里去 ~/.bash_history\n#估计原来是过一段时间什么的 才写入文件\n#查看保存记录的文件\necho $HISTFILE\n\n#history配置\nvim /etc/profile\n\n# 空格+命令,不会写入到history中. 防止有人用方向键不小心 使用history 里的rm命令 误删除等等\necho \"export HISTCONTROL=ignorespace\" &gt;&gt; ~/.zshrc\n\n\nw\n# 简洁\nusers\n# 最后登录的用户情况\nlast\n\n\n\n\n关机与重启alias查找 findddseqsort,tactarEOF\n\n\nhalt\n#或者init 0 也是关机\nshutdown -h now # h=halt\n\n### 重启\nreboot\ninit 6 #也是重启\nshutdown -r now #重启 r=reboot\n\n\nvim /etc/profile\nalias cls='clear'\n\n#所有用户永久生效\nvim /etc/bashrc\n#当前用户生效\nvim ~/.bashrc\n#设置的别名可以使用 which 来找\n\n\nwhich cp\nwhereis rsync\nwhereis -b rsync\n#查找更多有关这个字符串在哪里有的\nlocate cp\nfind /tmp -type f -name '*.log' -mtime +7\n\n\n\n生成空文件\n\ndd if=/dev/zero of=test bs=10M count=1\n\n复制文件内容到另外一个文件\n\ndd if=abc.jpg of=test conv=notrunc\n\n跳过复制源多少字节\n\n# 跳过test,jpg的 10m内容, 后面的内容复制到my.mp4\ndd if=test.jpg of=my.mp4 bs=10M skip=1\n\n跳过输出的目标文件的多少字节\n\n# 如果of指定的文件是不存在的,那么也会在文件前面写入空的10m 大小的数据\n# 就是从指定文件的10M 大小位置开始写入if指定的文件\ndd if=a.mp4  of=testbak.jpg  bs=10M seek=1\n\n\n# 默认以回车符 为分隔符 输出 1 2 3 4 5\nseq 1 5\nseq 1 2 5 #中间的2是间隔 这里打出1 3 5\n# -s 指定分隔符 这里是空格\nseq -s \" \" 1 5\n\n\n-w 补零\n\n# 根据更宽的那个来补足其他\nseq -w 5 11\n\n\n\n执行结果\n\n05\n06\n07\n08\n09\n10\n11\n\n\n\n-f 指定格式输出数字\n\n# %g 默认\n# %2g表示 宽度是2位, 不够就补空格\nseq -f \"%2g\" 1 3\n\n\n\n执行结果\n\n1\n2\n3\n\n# 0表示宽度不足的话,补零,而不是空格\nseq -f \"%02g\" 1 3\n\n\n执行结果\n\n01\n02\n03\n\nseq -f \"file%02g\" 1 3\nfile01\nfile02\nfile03\n\n\nseq 10|sort -rn\n# 倒序打出\nseq 10|tac\n\n\n\n\n打包\n\n# --exclude 排除\ntar -zcvf my-web.tar --exclude=web/.git --exclude=web/node_modules web/\n\n\n\n解包\n\ntar -zxvf my-web.tar\n# tar xf helm-v3.12.2-linux-amd64.tar.gz 解压后 的文件结果是这样的\nlinux-amd64/\n├── helm\n├── LICENSE\n└── README.md\n# -C 指定解压到的目录\n# --strip-components=1 表示 剥离路径一级, 因为这里我们只有  linux-amd64/ 这样一级目录\n# 如果你有2级就 写 --strip-components=2\n# --strip-components=1  后面 要写上 tar包里的 你要解压的文件路径 linux-amd64/helm\n# 结果就是将helm 可执行文件 解压到 /usr/local/bin/\ntar -zxvf helm-v3.12.2-linux-amd64.tar.gz  -C /usr/local/bin/ --strip-components=1 linux-amd64/helm\n\n\n\n命令接收方 &lt;&lt;EOF\nyour content\nEOF\n\ncat &lt;&lt;EOF\nhello\nworld\nEOF\n\nsed -n '/hello/p' &lt;&lt;EOF\nhello\nworld\nEOF\n\n\n-EOF 没有效果...\n\ncat &gt;tmp.txt&lt;&lt;-EOF\n    hello world\n    cat dog\nEOF\n\n\n\n\n\n\n\n关于EOF一个难以察觉的错误\n\n\n\ncat &gt; abc.txt &lt;&lt;EOF\nabc\nEOF \n\ncat &gt; 2.txt &lt;&lt;EOF\n222\nEOF\n\n如果在第三行的EOF后面我们多加了一个空格,其他EOF后都没有\n上面的程序运行的结果是\n\n\n\n最后abc.txt里的内容\n\nabc\nEOF\n\ncat &gt; 2.txt &lt;&lt;EOF\n222\n\n\n\n\n\n\n\nkillwatchtree任务前后台命令bg fg ctrl+z\n\n\nkillall -0 nginx\necho $? # 0 表示 进程存在, 非0 表示不存在\nkillall -s 0 nginx # 同上\n\n\n# 每隔1s 查看一次\nwatch -n 1 tail /var/log/syslog\n\n\n# -I 忽略文件 文件夹\n# -L 2 显示层级\ntree -L 2 -I node_modules\n\n\n# 比如你正在vim 编辑一个文件\n#按下 该按键，则会将当前执行的进程暂停，放到后台,这个时候你可以做其他事情了\nctrl+z \njobs # 查看当前放到后台的任务 1 这种就是任务的编号\n    # suspended 可以知道后台任务的状态\n    [1]  + suspended  vim my.md\nsleep 600 & #直接一个后台的任务\nsleep 500\nctrl+z # 将 sleep 500 这个任务暂停放到后台\njobs \n    [1]  + suspended  vim my.md\n    [2]    running    sleep 600  # 可以看到running的状态的任务\n    [3]  - suspended  sleep 500\n# fg %编号 或 直接 %编号 将后台暂停的任务重新放回前台运行 \nfg %1  \nfg # 这样会直接将编号1的任务 放回前台运行\nbg %3 # 表示将后台暂停的任务 变成在后台执行",
    "crumbs": [
      "bash",
      "基础"
    ]
  },
  {
    "objectID": "docs/devops/linux/bash/quick-start.html#磁盘",
    "href": "docs/devops/linux/bash/quick-start.html#磁盘",
    "title": "linux 基础命令",
    "section": "2 磁盘",
    "text": "2 磁盘\ndu -h -d 1 dir  #会显示dir目录里的子目录 一层\ndu -h -d 0 dir  #只会显示dir 的大小",
    "crumbs": [
      "bash",
      "基础"
    ]
  },
  {
    "objectID": "docs/devops/linux/bash/quick-start.html#网络命令",
    "href": "docs/devops/linux/bash/quick-start.html#网络命令",
    "title": "linux 基础命令",
    "section": "3 网络命令",
    "text": "3 网络命令\n\nnccurlss netstatlsofwget\n\n\n\n\n\n# 指定CA 证书 或 自签名证书 ,这个需要你配置 /etc/hosts\ncurl --cacert server.crt https://example1.com/\n#  无需配置 /etc/hosts, 直接指定dns\ncurl --cacert server.crt --resolve example1.com:443:192.168.1.104  https://example1.com/\n\n\nss -tnl\n\n\nlsof -i:8080\n# 通过pid 找文件位置\nlsof -p pid\n\n\n# -O 保存为指定的文件名\n# -q quiet\nwget https://mirrors.163.com/.help/sources.list.jammy -qO /etc/apt/sources.list\n# -c 断点续传\nwget -c url",
    "crumbs": [
      "bash",
      "基础"
    ]
  },
  {
    "objectID": "docs/devops/cicd/drone.html",
    "href": "docs/devops/cicd/drone.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "Warning\n\n\n\ntodo…",
    "crumbs": [
      "drone"
    ]
  },
  {
    "objectID": "docs/devops/cicd/drone.html#provider-gogs",
    "href": "docs/devops/cicd/drone.html#provider-gogs",
    "title": "斯巴拉稀",
    "section": "1 provider gogs",
    "text": "1 provider gogs\n你的git服务 是gogs的 情况.\n\nDRONE_AGENTS_ENABLED as true if you want to run server and agent in the same container(or 服务器). 但是https://docs.drone.io/server/reference/ 里 根本没有这个配置. 然后又在https://docs.drone.io/server/provider/gogs/ Start the Server 步骤里能看到…\n\nServer负责提供web管理页面显示执行情况, Runner是真正执行持续部署操作的服务, 不同的情况 ,就需要安装不同的runner, 比如你使用docker发布,就安装docker的runner\n\n\n\n\n\n\nNote\n\n\n\nWe strongly recommend using postgres instead of mysql. The system has been optimized for features not found in mysql. 官方相比mysql 更推荐使用postgres. 当然你可以用 sqlite DRONE_USER_CREATE 里设置的username ,你应该是在gogs里有的. username:root,machine:false,admin:true 因为我们会用gogs的账户登录,这里设置我们用gogs登录的账户root ,它为admin\n\n\n\n\n\n\n\n\nWarning\n\n\n\n我当前发现一个问题,就是你登录后. 然后 docker compose down 再重新up, 然后用gogs 刚刚登录成功的用户无法登录了. 我在gogs重新创建了一个用户,可以登录… 暂时这样记录一下\n\n\nhttps://github.com/drone-runners/drone-runner-docker 看版本, 用 :1 会拉取 1的最新版.\n\n\ndocker-compose.yaml\n\nversion: \"3\"\nvolumes:\n    drone-data:\nservices:\n  drone-server: # 服务端\n    image: drone/drone:2\n    container_name: drone-server\n    restart: always\n    environment:\n      DRONE_AGENTS_ENABLED: \"true\"\n      DRONE_GOGS_SERVER: \"http://192.168.1.105:10880/\"\n      DRONE_RPC_SECRET: \"00e8790ebd7e353bc75204f736207ece\"  #openssl rand -hex 16 生成\n      DRONE_SERVER_HOST: \"192.168.1.105:8084\"\n      DRONE_SERVER_PROTO: \"http\"\n      DRONE_USER_CREATE: \"username:root,machine:false,admin:true\"\n\n      # DRONE_DATABASE_DRIVER: mysql\n      # DRONE_DATABASE_DATASOURCE: \"root:password@tcp(1.2.3.4:3306)/drone?parseTime=true&loc=Local\"\n    ports:\n      - \"8084:80\"\n      - \"8443:443\"\n    volumes:\n      - drone-data:/data\n  drone-runner:\n    image: drone/drone-runner-docker:1\n    container_name: drone-runner\n    restart: always\n    environment:\n      DRONE_RPC_PROTO: \"http\"\n      DRONE_RPC_HOST: \"192.168.1.105:8084\"\n      DRONE_RPC_SECRET: \"00e8790ebd7e353bc75204f736207ece\"\n      DRONE_RUNNER_CAPACITY: \"2\"\n      DRONE_RUNNER_NAME: \"my-runner\"\n    ports:\n      - \"8300:3000\"\n    depends_on:\n      - drone-server\n    volumes:\n      - /var/run/docker.sock:/var/run/docker.sock\n      - /etc/docker:/etc/docker\n\n浏览器打开8084端口 使用您的Gogs用户名和密码登录 (root/root) 下一步 不用管 直接 submit 可以看到我们gogs 你gogs登录的用户在gogs里创建的2个 仓库. 如果没有, 点击sync 同步,比如gogs那边刚刚用仓库转移所有权给了登录用户.",
    "crumbs": [
      "drone"
    ]
  },
  {
    "objectID": "docs/devops/cicd/drone.html#provider-gitea",
    "href": "docs/devops/cicd/drone.html#provider-gitea",
    "title": "斯巴拉稀",
    "section": "2 provider gitea",
    "text": "2 provider gitea\nversion: \"3\"\nvolumes:\n    drone-data:\nservices:\n  drone-server:\n    image: drone/drone:2\n    container_name: drone-server\n    restart: always\n    environment:\n      DRONE_AGENTS_ENABLED: \"true\"\n      DRONE_GITEA_SERVER: \"http://192.168.1.105:10880/\"\n      DRONE_RPC_SECRET: \"00e8790ebd7e353bc75204f736207ece\"  #openssl rand -hex 16 生成\n      DRONE_GITEA_CLIENT_ID: \"2d14bdbb-28e1-4e67-9c36-32ef6bc6edf4\"\n      DRONE_GITEA_CLIENT_SECRET: \"gto_6bdgzvdgstzzucn4y2is4oi7wi6a7oyjg553yu5fcvasg4zozeja\"\n      DRONE_SERVER_HOST: \"192.168.1.105:8084\"\n      DRONE_SERVER_PROTO: \"http\"\n      DRONE_USER_CREATE: \"username:root,machine:false,admin:true\"\n    ports:\n      - \"8084:80\"\n      - \"8443:443\"\n    volumes:\n      - drone-data:/data\n  drone-runner:\n    image: drone/drone-runner-docker:1\n    container_name: drone-runner\n    restart: always\n    environment:\n      DRONE_RPC_PROTO: \"http\"\n      DRONE_RPC_HOST: \"192.168.1.105:8084\"\n      DRONE_RPC_SECRET: \"00e8790ebd7e353bc75204f736207ece\"\n      DRONE_RUNNER_CAPACITY: \"2\"\n      DRONE_RUNNER_NAME: \"my-runner\"\n    ports:\n      - \"8300:3000\"\n    depends_on:\n      - drone-server\n    volumes:\n      - /var/run/docker.sock:/var/run/docker.sock\n      - /etc/docker:/etc/docker\nhttps://docs.gitea.com/administration/config-cheat-sheet?_highlight=allowed_host_list#webhook-webhook\n\n\n\n\n\n\n一个错误\n\n\n\nDelivery: Post “http://192.168.1.105:8084/hook”: dial tcp 192.168.1.105:8084: webhook can only call allowed HTTP servers (check your webhook.ALLOWED_HOST_LIST setting), deny ‘192.168.1.105(192.168.1.105:8084)’\n\n\ndocker volume ls/inspect 找到目录\n修改app.ini\n添加\n[webhook]\nALLOWED_HOST_LIST=private,*\n# 或? 我怎么第一次弄不行.. 可以再试试...  好像也行了.\nALLOWED_HOST_LIST=192.168.1.105\n\ndocker compose restart",
    "crumbs": [
      "drone"
    ]
  },
  {
    "objectID": "docs/devops/cicd/drone.html#使用",
    "href": "docs/devops/cicd/drone.html#使用",
    "title": "斯巴拉稀",
    "section": "3 使用",
    "text": "3 使用\ndrone页面 点击一个仓库–&gt; settings–&gt; active Repository, 然后勾选trusted\n然后我们去gogs 页面看 对应仓库名-仓库设置-管理Web钩子 可以看到创建了一个hook.\n\n现在我们提交代码 增加 .drone.yml (这个文件名可以在drone页面进行修改.)\n\n\n\n.drone.yml\n\nkind: pipeline\ntype: docker\nname: 6o6-web-publish\n\nenvironment:\n  GOOS: linux\n  GOARCH: amd64\n\nsteps:\n  - name: build # git clone 仓库,然脏构建镜像并推送\n    image: plugins/docker\n    volumes:\n      - name: hosts\n        path: /etc/hosts # hb.6o6.com 这个是本地域名,需要挂载hosts\n      - name: docker-ca\n        path: /etc/docker  # 登录 私有镜像仓库  需要证书.\n      - name: docker-sock\n        path: /var/run/docker.sock\n    settings:\n      username: admin\n      password:\n        from_secret: harbor_password # drone页面里对应仓库 settings-&gt;secrets-&gt;创建这个名字的,密码是harbor的hb123\n      repo: hb.6o6.com/6o6/6o6-web\n      registry: hb.6o6.com\n      tags:\n        - v1.1\n  - name: ssh commands # 启动一个容器去ssh连接服务器 ,然后拉取镜像启动容器\n    image: appleboy/drone-ssh\n    settings:\n      host: 192.168.1.105\n      username: root\n      password:\n        from_secret: ssh_password # root ssh 连接192.168.1.105时 用的密码\n      port: 22  # 2340 是映射到主机的端口.. 这里还是22\n      script:\n        #拉取镜像并重启 注意--需要提前在目标主机完成docker login\n        - if [ $(docker ps -a | grep 6o6-web | wc -l) -ge 1 ];then docker stop 6o6-web && docker rm 6o6-web; fi\n        - docker pull hb.6o6.com/6o6/6o6-web:v1.1\n        - export BACKEND_HOST=http://192.168.1.105:8082/\n        - docker run --name 6o6-web --restart=always -d -p8081:80 -e BACKEND_HOST=$BACKEND_HOST hb.6o6.com/6o6/6o6-web:v1.1\nvolumes:\n  - name: hosts\n    host:\n      path: /etc/hosts\n  - name: docker-ca\n    host:\n      path: /etc/docker\n  - name: docker-sock\n    host:\n      path: /var/run/docker.sock\n\ngit add . \ngit ci -m \"first build\"\ngit push\n# 推送后, 我们在gogs上 管理web hook 那里看到推送记录.\n# 触发了 web hook, 会去请求 http://192.168.1.105:8084/hook\n# 就会在 drone 所在服务器 做一些操作了. 根据.drone.yml里的内容\n\n\n\n\n\n\nCaution\n\n\n\n需要在gogs里配置 白名单, 否则web hook 失败\n\n\ndocker volume inspect gogs_gogs-data\nvim /var/lib/docker/volumes/gogs_gogs-data/_data/gogs/conf/app.ini\n[security] 下\nLOCAL_NETWORK_ALLOWLIST = 192.168.1.105 # 添加 drone所在服务器.\n\n\n重启gogs 容器\n再 push 看看 看到ok的\n然后去 drone 页面看 ,构建ok的话,  \n我们就可以去访问 启动的容器web服务 8081 端口\n\n\n\n\n\n\nCaution\n\n\n\n使用gogs provider, 登录drone后, 退出再等,就报错.. 提示没有权限",
    "crumbs": [
      "drone"
    ]
  },
  {
    "objectID": "docs/devops/cicd/github-action.html",
    "href": "docs/devops/cicd/github-action.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "Caution\n\n\n\ntodo…",
    "crumbs": [
      "github-action"
    ]
  },
  {
    "objectID": "docs/devops/cicd/github-action.html#github-action",
    "href": "docs/devops/cicd/github-action.html#github-action",
    "title": "斯巴拉稀",
    "section": "1 github action",
    "text": "1 github action\ngithub action github action\n以hugo 为例 正常我们的发布流程可能是这样 1. build 本地代码 生成静态文件 2. 上传到服务器 (比如scp操作) 3. 域名配置 比如nginx\ngithub action 就是启动一个小的虚拟机,发现你push后,就做某些操作 ,比如build 和scp 的操作\n# 1. 当前git仓库中 创建.github/workflows/ 目录\nmkdir -p .github/workflows/\ntouch .github/workflows/learn-github-actions.yml\n\n\nlearn-github-actions.yml\n\nname: learn-github-actions\nrun-name: ${{ github.actor }} is learning GitHub Actions\non: [push] # 当有push 推送时 会触发我们的job\njobs:\n  check-bats-version: # 这个你你的任务的名字, 随便起, 当然我们起一个能表明任务的名字..\n   # 将作业配置为在最新版本的 Ubuntu Linux 运行器上运行。 \n   # 这意味着该作业将在 GitHub 托管的新虚拟机上执行\n    runs-on: ubuntu-latest\n    steps:\n      #  uses 关键字指定此步骤将运行 actions/checkout 操作的 v3\n      # 我们可以从字面上看出这是一个 git checkout  仓库的操作.\n      # 将仓库 checkout到运行器(虚拟机)上\n      - uses: actions/checkout@v3 #\n      # checkout 代码后, 然后这里是安装 node\n      - uses: actions/setup-node@v3\n        with:\n          node-version: '14' # 安装的版本是14\n      - run: npm install -g bats # 执行命令\n      - run: bats -v\n\n\non: [push] 指定分支的push发生时 官方文档\non:\n   push:\n      branches:\n         - main\n         - 'releases/**'\nuses: actions/checkout@v3 实际是个github仓库哦 https://github.com/actions/checkout\n\nhttps://github.com/peaceiris/actions-hugo https://github.com/peaceiris/actions-gh-pages\nmy_repo/nav_src hugo博客源码, 然后我想要push后,自动build 生成静态文件,发布到另外一个仓库中\n\n\nhugo.yml\n\nname: Hugo Actions\non:\n  push:\n    branches:\n      - main  # 这里的意思是当 main 分支发生 push 的时候，运行下面的 jobs\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      #   with:\n      #     submodules: true  # Fetch submodule\n      #     fetch-depth: 0 \n      - name: Setup Hugo\n        uses: peaceiris/actions-hugo@v2 # hugo官方的action, 安装hugo\n        with:\n          hugo-version: '0.110.0'   # 安装指定版本的hugo\n      - name: Build\n        run: hugo --minify  # 使用hugo生成静态网页\n      - name: Deploy To another  repository  # 部署至其他仓库,也可以是其他分支\n        uses: peaceiris/actions-gh-pages@v3 # hugo官方提供的自动发布github pages的action\n        with:\n          external_repository: my_repo/nav  # 发布到哪个repo\n          personal_token: ${{ secrets.PERSONAL_ACCESS_TOKEN }}\n          # hugo 生成的静态文件在 public 目录, 这里的意思是 要发布 public 文件夹里的内容\n          publish_dir: ./public\n          publish_branch: main  # 发布到哪个分支\n          force_orphan: true\n          full_commit_message: ${{ github.event.head_commit.message }}\n\n\n\n\n\n\n\n将hugo.yml中的PERSONAL_ACCESS_TOKEN改成你设置的NAME\n\n\n\n\n创建 Personal_Access_Token： \n\nNote: 给token 描述\nExpiration: No expiration\nSelect scopes: 全选\n\n生成后, 复制token\n目标仓库 设置 Personal_Access_Token：\n打开目标仓库页面 -&gt; 点击Settings -&gt; Security -&gt; Secrets and variables -&gt; Actions，选择 New repository secret -&gt;设置一个名字 NAME (比如 DEPLOY2NAV) -&gt; 粘贴前面生成的 personal_access_token\n将hugo.yml 里的 PERSONAL_ACCESS_TOKEN 改成DEPLOY2NAV\n\n\n\npush 后去看 my_repo/nav_src 仓库的 Actions ,看执行的命令情况. 成功的话,会在 my_repo/nav仓库里看到静态页面.",
    "crumbs": [
      "github-action"
    ]
  },
  {
    "objectID": "docs/devops/k8s/component/etcd.html",
    "href": "docs/devops/k8s/component/etcd.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "Tip\n\n\n\n\nEtcd是CoreOS基于Raft开发的 分布式key-value存储 可用于服务发现、共享配置以及一致性保障(如数据库选主、分布式锁等)\n在分布式系统中，如何管理节点间的状态一直是一个难题，etcd像是专门为集群环境的服务发现 和注册而设计，它提供了数据TTL失效、数据改变监视、多值、目录监听、分布式锁原子操作等功能，可以方便的跟踪并管理集群节点的状态",
    "crumbs": [
      "组件",
      "etcd"
    ]
  },
  {
    "objectID": "docs/devops/k8s/component/etcd.html#raft-协议",
    "href": "docs/devops/k8s/component/etcd.html#raft-协议",
    "title": "斯巴拉稀",
    "section": "1 raft 协议",
    "text": "1 raft 协议",
    "crumbs": [
      "组件",
      "etcd"
    ]
  },
  {
    "objectID": "docs/devops/k8s/component/etcd.html#安装",
    "href": "docs/devops/k8s/component/etcd.html#安装",
    "title": "斯巴拉稀",
    "section": "2 安装",
    "text": "2 安装\nETCD_VER=v3.4.17\n# DOWNLOAD_URL=https://github.com/etcd-io/etcd/releases/download\nDOWNLOAD_URL=https://repo.huaweicloud.com/etcd/\nrm -f /tmp/etcd-${ETCD_VER}-linux-amd64.tar.gz\nrm -rf /tmp/etcd-download-test && mkdir -p /tmp/etcd-download-test\ncurl -L ${DOWNLOAD_URL}/${ETCD_VER}/etcd-${ETCD_VER}-linux-amd64.tar.gz -o /tmp/etcd-${ETCD_VER}-linux-amd64.tar.gz\ntar xzvf /tmp/etcd-${ETCD_VER}-linux-amd64.tar.gz -C /tmp/etcd-download-test --strip-components=1\n\n#rm -f /tmp/etcd-${ETCD_VER}-linux-amd64.tar.gz\n#rm -rf /tmp/etcd-download-test\n\n\n# client 相关的 是给客户端 用的url\n# peer 是给集群节点之间通信用的\n#我们可以 启动, 使用别的端口, 因为这里我们 k8s已经启动了etcd 了.\n# 会在当前目录下创建 一个 default.etcd , 来存储数据\netcd --listen-client-urls 'http://localhost:12379' \\\n --advertise-client-urls 'http://localhost:12379' \\\n --listen-peer-urls 'http://localhost:12380' \\\n --initial-advertise-peer-urls 'http://localhost:12380' \\\n --initial-cluster 'default=http://localhost:12380'\n\n# 其他参数\n# 节点名称, 不指定的话,默认是default\n--name 'default'\n--data-dir #不指定的话,默认会在当前目录下 的 default.etcd 目录\n\n\n2.1 集群",
    "crumbs": [
      "组件",
      "etcd"
    ]
  },
  {
    "objectID": "docs/devops/k8s/component/etcd.html#etcdctl使用",
    "href": "docs/devops/k8s/component/etcd.html#etcdctl使用",
    "title": "斯巴拉稀",
    "section": "3 etcdctl使用",
    "text": "3 etcdctl使用\n\n\n别名配置\n\n# etcdctl --endpoints=http://localhost:12379 put a b\n# pod 安装的etcd ,我们的宿主机上 连接\nexport ETCDCTL_API=3\netcdctl member list -w table --endpoints=https://localhost:2379 --cacert=/etc/kubernetes/pki/etcd/ca.crt  --cert=/etc/kubernetes/pki/etcd/peer.crt --key=/etc/kubernetes/pki/etcd/peer.key\n\ncat &gt;&gt; /etc/profile &lt;&lt;EOF\nexport ETCDCTL_API=3\nalias e=\"etcdctl --endpoints=https://localhost:2379 --cacert=/etc/kubernetes/pki/etcd/ca.crt  --cert=/etc/kubernetes/pki/etcd/peer.crt --key=/etc/kubernetes/pki/etcd/peer.key\"\nEOF\n\n# 启动一个测试用etcd, 使用这个别名来测试\nalias ee=\"etcdctl --endpoints=http://localhost:12379\"\n\n\n节点增改查删\n\n\n# 节点成员 table 格式\nee member list -w table\n# json 格式显示\nee member list -w json\n# 状态\nee endpoint status -w table\n\n\nee put name tom #设置key value\nee get name # 显示key 和value\n    name\n    tom\nee put name jack # 有则修改,无则增加\nee get name -w json\n# etcd 的key 采用层次化的空间结构, 像 linux的目录一样\nee put /a a1 --debug # debug信息\nee put /a/b ab1\n# 带上前缀的 查询\nee get --prefix /a # /a 和/a/b 都会查询到\n\n\n# 查看key  --keys-only只显示key\nee get / --prefix  --keys-only\n# 这个才会显示所有的key,  put name tom 这种的key 也会显示出来\nee get \"\" --prefix  --keys-only\n\n\nee del name # 结果显示 删除的key的个数\nee put /person1/age 11\nee del /person1/age\n# 会删除以/a 为前缀 的key 包括/a\nee del /a --prefix",
    "crumbs": [
      "组件",
      "etcd"
    ]
  },
  {
    "objectID": "docs/devops/k8s/component/etcd.html#版本管理",
    "href": "docs/devops/k8s/component/etcd.html#版本管理",
    "title": "斯巴拉稀",
    "section": "4 版本管理",
    "text": "4 版本管理\n\n4.1 各个版本号的含义\n# 全新,没有添加过任何数据的etcd\n# 我们删除 启动etcd的目录下的 default.etcd 然后重新启动etcd 即可\n# 随便 get 一个key, 下面的 key a 是不存在的\nee get a -w json\n{\"header\":\n    {\n        \"cluster_id\":17478742799590499669,\n        \"member_id\":14532165781622267127,\n        \"revision\":1,  #作用域为集群，逻辑时间戳，全局单调递增，任何 key 的增删改都会使其自增\n        \"raft_term\":2\n    }\n}\n\n# 添加\nee put a b\nee get a -w json\n{\n  \"header\": {\n    \"cluster_id\": 17478742799590499669,\n    \"member_id\": 14532165781622267127,\n    \"revision\": 2, #全局 版本+1, 任何添加修改的操作都会自增, 即使值没有修改,比如2次 ee put a bb\n    \"raft_term\": 2\n  },\n  \"kvs\": [\n    {\n      \"key\": \"YQ==\", # echo YQ== |base64 -d  ==&gt; a\n      #作用域为 key, 值为: 创建这个key时集群的全局Revision, 直到删除前都保持不变\n      \"create_revision\": 2,\n      #作用域为 key, 值为: 最后修改这个key时 集群的全局Revision\n      \"mod_revision\": 2,\n      # 作用域为 key, 这个key刚创建时Version为1，之后每次更新都会自增，即这个key从创建以来更新的总次数\n      \"version\": 1,\n      \"value\": \"Yg==\"  # echo Yg== |base64 -d  ==&gt; b\n    }\n  ],\n  \"count\": 1\n}\n\n# 修改\nee put a abc\nee get a -w json\n{\n  \"header\": {\n    \"cluster_id\": 17478742799590499669,\n    \"member_id\": 14532165781622267127,\n    \"revision\": 3,\n    \"raft_term\": 2\n  },\n  \"kvs\": [\n    {\n      \"key\": \"YQ==\",\n      \"create_revision\": 2,\n      \"mod_revision\": 3,\n      \"version\": 2,  #这个key的第2个版本\n      \"value\": \"YWJj\"\n    }\n  ],\n  \"count\": 1\n}\n\nee put a hello\nee get a -w json\n{\n  \"header\": {\n    \"cluster_id\": 17478742799590499669,\n    \"member_id\": 14532165781622267127,\n    \"revision\": 4,\n    \"raft_term\": 2\n  },\n  \"kvs\": [\n    {\n      \"key\": \"YQ==\",\n      \"create_revision\": 2,\n      \"mod_revision\": 4,\n      \"version\": 3,\n      \"value\": \"aGVsbG8=\"\n    }\n  ],\n  \"count\": 1\n}\n\n\nee put hello world\nee get hello -w json\n{\n  \"header\": {\n    \"cluster_id\": 17478742799590499669,\n    \"member_id\": 14532165781622267127,\n    \"revision\": 5,\n    \"raft_term\": 2\n  },\n  \"kvs\": [\n    {\n      \"key\": \"aGVsbG8=\",\n      \"create_revision\": 5, #等于 当前的全局revision\n      \"mod_revision\": 5, #等于 当前的全局revision\n      \"version\": 1,\n      \"value\": \"d29ybGQ=\"\n    }\n  ],\n  \"count\": 1\n}\nee put b bb\n\n\n4.2 获取对应版本的数据\n# rev=0 表示获取当前版本的k v\nee get a --rev=0\n    a\n    hello\n# rev 指定的是全局版本 , 意思是在那个版本的时候, 这个key a 的值是多少\nee get a --rev=2\n    a\n    b\n# 所以 这个得到的是空. 全局rev=1的时候 a 还没创建. 创建的时候revision=2\nee get a --rev=1\n\n# 等到的是 hello, 因为这个版本下\nee get a --rev=5\n    a\n    hello\nee get a --rev=6 # 这个也是hello ,显然 全局版本是6的时候, a的值肯定是hello\n\n\n4.3 从指定版本号起监听\n# 可以看到指定版本号以及之后的所有版本数据, 如果版本已经被compact\n# 会提示 required revision has been compacted\n# 看后面的容量管理\nee watch a --rev=1 -w json",
    "crumbs": [
      "组件",
      "etcd"
    ]
  },
  {
    "objectID": "docs/devops/k8s/component/etcd.html#容量管理",
    "href": "docs/devops/k8s/component/etcd.html#容量管理",
    "title": "斯巴拉稀",
    "section": "5 容量管理",
    "text": "5 容量管理\n# 删除 default.etcd\n# 启动时我们 设置etcd存储大小 16M\netcd --listen-client-urls 'http://localhost:12379' \\\n    --advertise-client-urls 'http://localhost:12379' \\\n    --listen-peer-urls 'http://localhost:12380' \\\n    --initial-advertise-peer-urls 'http://localhost:12380' \\\n    --initial-cluster 'default=http://localhost:12380' \\\n    --quota-backend-bytes=$((16*1024*1024))\n\nee put a b\n# 修改key x ,因为版本的原因,每次修改数据都会保存,这样存储就满了\n# 满了后再put ,会报错\nwhile true\ndo\n    dd if=/dev/urandom bs=1M count=1 | ee put x || break\ndone\n# 查看状态 , 可以看到Errors alarm:NOSPACE\nee endpoint status -w table\n\nee alarm list # 查看报警信息\nmemberID:14532165781622267127 alarm:NOSPACE\n\n# 压缩版本\n# 表示压缩到 全局版本的第10个版本, 也就是, 10版本前的key,只保留里面最新版本的那个值\n# 然后版本归为 10\n# 如果是compact 当前版本, 那么就是压缩成到最新的版本,key对应旧版本的数据就都删除了,只保留最新版本的值.\nee compact 10\nee get a --rev 10 # 如果指定版本的话, 是指定10 不是2\n# 清理碎片\nee defrag\n\n# 清理alarm  解除报警,没有errors\nee alarm disarm\n\n5.1 compact配置\n\n\n\n\n\n\n单独的etcd\n\n\n\n/etc/kubernetes/manifests/etcd.yaml 添加2个配置可以控制压缩\n--auto-compaction-retention=1  # 每一个小时自动压缩\n--auto-compaction-mode=periodic # 模式是时间间隔, 另外一个模式是reversion数量\n\n\n\n\n\n\n\n\nk8s中的etcd\n\n\n\n上面那样修改是无效的, 这个压缩的操作,k8s代码里给写了1 staging/src/k8s.io/apiserver/pkg/storage/storagebackend/factory/etcd3.go#startCompactorOnce\n\n\ncmd/kube-apiserver/app/options/options.go\n\nfunc NewServerRunOptions() *ServerRunOptions {\n  s := ServerRunOptions{\n      GenericServerRunOptions: genericoptions.NewServerRunOptions(),\n      Etcd:                    genericoptions.NewEtcdOptions(\n          // NewDefaultConfig() 里会看到 DefaultCompactInterval = 5 * time.Minute\n                    storagebackend.NewDefaultConfig(kubeoptions.DefaultEtcdPathPrefix, nil)\n                                ),\n      ..\n  }\n}",
    "crumbs": [
      "组件",
      "etcd"
    ]
  },
  {
    "objectID": "docs/devops/k8s/component/etcd.html#关于k8s中的相关",
    "href": "docs/devops/k8s/component/etcd.html#关于k8s中的相关",
    "title": "斯巴拉稀",
    "section": "6 关于k8s中的相关",
    "text": "6 关于k8s中的相关",
    "crumbs": [
      "组件",
      "etcd"
    ]
  },
  {
    "objectID": "docs/devops/k8s/component/etcd.html#footnotes",
    "href": "docs/devops/k8s/component/etcd.html#footnotes",
    "title": "斯巴拉稀",
    "section": "Footnotes",
    "text": "Footnotes\n\n\n有关k8s中etcd compact的讨论↩︎",
    "crumbs": [
      "组件",
      "etcd"
    ]
  },
  {
    "objectID": "docs/devops/k8s/component/apiserver.html",
    "href": "docs/devops/k8s/component/apiserver.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "Tip\n\n\n\n\n集群的HTTP REST API接口,是集群控制的入口,包括认证授权、数据校验以及集群状态变更 等\n将k8s “资源组/资源版本/资源” 以RESTful风格的形式对外暴露并提供服务\nk8s集群中的所有组件都通过kube-apiserver组件操作资源对象,也通过它让各组件可以通信和交互\n只有API Server才直接操作etcd",
    "crumbs": [
      "组件",
      "apiserver"
    ]
  },
  {
    "objectID": "docs/devops/k8s/component/apiserver.html#介绍",
    "href": "docs/devops/k8s/component/apiserver.html#介绍",
    "title": "斯巴拉稀",
    "section": "",
    "text": "Tip\n\n\n\n\n集群的HTTP REST API接口,是集群控制的入口,包括认证授权、数据校验以及集群状态变更 等\n将k8s “资源组/资源版本/资源” 以RESTful风格的形式对外暴露并提供服务\nk8s集群中的所有组件都通过kube-apiserver组件操作资源对象,也通过它让各组件可以通信和交互\n只有API Server才直接操作etcd",
    "crumbs": [
      "组件",
      "apiserver"
    ]
  },
  {
    "objectID": "docs/devops/k8s/component/apiserver.html#go-restful",
    "href": "docs/devops/k8s/component/apiserver.html#go-restful",
    "title": "斯巴拉稀",
    "section": "2 go-restful",
    "text": "2 go-restful\ngithub\n\n\n\n\n\n\n\n概念介绍\n\n\n\n\nContainer 相当于 一个http server,不同的container监控不同的地址和端口\n每个container可以包含多个WebService,相当于一组不同服务的分类 ,比如Pod作为一组,configmap作为一组\n每个WebService包含多个Router(路由),Router根据http请求的URL路由到对应的处理函数(Handler)\n\n\n\npackage main\n\nimport (\n    // v3 支持go mod\n    \"io\"\n    \"log\"\n    \"net/http\"\n\n    restful \"github.com/emicklei/go-restful/v3\"\n)\n\nfunc main() {\n    ws := new(restful.WebService)\n    ws.Route(ws.GET(\"/hello\").To(hello))\n    // 这里有一个默认的Container,进行添加WebService的操作\n    restful.Add(ws)\n    go func() {\n        log.Fatal(http.ListenAndServe(\":8080\", nil))\n    }()\n    container2 := restful.NewContainer()\n    ws2 := new(restful.WebService)\n    ws2.Route(ws2.GET(\"/ping\").To(pong))\n    container2.Add(ws2)\n    server := &http.Server{Addr: \":8081\", Handler: container2}\n    log.Fatal(server.ListenAndServe())\n}\n\nfunc hello(req *restful.Request, resp *restful.Response) {\n    io.WriteString(resp, \"world\")\n}\nfunc pong(req *restful.Request, resp *restful.Response) {\n    io.WriteString(resp, \"pong\")\n}",
    "crumbs": [
      "组件",
      "apiserver"
    ]
  },
  {
    "objectID": "docs/devops/k8s/component/apiserver.html#访问控制",
    "href": "docs/devops/k8s/component/apiserver.html#访问控制",
    "title": "斯巴拉稀",
    "section": "3 访问控制",
    "text": "3 访问控制\n\n\n\n\n\n\nAPI Server 权限管理流程\n\n\n\n\n\n\n\n3.1 认证 Authentication\n\n\n\n\n\n\nTip\n\n\n\n针对请求的认证,确认是否具有访问Kubernetes集群的权限\n\n\n\n\nvendor/k8s.io/apiserver/pkg/endpoints/filters/authentication.go\n\nfunc withAuthentication(handler http.Handler, auth authenticator.Request, failed http.Handler, apiAuds authenticator.Audiences, metrics recordMetrics) http.Handler {\n    if auth == nil {\n        klog.Warning(\"Authentication is disabled\")\n        return handler\n    }\n    return http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) {\n        authenticationStart := time.Now()\n\n        if len(apiAuds) &gt; 0 {\n            req = req.WithContext(authenticator.WithAudiences(req.Context(), apiAuds))\n        }\n        resp, ok, err := auth.AuthenticateRequest(req)\n        authenticationFinish := time.Now()\n        defer func() {\n            metrics(req.Context(), resp, ok, err, apiAuds, authenticationStart, authenticationFinish)\n        }()\n        if err != nil || !ok {\n            if err != nil {\n                klog.ErrorS(err, \"Unable to authenticate the request\")\n            }\n            failed.ServeHTTP(w, req)\n            return\n        }\n\n        if !audiencesAreAcceptable(apiAuds, resp.Audiences) {\n            err = fmt.Errorf(\"unable to match the audience: %v , accepted: %v\", resp.Audiences, apiAuds)\n            klog.Error(err)\n            failed.ServeHTTP(w, req)\n            return\n        }\n\n        // authorization header is not required anymore in case of a successful authentication.\n        req.Header.Del(\"Authorization\")\n\n        req = req.WithContext(genericapirequest.WithUser(req.Context(), resp.User))\n        handler.ServeHTTP(w, req)\n    })\n}\n\n\n\nstaging/src/k8s.io/apiserver/pkg/authentication/request/union/union.go\n\nfunc (authHandler *unionAuthRequestHandler) AuthenticateRequest(req *http.Request) (*authenticator.Response, bool, error) {\n    var errlist []error\n    for _, currAuthRequestHandler := range authHandler.Handlers {\n        resp, ok, err := currAuthRequestHandler.AuthenticateRequest(req)\n        if err != nil {\n            if authHandler.FailOnError {\n                return resp, ok, err\n            }\n            errlist = append(errlist, err)\n            continue\n        }\n\n        if ok {\n            // 有很多认证方式, 只要一个ok就行\n            return resp, ok, err\n        }\n    }\n\n    return nil, false, utilerrors.NewAggregate(errlist)\n}\n\n\n3.1.1 自定义Webhook\n\n\n\n\n\n\nTip\n\n\n\n当客户端发送的认证请求到达kube-apiserver 时,kube-apiserver回调设置的webhook方法,将验证信息发送给远程的Webhook服务器进行认证,然后根据Webhook服务器返回的状态码来判断是否认证成功\n\n\n\n\n\n\n\n\n源码\n\n\n\n\n\n\n\nstaging/src/k8s.io/apiserver/plugin/pkg/authenticator/token/webhook/webhook.go\n\nfunc (w *WebhookTokenAuthenticator) AuthenticateToken(ctx context.Context, token string) (*authenticator.Response, bool, error) {\n    r := &authenticationv1.TokenReview{\n        Spec: authenticationv1.TokenReviewSpec{\n            Token:     token,\n            Audiences: wantAuds,\n        },\n    }\n\n\n    result, statusCode, tokenReviewErr = w.tokenReview.Create(ctx, r, metav1.CreateOptions{})\n\n    r.Status = result.Status\n    if !r.Status.Authenticated {\n        var err error\n        if len(r.Status.Error) != 0 {\n            err = errors.New(r.Status.Error)\n        }\n        return nil, false, err\n    }\n\n    var extra map[string][]string\n    if r.Status.User.Extra != nil {\n        extra = map[string][]string{}\n        for k, v := range r.Status.User.Extra {\n            extra[k] = v\n        }\n    }\n\n    return &authenticator.Response{\n        User: &user.DefaultInfo{\n            Name:   r.Status.User.Username,\n            UID:    r.Status.User.UID,\n            Groups: r.Status.User.Groups,\n            Extra:  extra,\n        },\n        Audiences: auds,\n    }, true, nil\n}\n\n\n\nstaging/src/k8s.io/apiserver/plugin/pkg/authenticator/token/webhook/webhook.go\n\nfunc (c *tokenReviewV1Client) Create(ctx context.Context, tokenReview *authenticationv1.TokenReview, opts metav1.CreateOptions) (result *authenticationv1.TokenReview, statusCode int, err error) {\n    result = &authenticationv1.TokenReview{}\n\n    restResult := c.client.Post().\n        Resource(\"tokenreviews\").\n        VersionedParams(&opts, scheme.ParameterCodec).\n        // body 是 authenticationv1.TokenReview 结构\n        Body(tokenReview).\n        Do(ctx)\n\n    restResult.StatusCode(&statusCode)\n    err = restResult.Into(result)\n    return\n}\n\n\n\n\n\nkubeconfig 配置文件添加用户\n\n\n\n~/.kube/config\n\napiVersion: v1\nclusters:\n- cluster:\n    certificate-authority-data: ...\n    server: https://192.168.66.100:6443\n  name: kubernetes\ncontexts:\n- context:\n    cluster: kubernetes\n    user: kubernetes-admin\n  name: kubernetes-admin@kubernetes\ncurrent-context: kubernetes-admin@kubernetes\nkind: Config\npreferences: {}\nusers:\n- name: kubernetes-admin\n  user:\n    client-certificate-data: ...\n    client-key-data: ...\n## 添加一个用户\n- name: xyz\n  user:\n    token: abc\n\nk get po\n# 默认是用这个用户去访问集群的. 用这个用户去认证\nk get po --user=kubernetes-admin\n# 现在我们用我们创建的用户去访问.\n# 发现无法识别你的用户时,就会去看你是否配置了webhook,有就将这个转发给它认证\n# 这里会提示你 You must be logged in to the server (Unauthorized)\nk get po --user=xyz\n\n创建一个webhook配置文件1\n\n# 目录随意\nmkdir -p /etc/kubernetes/abc\ncd /etc/kubernetes/abc\n# 1. 将集群详细信息添加到配置文件中\n# --server= 指定我们将来apiserver 转发去认证的服务地址\nkubectl config --kubeconfig=webhook.yaml set-cluster my-test --server=http://192.168.1.100:3000/authenticate\n# 2. 将用户详细信息添加到配置文件中\n# 创建一个用户 xyz , 这里token 我们随便写一个\nkubectl config --kubeconfig=webhook.yaml set-credentials xyz  --token=abc\n# 3. 将上下文详细信息添加到配置文件中\n# 添加一个上下文, 将集群和用户关联起来        --namespace=default\nkubectl config --kubeconfig=webhook.yaml set-context my-hook --cluster=my-test --user=xyz\n# 4. 设置当前上下文\nkubectl config --kubeconfig=webhook.yaml use-context my-hook\n\n# 会在当前目录生成一个 webhook.yaml文件\n\n\nwebhook.yaml\n\napiVersion: v1\nclusters:\n- cluster:\n    server: http://192.168.1.100:3000/authenticate # 宿主机的上的服务地址.\n  name: my-test\ncontexts:\n- context:\n    cluster: my-test\n    user: xyz\n  name: my-hook\ncurrent-context: my-hook\nkind: Config\npreferences: {}\nusers:\n- name: xyz\n  user:\n    token: abc\n\n\n创建服务,用来认证\n\npackage main\n\nimport (\n    \"encoding/json\"\n    \"fmt\"\n    \"log\"\n    \"net/http\"\n\n    authentication \"k8s.io/api/authentication/v1beta1\"\n)\n\nfunc main() {\n    http.HandleFunc(\"/authenticate\", auth)\n    log.Println(http.ListenAndServe(\":3000\", nil))\n}\n\nfunc auth(w http.ResponseWriter, r *http.Request) {\n    decoder := json.NewDecoder(r.Body)\n    var tr authentication.TokenReview\n    err := decoder.Decode(&tr)\n    if err != nil {\n        log.Println(\"[Error]\", err.Error())\n        w.WriteHeader(http.StatusBadRequest)\n        json.NewEncoder(w).Encode(map[string]interface{}{\n            \"apiVersion\": \"authentication.k8s.io/v1beta1\",\n            \"kind\":       \"TokenReview\",\n            \"status\": authentication.TokenReviewStatus{\n                Authenticated: false,\n            },\n        })\n        return\n    }\n    fmt.Println(\"tr:::\", tr)\n    log.Print(\"receving request\")\n\n    // 这里 随便 验证. (这里写的很粗糙,就为了测试,不用管)\n    if tr.Spec.Token == \"abc\" {\n        fmt.Println(888)\n        w.WriteHeader(http.StatusOK)\n        trs := authentication.TokenReviewStatus{\n            Authenticated: true,\n            User: authentication.UserInfo{\n                Username: \"xyz\",\n                UID:      \"xyz\",\n            },\n        }\n        json.NewEncoder(w).Encode(map[string]interface{}{\n            \"apiVersion\": \"authentication.k8s.io/v1beta1\",\n            \"kind\":       \"TokenReview\",\n            \"status\":     trs,\n        })\n        return\n    }\n\n    w.WriteHeader(http.StatusUnauthorized)\n    json.NewEncoder(w).Encode(map[string]interface{}{\n        \"apiVersion\": \"authentication.k8s.io/v1beta1\",\n        \"kind\":       \"TokenReview\",\n        \"status\": authentication.TokenReviewStatus{\n            Authenticated: false,\n        },\n    })\n    return\n}\n\n\n在你宿主机上运行即可.\n\ngo run main.go\n\n\n修改kube-apiserver pod的配置\n\n\n\n/etc/kubernetes/manifests/kube-apiserver.yaml\n\n...\nspec:\n  containers:\n  - command:\n    - kube-apiserver\n    - ...\n    - --authentication-token-webhook-config-file=/etc/config/apiserver/webhook.yaml\n    - --authentication-token-webhook-cache-ttl=2m #用来设定身份认证决定的缓存时间,默认时长就是2分钟\n    volumeMounts:\n    - ...\n    - mountPath: /etc/config/apiserver\n      name: webhook\n      readOnly: true\n  volumes:\n  - ...\n  - hostPath:\n      path: /etc/kubernetes/abc\n      type: DirectoryOrCreate\n    name: webhook\n\n\n等待apiserver 自动重启 或这 手动 systemctl restart kubelet\n使用用户xyz来访问 会报错,提示Error from server (Forbidden): pods is forbidden: User “xyz” cannot list resource “pods” in API group “” in the namespace “default” 这说明是ok了, 已经过了认证, 到了鉴权阶段了,提示没有权限\n\nk get po --user=xyz\n\n\n\n\n\n\n这里先展示授权用户\n\n\n\nk create role role-pod-reader --verb=get --verb=list --verb=watch --resource=pods\nk create rolebinding  rb-pod-reader --role=role-pod-reader --user=xyz\nk get po --user=xyz # 可以访问了..\n\n\n\n\n\n3.2 鉴权 Authorization\n\n\n\n\n\n\nTip\n\n\n\n针对资源的授权,确认是否对资源具有相关权限\n\n\n\n3.2.1 rbac\n\n\n\n\n\n\nTip\n\n\n\n\n给A老师授权进办公室的权限, 给B老师授权..\n给C学生授权进图书馆的权限, 还有好多学生老师 都这样弄.. 很麻烦\n很显然我们明白一个道理 是学生就能进图书馆, 学生是个角色,C是个体,只要确认C是学生即可\n还有一种情况, 一班的老师和二班的老师 比如对某个场所具有不同的权限,可以对一组人进行授权.\n\n\n\n\n\n3.2.1.1 role\n\n\n\n\n\n\nTip\n\n\n\nrole角色 (可以看成是一坨权限的集合) 是有命名空间的, 不指定默认是default, 它所拥有的权限 也只针对这个命名空间下的资源\n\n\n\n\n创建一个角色, 赋予它访问test命名空间下的pod的权限\n\nk create role role-pod-reader \\\n    --verb=get \\\n    --verb=list \\\n    --verb=watch \\\n    --resource=pods \\\n    --resource=pods/logs \\\n    -n test\n\nk get role -n test role-pod-reader -o yaml\n\n\n\nrole-pod-reader.yaml\n\napiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  name: role-pod-reader\n  namespace: test\nrules:\n- apiGroups:\n  - \"\"\n  resources:\n  - pods\n  verbs:\n  - get\n  - list\n  - watch\n\n\n\n3.2.1.2 clusterrole\n\n\n\n\n\n\nTip\n\n\n\nclusterrole 是没有命名空间,这个角色所拥有的权限是针对集群.\n\n\n\ncreate聚合ClusterRole默认的一些clusterrole\n\n\n# 看下admin的权限\nk get clusterrole admin  -o yaml\nk create clusterrole clusterrole-pod-reader --verb=get,list,watch --resource=pods\n\n\n\n\n\n\n\n\nTip\n\n\n\n将若干 ClusterRole 聚合（Aggregate） 起来，形成一个复合的 ClusterRole。 作为集群控制面的一部分，控制器会监视带有 aggregationRule 的 ClusterRole 对象集合。aggregationRule 为控制器定义一个标签选择算符供后者匹配应该组合到当前 ClusterRole 的 roles 字段中的 ClusterRole 对象\n\n\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\n  name: monitoring\naggregationRule:\n  clusterRoleSelectors:\n  - matchLabels:\n      rbac.example.com/aggregate-to-monitoring: \"true\"\nrules: [] # 控制面自动填充这里的规则\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\n  name: monitoring-endpoints\n  labels:\n    rbac.example.com/aggregate-to-monitoring: \"true\"\n# 当你创建 \"monitoring-endpoints\" ClusterRole 时，\n# 下面的规则会被添加到 \"monitoring\" ClusterRole 中\nrules:\n- apiGroups: [\"\"]\n  resources: [\"services\", \"endpointslices\", \"pods\"]\n  verbs: [\"get\", \"list\", \"watch\"]\n\n\n\n\n\n\n\n\nTip\n\n\n\n可以绑定view 给 开发者\n\n\n#好多默认的,我们可以看看admin这个clusterrole\nk get clusterrole\n# 关注一下这4个clusterrole 都是集群的role\n    cluster-admin\n    admin    # 权限稍微比上面的小点\n    edit\n    view   #规定了被作用者只有 Kubernetes API 的只读权限\n#可以看看有哪些可以定义的东西,可以学学\nk get clusterrole admin  \n\n# 我们默认的\nk get clusterrolebinding cluster-admin -o yaml\nk get clusterrole cluster-admin -o yaml\n    rules:\n    - apiGroups:\n        - '*'\n        resources:\n        - '*'\n        verbs:\n        - '*'\n    - nonResourceURLs:\n        - '*'\n        verbs:\n        - '*'\n\n\n\n\n\n3.2.1.3 rolebinding\n\n\n\n\n\n\nTip\n\n\n\n通过这个将角色和主体(User,Group,ServiceAccount) 进行绑定. 就是赋予这些主体这么一坨权限(角色) rolebinding 是有命名空间的, 真正的权限范围是由这个rolebinding 命名空间决定的.\n\n\n\n绑定role绑定clusterrole\n\n\n# -o yaml --dry-run=client 别忘记使用这个看yaml文件\n# --user=admin --user=xyz 指定多个 用户, 用户名是区分大小写的\n# 只能绑定一个role   --role=role1 --role=role2  会使用后面的role2\nk create rolebinding  rb-pod-reader --role=role-pod-reader --user=xyz -n test\nk get rolebinding  rb-pod-reader -o yaml\nk get po --user=xyz # 报错\nk get po -n test --user=xyz # ok\n# 首先 指定的role 在 test 命名空间下不存在是不会报错的.\n# 一定要注意命名空间,这里kube-system 命名空间下没有 role-pod-reader 这个角色\nk create rolebinding  rb-pod-reader --role=role-pod-reader --user=xyz  -n kube-system\nks get po --user=xyz # 报错 ,没有权限\n# 这个时候我们再创建这个 role\nk create role role-pod-reader \\\n    --verb=get \\\n    --verb=watch \\\n    --verb=list \\\n    --resource=pods \\\n    -n kube-system\nks get po # ok\n\n\n-n test rb-pod-reader.yaml\n\napiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\n  name: rb-pod-reader\n  namespace: test\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: Role\n  name: role-pod-reader\nsubjects:\n- apiGroup: rbac.authorization.k8s.io\n  kind: User\n  name: xyz\n\n\n\n\n\n\n\n\n\n绑定clusterrole还是只对指定的命名空间下资源有权限,那么有什么用呢?\n\n\n\n假设我们需要在10个命名空间下,10个用户都绑定一个角色,这样的整10个,你需要在每个命名空间下创建权限一样的role,现在你只需要创建一个clusterrole来进行rolebinding就行了.\n\n\n# k create clusterrole clusterrole-pod-reader --verb=get,list,watch --resource=pods\n# xyz 只对 test 命名空间下的资源 拥有clusterrole-pod-reader里设置的权限\nk create rolebinding  rb-clusterrole-pod-reader \\\n    --clusterrole=clusterrole-pod-reader \\\n    --user=xyz  \\\n    -n test\n\n\n\n\n\n3.2.1.4 clusterrolebinding\n\n\n\n\n\n\nTip\n\n\n\n对集群里的资源生效\n\n\nk create clusterrolebinding crb-xyz-clusterrole-pod-reader \\\n    --clusterrole=clusterrole-pod-reader \\\n    --user=xyz\n# 用户xyz可以list 所有命名空间的pod\n\n\ncrb-xyz-clusterrole-pod-reader.yaml\n\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRoleBinding\nmetadata:\n  name: crb-clusterrole-pod-reader\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: ClusterRole\n  name: clusterrole-pod-reader\nsubjects:\n- apiGroup: rbac.authorization.k8s.io\n  kind: User\n  name: xyz\n\n\n\n3.2.1.5 user\n\n普通用户, 不受k8s管理, 不是k8s来添加用户, 前面我们做认证的时候就外部直接添加了一个用户xyz\n所有的对apiserver 的请求都需要用户(user 或 serviceaccount)\n既然不受k8s管理,那么就没有命名空间的说法, 名字必须全局唯一\n\n\n\n3.2.1.6 serviceaccount(sa)\n官方文档\n\n服务账户\nk8s来管理(创建删除等), 所以有命名空间, 不同的命名空间下可以用相同的sa名\n\n# 每个ns下都有一个默认的default sa, 权限十分有限, 如果需要更多权限 需要绑定角色\n# 每个sa 都对应一个secret 用来进行身份验证\nk get sa\n    NAME          SECRETS   AGE\n    default       1         31d\n\nk get sa default -o yaml\n    apiVersion: v1\n    kind: ServiceAccount\n    metadata:\n      creationTimestamp: \"2023-06-28T07:29:23Z\"\n      name: default\n      namespace: default\n      resourceVersion: \"429\"\n      uid: ed1b8034-f70d-4db6-9fdd-14e132bf9258\n    secrets: # 每个sa 对应一个 secret, 可以k create sa sa-test 创建看看\n    - name: default-token-6tqd5\n# 默认情况下，Kubernetes 控制平面（特别是 ServiceAccount 准入控制器） 添加一个投射卷到 Pod， 此卷包括了访问 Kubernetes API 的令牌\nk get po nginx -o yaml\n# 每个 ns下都有 一个configmap kube-root-ca.crt 挂载到pod中去.\nk get cm\n\n\n给sa绑定角色\n\nk create rolebinding  rb-default-clusterrole-view \\\n    --clusterrole=view \\\n    --serviceaccount=default:default #命名空间:sa名字\n\n\n\nrb-default-clusterrole-view.yaml\n\napiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\n  name: rb-default-clusterrole-view\n  namespace: default\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: ClusterRole\n  name: view\nsubjects:\n- kind: ServiceAccount\n  name: default\n  namespace: default\n\n\n\n3.2.1.7 group\nk get rolebinding  -A -o wide\n\n\n\n\n3.3 准入 Admission\n\n\n\n\n\n\nTip\n\n\n\n对象被持久化之前,拦截kube-apiserver的请求,拦截后的请求进入准入控制器中处理,对请求的资源对象进行自定义 前面提到的创建的pod默认会设置一个投射卷, 就是准入控制器做的. 准入控制支持同时开启多个插件，它们依次调用，只有全部插件都通过的请求才可以放过进入系统\n\n\n# 查看默认的准入插件\nks exec kube-apiserver-master1 -- kube-apiserver --help|grep enable-admission-plugins\n\n3.3.1 准入 Webhook\n准入 Webhook\n\n\n\n\n\n\nTip\n\n\n\n\n除默认的准入控制插件以外, k8s预留了准入控制插件的扩展点，用户可自定义准入控制 插件实现自定义准入功能\n准入 Webhook 是一种用于接收准入请求并对其进行处理的 HTTP 回调机制。\n可以定义两种类型的准入 webhook，即 验证性质的准入 Webhook(ValidatingWebhookConfiguration) 和 修改性质的准入 Webhook (MutatingWebhookConfiguration)。\n修改性质的准入 Webhook 会先被调用。它们可以更改发送到 API 服务器的对象以执行自定义的设置默认值操作\n\n\n\n我们通过创建一个MutatingWebhookConfiguration,里面指定一个service服务,这个service就是webhook 服务,我这个service 是指向外部的应用,非pod\n\n证书编写webhook服务创建service创建MutatingWebhookConfiguration验证\n\n\n# 直接生成 根私钥 和 根证书\n#   -nodes 表示 no des 不加密的意思\n#   openssl 的命令真的... ,  建议 用逻辑上 一步一步来, 先私钥,再生成自签名 这样来.\n#    这里 我也记录一下, 以免看到这样的东西 觉得陌生.\nopenssl req -nodes -x509 -new -keyout ca.key -subj \"/CN=x.com\" -days 5000 -out ca.crt\n\nopenssl genrsa -out server.key 2048\n\ncat &gt;server.conf&lt;&lt;EOF\n[req]\nreq_extensions = v3_req\ndistinguished_name = req_distinguished_name\n# 表示 生成csr时,将直接从配置文件中读取关于申请者字段的信息,不会提示输入\n# req_distinguished_name 里的字段\nprompt = no\n[req_distinguished_name]\n# CN是 必填的, 其他也可以写, 什么国家 部门..\nCN = svc-mutate.default.svc\n[ v3_req ]\nbasicConstraints = CA:FALSE\nkeyUsage = nonRepudiation, digitalSignature, keyEncipherment\nextendedKeyUsage = clientAuth, serverAuth\nsubjectAltName = @alt_names\n[alt_names]\nDNS.1 = svc-mutate.default.svc  # svc\nIP.1 = 10.98.140.200  # svc的cluster ip\nEOF\n# -subj \"/CN=svc-mutate.default.svc\" 可以不用写\nopenssl req -new -key server.key  -out server.csr -config server.conf\nopenssl x509 -req -CA ca.crt -CAkey ca.key -CAcreateserial  -in server.csr -out server.crt -extensions v3_req -extfile server.conf\n\n\n\n目录结构\n\n# go 代码\ntree\n├── go.mod\n├── main.go\n└── pki\n  ├── server.crt # 前面生成的\n  ├── server.csr\n  └── server.key # 前面生成的\n\ngo代码\n\n\n\nmain.go 上面那个试过效果再来用这个实际示例,参考官方\n\npackage main\n\nimport (\n    \"crypto/tls\"\n    \"encoding/json\"\n    \"fmt\"\n    \"io/ioutil\"\n    \"log\"\n    \"net/http\"\n\n    v1 \"k8s.io/api/admission/v1\"\n    \"k8s.io/api/admission/v1beta1\"\n    metav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n    \"k8s.io/apimachinery/pkg/runtime\"\n    \"k8s.io/apimachinery/pkg/runtime/serializer\"\n    \"k8s.io/klog/v2\"\n)\n\ntype Config struct {\n    CertFile string\n    KeyFile  string\n}\n\nfunc configTLS(config Config) *tls.Config {\n    sCert, err := tls.LoadX509KeyPair(config.CertFile, config.KeyFile)\n    if err != nil {\n        klog.Fatal(err)\n    }\n    return &tls.Config{\n        Certificates: []tls.Certificate{sCert},\n        // ClientAuth:   tls.RequireAndVerifyClientCert,\n    }\n}\nfunc main() {\n    config := Config{\n        CertFile: \"./pki/server.crt\",\n        KeyFile:  \"./pki/server.key\",\n    }\n    http.HandleFunc(\"/add-label\", serveAddLabel)\n    server := &http.Server{\n        Addr:      fmt.Sprintf(\":%d\", 443),\n        TLSConfig: configTLS(config),\n    }\n    log.Println(server.ListenAndServeTLS(\"\", \"\"))\n}\n\nfunc serveAddLabel(w http.ResponseWriter, r *http.Request) {\n\n    admit := admitHandler{\n        v1beta1: delegateV1beta1AdmitToV1(addLabel),\n        v1:      addLabel,\n    }\n    var body []byte\n    if r.Body != nil {\n        if data, err := ioutil.ReadAll(r.Body); err == nil {\n            body = data\n        }\n    }\n    // 打印请求的数据\n    fmt.Println(\"handling request:\", string(body))\n    // return\n\n    // verify the content type is accurate\n    contentType := r.Header.Get(\"Content-Type\")\n    if contentType != \"application/json\" {\n        klog.Errorf(\"contentType=%s, expect application/json\", contentType)\n        return\n    }\n\n    var admissionReviewReq v1beta1.AdmissionReview\n    deserializer := codecs.UniversalDeserializer()\n    // 需要 指定 admissionReviewReq , 否则报错, 官方例子 这里是 body, nil, nil,会报错\n    obj, gvk, err := deserializer.Decode(body, nil, &admissionReviewReq)\n    if err != nil {\n        msg := fmt.Sprintf(\"Request could not be decoded: %v\", err)\n        klog.Error(msg)\n        http.Error(w, msg, http.StatusBadRequest)\n        return\n    }\n\n    var responseObj runtime.Object\n    switch *gvk {\n    case v1beta1.SchemeGroupVersion.WithKind(\"AdmissionReview\"):\n        requestedAdmissionReview, ok := obj.(*v1beta1.AdmissionReview)\n        if !ok {\n            klog.Errorf(\"Expected v1beta1.AdmissionReview but got: %T\", obj)\n            return\n        }\n        responseAdmissionReview := &v1beta1.AdmissionReview{}\n        responseAdmissionReview.SetGroupVersionKind(*gvk)\n        responseAdmissionReview.Response = admit.v1beta1(*requestedAdmissionReview)\n        responseAdmissionReview.Response.UID = requestedAdmissionReview.Request.UID\n        responseObj = responseAdmissionReview\n    case v1.SchemeGroupVersion.WithKind(\"AdmissionReview\"):\n        requestedAdmissionReview, ok := obj.(*v1.AdmissionReview)\n        if !ok {\n            klog.Errorf(\"Expected v1.AdmissionReview but got: %T\", obj)\n            return\n        }\n        responseAdmissionReview := &v1.AdmissionReview{}\n        responseAdmissionReview.SetGroupVersionKind(*gvk)\n        responseAdmissionReview.Response = admit.v1(*requestedAdmissionReview)\n        responseAdmissionReview.Response.UID = requestedAdmissionReview.Request.UID\n        responseObj = responseAdmissionReview\n    default:\n        msg := fmt.Sprintf(\"Unsupported group version kind: %v\", gvk)\n        klog.Error(msg)\n        http.Error(w, msg, http.StatusBadRequest)\n        return\n    }\n\n    klog.V(2).Info(fmt.Sprintf(\"sending response: %v\", responseObj))\n    respBytes, err := json.Marshal(responseObj)\n    if err != nil {\n        klog.Error(err)\n        http.Error(w, err.Error(), http.StatusInternalServerError)\n        return\n    }\n    w.Header().Set(\"Content-Type\", \"application/json\")\n    if _, err := w.Write(respBytes); err != nil {\n        klog.Error(err)\n    }\n}\n\nconst (\n    addFirstLabelPatch string = `[\n         { \"op\": \"add\", \"path\": \"/metadata/labels\", \"value\": {\"added-label\": \"yes\"}}\n     ]`\n    addAdditionalLabelPatch string = `[\n         { \"op\": \"add\", \"path\": \"/metadata/labels/added-label\", \"value\": \"yes\" }\n     ]`\n    updateLabelPatch string = `[\n         { \"op\": \"replace\", \"path\": \"/metadata/labels/added-label\", \"value\": \"yes\" }\n     ]`\n)\n\nfunc addLabel(ar v1.AdmissionReview) *v1.AdmissionResponse {\n    klog.V(2).Info(\"calling add-label\")\n    obj := struct {\n        metav1.ObjectMeta `json:\"metadata,omitempty\"`\n    }{}\n    raw := ar.Request.Object.Raw\n    err := json.Unmarshal(raw, &obj)\n    if err != nil {\n        klog.Error(err)\n        return toV1AdmissionResponse(err)\n    }\n\n    reviewResponse := v1.AdmissionResponse{}\n    reviewResponse.Allowed = true\n\n    pt := v1.PatchTypeJSONPatch\n    labelValue, hasLabel := obj.ObjectMeta.Labels[\"added-label\"]\n    switch {\n    case len(obj.ObjectMeta.Labels) == 0:\n        reviewResponse.Patch = []byte(addFirstLabelPatch)\n        reviewResponse.PatchType = &pt\n    case !hasLabel:\n        reviewResponse.Patch = []byte(addAdditionalLabelPatch)\n        reviewResponse.PatchType = &pt\n    case labelValue != \"yes\":\n        reviewResponse.Patch = []byte(updateLabelPatch)\n        reviewResponse.PatchType = &pt\n    default:\n        // already set\n    }\n    return &reviewResponse\n}\n\ntype admitv1beta1Func func(v1beta1.AdmissionReview) *v1beta1.AdmissionResponse\ntype admitv1Func func(v1.AdmissionReview) *v1.AdmissionResponse\n\nvar scheme = runtime.NewScheme()\nvar codecs = serializer.NewCodecFactory(scheme)\n\nfunc delegateV1beta1AdmitToV1(f admitv1Func) admitv1beta1Func {\n    return func(review v1beta1.AdmissionReview) *v1beta1.AdmissionResponse {\n        in := v1.AdmissionReview{Request: convertAdmissionRequestToV1(review.Request)}\n        out := f(in)\n        return convertAdmissionResponseToV1beta1(out)\n    }\n}\n\ntype admitHandler struct {\n    v1beta1 admitv1beta1Func\n    v1      admitv1Func\n}\n\nfunc convertAdmissionRequestToV1(r *v1beta1.AdmissionRequest) *v1.AdmissionRequest {\n    return &v1.AdmissionRequest{\n        Kind:               r.Kind,\n        Namespace:          r.Namespace,\n        Name:               r.Name,\n        Object:             r.Object,\n        Resource:           r.Resource,\n        Operation:          v1.Operation(r.Operation),\n        UID:                r.UID,\n        DryRun:             r.DryRun,\n        OldObject:          r.OldObject,\n        Options:            r.Options,\n        RequestKind:        r.RequestKind,\n        RequestResource:    r.RequestResource,\n        RequestSubResource: r.RequestSubResource,\n        SubResource:        r.SubResource,\n        UserInfo:           r.UserInfo,\n    }\n}\n\nfunc convertAdmissionRequestToV1beta1(r *v1.AdmissionRequest) *v1beta1.AdmissionRequest {\n    return &v1beta1.AdmissionRequest{\n        Kind:               r.Kind,\n        Namespace:          r.Namespace,\n        Name:               r.Name,\n        Object:             r.Object,\n        Resource:           r.Resource,\n        Operation:          v1beta1.Operation(r.Operation),\n        UID:                r.UID,\n        DryRun:             r.DryRun,\n        OldObject:          r.OldObject,\n        Options:            r.Options,\n        RequestKind:        r.RequestKind,\n        RequestResource:    r.RequestResource,\n        RequestSubResource: r.RequestSubResource,\n        SubResource:        r.SubResource,\n        UserInfo:           r.UserInfo,\n    }\n}\n\nfunc convertAdmissionResponseToV1(r *v1beta1.AdmissionResponse) *v1.AdmissionResponse {\n    var pt *v1.PatchType\n    if r.PatchType != nil {\n        t := v1.PatchType(*r.PatchType)\n        pt = &t\n    }\n    return &v1.AdmissionResponse{\n        UID:              r.UID,\n        Allowed:          r.Allowed,\n        AuditAnnotations: r.AuditAnnotations,\n        Patch:            r.Patch,\n        PatchType:        pt,\n        Result:           r.Result,\n        Warnings:         r.Warnings,\n    }\n}\n\nfunc convertAdmissionResponseToV1beta1(r *v1.AdmissionResponse) *v1beta1.AdmissionResponse {\n    var pt *v1beta1.PatchType\n    if r.PatchType != nil {\n        t := v1beta1.PatchType(*r.PatchType)\n        pt = &t\n    }\n    return &v1beta1.AdmissionResponse{\n        UID:              r.UID,\n        Allowed:          r.Allowed,\n        AuditAnnotations: r.AuditAnnotations,\n        Patch:            r.Patch,\n        PatchType:        pt,\n        Result:           r.Result,\n        Warnings:         r.Warnings,\n    }\n}\n\nfunc toV1AdmissionResponse(err error) *v1.AdmissionResponse {\n    return &v1.AdmissionResponse{\n        Result: &metav1.Status{\n            Message: err.Error(),\n        },\n    }\n}\n\n\n启动服务\n\n# ip地址为192.168.1.104\ngo run main.go\n\ncurl简单验证\n\n\n\n\n\n\n\n关于证书\n\n\n\nca证书是为了安全拿到 webhook服务 的公钥,具体参考https\n\n\n#  将根证书 ca.crt 复制到 任何可以访问192.168.1.104 的机器上\n#  用curl来看是否OK\ncurl --cacert ca.crt \\\n--resolve svc-mutate.default.svc:443:192.168.1.104 \\\nhttps://svc-mutate.default.svc/add-label\n\n\n\n\nservice 指定外部应用,我们的webhook服务在外部\n\napiVersion: v1\nkind: Service\nmetadata:\n  labels:\n  app: svc-mutate\n  name: svc-mutate\nspec:\n  ports:\n  - name: abc\n    port: 443\n    protocol: TCP\n    targetPort: 443\n  type: ClusterIP\n---\napiVersion: v1\nkind: Endpoints\nmetadata:\n  name: svc-mutate\n  namespace: default\nsubsets:\n- addresses:\n  - ip: 192.168.1.104 # 这个是我们go webhook 服务的ip\n  ports:\n  - port: 443\n    name: abc\n\n\n\n这个MutatingWebhookConfiguration一创建, 你再create pod 就会去回调配置里的service指向的webhook 服务\n\n\nmutate.yaml\n\napiVersion: admissionregistration.k8s.io/v1\nkind: MutatingWebhookConfiguration\nmetadata:\n  name: \"pod-policy.example.com\" # 随便起\nwebhooks:\n- name: my-webhook.example.com # 随便起\n  sideEffects: None\n  admissionReviewVersions: [\"v1\",\"v1beta1\"]\n  clientConfig:\n    service: # 指定webhook的类型, 这里是 service \n      namespace: \"default\"\n      name: \"svc-mutate\" # service 名称\n      path: \"/add-label\" # 访问路径\n    caBundle: &lt;openssl base64 -A &lt;ca.crt 的结果&gt; #(1)\n  rules:\n  - operations: [\"CREATE\"] # 所有创建的操作 都会回调这个 hook\n    apiGroups: [\"*\"]\n    apiVersions: [\"*\"]\n    resources: [\"*\"]\n    scope: \"*\"\n\n\ncaBundle 的值是 openssl base64 -A &lt;ca.crt  想要和https服务打交道, 就需要根证书(或自签名证书)\n\nk apply -f mutate.yaml\n\n\n# 我们在k8s上 随便创建一个pod ,看看\nk run --image=nginx:1.14.2-alpine ng-tmp\n# 可以看到 pod自动的添加一个label\nk get po ng-tmp --show-labels\n\n\n\n\n\n\n3.4 限流 APF",
    "crumbs": [
      "组件",
      "apiserver"
    ]
  },
  {
    "objectID": "docs/devops/k8s/component/apiserver.html#footnotes",
    "href": "docs/devops/k8s/component/apiserver.html#footnotes",
    "title": "斯巴拉稀",
    "section": "Footnotes",
    "text": "Footnotes\n\n\ndefine-clusters-users-and-contexts↩︎",
    "crumbs": [
      "组件",
      "apiserver"
    ]
  },
  {
    "objectID": "docs/devops/k8s/core/scheduler.html",
    "href": "docs/devops/k8s/core/scheduler.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "Tip\n\n\n\n\nkube-scheduler负责调度Pod到集群内的节点上,它监听kube-apiserver,查询还未分配Node的Pod\n然后根据调度策略为这些Pod分配节点(最终体现为更新Pod的spec.nodeName字段)\nkube-scheduler\npkg/scheduler/scheduler.go#New\nsnapshot := internalcache.NewEmptySnapshot()",
    "crumbs": [
      "核心概念与实战",
      "调度器"
    ]
  },
  {
    "objectID": "docs/devops/k8s/core/scheduler.html#nodename",
    "href": "docs/devops/k8s/core/scheduler.html#nodename",
    "title": "斯巴拉稀",
    "section": "1 nodeName",
    "text": "1 nodeName\n\n\n\n\n\n\nImportant\n\n\n\n直接指定节点名字,跳过调度器, 实际就没有走调度流程\n\n\napiVersion: v1\nkind: Pod\nmetadata:\n  name: nginx\nspec:\n  containers:\n  - name: nginx\n    image: nginx\n  nodeName: kube-01",
    "crumbs": [
      "核心概念与实战",
      "调度器"
    ]
  },
  {
    "objectID": "docs/devops/k8s/core/scheduler.html#nodeselector",
    "href": "docs/devops/k8s/core/scheduler.html#nodeselector",
    "title": "斯巴拉稀",
    "section": "2 nodeSelector",
    "text": "2 nodeSelector\n\n\n\n\n\n\nTip\n\n\n\n直接通过键值对将Pod调度到具有特定label的Node上\n\n\nnodeSelector\nk get no\n# 给节点打上标签\nk label nodes node1 disk-type=ssd\n# 查看节点标签\nk get nodes --show-labels\napiVersion: v1\nkind: Pod\nmetadata:\n  name: nginx\n  labels:\n    env: test\nspec:\n  containers:\n  - name: nginx\n    image: nginx\n    imagePullPolicy: IfNotPresent\n  nodeSelector:\n    disk-type: ssd",
    "crumbs": [
      "核心概念与实战",
      "调度器"
    ]
  },
  {
    "objectID": "docs/devops/k8s/core/scheduler.html#affinity",
    "href": "docs/devops/k8s/core/scheduler.html#affinity",
    "title": "斯巴拉稀",
    "section": "3 Affinity",
    "text": "3 Affinity\n\n3.1 基础介绍\n\n\n\n\n\n\nTip\n\n\n\n\n亲和: 亲近\nrequiredDuringSchedulingIgnoredDuringExecution 硬亲和\n\nrequiredDuringScheduling\n\n调度时必须满足, 比如你设置了想要调度到有标签是app=web的节点,那么节点上必须有这样的标签\n\nIgnoredDuringExecution\n\n执行时忽略, 比如你pod已经调度完在节点上运行了, 然后现在将节点上的标签app=web 删除了, 那么不会影响这个pod\n\n\npreferredDuringSchedulingIgnoredDuringExecution 软亲和\n\npreferredDuringScheduling\n\n调度时最好满足, 首选这样的节点.\n\nIgnoredDuringExecution\n\n同硬亲和\n\n\n\n\n\n\n\n查看说明\n\nk explain pod.spec.affinity.nodeAffinity\nk explain pod.spec.affinity.podAffinity\nk explain pod.spec.affinity.podAntiAffinity\n\n\n\n3.2 节点亲和性\n\n\n\n\n\n\nTip\n\n\n\n\nNodeSelector 的升级版,也是用labels来约束, 支持更丰富的配置规则,使用更灵活\n如果 nodeSelector 和 nodeAffinity 两者都指定,那 node 需要两个条件都满足,pod 才能调度\n\n\n\n节点亲和性\napiVersion: v1\nkind: Pod\nmetadata:\n  name: nginx\nspec:\n  affinity:\n    nodeAffinity:\n1      requiredDuringSchedulingIgnoredDuringExecution:\n2        nodeSelectorTerms:\n3        - matchExpressions:\n          - key: disk-type\n4            operator: In\n            values:\n            - ssd\n5      preferredDuringSchedulingIgnoredDuringExecution:\n6      - weight: 1\n7        preference:\n          matchExpressions:\n          - key: label-1\n            operator: In\n            values:\n            - key-1\n      - weight: 50\n        preference:\n          matchExpressions:\n          - key: label-2\n            operator: In\n            values:\n            - key-2\n  containers:\n  - name: nginx\n    image: nginx\n    imagePullPolicy: IfNotPresent\n\n1\n\n硬亲和力配置,必须符合\n\n2\n\n节点选择器配置, 可以配置多个matchExpressions,满足一个即可\n\n3\n\n可以配置多个key, 必须都满足\n\n4\n\n这里表示节点必须包含键名为 disk-type 的标签,并且其值为ssd\n\n5\n\n软亲和力配置,表示最好符合\n\n6\n\n软亲和力的权重, 权重越高优先级越大,范围1-100\n\n7\n\n软亲和力配置项,和weight同级\n\n\n如果存在两个候选节点,都满足 requiredDuringSchedulingIgnoredDuringExecution 规则,其中一个节点具有标签 label-1:key-1,另一个节点具有标签 label-2:key-2, 调度器会考察各个节点的 weight 取值，并将该权重值添加到节点的其他得分值之上\n\n\n3.3 pod间 亲和性和反亲和性\n\n\n\n\n\n\nTip\n\n\n\n\nPodAffinity : 想要和含有某些标签的pod 部署在”一起” (一个topology中)\npodAntiAffinity: 与PodAffinity 相反\n\n\n\npod-affinity\n\n\n\n\n\n\n什么是topologyKey\n\n\n\n\n\n\n拓扑域,主要针对节点进行区域的划分,比如服务器有华东区这类的,{==用节点的label进行判断==},key相同且value也相同才是属于同一个的拓扑域\n对于 Pod 亲和性而言,在 requiredDuringSchedulingIgnoredDuringExecution 和 preferredDuringSchedulingIgnoredDuringExecution 中,topologyKey 不允许为空\n对于 requiredDuringSchedulingIgnoredDuringExecution 要求的 Pod 反亲和性, 准入控制器 LimitPodHardAntiAffinityTopology 要求 topologyKey 只能是 kubernetes.io/hostname. 如果你希望使用其他定制拓扑逻辑,你可以更改准入控制器或者禁用之\n\nk explain pod.spec.affinity.podAffinity.requiredDuringSchedulingIgnoredDuringExecution.topologyKey\n# 节点默认都有一个 标签\nk get no --show-labels\n\n#我们能看到各个节点应该都有这样一个标签\nkubernetes.io/hostname=xxx\n#  我们可以给不同的节点设置相同的标签, 后续可以用以表示它们在同一个topology\nk label no node1 node2 area=north\n\n\n\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: redis-cache\nspec:\n  selector:\n    matchLabels:\n      app: store\n  replicas: 3\n  template:\n    metadata:\n      labels:\n        app: store\n    spec:\n      affinity:\n        podAntiAffinity:\n          requiredDuringSchedulingIgnoredDuringExecution:\n          - labelSelector:\n              matchExpressions:\n              - key: app\n                operator: In\n                values:\n                - store\n            topologyKey: \"kubernetes.io/hostname\"\n      containers:\n      - name: redis-server\n        image: redis:3.2-alpine\n\n反亲和性规则表示: Pod 不能被调度到这样的节点(集群/域)中\n\n具有标签kubernetes.io/hostname=xxx的节点们(集群),或说在这样一个名字叫kubernetes.io/hostname=xxx的域中\n且 集群(或域)中至少有一个节点运行着一个带有 app=store 标签的 Pod\n\n首先第一个redis副本, 因为现在虽然每个节点都有kubernetes.io/hostname的标签,但是没有运行着 app=store标签 的pod,所以随便选一个节点部署第一个redis副本,比如node1\n部署第一个redis副本后, 这个时候出现了这样的节点\n\n运行着带有 app=store 标签的 Pod,且节点具有标签kubernetes.io/hostname=node1\n\n部署第二个redis副本, 这个时候发现 node1 是不符合的, 因为有 app=store 的pod 且节点有标签是kubernetes.io/hostname,那么就在其他节点上随便选一个\n部署第三个同理, 这样就会将3个redis 部署到不同的节点上去了.\n\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: web-server\nspec:\n  selector:\n    matchLabels:\n      app: web-store\n  replicas: 3\n  template:\n    metadata:\n      labels:\n        app: web-store\n    spec:\n      affinity:\n        podAntiAffinity:\n          requiredDuringSchedulingIgnoredDuringExecution:\n          - labelSelector:\n              matchExpressions:\n              - key: app\n                operator: In\n                values:\n                - web-store\n            topologyKey: \"kubernetes.io/hostname\"\n        podAffinity:\n          requiredDuringSchedulingIgnoredDuringExecution:\n          - labelSelector:\n              matchExpressions:\n              - key: app\n                operator: In\n                values:\n                - store\n            topologyKey: \"kubernetes.io/hostname\"\n      containers:\n      - name: web-app\n        image: nginx:1.16-alpine\n\n现在我们可以马上理解,根据反亲和性规则 ,它们3个副本肯定会部署到不同的节点上\n接着根据亲和性规则: pod要被调度到这样的节点(集群/域)中\n\n具有标签kubernetes.io/hostname=xxx的节点们(集群),或说在这样一个名字叫kubernetes.io/hostname=xxx的域中\n且 集群(或域)中至少有一个节点运行着一个带有 app=store 标签的 Pod\n\n根据前面的redis副本, 现在3个节点是 有app=store标签的pod运行,然后节点标签具有kubernetes.io/hostname=xxx,它们符合亲和性规则\n第一个副本随机选择一个 redis所在的节点, 然后第二个根据反亲和会选择另外一个 redis所在的节点, 第三个同理\n\n最后的结果\n\n\n\nnode-1\nnode-2\nnode-3\n\n\n\n\nweb-server-1\nweb-server-2\nweb-server-3\n\n\nredis-cache-1\nredis-cache-2\nredis-cache-3",
    "crumbs": [
      "核心概念与实战",
      "调度器"
    ]
  },
  {
    "objectID": "docs/devops/k8s/core/scheduler.html#taint与toleration",
    "href": "docs/devops/k8s/core/scheduler.html#taint与toleration",
    "title": "斯巴拉稀",
    "section": "4 Taint与Toleration",
    "text": "4 Taint与Toleration\n\n4.1 基础介绍\n\n\n\n\n\n\nTip\n\n\n\n\nTaint: 污点\nToleration: 容忍\n原理:一旦某个节点被加上了一个Taint(理解为被打上了”污点”),那么正常情况下所有Pod都嫌这样的节点”脏”,都不会在这样的节点上运行\n除非有个别的Pod声明自己能”容忍”这个”污点”,即声明了Toleration, 这样它可以在这个节点上运行\nToleration是让Pod容忍节点上设置的污点Taint\npod有容忍不是说你就会调度到有个污点的节点, 只是说你这个pod可以调度到有这个污点的节点\n节点可以有多个污点, pod必须全部容忍这些污点才能够调度到该节点\n\n\n\n\n\n\n\n\n\nNote\n\n\n\n就像找男/女朋友, 不能容忍对方的缺点,pass, 可以容忍,ok\n\n\n\n污点类型说明\n\n\n\n\n\n\nTaint 效果(类型)\n解释\n\n\n\n\nNoSchedule\n\n节点打上污点后,禁止调度到该节点\n已经在该节点上的Pod不受影响,容忍这个污点的pod可以被调度到这个节点\n\n\n\nNoExecute\n\n节点打上污点后,禁止调度到该节点\n已经在该节点上的,但没有容忍这个污点的pod，会立马被驱逐\n如果pod容忍了污点但是设置了tolerationSeconds,则表示pod容忍含这个污点的节点tolerationSeconds秒后(容忍也有个限度),被驱逐\n如果pod容忍了污点,且没有设置tolerationSeconds,那么可以被调度到该节点,不会被驱逐\n单独的pod被驱逐后不会重新调度\n\n\n\nPreferNoSchedule\n\n节点被打上key=value:PreferNoSchedule 的污点, 你想要pod调度到这样的节点, pod是无需有对这个污点的容忍 |\n这个PreferNoSchedule表示尽量避免将Pod调度到这样的节点上，如果没有更合适的节点，可以部署到该节点\n\n\n\n\n\n\n4.2 污点操作命令\n\n\n\n\n\n\nImportant\n\n\n\nkey 和effect一起 才能表示 是否是同一个 污点\n\n\n\n增查删改\n\n\n#创建一个污点(一个节点可以有多个污点):\n# TAINT_VALUE可以不写, 就是 =TAINT_VALUE  不写\nk taint nodes NODE_NAME TAINT_KEY=TAINT_VALUE:EFFECT\nk taint nodes node01 ssd=true:PreferNoSchedule\n\n\nk describe no node1 |grep taint -iA 10\nk describe no master1 |grep taint -iA 10\n    # master 默认是不会被调度到的.\n    Taints:             node-role.kubernetes.io/master:NoSchedule\n\n\nk taint no node1 hello=tomcat:NoSchedule-\nk taint no node1 hello:NoSchedule- # 这样就可以了. 因为同样的key只会有一个\nk taint no node1 hello-  #删除这个key的所有污点 (不同的effect)\n\n\n# key 和effect 作为 区分不同的 污点\n# 修改 key为hello effect为NoSchedule 的污点的 value值, 没有就创建该污点\nk taint no node1 hello=world:NoSchedule --overwrite\n\n\n\n\n\n4.3 污点相关配置\n\n4.3.1 内置污点\nnode.kubernetes.io/not-ready:节点未准备好，相当于节点状态Ready的值为False。\nnode.kubernetes.io/unreachable:Node Controller访问不到节点，相当于节点状态Ready的值为Unknown。\nnode.kubernetes.io/out-of-disk:节点磁盘耗尽。\nnode.kubernetes.io/memory-pressure:节点存在内存压力。\nnode.kubernetes.io/disk-pressure:节点存在磁盘压力。\nnode.kubernetes.io/network-unavailable:节点网络不可达。\nnode.kubernetes.io/unschedulable:节点不可调度。\nnode.cloudprovider.kubernetes.io/uninitialized:如果Kubelet启动时指定了一个外部的cloudprovider,它\n将给当前节点添加一个Taint将其标记为不可用。在cloud-controller-manager的一个controller初始化这个 节点后，Kubelet将删除这个Taint。\n\n\n4.3.2 不可用多久才会被打上污点\nkube-controller-manager 参数\n\n\n/etc/kubernetes/manifests/kube-controller-manager.yaml 相关配置\n\nspec:\n  containers:\n  - command:\n    - kube-controller-manager\n    - ...\n1    - --node-monitor-grace-period=40s\n2    - --node-monitor-period=5s\n    - ...\n\n\n1\n\n添加这个 默认是40s, 表示40s 内一直不可用,就会被打上污点\n\n2\n\n5s会去探测一次节点是否可用\n\n\n\n\n\n\n\n\nCaution\n\n\n\n\n你的节点发生故障, pod需要等待40s+pod对污点的容忍时间tolerationSeconds\n可以准备2个节点,将node1 关机, 查看 k get no 看状态, 大概40s 才会看到 not_ready\n\n\n\n\n\n\n4.4 pod默认容忍\napiVersion: v1\nkind: Pod\nmetadata:\n  name: nginx\n  labels:\n    env: test\nspec:\n  containers:\n  - name: nginx\n    image: nginx:1.14.2\n    imagePullPolicy: IfNotPresent\n# 创建后\nk get pod nginx2 -o yaml|grep tolerations: -iA 10\n  tolerations:\n  - effect: NoExecute\n1    key: node.kubernetes.io/not-ready\n    operator: Exists\n    tolerationSeconds: 300\n  - effect: NoExecute\n    key: node.kubernetes.io/unreachable\n    operator: Exists\n    tolerationSeconds: 300\n\n1\n\n节点没有ready时会打上这样的污点,在节点上的pod(被控制器管理的pod)默认会等待5m中才会被驱逐,重新调度\n\n\n\n\n\n\n\n\nCaution\n\n\n\n\n你可能会疑问, 出了问题, pod 5m后才会被重新调度, 是不是有点长了.\n这个设置的原因是一般情况下节点是短暂的网络中断或临时故障,时间不会太长,这样做的目的是避免在节点暂时不可用的情况下频繁地驱逐和重建 Pod，以减少不必要的服务中断和资源浪费\n\n\n\n\n\n\n\n\n\n如果你确定节点会故障较长一段时间\n\n\n\n\n\ntoleration-patch.yaml\n\nspec:\n  tolerations:\n  - effect: NoExecute\n    key: node.kubernetes.io/not-ready\n    operator: Exists\n    tolerationSeconds: 60\n\n# 更新\nk patch po nginx2 --patch \"$(cat toleration-patch.yaml)\"\n\n\n\n\n4.5 pod容忍度操作命令\n\nkey value effect完全匹配容忍key,effect匹配的节点容忍key匹配的节点容忍所有污点\n\n\napiVersion: v1\nkind: Pod\nmetadata:\n  name: nginx\n  labels:\n    env: test\nspec:\n  containers:\n  - name: nginx\n    image: nginx\n    imagePullPolicy: IfNotPresent\n  tolerations:\n  - key: \"key1\"\n    operator: \"Equal\"\n    value: \"value1\"\n    effect: \"NoExecute\"\n1    tolerationSeconds: 3600\n\n1\n\n如果有这个设置,表示容忍这个节点3600s后,驱逐\n\n\n\n\napiVersion: v1\nkind: Pod\nmetadata:\n  name: nginx\n  labels:\n    env: test\nspec:\n  containers:\n  - name: nginx\n    image: nginx\n    imagePullPolicy: IfNotPresent\n  tolerations:\n  - key: \"key1\"\n    operator: \"Exists\"\n    effect: \"NoSchedule\"\n\n\n\n\n\n\n\n\nNote\n\n\n\n无需效果effect 匹配\n\n\napiVersion: v1\nkind: Pod\nmetadata:\n  name: nginx\n  labels:\n    env: test\nspec:\n  containers:\n  - name: nginx\n    image: nginx\n    imagePullPolicy: IfNotPresent\n  tolerations:\n  - key: \"key1\"\n    operator: \"Exists\"\n\n\napiVersion: v1\nkind: Pod\nmetadata:\n  name: nginx\nlabels:\n    env: test\nspec:\n  containers:\n  - name: nginx\n    image: nginx\n    imagePullPolicy: IfNotPresent\n  tolerations:\n  - operator: \"Exists\"\n\n\n\n\n\n4.6 问题答疑\n\n\n\n\n\n\n指定有污点的nodeName的pod 会如何?\n\n\n\n\n没有设置容忍的情况下,也会先创建pod,因为指定了nodeName就会跳过调度器,然后才会根据节点上污点的effect做相关行为\n比如\n\nnode1有 k=v:NoExecute, pod 设置nodeName=node1\n通过describe pod 可以看到pod 创建 并Started , 后马上就被驱逐了(但是describe 看不到)\n可以给pod 设置一个preStop sleep 20 这样可以看到…",
    "crumbs": [
      "核心概念与实战",
      "调度器"
    ]
  },
  {
    "objectID": "docs/devops/k8s/core/persistence.html",
    "href": "docs/devops/k8s/core/persistence.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "Tip\n\n\n\n\n容器中的磁盘文件是短暂的,{==容器重启后==},会以最干净的状态启动,之前的文件就会丢失\n一个pod里有多个容器,可能需要共享一些文件的情况\n数据需要持久化的情况\n\n\n\nkubectl explain pod.spec.volumes\n# 注意这个是 pod的\nkubectl explain pod.spec.volumes.emptyDir\n# 定义完 pod的后,我们需要定义pod中容器的 volume mount\nkubectl explain pod.spec.containers.volumeMounts\n官方文档\n\n\n\n\n\n\n\n\nTip\n\n\n\n\n当 Pod 因为某些原因被从节点上删除时，emptyDir 卷中的数据也会被永久删除\n容器崩溃重启并不会导致 Pod 被从节点上移除，因此容器崩溃期间 emptyDir 卷中的数据是安全\n实际是将节点上的目录挂载到 Pod 中的不同容器的不同或相同位置,所以他们可以共享数据,因为实际读的是节点上的目录\n\n\n\n# 创建一个pod ,里面有2个容器,一个写入数据到index.html\n# 一个读取\napiVersion: v1\nkind: Pod\nmetadata:\n  name: pod-vol-empty-dir\n  # namespace: test\nspec:\n  volumes:\n  - name: html\n    emptyDir: {}\n    #emptyDir:\n    #   medium: Memory\n  containers: # 这里配置了2个容器,挂载到自己容器里不同的目录\n  - name: nginx-c\n    image: nginx:1.12-alpine\n    volumeMounts:\n    - name: html          # 这个必须是上面定义的volumes中的name\n      mountPath: /usr/share/nginx/html # 挂载到容器里的哪个目录\n  - name: make-page-c\n    image: alpine\n    volumeMounts:\n    - name: html\n      mountPath: /html # 挂载到不同的目录\n    command: [\"/bin/sh\", \"-c\"]\n    args:\n    - while true; do\n        echo $(hostname) $(date) &gt;&gt; /html/index.html;\n        sleep 10;\n      done\n\n\n查看卷在节点中的位置\n\nk get po -o wide # 先看在哪个节点\nk get po pod-vol-empty-dir -o yaml\n    uid: 8c809c4c-6b74-4088-b416-d7dd11743cdb\n# 去对应的节点上\ncd /var/lib/kubelet/pods/8c809c4c-6b74-4088-b416-d7dd11743cdb\ntree -L 2\n  .\n  ├── containers\n  │   ├── make-page-c\n  │   └── nginx-c\n  ├── etc-hosts\n  ├── plugins\n  │   └── kubernetes.io~empty-dir\n  └── volumes\n      ├── kubernetes.io~empty-dir\n      └── kubernetes.io~projected\ntree volumes/kubernetes.io~empty-dir\n  volumes/kubernetes.io~empty-dir\n  └── html\n      └── index.html\n# 在 这个节点上的html目录增加文件, 2个容器都能看到\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\n将主机节点文件系统上的文件或目录挂载到你的 Pod 中\n\n\nhostPath\napiVersion: v1\nkind: Pod\nmetadata:\n  name: test-pd\nspec:\n  containers:\n  - image: nginx:1.14.2\n    name: test-container\n    volumeMounts:\n    - mountPath: /usr/share/nginx/html\n      name: test-volume\n  volumes:\n  - name: test-volume\n    hostPath:\n      # 宿主上目录位置\n      path: /nginx_html\n      #  如果宿主机上没有 该目录则创建\n      type: DirectoryOrCreate\nk get po -o wide\n  test-pd             1/1     Running   0          78s   10.244.1.45   node1\n# 到相应的节点上\necho hello &gt; /nginx_html/index.html\ncurl 10.244.1.45 # 显示hello\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nnfs 卷能将 NFS (网络文件系统) 挂载到你的 Pod 中。 不像 emptyDir 那样会在删除 Pod 的同时也会被删除，nfs 卷的内容在删除 Pod 时会被保存，卷只是被卸载。 这意味着 nfs 卷可以被预先填充数据，并且这些数据可以在 Pod 之间共享\n\n\n\n\n服务端安装\n\n#在一台主机上安装 ,这里我们直接用一个节点来. (当然如果你服务器多.就用一个新的.)\n# 这里我们用node1节点\nyum install nfs-utils rpcbind -y\nsystemctl start nfs-server\n# 查看当前nf服务所支持的版本\ncat /proc/fs/nfsd/versions\n\n# 1. 创建一个你要共享的目录\nmkdir -p /data/nfs\nchown 755 /data/nfs\n#nfsnobody 安装启动nfs服务后有的一个用户\nchown -R nfsnobody.nfsnobody /data/nfs\nsystemctl start nfs \nsystemctl start  rpcbind\n\n# *号 位可以设置成ip段 192.168.124.0/24 表示这些ip段的才可以访问\necho \"/data/nfs *(rw,sync,no_subtree_check,no_root_squash)\" &gt;&gt; /etc/exports\n# 这个不行...\n#echo \"/data/nfs *(rw,sync,all_squash)\" &gt;&gt; /etc/exports\nexportfs -r # 更新配置,重新读取配置\nexportfs #显示共享了哪些目录\nsystemctl restart nfs\nsystemctl restart  rpcbind\necho \"hello\" &gt; /data/nfs/index.html\n\n\n\n其他节点上挂载\n\n# node1 的ip地址 192.168.66.110\n# /nfs 你本地想要挂载到的目录, 随便创建一个, 需要有\nmkdir /nfs\nmount -t nfs -o rw,nosuid,noexec,nodev 192.168.66.110:/data/nfs /nfs\nll /nfs # 能看到index.html\n\n\n\npod-vol-nfs.yaml\n\napiVersion: v1\nkind: Pod\nmetadata:\n  name: pod-vol-nfs\n  labels:\n    app: nginx\nspec:\n  containers:\n  - name: nginx\n    image: nginx:1.14.2\n    volumeMounts:\n    - mountPath: /usr/share/nginx/html\n      name: nginx-data\n  volumes:\n    - name: nginx-data\n      nfs:\n        server: 192.168.66.110 # 就是nfs服务端的ip\n        path: /data/nfs  #nfs服务器里 共享的目录\n\nk create -f  pod-vol-nfs.yaml\n# curl pod ip 可以看到hello",
    "crumbs": [
      "核心概念与实战",
      "存储管理"
    ]
  },
  {
    "objectID": "docs/devops/k8s/core/persistence.html#卷挂载",
    "href": "docs/devops/k8s/core/persistence.html#卷挂载",
    "title": "斯巴拉稀",
    "section": "",
    "text": "Tip\n\n\n\n\n容器中的磁盘文件是短暂的,{==容器重启后==},会以最干净的状态启动,之前的文件就会丢失\n一个pod里有多个容器,可能需要共享一些文件的情况\n数据需要持久化的情况\n\n\n\nkubectl explain pod.spec.volumes\n# 注意这个是 pod的\nkubectl explain pod.spec.volumes.emptyDir\n# 定义完 pod的后,我们需要定义pod中容器的 volume mount\nkubectl explain pod.spec.containers.volumeMounts\n官方文档\n\n\n\n\n\n\n\n\nTip\n\n\n\n\n当 Pod 因为某些原因被从节点上删除时，emptyDir 卷中的数据也会被永久删除\n容器崩溃重启并不会导致 Pod 被从节点上移除，因此容器崩溃期间 emptyDir 卷中的数据是安全\n实际是将节点上的目录挂载到 Pod 中的不同容器的不同或相同位置,所以他们可以共享数据,因为实际读的是节点上的目录\n\n\n\n# 创建一个pod ,里面有2个容器,一个写入数据到index.html\n# 一个读取\napiVersion: v1\nkind: Pod\nmetadata:\n  name: pod-vol-empty-dir\n  # namespace: test\nspec:\n  volumes:\n  - name: html\n    emptyDir: {}\n    #emptyDir:\n    #   medium: Memory\n  containers: # 这里配置了2个容器,挂载到自己容器里不同的目录\n  - name: nginx-c\n    image: nginx:1.12-alpine\n    volumeMounts:\n    - name: html          # 这个必须是上面定义的volumes中的name\n      mountPath: /usr/share/nginx/html # 挂载到容器里的哪个目录\n  - name: make-page-c\n    image: alpine\n    volumeMounts:\n    - name: html\n      mountPath: /html # 挂载到不同的目录\n    command: [\"/bin/sh\", \"-c\"]\n    args:\n    - while true; do\n        echo $(hostname) $(date) &gt;&gt; /html/index.html;\n        sleep 10;\n      done\n\n\n查看卷在节点中的位置\n\nk get po -o wide # 先看在哪个节点\nk get po pod-vol-empty-dir -o yaml\n    uid: 8c809c4c-6b74-4088-b416-d7dd11743cdb\n# 去对应的节点上\ncd /var/lib/kubelet/pods/8c809c4c-6b74-4088-b416-d7dd11743cdb\ntree -L 2\n  .\n  ├── containers\n  │   ├── make-page-c\n  │   └── nginx-c\n  ├── etc-hosts\n  ├── plugins\n  │   └── kubernetes.io~empty-dir\n  └── volumes\n      ├── kubernetes.io~empty-dir\n      └── kubernetes.io~projected\ntree volumes/kubernetes.io~empty-dir\n  volumes/kubernetes.io~empty-dir\n  └── html\n      └── index.html\n# 在 这个节点上的html目录增加文件, 2个容器都能看到\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\n将主机节点文件系统上的文件或目录挂载到你的 Pod 中\n\n\nhostPath\napiVersion: v1\nkind: Pod\nmetadata:\n  name: test-pd\nspec:\n  containers:\n  - image: nginx:1.14.2\n    name: test-container\n    volumeMounts:\n    - mountPath: /usr/share/nginx/html\n      name: test-volume\n  volumes:\n  - name: test-volume\n    hostPath:\n      # 宿主上目录位置\n      path: /nginx_html\n      #  如果宿主机上没有 该目录则创建\n      type: DirectoryOrCreate\nk get po -o wide\n  test-pd             1/1     Running   0          78s   10.244.1.45   node1\n# 到相应的节点上\necho hello &gt; /nginx_html/index.html\ncurl 10.244.1.45 # 显示hello\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nnfs 卷能将 NFS (网络文件系统) 挂载到你的 Pod 中。 不像 emptyDir 那样会在删除 Pod 的同时也会被删除，nfs 卷的内容在删除 Pod 时会被保存，卷只是被卸载。 这意味着 nfs 卷可以被预先填充数据，并且这些数据可以在 Pod 之间共享\n\n\n\n\n服务端安装\n\n#在一台主机上安装 ,这里我们直接用一个节点来. (当然如果你服务器多.就用一个新的.)\n# 这里我们用node1节点\nyum install nfs-utils rpcbind -y\nsystemctl start nfs-server\n# 查看当前nf服务所支持的版本\ncat /proc/fs/nfsd/versions\n\n# 1. 创建一个你要共享的目录\nmkdir -p /data/nfs\nchown 755 /data/nfs\n#nfsnobody 安装启动nfs服务后有的一个用户\nchown -R nfsnobody.nfsnobody /data/nfs\nsystemctl start nfs \nsystemctl start  rpcbind\n\n# *号 位可以设置成ip段 192.168.124.0/24 表示这些ip段的才可以访问\necho \"/data/nfs *(rw,sync,no_subtree_check,no_root_squash)\" &gt;&gt; /etc/exports\n# 这个不行...\n#echo \"/data/nfs *(rw,sync,all_squash)\" &gt;&gt; /etc/exports\nexportfs -r # 更新配置,重新读取配置\nexportfs #显示共享了哪些目录\nsystemctl restart nfs\nsystemctl restart  rpcbind\necho \"hello\" &gt; /data/nfs/index.html\n\n\n\n其他节点上挂载\n\n# node1 的ip地址 192.168.66.110\n# /nfs 你本地想要挂载到的目录, 随便创建一个, 需要有\nmkdir /nfs\nmount -t nfs -o rw,nosuid,noexec,nodev 192.168.66.110:/data/nfs /nfs\nll /nfs # 能看到index.html\n\n\n\npod-vol-nfs.yaml\n\napiVersion: v1\nkind: Pod\nmetadata:\n  name: pod-vol-nfs\n  labels:\n    app: nginx\nspec:\n  containers:\n  - name: nginx\n    image: nginx:1.14.2\n    volumeMounts:\n    - mountPath: /usr/share/nginx/html\n      name: nginx-data\n  volumes:\n    - name: nginx-data\n      nfs:\n        server: 192.168.66.110 # 就是nfs服务端的ip\n        path: /data/nfs  #nfs服务器里 共享的目录\n\nk create -f  pod-vol-nfs.yaml\n# curl pod ip 可以看到hello",
    "crumbs": [
      "核心概念与实战",
      "存储管理"
    ]
  },
  {
    "objectID": "docs/devops/k8s/core/persistence.html#投射卷",
    "href": "docs/devops/k8s/core/persistence.html#投射卷",
    "title": "斯巴拉稀",
    "section": "2 投射卷",
    "text": "2 投射卷\n官方文档",
    "crumbs": [
      "核心概念与实战",
      "存储管理"
    ]
  },
  {
    "objectID": "docs/devops/k8s/core/persistence.html#pv-pvc",
    "href": "docs/devops/k8s/core/persistence.html#pv-pvc",
    "title": "斯巴拉稀",
    "section": "3 pv pvc",
    "text": "3 pv pvc\n\n3.1 概念\n\n\n\n\n\n\n\nTip\n\n\n\n\n一个pod 可以关联多个pvc, 一个pvc 只能绑定一个pv, 一个pv 可以被多个pvc 绑定\n\n\n\n\n\n3.2 创建pv\n\n\npv-nfs-1.yaml\n\napiVersion: v1\nkind: PersistentVolume\nmetadata:\n  name: pv-nfs-1\n  labels:\n    release: stable\nspec:\n1  capacity:\n2    storage: 100Mi\n9  volumeMode: Filesystem\n3  accessModes:\n    - ReadWriteMany\n4  # storageClassName: nfsslow\n5  persistentVolumeReclaimPolicy: Retain\n6  nfs:\n7    path:  \"/data/nfs\"\n8    server: 192.168.66.110\n\n\n1\n\n容量配置,并不是说你设置多少,就只能给这么多, 这需要你的后端存储的支持\n\n2\n\nGi表示以1024 来算的, 如果写5G表示以1000来算\n\n3\n\n该PV的访问模式, ReadWriteMany(表示可以被多个node节点读写,有些支持,有些不支持) ReadWriteOnce 等\n\n4\n\npv的类型,多个不同的pv可以有相同的类型,用于PVC 想要绑定什么类型的pv,pvc设置的时候也有这个字段,写上它想要的pv类型\n\n5\n\npv回收策略\n\n6\n\npv 申请的空间从哪里来\n\n7\n\nNFS上的共享目录\n\n8\n\nNFS的IP地址\n\n9\n\n卷的模式, 目前支持Filesystem(文件系统)和Block(块),其中Block类型需要后端存储支持,默认为文件系统\n\n\n\npv的回收策略\n\n\n\n\n\n\n策略\n描述\n\n\n\n\nRetain\n默认就是Retain,就是说删除pvc的时候,他绑定的pv保留,数据也保留\n\n\nRecycle\n表示pv里数据删除,但是pv还是保留的. k8s会创建一个pod .里面有rm 命令 来进行对数据删除\n\n\ndelete\n删除pvc时, 同时删除pv (deprecated: 表示强烈的不推荐)\n\n\n\n\npv 的状态\n\n\npv 的STATUS\n描述\n\n\n\n\nAvailable\n可用，没有被PVC绑定的空闲资源\n\n\nBound\n已绑定，已经被PVC绑定\n\n\nReleased\n已释放，PVC被删除，但是资源还未被重新使用\n\n\nFailed\n失败，自动回收失败\n\n\n\nk get pv\nNAME       CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS      CLAIM   STORAGECLASS   REASON   AGE\npv-nfs-1   100Mi      RWX            Retain           Available                                   1s\n\n\n3.3 创建pvc\n\n\npvc-nfs-1.yaml\n\napiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n  name: pvc-nfs-1\nspec:\n  accessModes:\n1    - ReadWriteMany\n  volumeMode: Filesystem\n  resources:\n    requests:\n2      storage: 100Mi\n3  selector:\n    matchLabels:\n      release: \"stable\"\n\n\n1\n\n注意 这个要与 pv一致\n\n2\n\n对应的pv 必须大于等于这个大小\n\n3\n\n标签过滤选择哪个 pv,也可以不用写,这样pvc选择的时候可能就是看需要的容量了\n\n\n# pvc 的状态 Bound\nk get pvc\n# 可以看到 pvc对象的volumeName字段 设置为了pv的名字pv-nfs-1,这就是表示pvc绑定了pv\nk get pvc pvc-nfs-1 -o yaml  |grep volumeName\n# pv 的状态变成Bound, CLAIM 显示成 pvc的name\nk get pv\nNAME          CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS   CLAIM               STORAGECLASS   REASON   AGE\npv-nfs-1       100Mi      RWX            Retain          Bound    default/pvc-nfs-1                           101s\n\n\n3.4 创建pod绑定pvc\napiVersion: v1\nkind: Pod\nmetadata:\n  name: pod-pv-pvc\nspec:\n  containers:\n  - name: nginx\n    image: nginx:1.14.2\n    volumeMounts:\n    - name: ng-data\n      mountPath: /usr/share/nginx/html\n  volumes:\n  - name: ng-data\n    persistentVolumeClaim: # 指定pvc的name\n      claimName: pvc-nfs-1\n\n\n3.5 storageClass\n官方文档\n\n\n\n\n\n\nTip\n\n\n\nstorageClass 没有命名空间一说. 只能有一个默认的 sc, 如果设置多个, 那么创建pvc 未指定 storageClassName 会报错 Internal error occurred: 2 default StorageClasses were found\n\n\nk get storageclass -A\nk get sc -A \n我们前面创建时没有指定storageClassName ,实际上会设置为默认的那个sc. 除非你设置为 “” 空字符串\n\n\n下面的显示是举个例子, 默认的会显示 (default)\n\nNAME                 PROVISIONER               AGE\nstandard (default)   kubernetes.io/gce-pd      1d\ngold                 kubernetes.io/gce-pd      1d\n\napiVersion: storage.k8s.io/v1\nkind: StorageClass\nmetadata:\n  name: example-nfs\nprovisioner: example.com/external-nfs\nparameters:\n  server: nfs-server.example.com\n  path: /share\n  readOnly: \"false\"\n# 正常情况下你要创建一个能用的 sc, provisioner 要有,这里我做个测试.\n# 创建完比后, 设置为默认\nk annotate sc example-nfs storageclass.kubernetes.io/is-default-class=true\n\n\npvc-nfs-2.yaml\n\napiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n  name: pvc-nfs-2\nspec:\n  accessModes:\n    - ReadWriteMany # (1)\n  volumeMode: Filesystem\n  resources:\n    requests:\n      storage: 500Mi\n\nk create -f pvc-nfs-2.yaml\nk get pvc #发现是pending 状态\n# storageClassName: example-nfs pv的storageClassName已经被设置为默认的了.\n# 因为这个 sc 不ok, 所以没有动态创建pv\nk get pvc pvc-nfs-2 -o yaml \n\n\npv-2.yaml\n\napiVersion: v1\nkind: PersistentVolume\nmetadata:\n  name: pv-nfs-0002\n  labels:\n    release: stable\nspec:\n  capacity: #\n    storage: 500Mi #\n  volumeMode: Filesystem\n  accessModes: #\n    - ReadWriteMany\n  persistentVolumeReclaimPolicy: Recycle\n  storageClassName: example-nfs\n  nfs:\n    path:  \"/data/nfs/abc\"\n    server: 192.168.66.110\n\n创建这个pv后, 我们发现上面的 pvc 与pv 绑定了, 说明有这个storageClassName的pv 的应该优先级更高\n\n3.5.1 nfs\nnfs storage class\nNFS subdir 外部驱动\nhelm repo add nfs-subdir-external-provisioner https://kubernetes-sigs.github.io/nfs-subdir-external-provisioner/\n# 先 pull  看是否能下载下来,  / 左边是 上面添加的repo名\nhelm pull nfs-subdir-external-provisioner/nfs-subdir-external-provisioner\n# 会在当前目录下 看到  下载的文件 nfs-subdir-external-provisioner-4.0.18.tgz\ntar xf nfs-subdir-external-provisioner-4.0.18.tgz\ncd nfs-subdir-external-provisioner\ntree\n  .\n  ├── Chart.yaml\n  ├── ci\n  │   └── test-values.yaml\n  ├── README.md\n  ├── templates\n  │   ├── clusterrolebinding.yaml\n  │   ├── clusterrole.yaml\n  │   ├── deployment.yaml\n  │   ├── _helpers.tpl\n  │   ├── persistentvolumeclaim.yaml\n  │   ├── persistentvolume.yaml\n  │   ├── poddisruptionbudget.yaml\n  │   ├── podsecuritypolicy.yaml\n  │   ├── rolebinding.yaml\n  │   ├── role.yaml\n  │   ├── serviceaccount.yaml\n  │   └── storageclass.yaml\n  └── values.yaml  #修改这个文件\n\n自己构建nfs-subdir-external-provisioner镜像\n\n\nvalue.yaml 部分要修改的内容\n\nreplicaCount: 1\nstrategyType: Recreate\n\nimage:\n1  repository: registry.cn-hangzhou.aliyuncs.com/your-namespace/nfs-subdir-external-provisioner\n2  tag: v4.0.18\n  pullPolicy: IfNotPresent\nimagePullSecrets: [\n3  {\"name\":\"regcred\"}\n]\n\nnfs:\n  server: 192.168.66.110\n  path: /data/nfs\n  mountOptions:\n  volumeName: nfs-subdir-external-provisioner-root\n  # Reclaim policy for the main nfs volume\n  reclaimPolicy: Retain\n\n\n1\n\n自己构建的镜像地址\n\n2\n\n镜像版本\n\n3\n\ndocker login aliyun 后创建的secret 名\n\n\n# 上面使用了自己的aliyun 镜像仓库\ndocker login --username=your-name registry.cn-hangzhou.aliyuncs.com\nkubectl create secret generic regcred \\\n    --from-file=.dockerconfigjson=/root/.docker/config.json  \\\n    --type=kubernetes.io/dockerconfigjson  \\\n    --namespace=kube-system\n# 安装\nhelm install nfs-subdir-external-provisioner . -n kube-system --debug\n# 查看\nks get po\n    nfs-subdir-external-provisioner-6db4fd89d9-nwqfv   1/1     Running   0  17h\nhelm list -A\nk get sc\nk get sc nfs-client -o yaml #(1)\n\n\nstorageClass 的yaml 里provisioner, 可以这样获取\n\nks get po nfs-subdir-external-provisioner-6db4fd89d9-nwqfv -oyaml |grep PROVISIONER_NAME -A 1\nks describe po nfs-subdir-external-provisioner-6db4fd89d9-nwqfv  |grep PROVISIONER_NAME -A 1\n\nallowVolumeExpansion: true\napiVersion: storage.k8s.io/v1\nkind: StorageClass\nmetadata:\n  annotations:\n    meta.helm.sh/release-name: nfs-subdir-external-provisioner\n    meta.helm.sh/release-namespace: kube-system\n  creationTimestamp: \"2023-07-19T08:37:44Z\"\n  labels:\n    app: nfs-subdir-external-provisioner\n    app.kubernetes.io/managed-by: Helm\n    chart: nfs-subdir-external-provisioner-4.0.18\n    heritage: Helm\n    release: nfs-subdir-external-provisioner\n  name: nfs-client\n  resourceVersion: \"1055715\"\n  uid: 5ae9beff-7646-4022-8acc-52396ea9723b\nparameters:\n  archiveOnDelete: \"true\"\nprovisioner: cluster.local/nfs-subdir-external-provisioner\nreclaimPolicy: Delete\n\n\npod-pvc-with-sc.yaml\n\napiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n  name: pvc-nfs-with-sc\nspec:\n  accessModes:\n    - ReadWriteMany\n  volumeMode: Filesystem\n  resources:\n    requests:\n      storage: 200Mi\n1  storageClassName: nfs-client\n---\napiVersion: v1\nkind: Pod\nmetadata:\n  name: pod-pv-pvc-with-sc\nspec:\n  containers:\n  - name: nginx\n    image: nginx:1.14.2\n    volumeMounts:\n    - name: ng-data\n      mountPath: /usr/share/nginx/html\n  volumes:\n  - name: ng-data\n    persistentVolumeClaim: # 指定pvc的name\n      claimName: pvc-nfs-with-sc\n\n\n1\n\n前面已经自动创建了sc, 当然我们可以自己手动创建一个.利用这个sc对应的provisioner组件自动创建pv  还有如果没有指定的sc不存在, 那么它会找对应pv,会与有设置这个storageClassName的pv进行绑定\n\n\nk create -f pod-pvc-with-sc.yaml\n\nk get pvc\n\n\n\n\n\n\n点击查看执行结果: 看到pvc已经bound,有pv绑定了\n\n\n\n\n\nNAME              STATUS   VOLUME                                     CAPACITY  ACCESS MODES  STORAGECLASS\npvc-nfs-with-sc   Bound    pvc-c5aebbf9-cd9e-43ba-866c-33bef06b4c2a   200Mi     RWX           nfs-client\n\n\n\n\n\nk get pv\n\n\n\n\n\n\n点击查看执行结果: pv已经被创建出来了\n\n\n\n\n\nNAME                                       CAPACITY STATUS   CLAIM                     STORAGECLASS\npvc-c5aebbf9-cd9e-43ba-866c-33bef06b4c2a   200Mi    Bound    default/pvc-nfs-with-sc   nfs-client\n\n\n\n\n# 获取这个pv 使用的 nfs 共享目录\nk get pv pvc-c5aebbf9-cd9e-43ba-866c-33bef06b4c2a -o yaml |grep nfs: -A 3\n# 最后到nfs服务器node1 上 ,看到 共享目录有带pvc的名字\n    /data/nfs/default-pvc-nfs-with-sc-pvc-c5aebbf9-cd9e-43ba-866c-33bef06b4c2a\n\n\n\n3.6 问题\n\n3.6.1 pvc 处于pending\n\nPVC的空间申请大小大于PV的大小\nPVC的StorageClassName没有和PV的一致\nPVC的accessModes和PV的不一致\n\n\n\n3.6.2 挂载PVC的Pod一直处于Pending\n\nPVC没有创建成功/PVC不存在\nPVC和Pod不在同一个Namespace",
    "crumbs": [
      "核心概念与实战",
      "存储管理"
    ]
  },
  {
    "objectID": "docs/devops/k8s/core/service/traefik.html",
    "href": "docs/devops/k8s/core/service/traefik.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "Traefik（也称为Traefik Proxy）是一款现代的反向代理和负载均衡器，专门用于处理HTTP和TCP流量\nTraefik可以与 istio 一起使用，作为istio的入口网关，用于处理外部流量并将其转发到Istio服务网格中的服务\n\n\n\n\n Back to top",
    "crumbs": [
      "核心概念与实战",
      "服务",
      "traefik"
    ]
  },
  {
    "objectID": "docs/devops/k8s/core/resource-quota-qos.html",
    "href": "docs/devops/k8s/core/resource-quota-qos.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "Back to top"
  },
  {
    "objectID": "docs/devops/k8s/core/controller.html",
    "href": "docs/devops/k8s/core/controller.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "假设你需要固定数量的pod 运行,如果某个 Pod 失效或被删除，你想要自动创建新的 Pod 来替代,从而保持应用程序的高可用性\n假如你想要滚动更新, 想平滑地更新应用程序的副本. 需要它可以控制旧 Pod 和新 Pod 的并行运行数量,以及更新的速率,从而避免应用程序的中断或过载\n…",
    "crumbs": [
      "核心概念与实战",
      "控制器"
    ]
  },
  {
    "objectID": "docs/devops/k8s/core/controller.html#为什么有这样的设计",
    "href": "docs/devops/k8s/core/controller.html#为什么有这样的设计",
    "title": "斯巴拉稀",
    "section": "",
    "text": "假设你需要固定数量的pod 运行,如果某个 Pod 失效或被删除，你想要自动创建新的 Pod 来替代,从而保持应用程序的高可用性\n假如你想要滚动更新, 想平滑地更新应用程序的副本. 需要它可以控制旧 Pod 和新 Pod 的并行运行数量,以及更新的速率,从而避免应用程序的中断或过载\n…",
    "crumbs": [
      "核心概念与实战",
      "控制器"
    ]
  },
  {
    "objectID": "docs/devops/k8s/core/controller.html#replicationcontroller",
    "href": "docs/devops/k8s/core/controller.html#replicationcontroller",
    "title": "斯巴拉稀",
    "section": "2 ReplicationController",
    "text": "2 ReplicationController\n\n\n\n\n\n\nWarning\n\n\n\n已经不推荐用, 推荐使用 ReplicaSet\n\n\n\n\n\n\n\n\n例子\n\n\n\n\n\napiVersion: v1\nkind: ReplicationController \nmetadata:\n  name: nginx\nspec:\n  replicas: 3\n  selector:\n      app: nginx\ntemplate:\n  metadata:\n    name: nginx\n    labels:\n      app: nginx\n  spec:\n    containers:\n    - name: nginx\n      image: nginx\n      ports:\n      - containerPort: 80",
    "crumbs": [
      "核心概念与实战",
      "控制器"
    ]
  },
  {
    "objectID": "docs/devops/k8s/core/controller.html#replicasetrs",
    "href": "docs/devops/k8s/core/controller.html#replicasetrs",
    "title": "斯巴拉稀",
    "section": "3 ReplicaSet(RS)",
    "text": "3 ReplicaSet(RS)\n\n\n\n\n\n\nTip\n\n\n\n\nRS确保任何时间都有指定数量的 Pod 副本在运行\n一般不会单独去用的\n\n\n\n官方文档\n\n3.1 创建\nkubectl explain rs # ReplicaSet可以简写为rs\n# 我们发现 rs 内部有个模板属性,看下里面的,其实就是pod的属性\n# pod 模板对象\nkubectl explain rs.spec.template\n\nkubectl api-resources |grep ReplicaSet\n\n\nrs-nginx.yaml\n\napiVersion: apps/v1\nkind: ReplicaSet\nmetadata:\n  name: rs-nginx\nspec:\n1  replicas: 2\n2  selector:\n     matchLabels:\n       app: rs-pod\n3  template:\n    metadata:\n      labels:\n4        app: rs-pod\n    spec:\n5      restartPolicy: Always\n      containers:\n      - name: c-nginx\n        image: nginx:1.14.2\n        ports:\n        - name: http\n          containerPort: 80\n\n\n1\n\n创建几个pod资源,2个都是按照下面设置的模板template来创建的,如果没有设置,默认就是1\n\n2\n\n使用什么样的标签 来选择 pod呢,符合这样的标签的pod 都会被rs所管理\n\n3\n\n定义pod的模板\n\n4\n\n这里定义的标签一定要和 上面selector定义的matchlabels一样\n\n5\n\nAlways 唯一允许的取值,也是默认值\n\n\nk create -f rs-nginx.yaml\n\nk get rs -o wide\n\n\n\n\n\n\n点击查看执行结果\n\n\n\n\n\nNAME       DESIRED   CURRENT   READY   AGE   CONTAINERS   IMAGES         SELECTOR\nrs-nginx   2         2         2       34s   c-nginx      nginx:1.14.2   app=rs-pod\n\n\n\n\n\nk get po\n\n\n\n\n\n\n点击查看执行结果:会有2个pod 运行\n\n\n\n\n\nrs-nginx-hn2jl       1/1     Running   0          7m21s\nrs-nginx-xqznf       1/1     Running   0          7m21s\n\n\n\n\n# ReplicaSet 的信息被pod设置在 metadata 的 ownerReferences 字段中\nk get po rs-nginx-hn2jl -o yaml|grep ownerReferences -A 8 -B 10\n# 我们删除其中一个pod 来看看\nk delete pod rs-nginx-hn2jl\nk get po # 发现 又重新创建了一个pod\n\n\n3.2 脱离模板的pod\n\n\n\n\n\n\nTip\n\n\n\n如果我们创建了符合rs 标签选择器的pod ,会如何呢?\n\n\n\n先创建rs ,后创建脱离模板的pod\n\n\n\npod-nginx-single-match-rs.yaml\n\napiVersion: v1\nkind: Pod\nmetadata:\n  labels:\n    app: rs-pod\n  name: pod-nginx-single-match-rs\n  namespace: default\nspec:\n  containers:\n  - image: nginx:1.14.2\n    imagePullPolicy: IfNotPresent\n    name: c-nginx\n    ports:\n    - containerPort: 80\n      name: http\n      protocol: TCP\n\n# 实时监控pod的创建情况\n# 我们会发现 创建后会开始删除\nk get po -w\n\n\n\n\n\n\nNote\n\n\n\n由于这些 Pod 没有控制器作为其属主引用(ownerReferences 属性),并且 其标签与 ReplicaSet 的选择算符匹配,它们会立即被该 ReplicaSet 获取, 但是该pod 会立即被 ReplicaSet 终止,因为 它们的存在会使得 ReplicaSet 中 Pod 个数超出其期望值\n\n\n\n先创建符合rs的pod, 再创建rs\n\n会被rs 管理, rs根据你符合条件的pod数量,再看是否需要创建rs中模板的pod.\n\n\n3.3 删除\n# 只删除rs, 不删除pod\nk delete --cascade=orphan -f rs-nginx.yaml",
    "crumbs": [
      "核心概念与实战",
      "控制器"
    ]
  },
  {
    "objectID": "docs/devops/k8s/core/controller.html#deployment-deploy",
    "href": "docs/devops/k8s/core/controller.html#deployment-deploy",
    "title": "斯巴拉稀",
    "section": "4 Deployment (deploy)",
    "text": "4 Deployment (deploy)\n\n\n\n\n\n\nTip\n\n\n\n\n一个 Deployment 为 Pod 和 ReplicaSet 提供声明式的更新能力\n你负责描述 Deployment 中的 目标状态,而 Deployment 控制器(Controller)以受控速率更改实际状态, 使其变为期望状态\n无状态资源管理,最常用的控制器, 继承了rs,通过控制 replicaSet来控制管理pod\n什么叫无状态? 无状态指的是对于请求方的每个请求,接收方都当这次请求是第一次请求\n\n\n\n官方文档\n\n4.1 创建\nk get deploy\n# 这样可以导出 配置文件, 做些修改\nk create deploy deploy-nginx \\\n  --image=nginx:1.14.2 \\\n  --dry-run=client -o yaml &gt; deploy-nginx.yaml \n\n\ndeploy-nginx.yaml\n\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: deploy-nginx\n  labels:\n    app: nginx\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: pod-deploy-nginx\n  template:\n    metadata:\n      labels:\n        app: pod-deploy-nginx\n    spec:\n      containers:\n      - name: c-deploy-nginx\n        image: nginx:1.14.2\n        ports:\n        - containerPort: 80\n\n\n\n创建\n\nk create -f deploy-nginx.yaml\n\n\nk get deploy \n\n\n\n\n\n\n点击查看执行结果\n\n\n\n\n\nNAME           READY   UP-TO-DATE   AVAILABLE   AGE\ndeploy-nginx   3/3     3            3           15s\n\n\n\n\n\n# 每个deploy 都会有一个rs控制器,来实际创建pod\nk get rs\n\n\n\n\n\n\n点击查看执行结果\n\n\n\n\n\nNAME                      DESIRED   CURRENT   READY   AGE\ndeploy-nginx-77d87b4b6c   3         3         3       2m34s \n\n\n\n\n\n\n4.2 更新\n\n\n\n\n\n\n如何更新\n\n\n\n\n假设我们deploy 管理着3个pod ,3个nginx pod 让用户访问, 负载均衡\n现在我们要更新里面nginx 的版本\n问题\n\n因为只有好像只能有3个, 不能超过, 所以更新的时候先删除一个pod?\n但是如果这个时候因为删除一个pod导致用户访问满载… 就有问题了\n\n解决\n\ndeploy 支持临时添加pod, 支持在滚动更新前,设置最多多几个(比如原来是3个,现在可以是4个),和最多少几个(比如原先3个,现在至少需要2个pod运行)\n\n\n\n\n\n\n看一下创建的deploy的更新策略\n\n# 我们yaml没有指定, 这里显示的就是默认的.\nk get deployments.apps  deploy-nginx  -o yaml |grep strategy -A 5\n  strategy:\n    rollingUpdate:\n      maxSurge: 25%\n      maxUnavailable: 25%\n    type: RollingUpdate\n\nkubectl explain deploy.spec.strategy\n\n\n更新策略\n\n\n\n\n\n\n\n属性\n值/子属性\n描述\n\n\n\n\ntype\nRecreate\n\n这个策略就是先删除,再重建,设置这个值后 rollingUpdate属性无效了\n\n\n\n\nRollingUpdate\n\n滚动更新,再去设置 设置 rollingUpdate属性\n\n\n\nRollingUpdate\nmaxSurge\n\n在更新期间,最多可以多几个可用\n比如原先3个,设置1,则表示最多可以有4个pod保持运\n原先3个,设置25%,就是能多4*25%也是1,如果不足1,当成1,也是表示最多可以有4个pod运行\n\n\n\n\nmaxUnavailable\n\n在更新期间,最多有几个不可用原先是5\n这里设置1,则表示至少需要有4个pod保持运行\n\n\n\n\n# 直接修改 deploy 中pod使用的image\n# --record 记录 会在 kubectl rollout history deployment demo-nginx 命令中显示,\n# 会在 CHANGE-CAUSE 里显示 你的命令,否则显示none\n# --record will be removed in the future ,未来会被移除\n# pod-deploy-nginx 是模板中pod的名字 , nginx:1.9.1 是新的镜像名\nkubectl set image deploy deploy-nginx pod-deploy-nginx=nginx:1.9.1 --record=true\n\n#  annotations 里有kubernetes.io/change-cause 会显示为最新变更的原因\n# 如果上面不加 --record 就不会记录新的,会显示旧的\nk get deployments.apps deploy-nginx -o yaml|grep annotations -A 5 #(1)\n\n\n\n\n\n\n点击查看执行结果,可以看到annotations有添加相关信息\n\n\n\n\n\n  annotations:\n    deployment.kubernetes.io/revision: \"4\"\n    kubernetes.io/change-cause: kubectl set image deploy deploy-nginx pod-deploy-nginx=nginx:1.9.1\n  --record=true\n\n\n\n\n# 或使用edit\nkubectl edit deploy deploy-nginx\n# 或\nkubectl apply -f deploy-nginx.yaml --record=true\nk get rs -w\n  # 为了 方便看,我将新的rs 名字下面显示为 deploy-nginx-new\n  NAME                      DESIRED   CURRENT   READY   AGE\n  deploy-nginx-77d87b4b6c   3         3         3       7m38s\n  deploy-nginx--------new   1         0         0       0s\n  deploy-nginx--------new   1         1         0       0s\n  deploy-nginx--------new   1         1         1       85s\n  deploy-nginx-77d87b4b6c   2         3         3       9m52s\n  deploy-nginx--------new   2         1         1       85s\n  deploy-nginx-77d87b4b6c   2         2         2       9m52s\n  deploy-nginx--------new   2         2         1       85s\n  deploy-nginx--------new   2         2         2       2m47s\n  deploy-nginx-77d87b4b6c   1         2         2       11m\n  deploy-nginx--------new   3         2         2       2m47s\n  deploy-nginx-77d87b4b6c   1         1         1       11m\n  deploy-nginx--------new   3         3         2       2m47s\n  deploy-nginx--------new   3         3         3       2m48s\n  deploy-nginx-77d87b4b6c   0         1         1       11m\n  deploy-nginx-77d87b4b6c   0         0         0       11m\n\n创建了一个新的rs, 新rs创建一个pod, 旧的rs 缩容,减少一个pod\n继续以上操作, 最终新的rs 创建了3个, 旧的缩容为0\n\nk get deploy  -w\n  NAME           READY   UP-TO-DATE   AVAILABLE   AGE\n  deploy-nginx   3/3     3            3           20m\n  deploy-nginx   3/3     0            3           20m\n  deploy-nginx   3/3     1            3           20m\n  deploy-nginx   4/3     1            4           20m\n  deploy-nginx   3/3     1            3           20m\n  deploy-nginx   3/3     2            3           20m\n  deploy-nginx   4/3     2            4           20m\n  deploy-nginx   3/3     2            3           20m\n  deploy-nginx   3/3     3            3           20m\n  deploy-nginx   4/3     3            4           20m\n  deploy-nginx   3/3     3            3           20m\n\n\n# 也可以看到相关的信息, 通过控制rs的replicas的数量\n# 新rs先创建一个pod,是因为 一开始replicas=1\nk describe deploy deploy-nginx\n# 上线的状态如何,是否更新成功\nk rollout status deploy deploy-nginx\n\n\n\n\n\n\n\n状态\n描述\n\n\n\n\nDESIRED\n用户期望的 Pod 副本个数 (spec.replicas 的值)\n\n\nCURRENT\n当前处于 Running 状态的 Pod 的个数, pull image时期就属于running状态\n\n\nREADY\npod已经启动可以提供服务的状态\n\n\nUP-TO-DATE\n\n当前处于最新版本的 Pod 的个数\n所谓最新版本指的是Pod的Spec部分与Deployment里 Pod 模板里定义的完全一\n\n\n\nAVAILABLE\n\n当前已经可用的Pod 的个数\nRunning 状态,又是最新版本,并且已经处于 Ready(健康检查正确)状态的 Pod\n应用可供用户使用的副本数\n\n\n\n\n\n\n4.3 回滚\n\n\n\n\n\n\nTip\n\n\n\n前面更新那里我们会看到,更新成功后, 旧的rs 不会被删除. 有什么用呢?\n\n\n# 我们再看看 \nk describe deployments.apps deploy-nginx  | grep  annotation -iA 3\n  Annotations:            deployment.kubernetes.io/revision: 9\n                          kubernetes.io/change-cause: kubectl set image deploy deploy-nginx pod-deploy-nginx=nginx:1.9.1 --record=true\n\n# 查看deploy-nginx 的上线历史, 显示的相关信息对应上面的版本号和 change-cause\nk  rollout history deployment deploy-nginx\n  1         kubectl set image deploy deploy-nginx pod-deploy-nginx=nginx:1.9.1 --record=true\n  2         kubectl set image deploy deploy-nginx pod-deploy-nginx=nginx:1.14.1 --record=true\n\n# 表示默认保留10个历史记录 可以用于回滚, 可以在创建deploy时指定\n# 0 的话,表示不保留\nk get deployments.apps deploy-nginx  -o yaml  | grep revisionHistoryLimit\n  revisionHistoryLimit: 10 \n\n#我们再做一次更新, 没有record,\nkubectl set image deploy deploy-nginx pod-deploy-nginx=nginx:latest\nk  rollout history deployment deploy-nginx\n  REVISION  CHANGE-CAUSE\n  1         kubectl set image deploy deploy-nginx pod-deploy-nginx=nginx:1.9.1 --record=true\n  2         kubectl set image deploy deploy-nginx pod-deploy-nginx=nginx:1.14.2 --record=true\n  3        kubectl set image deploy deploy-nginx pod-deploy-nginx=nginx:1.14.2 --record=true # 这里还是用的旧的.\n\n# 前面说到 --record 会废弃, 那么实际上就是给deploy 添加一个annotation\n# 我们可以手动添加你这个更新的原因. 仅作为注释.\nk annotate deploy deploy-nginx  kubernetes.io/change-cause='kubectl set image deploy deploy-nginx pod-deploy-nginx=nginx:latest'\n\n# 会先是3个rs. 都保留着 用来回滚用的.\n# rs 的配置里面image用的之前的nginx 版本.\nk get rs\n\n# 查看某个版本的详情\nk rollout history deployment deploy-nginx --revision=1\n# 回滚到上一个版本\nk rollout undo deploy deploy-nginx\nk get rs # 对应的rs就会创建pod了.\n# 回滚到指定版本\nk rollout undo deploy deploy-nginx  --to-revision=2\n\n\n\n4.4 扩容\nk scale deployment deploy-nginx --replicas=4\n\n\n4.5 暂停和恢复\n\n\n\n\n\n\nTip\n\n\n\n\n如果你是用命令修改, 需要多次操作,比如一次修改了image,一次修改了cpu什么的. 你不希望修改后就马上重建pod,则可以先暂停, 当然你直接edit 一次全部修改就得了\n这个就是你自动化操作的时候可能就有用了. 我们一般会在cicd里使用诸如 kubectl set …\n\n\n\n\nkubectl rollout pause deploy deploy-nginx\n\n..... 做了修改后\n\nkubectl rollout resume deploy deploy-nginx",
    "crumbs": [
      "核心概念与实战",
      "控制器"
    ]
  },
  {
    "objectID": "docs/devops/k8s/core/controller.html#statefulsetsts",
    "href": "docs/devops/k8s/core/controller.html#statefulsetsts",
    "title": "斯巴拉稀",
    "section": "5 statefulset(sts)",
    "text": "5 statefulset(sts)\n\n\n\n\n\n\nTip\n\n\n\n\n前面我们说到的pod控制器都是无状态的,关注的是群体(群体里的个体都是一样的,所以把整个群体当成一个个体)\nstatefulset 关注个体\nStatefulSet(有状态集)常用于部署有状态的且需要有序启动的应用程序\n\n\n\n\nStatefulSet 的核心功能,就是通过某种方式记录这些状态,然后在 Pod 被重新创 建时，能够为新 Pod 恢复这些状态.",
    "crumbs": [
      "核心概念与实战",
      "控制器"
    ]
  },
  {
    "objectID": "docs/devops/k8s/core/controller.html#daemonset-ds",
    "href": "docs/devops/k8s/core/controller.html#daemonset-ds",
    "title": "斯巴拉稀",
    "section": "6 daemonSet (ds)",
    "text": "6 daemonSet (ds)",
    "crumbs": [
      "核心概念与实战",
      "控制器"
    ]
  },
  {
    "objectID": "docs/devops/k8s/core/controller.html#job",
    "href": "docs/devops/k8s/core/controller.html#job",
    "title": "斯巴拉稀",
    "section": "7 job",
    "text": "7 job",
    "crumbs": [
      "核心概念与实战",
      "控制器"
    ]
  },
  {
    "objectID": "docs/devops/k8s/core/controller.html#cronjob",
    "href": "docs/devops/k8s/core/controller.html#cronjob",
    "title": "斯巴拉稀",
    "section": "8 cronjob",
    "text": "8 cronjob",
    "crumbs": [
      "核心概念与实战",
      "控制器"
    ]
  },
  {
    "objectID": "docs/devops/k8s/develop/code-generator.html",
    "href": "docs/devops/k8s/develop/code-generator.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "!!! tip 关于k8s生成器, 和go generate 有类似的地方, go-generate\n\ngit clone https://github.com/kubernetes/code-generator\ngit  co -b v0.23.17 v0.23.17\n# k8s 源码中  也有\n\ncd  code-generator\n./generate-groups.sh\n\n\n\n\n Back to top"
  },
  {
    "objectID": "docs/devops/k8s/develop/operator/sample-controller.html",
    "href": "docs/devops/k8s/develop/operator/sample-controller.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "重要说明\n\n\n\n\n先看控制器组件的原理以及自定义控制器\noperator 其实就是自定义控制器, 可能一般会将 编写自定义资源和自定以控制器 叫做编写operator\n参考学习 k8s源码中staging/src/k8s.io/sample-controller/这个例子 这个时候 再看看 里面的controller.go文件, 和我们之前写的自定义控制器差不多.",
    "crumbs": [
      "二次开发",
      "operator",
      "sample-controller"
    ]
  },
  {
    "objectID": "docs/devops/k8s/develop/operator/sample-controller.html#自定义资源",
    "href": "docs/devops/k8s/develop/operator/sample-controller.html#自定义资源",
    "title": "斯巴拉稀",
    "section": "1 自定义资源",
    "text": "1 自定义资源\n自定义资源\n\n\ncrd-crontab.yaml\n\napiVersion: apiextensions.k8s.io/v1\nkind: CustomResourceDefinition\nmetadata:\n  name: crontabs.stable.example.com\nspec:\n  group: stable.example.com\n  versions:\n    - name: v1\n      served: true\n      storage: true\n      schema:\n        openAPIV3Schema:\n          type: object\n          properties:\n            spec:\n              type: object\n              properties:\n                cron:\n                  type: string\n                image:\n                  type: string\n                replicas:\n                  type: integer\n            status:\n              type: object\n              properties:\n                availableReplicas:\n                  type: integer\n---\napiVersion: \"stable.example.com/v1\"\nkind: CronTab\nmetadata:\n  name: my-new-cron-object\nspec:\n  cron: \"* * * * */5\"\n  image: my-awesome-cron-image\n\nk apply -f crd-crontab.yaml",
    "crumbs": [
      "二次开发",
      "operator",
      "sample-controller"
    ]
  },
  {
    "objectID": "docs/devops/k8s/develop/operator/sample-controller.html#定义类型",
    "href": "docs/devops/k8s/develop/operator/sample-controller.html#定义类型",
    "title": "斯巴拉稀",
    "section": "2 定义类型",
    "text": "2 定义类型\n\n\n\n\n\n\nTip\n\n\n\n参考k8s源码中`staging/src/k8s.io/sample-controller/ 相关文件复制过来修改修改\n\n\ntree crd-operator\ncrd-operator\n├── go.mod\n├── hack\n│   ├── boilerplate.go.txt\n│   ├── tools.go\n│   └── update-codegen.sh\n├── main.go\n└── pkg\n    └── apis # 自定义资源是非核心api, 所以是apis\n        └── stable.example.com # group\n            ├── register.go\n            └── v1 # version\n                ├── doc.go\n                ├── register.go\n                ├── types.go\n\nregister.gov1/register.gov1/doc.gov1/types.gohack/tools.gohack/update-codegen.sh\n\n\npackage stableexamplecom\n\nconst (\n    GroupName = \"stable.example.com\"\n)\n\n\npackage v1\n\nimport (\n    stableexamplecom \"crd-operator/pkg/apis/stable.example.com\"\n\n    metav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n    \"k8s.io/apimachinery/pkg/runtime\"\n    \"k8s.io/apimachinery/pkg/runtime/schema\"\n)\n\n// SchemeGroupVersion is group version used to register these objects\nvar SchemeGroupVersion = schema.GroupVersion{Group: stableexamplecom.GroupName, Version: \"v1\"}\n\n// Kind takes an unqualified kind and returns back a Group qualified GroupKind\nfunc Kind(kind string) schema.GroupKind {\n    return SchemeGroupVersion.WithKind(kind).GroupKind()\n}\n\n// Resource takes an unqualified resource and returns a Group qualified GroupResource\nfunc Resource(resource string) schema.GroupResource {\n    return SchemeGroupVersion.WithResource(resource).GroupResource()\n}\n\nvar (\n    // SchemeBuilder initializes a scheme builder\n    SchemeBuilder = runtime.NewSchemeBuilder(addKnownTypes)\n    // AddToScheme is a global function that registers this API group & version to a scheme\n    AddToScheme = SchemeBuilder.AddToScheme\n)\n\n// Adds the list of known types to Scheme.\nfunc addKnownTypes(scheme *runtime.Scheme) error {\n    scheme.AddKnownTypes(SchemeGroupVersion,\n        &CronTab{},\n        &CronTabList{},\n    )\n    metav1.AddToGroupVersion(scheme, SchemeGroupVersion)\n    return nil\n}\n\n\n// +k8s:deepcopy-gen=package\n// +groupName=stable.example.com\n\n// Package v1 is the v1 version of the API.\npackage v1\n\n\npackage v1\n\nimport (\n    metav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n)\n\n// +genclient\n// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object\n\n// CronTab is a specification for a CronTab resource\n// 就像内置资源对象一样, 4个大属性.\ntype CronTab struct {\n    metav1.TypeMeta   `json:\",inline\"`\n    metav1.ObjectMeta `json:\"metadata,omitempty\"`\n\n    Spec   CronTabSpec   `json:\"spec\"`\n    Status CronTabStatus `json:\"status\"`\n}\n\n// CronTabSpec is the spec for a CronTab resource\ntype CronTabSpec struct {\n    Cron     string `json:\"cron\"` // 注意和你的crd里定义的一样\n    Replicas *int32 `json:\"replicas\"`\n}\n\n// CronTabStatus is the status for a CronTab resource\ntype CronTabStatus struct {\n    AvailableReplicas int32 `json:\"availableReplicas\"`\n}\n\n// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object\n\n// CronTabList is a list of CronTab resources\ntype CronTabList struct {\n    metav1.TypeMeta `json:\",inline\"`\n    metav1.ListMeta `json:\"metadata\"`\n\n    Items []CronTab `json:\"items\"`\n}\n\n\n//go:build tools\n// +build tools\n\n/*\nCopyright 2019 The Kubernetes Authors.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\npackage tools\n\n// 因为我们代码中没有使用这个库,但是我们又要使用代码生成器\n// 所以用这个方式将这个依赖下载下来 (你当然可以在任何.go文件里写上这样的import,也是ok的.)\n// 然后 使用 go mod vendor 后将下载依赖到项目目录下的vendor 目录,里面就会有依赖(code-generator)\n// 接着 我们在代码生成脚本中指定code-generator的路径 (update-codegen.sh)\nimport _ \"k8s.io/code-generator\"\n\n\n#!/bin/bash\nSCRIPT_ROOT=$(dirname \"${BASH_SOURCE[0]}\")/..\n# code-generator 目录\n# 一般情况下我们创建operator 写代码, 是在任何一个地方创建项目目录的\n# 所以可能最好是 在项目目录 将依赖生成到vendor 目录(go mod vendor)\n# 然后从这个 vendor 目录下找到 代码生成器脚本\nCODEGEN_PKG=${CODEGEN_PKG:-$(cd \"${SCRIPT_ROOT}\"; ls -d -1 ./vendor/k8s.io/code-generator 2&gt;/dev/null)}\nif [ -z ${CODEGEN_PKG} ];then\n    echo \"请指定代码生成器脚本路径!!!或使用 go mod vendor后再执行脚本!\"\n    exit\nfi\nGROUP_NAME=\"stable.example.com\"\nVERSION=\"v1\"\nMOD_NAME=\"crd-operator\" # go mod init 创建的名字\necho $ROOT_DIR\n# generate-groups.sh &lt;generators&gt; &lt;output-package&gt; &lt;apis-package&gt; &lt;groups-versions&gt; ...\n# output-package:\n#       设置为当前项目根目录的父目录\n#       项目目录的名字要与  MOD_NAME 一样\n# --go-header-file  生成的文件前面的注释,必须指定,否则报错\n# bash \"${CODEGEN_PKG}\"/generate-groups.sh \"deepcopy,client,informer,lister\" \\\nbash \"${CODEGEN_PKG}\"/generate-groups.sh all \\\n  ${MOD_NAME}/pkg/generated ${MOD_NAME}/pkg/apis \\\n  ${GROUP_NAME}:${VERSION} \\\n  --output-base \"${SCRIPT_ROOT}/../\" \\\n  --go-header-file \"${SCRIPT_ROOT}\"/hack/boilerplate.go.txt",
    "crumbs": [
      "二次开发",
      "operator",
      "sample-controller"
    ]
  },
  {
    "objectID": "docs/devops/k8s/develop/operator/sample-controller.html#代码生成器生成所需代码",
    "href": "docs/devops/k8s/develop/operator/sample-controller.html#代码生成器生成所需代码",
    "title": "斯巴拉稀",
    "section": "3 代码生成器生成所需代码",
    "text": "3 代码生成器生成所需代码\n生成代码后, 可以像 操作内置资源对象那样\ngo get k8s.io/client-go@v0.23.17\ngo get k8s.io/api@v0.23.17\ngo get k8s.io/apimachinery@v0.23.17\ngo get k8s.io/code-generator@v0.23.17\ngo mod tidy\ngo mod vendor\n./hack/update-codegen.sh\n\ntree crd-operator\n├── pkg\n│   ├── apis\n│   │   └── stable.example.com\n│   └── generated # 自动生成的目录\n│       ├── clientset # 这样我们能像使用pod 一样, 用clientset.CoreV1().Pods(\"\").List()\n│       ├── informers # 同理\n│       └── listers\n\n\n\n\n\n\nTip\n\n\n\n编写main.go, 就像 client-go查询pod列表一样 或编写自定义控制器那样使用informer 等等..\n\n\n\n\nmain.go\n\npackage main\n\nimport (\n    \"context\"\n    \"flag\"\n    \"fmt\"\n    \"path/filepath\"\n\n    clientset \"crd-operator/pkg/generated/clientset/versioned\"\n\n    metav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n    \"k8s.io/client-go/tools/clientcmd\"\n    \"k8s.io/client-go/util/homedir\"\n)\n\nfunc main() {\n    var kubeconfig *string\n    if home := homedir.HomeDir(); home != \"\" {\n        // ~/.kube/config 确保你家目录下有k8s的配置文件\n        // 你本地可以用kubectl get po 进行查询.\n        kubeconfig = flag.String(\"kubeconfig\", filepath.Join(home, \".kube\", \"config\"), \"(optional) absolute path to the kubeconfig file\")\n    } else {\n        kubeconfig = flag.String(\"kubeconfig\", \"\", \"absolute path to the kubeconfig file\")\n    }\n    flag.Parse()\n\n    // 使用指定的kubeconfig文件创建一个Config对象\n    config, err := clientcmd.BuildConfigFromFlags(\"\", *kubeconfig)\n    if err != nil {\n        panic(err.Error())\n    }\n\n    // 创建一个新的Kubernetes客户端\n    client, err := clientset.NewForConfig(config)\n    if err != nil {\n        panic(err.Error())\n    }\n    crontabs, err := client.StableV1().CronTabs(\"default\").\n        List(context.TODO(), metav1.ListOptions{})\n    if err != nil {\n        panic(err.Error())\n    }\n    for _, item := range crontabs.Items {\n        fmt.Println(item.Name, \":\", item.Spec.Cron)\n    }\n}",
    "crumbs": [
      "二次开发",
      "operator",
      "sample-controller"
    ]
  },
  {
    "objectID": "docs/devops/k8s/develop/data-structure.html",
    "href": "docs/devops/k8s/develop/data-structure.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "!!! note K8s系统虽然有相当复杂和众多的功能,但它本质上是一个资源控制系统: 注册、管理、调度资源并维护资源的状态 K8s将资源再次分组和版本化,形成Group(资源组)、Version(资源版本)、Resource(资源)\n@startmindmap\n&lt;style&gt;\nmindmapDiagram {\n  .green {\n    BackgroundColor lightgreen\n  }\n    .rose {\n    BackgroundColor #FFBBCC\n  }\n  .lightblue {\n    BackgroundColor lightblue\n  }\n  .yellow{\n    BackgroundColor yellow\n  }\n  .gold{\n    BackgroundColor gold\n  }\n}\n&lt;/style&gt;\n* a\n@endmindmap\n\n\n\n Back to top"
  },
  {
    "objectID": "docs/devops/k8s/develop/client-go/index.html",
    "href": "docs/devops/k8s/develop/client-go/index.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "git clone https://github.com/kubernetes/client-go.git\n\ngit tag # 查看tag\n# 以tag kubernetes-1.23.17 创建一个分支\ngit co -b kubernetes-1.23.17 kubernetes-1.23.17\n# 或\ngit co -b v0.23.17 v0.23.17\n➜ tree -L 1\n.\n├── rest\n├── kubernetes\n├── dynamic\n├── discovery\n├── informers\n├── listers\n├── applyconfigurations\n├── metadata\n├── pkg\n├── plugin\n├── restmapper\n├── scale\n├── testing\n├── third_party\n├── tools\n├── transport\n└── util",
    "crumbs": [
      "二次开发",
      "client-go",
      "介绍"
    ]
  },
  {
    "objectID": "docs/devops/k8s/develop/client-go/index.html#代码结构",
    "href": "docs/devops/k8s/develop/client-go/index.html#代码结构",
    "title": "斯巴拉稀",
    "section": "",
    "text": "git clone https://github.com/kubernetes/client-go.git\n\ngit tag # 查看tag\n# 以tag kubernetes-1.23.17 创建一个分支\ngit co -b kubernetes-1.23.17 kubernetes-1.23.17\n# 或\ngit co -b v0.23.17 v0.23.17\n➜ tree -L 1\n.\n├── rest\n├── kubernetes\n├── dynamic\n├── discovery\n├── informers\n├── listers\n├── applyconfigurations\n├── metadata\n├── pkg\n├── plugin\n├── restmapper\n├── scale\n├── testing\n├── third_party\n├── tools\n├── transport\n└── util",
    "crumbs": [
      "二次开发",
      "client-go",
      "介绍"
    ]
  },
  {
    "objectID": "docs/devops/k8s/develop/client-go/index.html#restclient",
    "href": "docs/devops/k8s/develop/client-go/index.html#restclient",
    "title": "斯巴拉稀",
    "section": "2 RESTClient",
    "text": "2 RESTClient\n\n\n\n\n\n\nTip\n\n\n\nRESTClient是最基础的客户端 其他的ClientSet、DynamicClient及DiscoveryClient都是基于RESTClient实现的 RESTClient 对HTTP Request进行了封装,实现了RESTful风格的API\n\n\npackage main\n\nimport (\n    \"context\"\n    \"flag\"\n    \"fmt\"\n    \"path/filepath\"\n\n    corev1 \"k8s.io/api/core/v1\"\n\n    metav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n    \"k8s.io/client-go/kubernetes/scheme\"\n    \"k8s.io/client-go/rest\"\n    \"k8s.io/client-go/tools/clientcmd\"\n    \"k8s.io/client-go/util/homedir\"\n)\n\nfunc main() {\n    var kubeconfig *string\n    if home := homedir.HomeDir(); home != \"\" {\n        // ~/.kube/config 确保你家目录下有k8s的配置文件\n        // 你本地可以用kubectl get po 进行查询.\n        kubeconfig = flag.String(\"kubeconfig\", filepath.Join(home, \".kube\", \"config\"), \"(optional) absolute path to the kubeconfig file\")\n    } else {\n        kubeconfig = flag.String(\"kubeconfig\", \"\", \"absolute path to the kubeconfig file\")\n    }\n    flag.Parse()\n\n    // 使用指定的kubeconfig文件创建一个Config对象\n    config, err := clientcmd.BuildConfigFromFlags(\"\", *kubeconfig)\n    if err != nil {\n        panic(err.Error())\n    }\n\n    // 由于后面我们请求的是pod ,是核心资源, /api 这样\n    config.APIPath = \"api\"\n    // 前面我们说过, 核心资源 的group 是空, 点进去会看到是group是空的.\n    config.GroupVersion = &corev1.SchemeGroupVersion\n    config.NegotiatedSerializer = scheme.Codecs\n\n    restClient, err := rest.RESTClientFor(config)\n    if err != nil {\n        panic(err.Error())\n    }\n\n    // k get po -n default\n    // 最终 变成 http请求 localhost:8001/api/v1/namespaces/default/pods?limit=5\n    podList := &corev1.PodList{}\n    err = restClient.Get().\n        Namespace(\"default\").\n        Resource(\"pods\").\n        VersionedParams(\n            &metav1.ListOptions{Limit: 5},\n            scheme.ParameterCodec).\n        Do(context.TODO()).\n        Into(podList)\n    if err != nil {\n        panic(err)\n    }\n    for _, item := range podList.Items {\n        fmt.Println(item.Name)\n    }\n\n}",
    "crumbs": [
      "二次开发",
      "client-go",
      "介绍"
    ]
  },
  {
    "objectID": "docs/devops/k8s/basics/harbor.html",
    "href": "docs/devops/k8s/basics/harbor.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "Tip\n\n\n\n搭建自己的仓库\n\n\n\n\n\n\nGenerate a Certificate Authority Certificate\n\n# Generate a CA certificate private key.\nopenssl genrsa -out ca.key 4096\n# Generate the CA certificate\n# CN= 改成你的域名\nopenssl req -x509 -new -nodes -sha512 -days 3650 \\\n -subj \"/C=CN/ST=Beijing/L=Beijing/O=example/OU=Personal/CN=hb.6o6.com\" \\\n -key ca.key \\\n -out ca.crt\n\n\n\nGenerate a Server Certificate\n\n# Generate a private key.\nopenssl genrsa -out hb.6o6.com.key 4096\n# Generate a certificate signing request (CSR).\nopenssl req -sha512 -new \\\n    -subj \"/C=CN/ST=Beijing/L=Beijing/O=example/OU=Personal/CN=hb.xx.com\" \\\n    -key hb.6o6.com.key \\\n    -out hb.6o6.com.csr\n\n# Generate an x509 v3 extension file\ncat &gt; v3.ext &lt;&lt;-EOF\nauthorityKeyIdentifier=keyid,issuer\nbasicConstraints=CA:FALSE\nkeyUsage = digitalSignature, nonRepudiation, keyEncipherment, dataEncipherment\nextendedKeyUsage = serverAuth\nsubjectAltName = @alt_names\n\n[alt_names]\nDNS.1=hb.6o6.com\nDNS.2=hb.6o6\nDNS.3=hostname\nEOF\n\nopenssl x509 -req -sha512 -days 3650 \\\n    -extfile v3.ext \\\n    -CA ca.crt -CAkey ca.key -CAcreateserial \\\n    -in hb.6o6.com.csr \\\n    -out hb.6o6.com.crt\n\n\n\nProvide the Certificates to Harbor and Docker\n\nmkdir -p /hb_data/cert\ncp hb.6o6.com.crt /hb_data/cert/\ncp hb.6o6.com.key /hb_data/cert/\n\nopenssl x509 -inform PEM -in hb.6o6.com.crt -out hb.6o6.com.cert\nmkdir -p /etc/docker/certs.d/hb.6o6.com/\ncp hb.6o6.com.cert /etc/docker/certs.d/hb.6o6.com/\ncp hb.6o6.com.key /etc/docker/certs.d/hb.6o6.com/\ncp ca.crt /etc/docker/certs.d/hb.6o6.com/\n\nsystemctl restart docker\n# 下载online版, 自己pull 镜像\nwget https://github.com/goharbor/harbor/releases/download/v2.8.2/harbor-online-installer-v2.8.2.tgz\ntar xf harbor-online-installer-v2.8.2.tgz\ncd harbor\ncp harbor.yml.tmpl harbor.yml\nsed -i 's/reg.mydomain.com$/hb.6o6.com/' harbor.yml\nsed -i 's#certificate: /your/certificate/path#certificate: /etc/docker/certs.d/hb.6o6.com/hb.6o6.com.cert#' harbor.yml\nsed -i 's#private_key: /your/private/key/path#private_key: /etc/docker/certs.d/hb.6o6.com/hb.6o6.com.key#' harbor.yml\n# 页面密码\nsed -i 's/harbor_admin_password: Harbor12345/harbor_admin_password: hb123/' harbor.yml\n# db密码\nsed -i 's/password: root123/password: hb123/' harbor.yml\nsed -i 's#data_volume: /data#data_volume: /hb_data#' harbor.yml\n\n./install.sh\n\n# 所有节点上\necho &gt;&gt;/etc/hosts &lt;&lt;EOF\n192.168.1.105 hb.6o6.com\nEOF\n\n浏览器访问 自己的harbor 用户是admin ### helm 方式安装 ### 使用\n\n新建项目, 设置一个名称xyz, 访问级别 不要点选, 这样就表示私有, -1表示容量不限.\n点击新建的项目名xyz–&gt;镜像仓库–&gt;推送命令\n\n\n\n在我们的k8s 节点上操作\n\ndocker login hb.6o6.com\nUsername: admin\nPassword:  # 输入前面修改的password\ndocker pull busybox # 这个是会从 docker.io 拉取?\ndocker tag busybox:latest hb.6o6.com/xyz/busybox:newest\ndocker images\n    REPOSITORY                    TAG\n    busybox                       latest\n    hb.6o6.com/xyz/busybox        newest\ndocker push hb.6o6.com/xyz/busybox:newest\n# 可以去页面看看.\n\nCosign 签名\n\n\n\n\n\n\n\n\n\nWarning\n\n\n\n创建的secret需要和你创建的pod在同一个namespace\n\n\n\n\n\n创建secret\n\n\n通过docker login后的配置文件指定用户密码\n\n\ndocker login hb.6o6.web # 输入用户密码后.\nkubectl create secret generic regcred  \\\n    --from-file=.dockerconfigjson=/root/.docker/config.json \\\n    --type=kubernetes.io/dockerconfigjson \\\n    --namespace=test\n\n\nkubectl create secret docker-registry regcred \\\n  --docker-server=hb.6o6.web/6o6 \\\n  --docker-username=admin \\\n  --docker-password=hb123 \\\n  --namespace=test\n\n\n\n\n查看生成的secret\n\nkubectl get secret regcred --output=yaml\nkubectl get secret regcred --output=\"jsonpath={.data.\\.dockerconfigjson}\" | base64 --decode\n\n配置docker\n\n\n\n所有节点上/etc/docker/daemon.json添加\n\n// 与 \"registry-mirrors\" 同级\n\"insecure-registries\": [\"hb.6o6.com\"],\n\n\n重启docker\n\nsystemctl daemon-reload\nsystemctl restart docker\n\n修改pod的yaml文件\n\n\n\npod的属性,与containers同级的\n\nimagePullSecrets:\n  - name: regcred",
    "crumbs": [
      "基础",
      "镜像仓库"
    ]
  },
  {
    "objectID": "docs/devops/k8s/basics/harbor.html#harbor",
    "href": "docs/devops/k8s/basics/harbor.html#harbor",
    "title": "斯巴拉稀",
    "section": "",
    "text": "Tip\n\n\n\n搭建自己的仓库\n\n\n\n\n\n\nGenerate a Certificate Authority Certificate\n\n# Generate a CA certificate private key.\nopenssl genrsa -out ca.key 4096\n# Generate the CA certificate\n# CN= 改成你的域名\nopenssl req -x509 -new -nodes -sha512 -days 3650 \\\n -subj \"/C=CN/ST=Beijing/L=Beijing/O=example/OU=Personal/CN=hb.6o6.com\" \\\n -key ca.key \\\n -out ca.crt\n\n\n\nGenerate a Server Certificate\n\n# Generate a private key.\nopenssl genrsa -out hb.6o6.com.key 4096\n# Generate a certificate signing request (CSR).\nopenssl req -sha512 -new \\\n    -subj \"/C=CN/ST=Beijing/L=Beijing/O=example/OU=Personal/CN=hb.xx.com\" \\\n    -key hb.6o6.com.key \\\n    -out hb.6o6.com.csr\n\n# Generate an x509 v3 extension file\ncat &gt; v3.ext &lt;&lt;-EOF\nauthorityKeyIdentifier=keyid,issuer\nbasicConstraints=CA:FALSE\nkeyUsage = digitalSignature, nonRepudiation, keyEncipherment, dataEncipherment\nextendedKeyUsage = serverAuth\nsubjectAltName = @alt_names\n\n[alt_names]\nDNS.1=hb.6o6.com\nDNS.2=hb.6o6\nDNS.3=hostname\nEOF\n\nopenssl x509 -req -sha512 -days 3650 \\\n    -extfile v3.ext \\\n    -CA ca.crt -CAkey ca.key -CAcreateserial \\\n    -in hb.6o6.com.csr \\\n    -out hb.6o6.com.crt\n\n\n\nProvide the Certificates to Harbor and Docker\n\nmkdir -p /hb_data/cert\ncp hb.6o6.com.crt /hb_data/cert/\ncp hb.6o6.com.key /hb_data/cert/\n\nopenssl x509 -inform PEM -in hb.6o6.com.crt -out hb.6o6.com.cert\nmkdir -p /etc/docker/certs.d/hb.6o6.com/\ncp hb.6o6.com.cert /etc/docker/certs.d/hb.6o6.com/\ncp hb.6o6.com.key /etc/docker/certs.d/hb.6o6.com/\ncp ca.crt /etc/docker/certs.d/hb.6o6.com/\n\nsystemctl restart docker\n# 下载online版, 自己pull 镜像\nwget https://github.com/goharbor/harbor/releases/download/v2.8.2/harbor-online-installer-v2.8.2.tgz\ntar xf harbor-online-installer-v2.8.2.tgz\ncd harbor\ncp harbor.yml.tmpl harbor.yml\nsed -i 's/reg.mydomain.com$/hb.6o6.com/' harbor.yml\nsed -i 's#certificate: /your/certificate/path#certificate: /etc/docker/certs.d/hb.6o6.com/hb.6o6.com.cert#' harbor.yml\nsed -i 's#private_key: /your/private/key/path#private_key: /etc/docker/certs.d/hb.6o6.com/hb.6o6.com.key#' harbor.yml\n# 页面密码\nsed -i 's/harbor_admin_password: Harbor12345/harbor_admin_password: hb123/' harbor.yml\n# db密码\nsed -i 's/password: root123/password: hb123/' harbor.yml\nsed -i 's#data_volume: /data#data_volume: /hb_data#' harbor.yml\n\n./install.sh\n\n# 所有节点上\necho &gt;&gt;/etc/hosts &lt;&lt;EOF\n192.168.1.105 hb.6o6.com\nEOF\n\n浏览器访问 自己的harbor 用户是admin ### helm 方式安装 ### 使用\n\n新建项目, 设置一个名称xyz, 访问级别 不要点选, 这样就表示私有, -1表示容量不限.\n点击新建的项目名xyz–&gt;镜像仓库–&gt;推送命令\n\n\n\n在我们的k8s 节点上操作\n\ndocker login hb.6o6.com\nUsername: admin\nPassword:  # 输入前面修改的password\ndocker pull busybox # 这个是会从 docker.io 拉取?\ndocker tag busybox:latest hb.6o6.com/xyz/busybox:newest\ndocker images\n    REPOSITORY                    TAG\n    busybox                       latest\n    hb.6o6.com/xyz/busybox        newest\ndocker push hb.6o6.com/xyz/busybox:newest\n# 可以去页面看看.\n\nCosign 签名\n\n\n\n\n\n\n\n\n\nWarning\n\n\n\n创建的secret需要和你创建的pod在同一个namespace\n\n\n\n\n\n创建secret\n\n\n通过docker login后的配置文件指定用户密码\n\n\ndocker login hb.6o6.web # 输入用户密码后.\nkubectl create secret generic regcred  \\\n    --from-file=.dockerconfigjson=/root/.docker/config.json \\\n    --type=kubernetes.io/dockerconfigjson \\\n    --namespace=test\n\n\nkubectl create secret docker-registry regcred \\\n  --docker-server=hb.6o6.web/6o6 \\\n  --docker-username=admin \\\n  --docker-password=hb123 \\\n  --namespace=test\n\n\n\n\n查看生成的secret\n\nkubectl get secret regcred --output=yaml\nkubectl get secret regcred --output=\"jsonpath={.data.\\.dockerconfigjson}\" | base64 --decode\n\n配置docker\n\n\n\n所有节点上/etc/docker/daemon.json添加\n\n// 与 \"registry-mirrors\" 同级\n\"insecure-registries\": [\"hb.6o6.com\"],\n\n\n重启docker\n\nsystemctl daemon-reload\nsystemctl restart docker\n\n修改pod的yaml文件\n\n\n\npod的属性,与containers同级的\n\nimagePullSecrets:\n  - name: regcred",
    "crumbs": [
      "基础",
      "镜像仓库"
    ]
  },
  {
    "objectID": "docs/devops/k8s/basics/harbor.html#aliyun-镜像仓库",
    "href": "docs/devops/k8s/basics/harbor.html#aliyun-镜像仓库",
    "title": "斯巴拉稀",
    "section": "2 aliyun 镜像仓库",
    "text": "2 aliyun 镜像仓库\n\n\n\n\n\n\nTip\n\n\n\n我们可以利用它来构建需要fq才能快速构建的镜像\n\n\n\n\n2.1 基础设置\n打开阿里云镜像仓库\n\n创建命名空间\n设置访问凭证\n\n# 测试一下是否能登录\ndocker login --username=your-name registry.cn-hangzhou.aliyuncs.com\n\n\n2.2 通过关联的git仓库的dockerfile\n\n\n2.3 通过独立github仓库的action\n\nfork nfs-subdir-external-provisioner\ngithub forked的 仓库 激活action\n\ngit clone https://github.com/your-fork-user/nfs-subdir-external-provisioner\ngit co -b test-br    nfs-subdir-external-provisioner-4.0.18\n# 修改部分数据\nvim .github/workflows/release.yml\n\non:\n  push:\n    branches:\n      - 'test-br'  #(1)\njobs:\n  docker:\n    runs-on: ubuntu-latest\n    steps:\n      -\n        name: Prepare\n        id: prep\n        name: Login to the container registry\n        if: github.event_name != 'pull_request'\n        uses: docker/login-action@v1\n        with:\n          registry: registry.cn-hangzhou.aliyuncs.com #(2)\n          username: ${{ secrets.REGISTRY_USERNAME }} #(3)\n          password: ${{ secrets.REGISTRY_TOKEN }}\n      -\n        name: Build and push\n\n        with:\n          platforms: linux/amd64 #(4)\n          tags: 'registry.cn-hangzhou.aliyuncs.com/your-namespace/nfs-subdir-external-provisioner:4.0.18' #(5)\n\n\ngit ci -a -m 'test'\ngit push -u origin test-br\n\n改成你的分支名\n阿里云镜像仓库\ngithub forked 对应仓库设置secret\n\n点击New repository secret按钮创建\nname设置为 REGISTRY_USERNAME , 内容secret 设置为你的 阿里云镜像仓库 登录帐号\nname设置为 REGISTRY_TOKEN, 内容secret 设置为你的 阿里云镜像仓库 登录凭证\n\n先弄成一个\n我这里为了测试先直接写死 阿里云镜像url tag. 阿里云镜像命名空间必须存在\n\n去 github 对应项目的action 页面查看是否成功, 最后确认阿里云镜像",
    "crumbs": [
      "基础",
      "镜像仓库"
    ]
  },
  {
    "objectID": "docs/devops/k8s/basics/env.html",
    "href": "docs/devops/k8s/basics/env.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "Warning\n\n\n\n从1.24开始 k8s使用的docker-engine 不一样了. 是cri-dockerd 而不是原来的dockerd-shm",
    "crumbs": [
      "基础",
      "环境安装"
    ]
  },
  {
    "objectID": "docs/devops/k8s/basics/env.html#k8s文档离线部署",
    "href": "docs/devops/k8s/basics/env.html#k8s文档离线部署",
    "title": "斯巴拉稀",
    "section": "1 k8s文档离线部署",
    "text": "1 k8s文档离线部署\ngit clone https://github.com/kubernetes/website.git\ncd website\n\n\n\n\n\n\n解决搜索后得到的url是kubernetes官方地址的问题\n\n\n\n这只是简单的处理, 还是有部分url是官方的 \n\n\n配置文件修改, 可能不需要?\n\n修改config.toml的baseURL为你配置的nginx地址\nbaseURL = \"http://localhost:8000\"\n\n修改 netlify.toml\nHUGO_BASEURL = \"http://localhost:8000/\"\n\n\n\nstatic/js/search.js 添加替换url的代码\n\n        $.ajax(ajaxConf).done(function(res) {\n            if (res.webPages == null) return; // If no result, 'webPages' is 'undefined'\n            var paginationAnchors = window.getPaginationAnchors(Math.ceil(res.webPages.totalEstimatedMatches / 10));\n            res.webPages.value.map(ob =&gt; { results += window.getResultMarkupString(ob); })\n            // ===== add start ======\n            re = new RegExp(\"https://kubernetes.io\",\"g\");\n            results = results.replace(re, \"http://localhost:8000\");\n            // ===== add end   ======\n            if($('#bing-results-container').length &gt; 0) $('#bing-results-container').html(results);\n            if($('#bing-pagination-container').length &gt; 0) $('#bing-pagination-container').html(paginationAnchors);\n        });\n\n\n\n\nhugo 生成静态文件方式指定版本docker 方式\n\n\n# 安装hugo 和node , 将里面的对应版本修改为你安装的版本\n# netlify.toml\ngit config --global url.\"https://ghproxy.com/https://github.com/\".insteadOf https://github.com/\nmake module-init\nnpm ci\nhugo # 生成静态文件到当前public目录 ,用nginx 来配置, 不要用 make serve ,会占用大量内存.\n# 取消\ngit config --global  --unset url.\"https://ghproxy.com/https://github.com/\".insteadOf\n# 更新api 文档\ncurl 'https://ghproxy.com/https://raw.githubusercontent.com/kubernetes/kubernetes/master/api/openapi-spec/swagger.json' &gt; api-ref-assets/api/swagger.json\ncd api-ref-generator/gen-resourcesdocs\ngo get -u golang.org/x/sys\n#go: upgraded golang.org/x/sys v0.0.0-20200930185726-fdedc70b468f =&gt; v0.9.0\ncd ../../\nmake api-reference\n\n\nnginx.conf\n\n    server {\n    listen       8000;\n    server_name  localhost;\n\n    location / {\n        root   /your-path/website/public;\n        index  index.html index.htm;\n    }\n}\n\n\n\n\n\n\n\n\n\nTip\n\n\n\n如果想要配置多个版本, 在页面上可以点击跳转到比如1.26的文档, 那么修改 config.toml里的params.versions对应的url,也要对应生成静态文件,nginx 配置url 打开网页,首页就会看到 You are viewing documentation for Kubernetes version: v1.23\n\n\ngit co release-1.23\n# 使用配置文件里原来的版本, 最新的hugo 生成静态文件时会报错...\ngo install -tags extended github.com/gohugoio/hugo@v0.87.0\ngit config --global url.\"https://ghproxy.com/https://github.com/\".insteadOf https://github.com/\nmake module-init\nnpm ci\n~/go/bin/hugo # 生成静态文件到当前public目录 ,用nginx 来配置, 不要用 make serve ,会占用大量内存.\n# 取消\ngit config --global  --unset url.\"https://ghproxy.com/https://github.com/\".insteadOf\n# 更新api 文档\ncurl https://ghproxy.com/https://raw.githubusercontent.com/kubernetes/kubernetes/release-1.23/api/openapi-spec/swagger.json &gt; api-ref-assets/api/swagger.json\ncd api-ref-generator/gen-resourcesdocs\ngo get -u golang.org/x/sys\n#go: upgraded golang.org/x/sys v0.0.0-20200930185726-fdedc70b468f =&gt; v0.9.0\ncd ../../\nmake api-reference",
    "crumbs": [
      "基础",
      "环境安装"
    ]
  },
  {
    "objectID": "docs/devops/k8s/basics/env.html#api-导入postman",
    "href": "docs/devops/k8s/basics/env.html#api-导入postman",
    "title": "斯巴拉稀",
    "section": "2 api 导入postman",
    "text": "2 api 导入postman\n上面的 swagger.json 导入postman\n# 部署完k8s后\nkubectl proxy --accept-hosts=\".*\" --address=0.0.0.0\n宿主机上添加这个参数, 值是 上面设置的 kubectl 所在主机ip:8001 \nsed发送请求后提示ssl错误, 在settings 里将 Enable SSL certificate verification 取消",
    "crumbs": [
      "基础",
      "环境安装"
    ]
  },
  {
    "objectID": "docs/devops/k8s/basics/env.html#前置安装",
    "href": "docs/devops/k8s/basics/env.html#前置安装",
    "title": "斯巴拉稀",
    "section": "3 前置安装",
    "text": "3 前置安装\n\n\n\n\n\n\nWarning\n\n\n\n我打包的虚拟机镜像里已经前置安装了一些东西,可能有些这里没记录.后续我再整理.\n\n\n\n关闭防火墙\n\n# --now 表示 马上停止, 这样就是禁用并停止\nsystemctl disable --now firewalld\n# systemctl disable --now dnsmasq\n# systemctl disable --now NetworkManager\n# 以前我这个也是disabled\nsed -Ei.bak 's/^SELINUX=[[:alpha:]]+$/SELINUX=permissive/' /etc/selinux/config\nsed -Ei.bak 's/^SELINUX=[[:alpha:]]+$/SELINUX=disabled/' /etc/sysconfig/selinux\nsetenforce 0 # 0表示设置为permissive\ngetenforce # 查看, 显示 permissive\n\n关闭 swap分区\n\nswapoff -a && sysctl -w vm.swappiness=0\n# 注释掉fstab 里的swap配置\nsed -Ei.bak '/^[^#]*swap/s/^/#/' /etc/fstab\n\ndocker配置\n\n\n\n/etc/docker/daemon.json\n\n{\n  \"registry-mirrors\": [\n    \"https://registry.docker-cn.com\",\n    \"http://hub-mirror.c.163.com\",\n    \"https://docker.mirrors.ustc.edu.cn\"\n  ],\n  \"exec-opts\": [\"native.cgroupdriver=systemd\"],\n  \"max-concurrent-downloads\": 10,\n  \"max-concurrent-uploads\": 5,\n  \"log-opts\": {  // /var/lib/docker/containers/\n    \"max-size\": \"300m\",\n    \"max-file\": \"2\"\n  },\n  \"live-restore\": true  // 如果不是true, 重启docker,回导致容器重启.\n}\n\nsystemctl daemon-reload\nsystemctl restart docker\n# 查看是否配置\ndocker info |grep -E -A 3 \"Cgroup|Registry Mirrors\"\n\n时间同步\n\ntimedatectl set-timezone Asia/Shanghai\nsed -i \"s/server 0.centos.pool.ntp.org iburst/server cn.pool.ntp.org iburst/\" /etc/chrony.conf\nsystemctl enable chronyd\nsystemctl start chronyd\n\nulimit\n\nulimit -SHn 65535\n\ncat &gt;&gt; /etc/security/limits.conf &lt;&lt;EOF\n*    soft    nofile    655350\n*    hard    nofile    655350\n*    soft    noproc    655350\n*    hard    noproc    655350\n*    soft    memlock   unlimited\n*    hard    memlock   unlimited\nEOF\n\n节点间ssh配置\n\ncat &gt;&gt; /etc/hosts &lt;&lt; EOF\n192.168.66.100  m1\n192.168.66.101  m2\n192.168.66.102  m3\n192.168.66.110  n1\n192.168.66.111  n2\nEOF\n# 将 master的 pub 发送到 node\nssh-keygen -t rsa\nfor i in n1 n2 m2 m3;do ssh-copy-id -i ~/.ssh/id_rsa.pub root@$i;done",
    "crumbs": [
      "基础",
      "环境安装"
    ]
  },
  {
    "objectID": "docs/devops/k8s/basics/env.html#部署",
    "href": "docs/devops/k8s/basics/env.html#部署",
    "title": "斯巴拉稀",
    "section": "4 部署",
    "text": "4 部署\n\n4.1 kubeadm方式\n官方文档\n\n4.1.1 所有节点安装kubeadm\n\nred hat-based\n\n\ncat &lt;&lt;EOF | sudo tee /etc/yum.repos.d/kubernetes.repo\n[kubernetes]\nname=Kubernetes\nbaseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/\nenabled=1\ngpgcheck=1\nrepo_gpgcheck=1\ngpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg\nEOF\n# sudo yum install -y kubelet kubeadm kubectl --disableexcludes=kubernetes\n# 安装指定版本\nsudo yum install -y kubelet-1.23.17 kubeadm-1.23.17 kubectl-1.23.17  # cri-tools-1.23.0\nsudo systemctl enable kubelet\n\n\n\n\n验证安装\n\nkubeadm version\n\n\n4.1.2 master节点init\nkubeadm config print init-defaults &gt; kubeadm.yaml\n\n\n\n\n\n\nTip\n\n\n\napiVersion 注意看配置文件的每个kind的版本, 然后去文档搜对应的配置,可能有变化\n\n\n\n\nkubeadm.yaml 做一些修改\n\napiVersion: kubeadm.k8s.io/v1beta3\nbootstrapTokens:\n- groups:\n  - system:bootstrappers:kubeadm:default-node-token\n  token: abcdef.0123456789abcdef\n  ttl: 24h0m0s\n  usages:\n  - signing\n  - authentication\nkind: InitConfiguration\nlocalAPIEndpoint:\n  advertiseAddress: 192.168.66.102 # (1)\n  bindPort: 6443\nnodeRegistration:\n  criSocket: /var/run/dockershim.sock # docker 作为runtime\n#   criSocket: unix:///var/run/containerd/containerd.sock  # containerd 作为runtime\n  imagePullPolicy: IfNotPresent\n  name: master # (4)\n  taints: null\n---\napiServer:\n  timeoutForControlPlane: 4m0s\napiVersion: kubeadm.k8s.io/v1beta3\ncertificatesDir: /etc/kubernetes/pki\nclusterName: kubernetes\ncontrollerManager: {}\ndns: {}\n#   type: CoreDNS   v1beta3 字段 \"ClusterConfiguration.dns.type\" 已经被移除，因为 CoreDNS 是 kubeadm 所支持 的唯一 DNS 服务器类型。\netcd:\n  local:\n    dataDir: /var/lib/etcd\n    listen-peer-urls: \"https://192.168.66.102:2380\" # (2)\n    listen-client-urls: \"https://192.168.66.102:2379,http://127.0.0.1:2379\"\nimageRepository: registry.cn-hangzhou.aliyuncs.com/google_containers # (3)\nkind: ClusterConfiguration\nkubernetesVersion: 1.23.17\nnetworking:\n  dnsDomain: cluster.local\n  serviceSubnet: 10.96.0.0/12\n  podSubnet: 10.244.0.0/16 # (5)\nscheduler: {}\n\n\nmaster节点的ip\n添加listen-peer-urls\n修改为 aliyun 的\n节点的名字\n集群Pod的网段\n\n\n\nmaster节点\n\n# 列出需要下载的镜像\nkubeadm config images list --config kubeadm.yaml\n# 先 下载 镜像\nkubeadm config images pull --config kubeadm.yaml\nkubeadm init --config kubeadm.yaml\n\n# 可以重新修改相关配置.\nkubectl edit cm -n kube-system kubeadm-config\n\nmkdir -p $HOME/.kube\nsudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config\nsudo chown $(id -u):$(id -g) $HOME/.kube/config\n\n# 记下 kubeadm join 的命令\n# 忘记了, 也没关系 ,重新输出\nkubeadm  token create --print-join-command\n\nk get po -A # 会看到CoreDNS pending 中, 需要安装网络插件\n\n\n4.1.3 安装 Pod 网络附加组件\n\n\n\n\n\n\nTip\n\n\n\n\n有许多网络模型可以选择\n需要kubeadm init 时指定 –pod-network-cidr 这个参数\n\n\n\n\nflannel\n\nwget https://ghproxy.com/https://github.com/flannel-io/flannel/releases/latest/download/kube-flannel.yml\nk create -f  kube-flannel.yml\n\nk get po -A # 会看到CoreDNS 也成功running了.\n\ncalico https://docs.tigera.io/calico/latest/getting-started/kubernetes/quickstart#install-calico\n\nwget  https://docs.projectcalico.org/manifests/calico.yaml\n# 会看到  实际的url \nhttps://raw.githubusercontent.com/projectcalico/calico/v3.26.1/manifests/calico.yaml\nwget https://ghproxy.com/https://raw.githubusercontent.com/projectcalico/calico/v3.26.1/manifests/calico.yaml\n# 做相应修改..\nk apply -f calico.yaml\nnetwork-plugins\n通过给 Kubelet 传递 –network-plugin=cni 命令行选项可以选择 CNI 插件。 Kubelet 从 –cni-conf-dir （默认是 /etc/cni/net.d） 读取文件并使用 该文件中的 CNI 配置来设置各个 Pod 的网络\n删除calico 需要到 每个节点上的 /etc/cni/net.d 目录下删除 calico 的相关配置, 然后 都systemctl restart kubelet\n\n\n4.1.4 node节点join\n\n\n\n\n\n\nTip\n\n\n\n\nkubectl 执行的命令会去请求master节点的apiserver,需要权限, 使用的配置文件需要从master那里复制过来.\n任何机器上有kubectl 这个命令, 然后有可以连接上apiserver的配置文件, 那么就可以用kubectl进行查看等操作\n\n\n\nall_nodes='n1 n2'\nfor node in $all_nodes; do\n     ssh $node \"mkdir -p /root/.kube\"\n     scp /etc/kubernetes/admin.conf $node:/root/.kube/config\ndone\n\nkubeadm join 192.168.66.100:6443 --token ... --discovery-token-ca-cert-hash ...\n\n\n4.1.5 安装后的相关配置以及更新\n\n\n\n\n\n\nTip\n\n\n\n在 k8s 中,有一种特殊的容器启动方法叫做”Static Pod”。它允许你把要部署的 Pod 的 YAML 文件放在一个指定的目录里,当这台机器上的 kubelet 启动时，它会 自动检查这个目录，加载所有的 Pod YAML 文件，然后在这台机器上启动它们 静态 Pod 在指定的节点上由 kubelet 守护进程直接管理,不需要 API 服务器监管. 与由控制面管理的 Pod（例如，Deployment） 不同,kubelet 监视每个静态 Pod（在它失败之后重新启动）\n\n\n\n\ncentos找到kubelet的配置文件\n\n# 1. 先看配置文件位置\nps -ef |grep kubelet\n# 2. 首先我们 kubelet 是通过systemctl 启动的.\ntree /etc/systemd/system |grep kubelet -B 10\n# 3. 位置在这, 你会发现里面并没有配置信息,这与我们 ps -ef |grep kubelet 看到的,不一样\n/usr/lib/systemd/system/kubelet.service\n# 4. 那么必定有 /usr/lib/systemd/system/kubelet.service.d 文件夹用于放置配置文件的\n#    里面的.conf 配置文件会对 systemd 单元文件(.service 里的启动程序) 进行添加、修改或覆盖服务的特定选项\n#    systemd 会加载它们并应用于原始服务单元文件\ntree /usr/lib/systemd/system/kubelet.service.d\n└── 10-kubeadm.conf\n# 5. 10-kubeadm.conf 看名字都知道这个是kubeadm 给我们创建的.\ncat 10-kubeadm.conf\n\n\n\nkubelet.service\n\n[Unit]\nDescription=kubelet: The Kubernetes Node Agent\nDocumentation=https://kubernetes.io/docs/\nWants=network-online.target\nAfter=network-online.target\n\n[Service]\nExecStart=/usr/bin/kubelet\nRestart=always\nStartLimitInterval=0\nRestartSec=10\n\n[Install]\nWantedBy=multi-user.target\n\n\n\n10-kubeadm.conf\n\n# Note: This dropin only works with kubeadm and kubelet v1.11+\n[Service]\nEnvironment=\"KUBELET_KUBECONFIG_ARGS=--bootstrap-kubeconfig=/etc/kubernetes/bootstrap-kubelet.conf --kubeconfig=/etc/kubernetes/kubelet.conf\"\nEnvironment=\"KUBELET_CONFIG_ARGS=--config=/var/lib/kubelet/config.yaml\"\n# This is a file that \"kubeadm init\" and \"kubeadm join\" generates at runtime, populating the KUBELET_KUBEADM_ARGS variable dynamically\nEnvironmentFile=-/var/lib/kubelet/kubeadm-flags.env\n# This is a file that the user can use for overrides of the kubelet args as a last resort. Preferably, the user should use\n# the .NodeRegistration.KubeletExtraArgs object in the configuration files instead. KUBELET_EXTRA_ARGS should be sourced from this file.\nEnvironmentFile=-/etc/sysconfig/kubelet\nExecStart=\nExecStart=/usr/bin/kubelet $KUBELET_KUBECONFIG_ARGS $KUBELET_CONFIG_ARGS $KUBELET_KUBEADM_ARGS $KUBELET_EXTRA_ARGS\n\n\n\n查看staticPod目录\n\ngrep staticPod /var/lib/kubelet/config.yaml\ntree /etc/kubernetes/manifests\n├── etcd.yaml\n├── kube-apiserver.yaml\n├── kube-controller-manager.yaml\n└── kube-scheduler.yaml\n\n\n\n\n\n\n\nTip\n\n\n\nkubelet 会监视这个目录,你在里面比如创建一个pod的yaml,kubelet就会为你创建这个pod. 修改里面的配置文件, K8s 将自动检测到配置文件的更改并重新启动相关服务\n\n\n\n\n\n4.2 minikube\n\n\n4.3 kind方式\n\n\n4.4 二进制方式\n\n\n4.5 kubespray方式\nkubespray\n\n\n4.6 kubesphere\n\n\n4.7 rancher\n\n\n4.8 kops\n\n\n\n\n\n\nTip\n\n\n\nInstalling and launching a Kubernetes cluster hosted on AWS, GCE, DigitalOcean, Hetzner, OpenStack, Azure\n\n\n\n\n4.9 Google Kubernetes Engine (GKE)\n\n\n4.10 高可用集群",
    "crumbs": [
      "基础",
      "环境安装"
    ]
  },
  {
    "objectID": "docs/devops/k8s/basics/env.html#后置安装",
    "href": "docs/devops/k8s/basics/env.html#后置安装",
    "title": "斯巴拉稀",
    "section": "5 后置安装",
    "text": "5 后置安装\n\n5.1 自动补全\nkubectl自动补全\n\n当前用户全局设置\n\n\n# apt-get install bash-completion\nyum install bash-completion -y\nsource /usr/share/bash-completion/bash_completion\necho  \"source /usr/share/bash-completion/bash_completion\" &gt;&gt; ~/.bashrc\n# 检查 bash-completion 是否设置完成\ntype _init_completion\necho \"source &lt;(kubectl completion bash)\" &gt;&gt; ~/.bashrc\n# 这样 使用k 就能自动补全了\necho 'alias k=kubectl' &gt;&gt;~/.bashrc\necho 'complete -o default -F __start_kubectl k' &gt;&gt;~/.bashrc\n# 这样去搜关键字  kubectl alias auto complete\necho 'alias ks=\"kubectl -n kube-system\"' &gt;&gt;~/.bashrc\necho 'complete -o default -F __start_kubectl ks' &gt;&gt;~/.bashrc\n\n\n# apt-get install bash-completion\nyum install bash-completion -y\nsource /usr/share/bash-completion/bash_completion\n# echo  \"source /usr/share/bash-completion/bash_completion\" &gt;&gt; /etc/profile\nkubectl completion bash | sudo tee /etc/bash_completion.d/kubectl &gt; /dev/null\n# 检查 bash-completion 是否设置完成\ntype _init_completion\necho \"source &lt;(kubectl completion bash)\" &gt;&gt; /etc/profile\n# 这样 使用k 就能自动补全了\necho 'alias k=kubectl' &gt;&gt;/etc/profile\necho 'complete -o default -F __start_kubectl k' &gt;&gt;/etc/profile\n# 这样去搜关键字  kubectl alias auto complete\necho 'alias ks=\"kubectl -n kube-system\"' &gt;&gt;/etc/profile\necho 'complete -o default -F __start_kubectl ks' &gt;&gt;/etc/profile\n\n\n\n\n\n5.2 独立安装kubectl\nmac安装kubectl\ncurl -LO \"https://dl.k8s.io/release/v1.23.17/bin/darwin/amd64/kubectl\"\nchmod +x kubectl\nmv kubectl /usr/local/bin\n# 将master节点(我的环境 是虚拟机)里的.kube 文件夹复制到 mac (host 主机)的 ~ 目录\n# 这样\n\n\n验证是否配置成功\n\nkubectl cluster-info # 看看\nkubectl get no\n  NAME      STATUS   ROLES                  AGE     VERSION\n  master1   Ready    control-plane,master   4d23h   v1.23.17\n  node1     Ready    &lt;none&gt;                 3d17h   v1.23.17\n  node2     Ready    &lt;none&gt;                 4m46s   v1.23.17\nkubectl get no -o wide # 可以看到 使用的容器运行时",
    "crumbs": [
      "基础",
      "环境安装"
    ]
  },
  {
    "objectID": "docs/devops/k8s/ecosystem/helm.html",
    "href": "docs/devops/k8s/ecosystem/helm.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "https://artifacthub.io/",
    "crumbs": [
      "生态",
      "helm"
    ]
  },
  {
    "objectID": "docs/devops/k8s/ecosystem/helm.html#介绍1",
    "href": "docs/devops/k8s/ecosystem/helm.html#介绍1",
    "title": "斯巴拉稀",
    "section": "1 介绍1",
    "text": "1 介绍1\n\n\n\n\nKubernetes的世界\nLinux的世界\n\n\n\n\n运行着的对象\n容器\n进程\n\n\n运行态管理\nhelm3 移除了 tiller\nSystemd\n\n\n安装包版本\nHelm Chart Version\nRPM Version\n\n\n安装包\nHelm Chart\nRPM包\n\n\n包管理工具\nHelm\nYum\n\n\n安装包仓库\nHelm Repository\nRPM Repositoy/Mirror\n\n\n操作系统\nKubernetes\nLinux发行版",
    "crumbs": [
      "生态",
      "helm"
    ]
  },
  {
    "objectID": "docs/devops/k8s/ecosystem/helm.html#安装3",
    "href": "docs/devops/k8s/ecosystem/helm.html#安装3",
    "title": "斯巴拉稀",
    "section": "2 安装2",
    "text": "2 安装2\nwget https://repo.huaweicloud.com/helm/v3.12.2/helm-v3.12.2-linux-amd64.tar.gz\ntest $(sha256sum helm-v3.12.2-linux-amd64.tar.gz  |awk '{print $1}') == \"2b6efaa009891d3703869f4be80ab86faa33fa83d9d5ff2f6492a8aebe97b219\" && echo \"file is ok\" || echo \"file is not ok\"\ntar -zxvf helm-v3.12.2-linux-amd64.tar.gz  -C /usr/local/bin/ --strip-components=1 linux-amd64/helm",
    "crumbs": [
      "生态",
      "helm"
    ]
  },
  {
    "objectID": "docs/devops/k8s/ecosystem/helm.html#使用",
    "href": "docs/devops/k8s/ecosystem/helm.html#使用",
    "title": "斯巴拉稀",
    "section": "3 使用",
    "text": "3 使用\n# 显示安装的  -A 表示所有命名空间\nhelm list -A\nhelm uninstall xxx -n your-namespace\n\nhelm repo add nfs-subdir-external-provisioner https://kubernetes-sigs.github.io/nfs-subdir-external-provisioner/\nhelm repo list",
    "crumbs": [
      "生态",
      "helm"
    ]
  },
  {
    "objectID": "docs/devops/k8s/ecosystem/helm.html#footnotes",
    "href": "docs/devops/k8s/ecosystem/helm.html#footnotes",
    "title": "斯巴拉稀",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nhelm官方↩︎\n国内源下载helm↩︎",
    "crumbs": [
      "生态",
      "helm"
    ]
  },
  {
    "objectID": "docs/devops/docker/namespace.html",
    "href": "docs/devops/docker/namespace.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "Back to top",
    "crumbs": [
      "底层原理(todo...)",
      "namespace"
    ]
  },
  {
    "objectID": "docs/devops/docker/architecture.html",
    "href": "docs/devops/docker/architecture.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "todo…\nOCI Containerd RunC\n\n\n\n\n Back to top",
    "crumbs": [
      "基础",
      "架构"
    ]
  },
  {
    "objectID": "docs/devops/docker/docker.html",
    "href": "docs/devops/docker/docker.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "待整理",
    "crumbs": [
      "基础",
      "常用命令"
    ]
  },
  {
    "objectID": "docs/devops/docker/docker.html#基础命令",
    "href": "docs/devops/docker/docker.html#基础命令",
    "title": "斯巴拉稀",
    "section": "1 基础命令",
    "text": "1 基础命令\n\n显示docker相关信息\n\ndocker info\nClient:\n Context:    default\n Debug Mode: false\n Plugins:\n  buildx: Docker Buildx (Docker Inc.)\n    Version:  v0.10.4\n    Path:     /usr/libexec/docker/cli-plugins/docker-buildx\n  compose: Docker Compose (Docker Inc.)\n    Version:  v2.17.2\n    Path:     /usr/libexec/docker/cli-plugins/docker-compose\n  scan: Docker Scan (Docker Inc.)\n    Version:  v0.23.0\n    Path:     /usr/libexec/docker/cli-plugins/docker-scan\n\nServer:\n Containers: 6\n  Running: 6\n  Paused: 0\n  Stopped: 0\n Images: 6\n Server Version: 23.0.2\n Storage Driver: overlay2\n  Backing Filesystem: extfs\n  Supports d_type: true\n  Using metacopy: false\n  Native Overlay Diff: true\n  userxattr: false\n Logging Driver: json-file # 表示存在本地, 是可以让他存放在远端的\n Cgroup Driver: cgroupfs # 限制与隔离的驱动\n Cgroup Version: 1\n Plugins:\n  Volume: local\n  Network: bridge host ipvlan macvlan null overlay\n  Log: awslogs fluentd gcplogs gelf journald json-file local logentries splunk syslog\n Swarm: inactive  # 编排工具, 不开启\n Runtimes: io.containerd.runc.v2 runc\n Default Runtime: runc\n Init Binary: docker-init\n containerd version: 2806fc1057397dbaeefbea0e4e17bddfbd388f38\n runc version: v1.1.5-0-gf19387a\n init version: de40ad0\n Security Options:\n  apparmor\n  seccomp\n   Profile: builtin\n Kernel Version: 5.4.0-146-generic\n Operating System: Ubuntu 20.04.6 LTS\n OSType: linux\n Architecture: x86_64\n CPUs: 2\n Total Memory: 3.84GiB\n Name: ubtest\n ID: fb514c1e-58bd-4be0-ad81-c8d7c4413f53\n Docker Root Dir: /var/lib/docker  # 数据存放的位置\n Debug Mode: false\n Registry: https://index.docker.io/v1/ \n Experimental: false\n Insecure Registries:\n  127.0.0.0/8\n Live Restore Enabled: false  #热更新 生产环境 设置为true ,表示重启docker ,容器不会重启\n\n查看版本\n\ndocker version\nServer: Docker Engine - Community\n Engine:\n  Version:          23.0.2\n  API version:      1.42 (minimum version 1.12)\n  Go version:       go1.19.7\n  Git commit:       219f21b\n  Built:            Mon Mar 27 16:16:18 2023\n  OS/Arch:          linux/amd64\n  Experimental:     false\n containerd:\n  Version:          1.6.20\n  GitCommit:        2806fc1057397dbaeefbea0e4e17bddfbd388f38\n runc:\n  Version:          1.1.5\n  GitCommit:        v1.1.5-0-gf19387a\n docker-init:\n  Version:          0.19.0\n  GitCommit:        de40ad0",
    "crumbs": [
      "基础",
      "常用命令"
    ]
  },
  {
    "objectID": "docs/devops/docker/docker.html#镜像操作",
    "href": "docs/devops/docker/docker.html#镜像操作",
    "title": "斯巴拉稀",
    "section": "2 镜像操作",
    "text": "2 镜像操作\n\n2.1 搜索\ndocker search nginx\n\n\n2.2 拉取\n# 默认拉取最新版\ndocker pull nginx\n# 等价于这个\ndocker pull nginx:latest\n# 拉取某个 sha256的版本\ndocker pull nginx@sha256:1195d1c1cd901058d1f059f2e31e17b559f51a03e093bf0a774c9304aebb5c36\n\n\n2.3 查看\n# 查看本地下载的所有镜像\ndocker images\n# 查看镜像有几层 (看dockerfile后就明白了)\ndocker history image_id\n\n\n2.4 标签\n# docker tag 镜像id或者镜像名:版本  新的...\ndocker images\n    REPOSITORY   TAG       IMAGE ID       CREATED      SIZE\n    nginx        latest    0e901e68141f   3 days ago   142MB\ndocker tag 0e901e68141f nginx:v1.0\n# 或\ndocker tag nginx:latest nginx:v1.0\n\n# 查看 ,原来的还在的, 另外一个并不会占用空间的.\ndocker images\n    REPOSITORY   TAG       IMAGE ID       CREATED      SIZE\n    nginx        v1.0      0e901e68141f   3 days ago   142MB\n    nginx        latest    0e901e68141f   3 days ago   142MB\n\ndocker rmi nginx:latest # 相当于删除标签\n\n\n2.5 登录和推送\ndocker login  #默认登录官方的 hub库\ndocker login hub.yy.com # 登录自己的镜像仓库. hub.yy.com 自己弄去\n# 登录你的aliyun 的 仓库. \ndocker login --username=...  register.cn-hz-aliyuncs.com\n# 将你的镜像tag 改成你的 仓库名. myhub是你的仓库名\ndocker tag 0e901e68141f myhub/nginx:latest\n\n# 推送镜像\ndocker image push myhub/nginx:latest\n#等价与\ndocker push myhub/nginx:latest\n\n\n2.6 删除\n# 如果镜像正在被容器使用, 是无法删除的\ndocker rmi image_id\n# 等价\ndocker image rm image_id\n\n# 删除所有的镜像\ndocker image prune\n\n\n2.7 编译打包\n# 根据dockerfile 打包镜像\n# -t 表示 镜像的tag, . 是dockerfile所在路径\ndocker build -t nginx:123 .\n\n\n2.8 save && load\n!!! tip 当你镜像不能通过仓库进行分享或传输, 我们本地保存然后给其他人.\ndocker save nginx -o nginx.tar\n# 其他人使用的时候\ndocker load &lt; nginx.tar",
    "crumbs": [
      "基础",
      "常用命令"
    ]
  },
  {
    "objectID": "docs/devops/docker/docker.html#容器操作",
    "href": "docs/devops/docker/docker.html#容器操作",
    "title": "斯巴拉稀",
    "section": "3 容器操作",
    "text": "3 容器操作\n\n3.1 创建,启动,停止\n# 创建\ndocker create -it --name nginx nginx:latest\ndocker ps # 没有看到, 只是创建了.\n# 启动容器, 使用容器名或容器id\ndocker start nginx\ndocker ps\n# 优雅停止, 使用容器名或容器id\ndocker stop nginx\n# 强制停止, 使用容器名或容器id\ndocker kill nginx\n# 停止容器里的进程\ndocker pause nginx\ndocker ps # 查看, 容器还是运行的, status 显示 pause\n  CONTAINER ID   IMAGE          COMMAND                  CREATED         STATUS                  PORTS     NAMES\n  316e566c99fa   nginx:latest   \"/docker-entrypoint.…\"   4 minutes ago   Up 7 seconds (Paused)   80/tcp    nginx\ndocker unpause nginx # 重新启动进程\n\n\n3.2 运行\n!!! tip 相比较前面的 create start 这个更常用, 直接就创建并且启动了容器\n\n#交互的,直接进入该容器,如果退出exit,该容器就退出了\n# -it  交互式 前台, 运行bash 命令 ,-i=--interactive -t=tty\n# nginx:latest 镜像名, 先会查看本地有没有这个镜像,如果没有则从 docker.io上拉取\n# --name 容器名\ndocker run -it --name abc nginx:latest bash\n# 后台 -d\ndocker run -itd nginx:latest\n# 端口映射,将容器里的80端口映射到本机的8080端口\ndocker run -itd -p 8080:80 nginx:latest\n\n# 退出会自动删除容器\ndocker run -it --rm nginx:latest\n\n\n3.3 commit\n\ndocker pull centos\ndocker run -it centos\n#这个时候已经直接进去该容器的bash了\nyum install vim -y #我们安装一个vim\n#exit #然后退出\n#可以查看一下该容器的信息\n#将该容器commit 成一个image 下面的:latest 是tag 可以不设置,默认就是latest\ndocker commit -m 'install vim' 容器名 自己设置的image名(test/centos-vim:latest)\n\n\n3.4 exec 执行指令\n# 执行容器里的bash , 这个实际就是进入了容器, 执行了bash ,前台\ndocker exec -it nginx bash\n# 进入容器运行指令后直接退出\ndocker exec -it nginx ls /var/log/nginx\n  # access.log  error.log\n\n\n3.5 查看容器进程信息\n# 查看容器里的运行的进程\ndocker top nginx\n# 查看容器里进程的资源使用情况, 会前台执行一直\ndocker stats nginx\n# 输出一次就退出\ndocker stats nginx --no-stream\n\n\n3.6 重命名\ndocker rename nginx nginx_new\n\n\n3.7 控制cpu的使用的运行\ndocker run -itd --name=nginx --cpu-period=100000 --cpu-quota=10000 nginx\n\n\n3.8 加入其他容器的net ns\ndocker run -it --net container:4ddf4638572d busybox ifconfig\n\n\n3.9 带上数据持久化的运行\n#将本地的/home/html目录映射到容器中的/usr/share/nginx/html\n#这样本地做什么修改，容器就修改，通过容器修改，本地也就修改了\ndocker run -d --name nginx01 -v /home/html:/usr/share/nginx/html nginx\n\ndocker volume ls\n\n\n3.10 查看运行的容器\n#显示当前正在运行的容器\ndocker ps\ndocker container ls #等价于上面的\n# 查看 状态是退出的容器\ndocker ps -f 'status=exited'\n# 比如你创建了一个名字为go-web 的容器, 你想要看这个容器 包含关系\ndocker ps -f name=go\ndocker ps -l # 最新创建的一个容器\n#显示所有的容器，包括已经退出的\ndocker ps -a\ndocker container ls -a\n# 查看运行的容器的id (简化输出)\ndocker ps -q\n# 所有容器的id\ndocker ps -aq\n\n\n3.11 删除\n# 这个默认就是删除容器\n# id 只要前面几位就行，能区别其他的容器就ok\n# 容器正在运行 这个命令会报错\ndocker rm 容器id\ndocker container rm 容器id\n# 强制删除, 不管是否在运行\ndocker rm -f 容器id\n\n# 删除所有的容器,强制的. 注意操作.\ndocker rm -f $(docker ps -aq)\n# 只删除已经退出的容器\ndocker rm $(docker ps -f 'status=exited' -q)\n# 删除已经退出的容器\ndocker container prune\n\n\n3.12 查看容器运行日志\n# 假如你的容器里的日志是写在文件里的, 那么这里就看不到 容器的日志了\n# 我们自己开发的镜像 运行后  应该将日志显示在前台. 控制台, 才能看到日志\ndocker logs -f  容器id\ndocker logs -f  容器id  --tail 1\n\n\n3.13 容器与主机的文件传输\n\n从容器复制到主机从主机复制到容器\n\n\n# nginx 是容器名  ~/ 是主机的目录\ndocker cp nginx:/app.c ~/\n\n\n# nginx: 表示容器名, text.txt 是主机的文件\ndocker cp text.txt nginx:/\n\n\n\n\n\n3.14 排查 容器的操作记录\n# 查看从昨天开始到现在的 docker的操作记录\ndocker events --since=$(date -d \"1 day ago\" +%s)\ndocker events --since=$(date -d \"2 day ago\" +%s) --until=$(date -d \"1 day ago\" +%s)",
    "crumbs": [
      "基础",
      "常用命令"
    ]
  },
  {
    "objectID": "docs/devops/docker/docker.html#inspect-获取容器镜像的元数据",
    "href": "docs/devops/docker/docker.html#inspect-获取容器镜像的元数据",
    "title": "斯巴拉稀",
    "section": "4 inspect 获取容器/镜像的元数据",
    "text": "4 inspect 获取容器/镜像的元数据\ndocker inspect 容器id/容器名/镜像名/镜像id",
    "crumbs": [
      "基础",
      "常用命令"
    ]
  },
  {
    "objectID": "docs/devops/docker/docker-compose.html",
    "href": "docs/devops/docker/docker-compose.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "Caution\n\n\n\ntodo…\nhttps://docs.docker.com/compose/install/linux/",
    "crumbs": [
      "基础",
      "docker-compose"
    ]
  },
  {
    "objectID": "docs/devops/docker/docker-compose.html#一些简易的yml",
    "href": "docs/devops/docker/docker-compose.html#一些简易的yml",
    "title": "斯巴拉稀",
    "section": "1 一些简易的yml",
    "text": "1 一些简易的yml\n\n\nconsul\n\nversion: '3'\nservices:\n  consul:\n    image: consul\n    restart: always\n    container_name: consul_server\n    network_mode: bridge \n    volumes: \n      - ./consul:/tmp/consul\n    ports:\n      - 8300:8300\n      - 8301:8301\n      - 8301:8301/udp\n      - 8302:8302\n      - 8302:8302/udp\n      - 8400:8400\n      - 8500:8500\n      - 8600:8600/udp\n      - 53:53/udp\n    command: consul agent -data-dir=/tmp/consul -dev -client=0.0.0.0\n\n\n\ngrafana\n\nversion: \"3\"\n\nservices:\n  grafana:\n    image: grafana/grafana\n    ports:\n      - 3000:3000\n    environment:\n    #   GF_INSTALL_PLUGINS=grafana-clock-panel,grafana-simple-json-datasource\n    #   GF_SECURITY_ADMIN_PASSWORD=admin\n      GF_INSTALL_PLUGINS: grafana-clock-panel,grafana-simple-json-datasource \n      # 卡的话,使用url地址来;后面是别名 然后用,隔开表示另外一个插件 https://codeload.github.com/grafana/clock-panel/legacy.zip/bb466d0682d58af659b018748d53c0d3b69a8377;clock-panel,https://codeload.github.com/grafana/simple-json-datasource/legacy.zip/87ced44c4587eae39eeedcbd4b2936593724de16;simple-json-datasource\n      GF_SECURITY_ADMIN_PASSWORD: admin\n    volumes:\n      - ./grafana:/var/lib/grafana\n\n\n\nmysql\n\nversion: '3'\nservices:\n  db:\n    image: mysql:5.7\n    container_name: mysql\n    ports:\n      - 3306:3306\n    environment:\n      MYSQL_ALLOW_EMPTY_PASSWORD: 1\n    volumes:\n      - ./mysql/data:/var/lib/mysql\n    networks:\n      - my-bridge\nnetworks:\n  my-bridge:\n    driver: bridge\n\n\n\nrabbitmq\n\nversion: '3.1'\nservices:\n  rabbitmq:\n    image: rabbitmq:3.6.9-management\n    ports:\n      - \"4369:4369\"\n      - \"5671:5671\"\n      - \"5672:5672\"\n      - \"15672:15672\"\n      - \"25672:25672\"\n    hostname: rmq\n    container_name: rabbitmq\n    environment:\n      RABBITMQ_DEFAULT_VHOST: /\n      RABBITMQ_DEFAULT_USER: admin\n      RABBITMQ_DEFAULT_PASS: admin\n      RABBITMQ_LOGS: /var/lib/rabbitmq/rabbitmq.log\n      RABBITMQ_SASL_LOGS: /var/lib/rabbitmq/rabbitmq-sasl.log\n      RABBITMQ_ERLANG_COOKIE: LZJADKXKLULIXFKAALGX\n      TZ: Asia/Shanghai\n      #extra_hosts:\n#      - \"rmq_node1:172.16.11.106\"\n#- \"rmq_node2:172.16.11.156\"\n#      - \"rmq_node3:172.16.11.206\"\n    volumes:\n      - ./rabbitmq:/var/lib/rabbitmq\n#      - /etc/hosts:/etc/hosts\n    restart: always\n\n\n\nredis\n\nversion: '3'\nservices:\n  redis:\n    image: redis:alpine\n    container_name: redis\n      #    restart: always\n    volumes:\n      - ~/docker_data/redis/data:/data\n      - ~/docker_data/redis/logs:/logs\n        #- ./conf/redis.conf:/usr/local/etc/redis/redis.conf\n    ports:\n      - 6379:6379\n\n\n1.1 vscode go开发用\ngolang-vscode1\nnacos2",
    "crumbs": [
      "基础",
      "docker-compose"
    ]
  },
  {
    "objectID": "docs/devops/docker/docker-compose.html#footnotes",
    "href": "docs/devops/docker/docker-compose.html#footnotes",
    "title": "斯巴拉稀",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nhttps://github.com/microsoft/vscode-remote-try-go↩︎\nnacos-docker↩︎",
    "crumbs": [
      "基础",
      "docker-compose"
    ]
  },
  {
    "objectID": "docs/devops/docker/docker-file.html",
    "href": "docs/devops/docker/docker-file.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "未完待续",
    "crumbs": [
      "基础",
      "dockerfile"
    ]
  },
  {
    "objectID": "docs/devops/docker/docker-file.html#dockerfile-指令",
    "href": "docs/devops/docker/docker-file.html#dockerfile-指令",
    "title": "斯巴拉稀",
    "section": "1 dockerfile 指令",
    "text": "1 dockerfile 指令\n\n1.1 from\nFROM:选择基础镜像，推荐 alpine\nFROM [--platform=&lt;platform&gt;] &lt;image&gt;[@&lt;digest&gt;] [AS &lt;name&gt;]\n\n\n1.2 LABEL\nmaintainer 废弃\n按标签组织项目 (不用搞目录什么的.)\nLABEL multi.label1=\"value1\" multi.label2=\"value2\" other=\"value3\"\n配合 label filter 可过滤镜像查询结果\ndocker images -f label=multi.label1=\"value1\"\n查看镜像的label\n# -A 10 看 labels 后10行\ndocker inspect image_name |grep labels -A 10\n\n\n1.3 RUN\n!!! warning 这两条命令应该永远用&&连接，如果分开执行，RUN apt-get update 构建层被缓存，可能会导致新 package 无法安装\n执行命令,最常见的用法是\nRUN apt-get update && apt-get install\n\n\n1.4 CMD\n!!! tip 1. 运行的命令会被实际执行是指定的命令覆盖 2. 定义了多个,只有最后一个会执行 3. 当指定了 ENTRYPOINT 后，CMD 的含义就发生了改变，不再是直接的运行其命令，而是将 CMD 的内容作为参数传给 ENTRYPOINT 指令\nCMD [\"executableA\", \"param1\", \"param2\"...]\nCMD [\"executableB\", \"param1\", \"param2\"...]\n# 这个echo hello 会覆盖配置里的cmd, 配置里的cmd不会执行\n# 在没有 ENTRYPOINT的时候,我们运行容器, 想执行什么命令就执行什么命令\ndocker run image_name echo hello\n\n\n1.5 ENTRYPOINT\n!!! tips - 定义可以执行的容器镜像入口命令 ,必定会执行,不会被覆盖 - ==在不指定entrypoint的情况下,Docker 会为你提供一个隐含的 ENTRYPOINT，即:/bin/sh -c, 所以你的cmd 是这个的参数哦== - 不过docker run 时指定–entrypoint 可以覆盖\n# 我们一般 是不会这么做的...\ndocker run -it --entrypoint /bin/bash image_name \n# 注意覆盖的是 entrypoint 里的指令,\n# 设置的cmd 还是作为 entrypoint 的参数,这里可以指定参数 /usr/share/nginx/html\ndocker run -it --entrypoint ls nginx  /usr/share/nginx/html\n\n# 这个是进入容器执行, 不是说覆盖了原来的entrypoint..  别混淆了.\n# 任何运行的容器,都可以这样操作..\ndocker exec -it image_name bash\n#docker run –-entrypoint 可替换 Dockerfile 中定义的 ENTRYPOINT  \n#ENTRYPOINT 的最佳实践是用 ENTRYPOINT 定义镜像主命令，并通过 CMD 定义主要参数，如下所示\nENTRYPOINT [\"sed\"]\nCMD [\"--help\"]\n\n#可以这样, 这样的话, 就看你运行的时候指定啥了.\nCMD []\nFROM ubuntu\nRUN apt-get update && apt-get install  -y stress\nENTRYPOINT [\"/usr/bin/stress\"]\nCMD []\ndocker build -t stress .\n# 指定的参数-v会覆盖 dockerfile里配置的cmd\ndocker run --rm stress -v\n\n1.5.1 exec模式 与 shell模式\n!!! note “shell模式与exec模式的区别” shell 模式会忽略所有 CMD 命令的参数和 docker run 的命令行参数，ENTRYPOINT 要运行的命令会作为 /bin/sh -c 的子命令运行，而且 /bin/sh 不会传递信号，也就是说 ENTRYPOINT 要运行的命令不是 PID 为 1 的进程，且不会收到 Unix 信号，所以你要执行的命令不会收到 docker stop  发出的 SIGTERM 信号 (这里说的是,不会优雅退出, 就是直接停止了容器, 还没停止里面的程序, 可以写个程序测试) 一般情况下,我们停止一个服务, 是需要优雅退出的. 比如nginx ,会先让其处理已经发送过来的请求.\n=== “exec模式 (推荐)” dockerfile     # exec 模式     ENTRYPOINT [\"executable\", \"param1\", \"param2\"] dockerfile     FROM ubuntu     ENTRYPOINT [\"top\", \"-b\"]     CMD [\"-c\"] bash     docker build -t top .     docker run --rm --name top top     # 然后在另外一个会话执行 下面的, 可以看到, 执行的命令本身 pid =1     docker exec -it top ps -ef         UID        PID  PPID  C STIME TTY          TIME CMD         root         1     0  0 03:29 ?        00:00:00 top -b -c         root        16     0  0 03:30 pts/0    00:00:00 ps -ef     我们可以 ctrl+c 退出 === “shell模式”\n```dockerfile\nENTRYPOINT command param1 param2\n```\n\n```dockerfile\nFROM ubuntu\nENTRYPOINT top -b\nCMD -c\n```\n```bash\n# 是 pid=1 的shell 进程的 子进程\ndocker exec -it stest ps -ef\n    UID        PID  PPID  C STIME TTY          TIME CMD\n    root         1     0  0 03:36 ?        00:00:00 /bin/sh -c top -b /bin/sh -c -c\n    root         7     1  0 03:36 ?        00:00:00 top -b\n    root        17     0  0 03:36 pts/0    00:00:00 ps -ef\n#ctrl+c 没反应.. \n```\n=== “go程序测试” !!! warning 写的代码 测试信号接收.. 代码暂时没找到在哪…..\n\n\n\n1.6 EXPOSE\n暴露端口\n\n是镜像创建者和使用者的约定,告知用户你暴露了什么服务(端口)\n在 docker run –P 时，docker 会自动映射 expose 的端口到主机大端口，如0.0.0.0:32768-&gt;80/tcp\n-P 是将容器内所有暴露的端口(写了EXPOSE的) 映射到主机的随机端口上,如果没有写EXPOSE, 就不会映射任何端口\n-p 指定容器的端口({==无需 dockerfile 写 EXPOSE==})映射到主机\n从某种意义上看{==EXPOSE只是一种提醒/告知: 说我这个应用应该访问这个端口,这个端口提供服务==}\n\n--8&lt;-- \"devops/docker/code/go-web-simple/main.go\"\n--8&lt;-- \"devops/docker/code/go-web-simple/dockerfile\"\nEXPOSE &lt;port&gt; [&lt;port&gt;/&lt;protocol&gt;...]\n\n\n1.7 HEALTHCHECK\n健康检查\n--interval=&lt;duration&gt;：指定健康检查的时间间隔,默认为 30 秒.\n--timeout=&lt;duration&gt;：指定每次健康检查的超时时间,默认为 30 秒.\n--retries=&lt;number&gt;：指定在将容器标记为不健康之前尝试健康检查的次数,默认为 3 次.\nHEALTHCHECK --interval=5s --timeout=3s \\\n  CMD curl -f http://localhost/ || exit 1\n\n\n1.8 ENV\n设置环境变量, 就是进入容器后,你可以用env 看到这些\nENV &lt;key&gt;=&lt;value&gt; ...\n#或者MYSQL_VERSION=5.7\nENV MYSQL_VERSION 5.7\n# run 实际上是进入容器执行的. 所以用到的变量可以\nRUN agt-get install -y mysql-server=\"${MYSQL_VERSION}\"  \n\n\n1.9 ADD (不推荐)\n!!! note - 从源地址(文件，目录或者 URL)复制文件到目标路径 - 如果 src 是一个本地压缩文件,则在 ADD 的同时完整解压操作 - 如果 dest 不存在,则 ADD 指令会创建目标目录 - 如果 dest 结尾没有/,那么 dest 是目标文件名,如果 dest 结尾有/,那么 dest 是目标目录名 - 如果 src 是一个目录,则所有文件都会被复制至 dest - 如果 src 是一个本地压缩文件,则在 ADD 的同时完整解压操作 - ADD 支持通配符，如 ADD check* /testdir/\nADD [--chown=&lt;user&gt;:&lt;group&gt;] &lt;src&gt;... &lt;dest&gt;  \nADD [--chown=&lt;user&gt;:&lt;group&gt;] [\"&lt;src&gt;\",... \"&lt;dest&gt;\"] (路径中有空格时使用)\n\n\n1.10 COPY\n!!! note - COPY:从源地址(文件，目录)复制文件到目标路径 - 可以用于多阶段编译场景，可以用前一个临时镜像中拷贝文件 - COPY 不解压文件 - COPY 只支持本地文件的复制\nCOPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;src&gt;... &lt;dest&gt;\nCOPY [--chown=&lt;user&gt;:&lt;group&gt;] [\"&lt;src&gt;\",... \"&lt;dest&gt;\"] # 路径中有空格时使用\nCOPY --from=build /bin/project /bin/project\n```bash title=“src是目录时注意点” FROM ubuntu COPY tmp /root/\n. ├── dockerfile └── tmp ├── abc └── t2 └── 123\ndocker run –rm tmp ls /root abc t2 #没有 tmp 目录,, 所以写copy的时候 要 copy tmp /root/tmp\n\n\n\n###  VOLUME\n将指定目录定义为外挂存储卷，Dockerfile 中在该指令之后所有对同一目录的修改都无效 VOLUME [\"/data\"]\n等价于 docker run –v /data，可通过 docker inspect 查看主机的 mount point， /var/lib/docker/volumes//_data\n### WORKDIR\n切换工作目录\nWORKDIR，意思是在这一句之后，Dockerfile 后面的操作都以这一句指定的 WORKDIR 目录作为当前目录\n还有设置后,你`docker run -it xxx bash` 进入后, `pwd`看到的,就不会是默认的/ 而是这个了.\n\n\n```dockerfile\nWORKDIR /path/to/workdir\n\n\n1.11 USER\nUSER:切换运行镜像的用户和用户组, 容器默认会以root的用户去运行容器, 可以用user指定成其他 用户必须存在,没有的话先添加\n#RUN USERADD abc\nUSER &lt;user&gt;[:&lt;group&gt;] \n\n# 进去容器后,  whoami 能看到\n\n\n1.12 ARG\nfrom ubuntu\nARG FILE\n# 可以有默认值\nARG DIR=\"/root\"\n\nRUN cd $DIR && touch $FILE\n\n# 生成镜像的时候 --build-arg 然后 FILE=hello.txt 传递 参数\ndocker build --build-arg FILE=hello.txt -t yyy  .\n\n\n1.13 其他\n• ONBUILD  \n• STOPSIGNAL  \n• HEALTHCHECK \n• SHELL\n\n\n1.14 dockerfile 最佳实践\n\n每个镜像最好只有一个进程\n当无法避免同一镜像运行多进程时,应选择合理的初始化进程(init process)\n最小化层级数\n\n只有 RUN,COPY,ADD 会创建新层,其他指令创建临时层,不会增加镜像大小\n多条 RUN 命令可通过连接符连接成一条指令集以减少层数\n通过多段构建减少镜像层数\n\n把多行参数按字母排序，可以减少可能出现的重复参数，并且提高可读性\n编写 dockerfile 的时候,应该把变更频率低的编译指令优先构建以便放在镜像底层以有效利用 build cache\n复制文件时,每个文件应独立复制,这确保某个文件变更时,只影响改文件对应的缓存",
    "crumbs": [
      "基础",
      "dockerfile"
    ]
  },
  {
    "objectID": "docs/devops/docker/docker-file.html#多进程的容器镜像1",
    "href": "docs/devops/docker/docker-file.html#多进程的容器镜像1",
    "title": "斯巴拉稀",
    "section": "2 多进程的容器镜像1",
    "text": "2 多进程的容器镜像1\n\n选择适当的 init 进程\n需要捕获 SIGTERM 信号并完成子进程的优雅终止\n负责清理退出的子进程以避免僵尸进程",
    "crumbs": [
      "基础",
      "dockerfile"
    ]
  },
  {
    "objectID": "docs/devops/docker/docker-file.html#构建-build",
    "href": "docs/devops/docker/docker-file.html#构建-build",
    "title": "斯巴拉稀",
    "section": "3 构建 build",
    "text": "3 构建 build\n\n3.1 理解构建上下文(Build Context)\n!!! note - 当运行 docker build 命令时，当前工作目录被称为构建上下文 - 首先会把构建上下文传输给docker daemon,可能当前目录(构建上下文)里有很多没用的文件,这样就会导致传输时间长,所以当前目录要干净 - 可以通过 .dockerignore 文件从编译上下文排除某些文件 - 可以创建一个专门的目录放置 Dockerfile，并在目录中运行 docker build\n# .  就是你的构建目录,会将这个目录下的所有文件包含在构建上下文\n# 默认查找当前目录的 Dockerfile ,–f 指定 Dockerfile\ndocker build . –f ./Dockerfile\n\n\n3.2 Build Cache\n构建容器镜像时，Docker 依次读取 Dockerfile 中的指令，并按顺序依次执行构建指令。\nDocker 读取指令后，会先判断缓存中是否有可用的已存镜像，只有已存镜像不存在时才会重新构建。\n\n通常 Docker 简单判断 Dockerfile 中的指令与镜像。\n针对 ADD 和 COPY 指令，Docker 判断该镜像层每一个文件的内容并生成一个 checksum，与现存镜像比较时，Docker 比较的是二者的 checksum。\n其他指令，比如 RUN apt-get -y update，Docker 简单比较与现存镜像中的指令字串是否一致。\n当某一层 cache 失效以后，所有所有层级的 cache 均一并失效，后续指令都重新构建镜像。\n\n==所以构建的时候,不会变的东西放到最上面==\n\n\n\n\n3.3 多段构建(Multi-stage build)\nFROM golang:1.10-alpine3.8 AS multistage\n\nRUN apk add --no-cache --update git\n\nWORKDIR /go/src/api\nCOPY . .\n\nRUN go get -d -v \\\n  && go install -v \\\n  && go build\n\n##alpine 空的,啥也没有, 因为我们的go程序本身就是可执行文件.\n\nFROM alpine:3.8\nCOPY --from=multistage /go/bin/api /go/bin/\nEXPOSE 3000\nCMD [\"/go/bin/api\"]\n!!! tip 也可以使用--from=0 来表示从第一个阶段来\n\n3.3.1 使用最小的镜像\nfrom scratch # 空的, 里面基础命令都没有, 所以一般我们用 alpine\n\n#很多都有这种 -alpine\nfrom golang:1.17.2-alpine\n\nfrom openjdk:alpine",
    "crumbs": [
      "基础",
      "dockerfile"
    ]
  },
  {
    "objectID": "docs/devops/docker/docker-file.html#通过镜像逆向dockerfile",
    "href": "docs/devops/docker/docker-file.html#通过镜像逆向dockerfile",
    "title": "斯巴拉稀",
    "section": "4 通过镜像逆向dockerfile",
    "text": "4 通过镜像逆向dockerfile\ndocker run -v /var/run/docker.sock:/var/run/docker.sock alpine/dfimage nginx:alpine",
    "crumbs": [
      "基础",
      "dockerfile"
    ]
  },
  {
    "objectID": "docs/devops/docker/docker-file.html#dockerignore",
    "href": "docs/devops/docker/docker-file.html#dockerignore",
    "title": "斯巴拉稀",
    "section": "5 .dockerignore",
    "text": "5 .dockerignore",
    "crumbs": [
      "基础",
      "dockerfile"
    ]
  },
  {
    "objectID": "docs/devops/docker/docker-file.html#footnotes",
    "href": "docs/devops/docker/docker-file.html#footnotes",
    "title": "斯巴拉稀",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nhttps://github.com/krallin/tini↩︎",
    "crumbs": [
      "基础",
      "dockerfile"
    ]
  },
  {
    "objectID": "docs/devops/docker/env.html",
    "href": "docs/devops/docker/env.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "docker.io 是debian/ubuntu 团队维护的. 基于社区源码封装的版本,采用apt的方式管理依赖 docker-ce 社区版,docker官方维护的. 用go的方式管理依赖, 会自己管理所有的依赖\n\n\n安装后,打开点击配置, 点击 advanced 配置, 选择 system 这样 docker命令会放到 /usr/local/bin 目录下, 方便全局使用.\n默认设置user, 可能需要你手动配置 path 才行",
    "crumbs": [
      "基础",
      "环境准备"
    ]
  },
  {
    "objectID": "docs/devops/docker/env.html#安装",
    "href": "docs/devops/docker/env.html#安装",
    "title": "斯巴拉稀",
    "section": "",
    "text": "docker.io 是debian/ubuntu 团队维护的. 基于社区源码封装的版本,采用apt的方式管理依赖 docker-ce 社区版,docker官方维护的. 用go的方式管理依赖, 会自己管理所有的依赖\n\n\n安装后,打开点击配置, 点击 advanced 配置, 选择 system 这样 docker命令会放到 /usr/local/bin 目录下, 方便全局使用.\n默认设置user, 可能需要你手动配置 path 才行",
    "crumbs": [
      "基础",
      "环境准备"
    ]
  },
  {
    "objectID": "docs/devops/docker/env.html#国内源配置",
    "href": "docs/devops/docker/env.html#国内源配置",
    "title": "斯巴拉稀",
    "section": "2 国内源配置",
    "text": "2 国内源配置\n\n\n\n/etc/docker/daemon.json\n\n{\n  \"registry-mirrors\": [\n    \"https://registry.docker-cn.com\",\n    \"http://hub-mirror.c.163.com\",\n    \"https://docker.mirrors.ustc.edu.cn\"\n  ]\n}\n\n\n\ncentos\n\n# 修改后,需要.\nsudo systemctl daemon-reload\nsudo systemctl restart docker\ndocker info # 能看到 Registry Mirrors 的配置\n\n\n\nubuntu\n\nservice docker restart\ndocker info",
    "crumbs": [
      "基础",
      "环境准备"
    ]
  },
  {
    "objectID": "docs/developer/blog.html",
    "href": "docs/developer/blog.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "Warning\n\n\n\n未完待续"
  },
  {
    "objectID": "docs/developer/blog.html#域名1",
    "href": "docs/developer/blog.html#域名1",
    "title": "斯巴拉稀",
    "section": "1 域名1",
    "text": "1 域名1\n购买网站"
  },
  {
    "objectID": "docs/developer/blog.html#博客书写工具",
    "href": "docs/developer/blog.html#博客书写工具",
    "title": "斯巴拉稀",
    "section": "2 博客书写工具",
    "text": "2 博客书写工具\n\n2.1 kroki\n\n\ndocker-compose.yml\n\nversion: \"3\"\nservices:\n  kroki:\n    image: yuzutech/kroki\n    depends_on:\n      - blockdiag\n      - bpmn\n      - excalidraw\n    environment:\n      - KROKI_BLOCKDIAG_HOST=blockdiag\n      - KROKI_BPMN_HOST=bpmn\n      - KROKI_EXCALIDRAW_HOST=excalidraw\n      - KROKI_MAX_URI_LENGTH=64000\n1      - KROKI_SAFE_MODE=unsafe\n    ports:\n      - \"8000:8000\"\n  blockdiag:\n    image: yuzutech/kroki-blockdiag\n    expose:\n      - \"8001\"\n  bpmn:\n    image: yuzutech/kroki-bpmn\n    expose:\n      - \"8003\"\n  excalidraw:\n    image: yuzutech/kroki-excalidraw\n    expose:\n        - \"8004\"\n    ports:\n      - \"8004:8004\"\n\n\n1\n\n默认模式是SECURE, 不支持plantuml的标准库2, 改为unsafe3 即可\n\n\n\n\n2.2 mkdocs\nmkdocs-material best plugin charts\n\n2.2.1 tasklist/checklist\n\n\n/opt/miniconda3/envs/py310/lib/python3.10/site-packages/pymdownx\n\n    classes.append(\"task-list-item\")\n    # 这里简单改改...\n    #  [ ] __xxx 开头的tasklist 表示正在进行中的任务\n    #  [x] --xxx 开头表示已经完成,比较满意\n    #  __ 开头的tasklist 表示正在进行中的任务\n    if li.text is not None:\n        if \"__\" in li.text :\n            classes.append(\"task-list-item-wip\")\n            li.text = li.text.replace(\"__\", \"\")\n        elif \"--\" in li.text:\n            classes.append(\"task-list-item-perfect\")\n            li.text = li.text.replace(\"--\", \"\")\n        else:\n            classes.append(\"task-list-item-todo-finish\")\n\n    if len(li):\n        first = list(li)[0]\n        if first.tag == \"p\" and first.text is not None:\n            if \"__\" in first.text:\n                classes.append(\"task-list-item-wip\")\n                first.text = first.text.replace(\"__\", \"\")\n            elif \"--\" in first.text:\n                classes.append(\"task-list-item-perfect\")\n                first.text = first.text.replace(\"--\", \"\")\n            else:\n                classes.append(\"task-list-item-todo-finish\")\n\n- [x] java\n- [ ] python\n    * [x] golang\n    * [x] js\n    * [ ] __rust __表示正在进行\n- [ ] c\n\n\n2.2.2 chart\ncharts demo page\n\n\n2.2.3 markmap\nmkdocs-markmap markmap\n```markmap\n# Root\n\n## Branch 1\n\n- Branchlet 1a\n- Branchlet 1b\n- abc\n- fff\n    - fff\n\n## Branch 2\n\n- Branchlet 2a\n- Branchlet 2b\n```\n# Root\n\n## Branch 1\n\n- Branchlet 1a\n- Branchlet 1b\n- abc\n- fff\n    - fff\n\n## Branch 2\n\n- Branchlet 2a\n- Branchlet 2b\n\n\n2.2.4 bitfield\n{ reg: [\n  { \"name\": \"IPO\",   \"bits\": 8, \"attr\": \"RO\" },\n  {                  \"bits\": 7 },\n  { \"name\": \"BRK\",   \"bits\": 5, \"attr\": \"RW\", \"type\": 4 },\n  { \"name\": \"CPK\",   \"bits\": 1 },\n  { \"name\": \"Clear\", \"bits\": 3 },\n  { \"bits\": 8 }\n]}\n\n\n2.2.5 plantuml\n```\n@from_file:go/.diagram/reflect-type.plantuml\n```\nwbs\n@startwbs\n&lt;style&gt;\n' this time, scoping to wbsDiagram\nwbsDiagram {\n\n  ' Here we introduce a global style, i.e. not targeted to any element\n  ' thus all lines (meaning connector and borders,\n  ' there are no other lines in WBS) are black by default\n  Linecolor black\n\n  ' But we can also target a diagram specific element, like arrow\n   arrow {\n    ' note that Connectors are actually \"Arrows\"; this may change in the future\n    ' so this means all Connectors and Arrows are now going to be green\n    LineColor green\n  }\n\n}\n&lt;/style&gt;\n\n* World\n** America\n*** Canada\n** Europe\n*** England\n*** Germany\n*** Spain\n@endwbs\n样式修改, 可以这样看 有哪些可以改的\n```kroki-plantuml\n@startuml\nskinparameters\n@enduml\n```\n\n\n然后在puml文件中前面几行添加\n\nskinparam TitleBorderThickness 0\n\n写更丰富的类似html,markdown\n\n\n2.2.6 blockdiag\nblockdiag\n\n\n2.2.7 导入文件\n!!! warning 文件路径请用 “” 包起来\n--8&lt;-- \"c/basis/code/main.c\"\n或使用--8&lt;-- 然后换行+文件路径+换行+--8&lt;-- 的方式\n你可以在这些外面用 3个`包起来,这样就变成代码块\n\n\n\n2.3 hugo\ndocsy主题 hugo官网\nhugo # 生成静态文件. public/"
  },
  {
    "objectID": "docs/developer/blog.html#博客部署方案",
    "href": "docs/developer/blog.html#博客部署方案",
    "title": "斯巴拉稀",
    "section": "3 博客部署方案",
    "text": "3 博客部署方案\n\n3.1 netlify\n\n\n3.2 heroku\n注册需要fq, 才能看到 验证码\n\n\n3.3 github pages\n\n\n3.4 vercel\n\n\n\n\n\n\nCaution\n\n\n\n你部署在vercel上的网站是可以访问外网的哦,不用翻墙.\n\n\n\n3.4.1 注册\n\n访问vercel网站\n输入用户名后,continue \n选择注册方式 \n\n\nContinue with GithubContinue with Email\n\n\n点击后,弹出的页面中选择这个授权  如果你用的github邮箱是国内的,或者 hotmail 可能都会提示user block之类的错误. 可以试着为你的github添加一个gmail邮箱(关于注册自行解决,登录可以用QQ邮箱APP,无需fq),然后将它设置为你的主邮箱. 再试着点击 Continue with Github (可能需要等待一段时间),如果还不行的话, 我们就使用 Continue with Email 邮箱来注册.\n\n\n输入邮箱 ,请使用gmail邮箱\n\n\n\n\n手机验证, 可以使用国内的手机号\n\n\n\n3.4.2 登录\n\n\n\n\n\n\nCaution\n\n\n\n用邮箱登录的时候,提示的页面{==千万不要关闭==}, 先去验证邮箱,然后这个 页面会自动跳转到已经登录的界面!!\n\n\n\n\n3.4.3 部署\n\n\n3.4.4 国内无法访问的问题\n需要配置域名\n\n打开 域名解析页面(这里以aliyun为例)\n点击 你想要使用的域名 那行的{==解析设置==},添加记录\n输入\n\n\n\n选项\n输入或选择的内容\n\n\n\n\n记录类型\nCNAME\n\n\n记录类型\n随便, 作为你部署的站点的域名\n\n\n记录值\ncname.vercel-dns.com\n\n\n\n在该dashboard页面,点击你部署的项目\n选择settings-&gt;Domains-&gt;输入你的域名–&gt;点击ADD\n\n等待vercel验证你的域名,然后就可以在国内网络上访问了.\n\n\n\n\n3.5 cloudflare\npages workers-and-pages/create/pages"
  },
  {
    "objectID": "docs/developer/blog.html#footnotes",
    "href": "docs/developer/blog.html#footnotes",
    "title": "斯巴拉稀",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nhttps://wanwang.aliyun.com/domain↩︎\nplantuml 标准库  PlantUMLHitchhikersGuide  github↩︎\nkroki safe mode↩︎"
  },
  {
    "objectID": "docs/developer/git/git.html",
    "href": "docs/developer/git/git.html",
    "title": "git 入门到精通",
    "section": "",
    "text": "Caution\n\n\n\n未完待续..",
    "crumbs": [
      "git"
    ]
  },
  {
    "objectID": "docs/developer/git/git.html#配置",
    "href": "docs/developer/git/git.html#配置",
    "title": "git 入门到精通",
    "section": "1 配置",
    "text": "1 配置\n\n1.1 修改配置\ngit config --global user.name \"tt\"\ngit config --global user.email \"tt@email.com\"\n# 删除配置\ngit config --global --unset user.name\n\n\n1.2 config的作用域\n# 只对当前仓库有效, 当前仓库目录/.git/config\ngit config --local\n# 对当前用户所有仓库有效 , ~/.gitconfig\ngit config --global\n# 对系统所有用户的仓库有效, /etc/gitconfig\ngit config --system\n\n\n1.3 显示配置\ngit config --list --system\ngit config --list --global\ngit config --list --local\n\n\n1.4 我的配置\n[user]\n    name = yourusername\n    email = youremail\n[core]\n    trustctime = false\n    editor = vim\n    filemode = false\n    autocrlf = false\n    # 如果是true ,非ASCII 字符会用八进制进行转义\n    # 现在终端都支持输出其他字符了,所以取消\n    quotepath = false\n[alias]\n    last = log -1 --stat\n    cp = cherry-pick\n    co = checkout\n    cl = clone\n    ci = commit\n    st = status -sb\n    br = branch\n    unstage = reset HEAD --\n    dc = diff --cached\n    lg = log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %Cblue&lt;%an&gt;%Creset' --abbrev-commit --date=relative\n    pull = pull --ff-only\n    df = difftool\n    mg = mergetool\n[merge]\n    tool = vimdiff\n[diff]\n    tool = vimdiff\n[difftool]\n    prompt = false\n\n\n1.5 git clone慢的解决方法\n\nurl insteadOf使用代理\n\n\n这样你git clone https://github.com/xx/yy 就会变成 git clone https://ghproxy.com/https://github.com/xx/yy\ngit config --global url.\"https://ghproxy.com/https://github.com/\".insteadOf https://github.com/\n\n\n取消url insteadOf\n\ngit config --global  --unset url.\"https://ghproxy.com/https://github.com/\".insteadOf\n\n\n\n\n\n使用http代理\n\ngit config --global https.proxy http://127.0.0.1:1080\ngit config --global https.proxy https://127.0.0.1:1080\n\n\n\n使用socks5代理\n\ngit config --global http.proxy 'socks5://127.0.0.1:1080' \ngit config --global https.proxy 'socks5://127.0.0.1:1080'\n\n\n\n取消使用代理\n\ngit config --global --unset http.proxy\ngit config --global --unset https.proxy\n\n\n\n\n\n\n1.6 .gitignore\n从 github1 上下载 对应语言的.gitignore 文件\n\n1.6.1 保留文件夹,忽略里面的内容\n在目标文件夹内单独建一个.gitignore文件，而不是写在根目录的.gitignore里\n*\n!.gitignore\n或者 目标文件夹data里面 添加一个.gitkeep 总的.gitignore\ndata/*\n!data/.gitkeep\n\n\n1.6.2 查看文件是否符合.gitignore规则\n# 看下当前data目录下的文件, 是否被规则匹配到.\ngit check-ignore -v ./data/abc\n# 返回值是 0 表示该目录文件被 匹配到,将被忽略",
    "crumbs": [
      "git"
    ]
  },
  {
    "objectID": "docs/developer/git/git.html#开发人员一般步骤",
    "href": "docs/developer/git/git.html#开发人员一般步骤",
    "title": "git 入门到精通",
    "section": "2 开发人员一般步骤",
    "text": "2 开发人员一般步骤\n1.git clone 下公司代码仓库\ngit clone git@gitee.com:xyz/test.git\n2.以dev或其他开发中的主分支比如WIP(用公司可能用这个分支名字)或者其他 v1.0 这种 创建一个分支进行开发 注意一个功能,或一次bug修复就用一个分支.\ngit co -b fix/xyz dev\n3.写代码, git add,commit, 至少每天下班前 git commit 一次, 功能开发完毕 合并前,可以随意commit,随意的推送该分支到远程\ngit add .\ngit ci -m \"msg\"\n4.提交pull request 阶段\n将你的commit 合并成一个commit 这个commit_id 是你 git co -b fix/xyz 分支时的最新commit\n\ngit reset 方式git rebase方式\n\n\ngit reset commit_id\ngit add .\ngit ci -m \"msg\"\n\n\n保留第一行的那个commit ,不动, 就是你第一次提交的commit 将其他前面的pick 改成s ,然后 保存退出, 提示 输入新的commit msg 再保存退出\ngit rebase -i commit_id\n\n\n\n合并现在最新的dev代码到你的分支\n# 先拉取最新的dev代码到本地dev\ngit pull origin dev:dev\n# 本地合并来自 dev的最新代码 不要用merge\n# 就相当于你在最新代码的dev分支的基础上进行开发,merge 完全没必要\ngit rebase dev\n\n开发前的dev分支现在的dev你的分支merge wip后rebase wip后\n\n\n* 123ffca - add c.txt\n* 5721887 - add b.txt\n* b8172ad - add a.txt\n* 128d312 - (origin/master, origin/HEAD, master) readme\n\n\n*   e33481e - (HEAD -&gt; wip) Merge branch 'fix/hello' into wip\n|\\\n| * be69a6e - (origin/fix/hello, fix/hello) fix b.txt add hello\n|/\n* 123ffca - add c.txt\n* 5721887 - add b.txt\n* b8172ad - add a.txt\n* 128d312 - (origin/master, origin/HEAD, master) readme\n\n\n* 95d6da4 - (HEAD -&gt; fix/one) fix c.txt add one\n* 123ffca - add c.txt\n* 5721887 - add b.txt\n* b8172ad - add a.txt\n* 128d312 - (origin/master, origin/HEAD, master) readme\n\n\n*   99a02ef - (HEAD -&gt; fix/one) Merge branch 'wip' into fix/one\n|\\\n| *   e33481e - (wip) Merge branch 'fix/hello' into wip\n| |\\\n| | * be69a6e - (origin/fix/hello, fix/hello) fix b.txt add hello\n| |/\n* / 95d6da4 - fix c.txt add one\n|/\n* 123ffca - add c.txt\n* 5721887 - add b.txt\n* b8172ad - add a.txt\n* 128d312 - (origin/master, origin/HEAD, master) readme\n\n\n* 8c0df48 - (HEAD -&gt; fix/one) fix c.txt add one\n*   e33481e - (wip) Merge branch 'fix/hello' into wip\n|\\\n| * be69a6e - (origin/fix/hello, fix/hello) fix b.txt add hello\n|/\n* 123ffca - add c.txt\n* 5721887 - add b.txt\n* b8172ad - add a.txt\n* 128d312 - (origin/master, origin/HEAD, master) readme",
    "crumbs": [
      "git"
    ]
  },
  {
    "objectID": "docs/developer/git/git.html#常用命令",
    "href": "docs/developer/git/git.html#常用命令",
    "title": "git 入门到精通",
    "section": "3 常用命令",
    "text": "3 常用命令\n\n3.1 clone\n\n\n仅仅为了使用那个仓库\n\n# 只下载最近一个commit, 我们下载最新的代码就行了\ngit clone --depth=1  https://github.com/vuejs/vuepress.git\n# --branch 分支名:  对比 git clone ,checkout 指定的分支, 其他分支还是会拉取\ngit clone --branch dev https://github.com/vuejs/vuepress.git\n# 只下载指定分支  需要再加上 --single-branch ,其他分支不会拉取\ngit clone --branch dev --single-branch https://github.com/vuejs/vuepress.git\n\n\n\n3.2 pull\n# 拉取远程分支remote_dev 合并到 本地的local_dev 分支\ngit pull origin remote_dev:local_dev\n\n–ff 自动合并模式(默认就是这个)–no-ff non-Fast-forward 模式–ff-only Fast-forward 模式\n\n\n\n当合并的分支为当前分支的后代时, 会自动执行 –ff (Fast-forward)模式,\n如果不是后代则执行 –no-ff (non-Fast-forward)合并模式\n\n\n\n在任何情况下都会创建新的commit\n\n\n只会按照 Fast-forward 模式进行合并，如果不是当前分支的直接后代,则会拒绝合并请求并退出\n\n\n\n\n\n3.3 remote 仓库\n# 查看远程仓库信息\ngit remote -vv\n# 添加 新的远程仓库,你可以添加多个远程仓库\ngit remote add new_origin git@github.com:llibeohs/llibeohs.github.io.git\n# 直接修改远程仓库地址\ngit remote set-url origin git@.../test.git\n# 删除\ngit remote rm origin\n本地删除已经不存在的远程分支, 别人提交的远程分支,你 pull过, 然后别人删除了远程分支,这个时候你本地还保留着,想要删除\n\n\n\n查看远程的相关信息\n\ngit remote show origin\n\n\n\n执行结果\n\n* remote origin\n        Fetch URL: /root/gittest/./rep\n        Push  URL: /root/gittest/./rep\n        HEAD branch: master\n        Remote branches:\n          master                  tracked\n          refs/remotes/origin/gen stale (use 'git remote prune' to remove)\n\n\n\n\n删除\n\ngit remote prune origin\n\n\n\n3.4 branch\n\n查看切换创建推送到远程删除修改分支名\n\n\ngit br -r #只显示远程的分支\ngit br # 本地分支\ngit br -a #显示所有的分支\n\n\n\n\n切换到master分支, 分支名必须存在\n\ngit co master\n\n\n\n# 根据当前分支 创建了一个分支,并切换到该分支\ngit co -b your_branch\n# 以某个commit 创建分支\ngit co -b your_branch commit_id\n\n\n# 推送本地分支到远程分支,这个远程分支名与你的本地分支同名\ngit push origin your_branch\n# :左边是本地分支 右边是远程分支名\ngit push origin dev:dev\n# 将你新建的本地分支dev与远程分支关联起来\n# 这样 你就可以直接 git push, 不需要每次都 git push origin dev\ngit br -u origin/dev dev\n# 可以看到关联信息\ngit br -vv\n     #dev2   a950611 up  &lt;--- 无关联\n     #master a950611 [origin/master: ahead 3] up&lt;---- 有关联\n# 第一次push 时直接关联远程分支\ngit push -u origin dev\n\n# 该方式直接从远程分支origin/dev 创建本地分支dev,并切换到 该本地分支dev,\n# 这个时候 已经互相关联上了,可直接git pull/push\ngit co -b dev origin/dev\n\n\n\n\n删除本地分支\n\ngit br -d 分支名 # 会提示一些警告,比如你当前分支没有做过merge什么的, 不能删除\ngit br -D 分支名 # 加入你确定要删除分支, 则使用-D 来\n\n\n\n删除远程分支\n\n#git push 远程名 :远程分支名\ngit push origin :dev # 删除远程分支 dev\n\n\n\ngit br -m old_br new_br\n\n\n\n\n\n3.5 checkout (co)\n\n3.5.1 co –\n# 就是你 git add 一次到了暂存区,然后又做了修改, 但是你发现\n# 还不如 暂存区的内容好,所以想要将工作区的内容变成和暂存区一模一样\n# 修改内容后, git status  一样可以看到提示\ngit co -- a.txt\n\n\n3.5.2 孤儿分支\n# 会将原分支的内容拷贝, 然后新的分支里 没有一个commit ,你需要git add ,commit 做一个初始提交.\n# 或者你可以删除里面所有的内容, 这样 变成一个空的分支,你做啥都行.\ngit co --orphan 分支名\n\n\n\n3.6 add\n\n\n\n3.7 unstage\n# unstage = reset HEAD --\n#将文件从暂存区 放到工作区.\n#就是 git add 后, 我们 取消这个操作\ngit unstage world.txt\n\n\n3.8 commit 注释修改\n\n\n修改最新的commit的注释信息\n\ngit ci --amend\n\n\n\n修改之前的commit的注释信息\n\ngit lg\n    * df6b55b - (HEAD -&gt; master) modify:d \n    * 565bd5a - modify c.txt\n    * b50b285 - stg3yy\n    * 23fd353 - stg2\n    * 4164370 - stg1\n# 比如你要修改23fd353 的msg,那么你需要\ngit rebase -i 4164370 #(你要修改的commit的上一个commit)\n# 会弹出一个窗口\n# 注释也说的很明白,\n# 这里比如我们要修改2个commit的msg,我们将前面默认的pick 修改为r,\n#   r, reword = use commit, but edit the commit message\n# 其他不要变的 就还是pick\n# :wq 保存退出,会跳出另外一个窗口\n    r 23fd353 stg2\n    r b50b285 stg3yy\n    pick 565bd5a modify c.txt\n    pick df6b55b modify:d\n\n\n\n3.9 cherry-pick (cp)\n将任意分支上的某几个提交,应用到当前分支上, 相当于在当前分支上你做了这些修改\ngit cp commit_id\n# 两个commit区间的所有commit, ..左边的是旧的commit,不包含该commit\ngit cp commit_id1..commit_id2\n# 2个分支之间的.\ngit cp dev..fix/one\ngit lg\n* 411be80 - d\n* f145376 - c\n* ca55914 - b\ngit cp ca55914..411be80  相当于\n  git cp f145376\n  git cp 411be80\n# 如果有冲突\n    git add .\n    git cp --continue\n# 或者 取消\ngit cp --abort\n\n\n3.10 clean 删除不在工作区的文件\n# -n = --dry-run\n# 表示先看看会删除什么 ,删除不在工作区的文件. 就是还从没git add过的\n# 只会看文件\ngit clean -n\n# -d 会看不在工作区 的文件(默认就会看的)和文件夹\ngit clean -n -d\n# 会提示你 clean.requireForce defaults to true and neither -i, -n, nor -f given; refusing to clean\ngit clean\n# 执行删除操作 , 需要-f\ngit clean -f\n# -d 文件夹也删除\ngit clean -f -d\n# -x 在.gitignore 文件里的 也会删除,默认不会删除\ngit clean -f -d -x\n\n\n3.11 rm\n# 删除文件, 状态已经是 在 暂存区了, 相当于 rm 文件后, 然后git add filename\ngit rm filename\n# 本地保留该文件, 然后untrack 该文件, 就是不要版本控制它...\n# 一般情况下,我们会接着将该文件添加到.gitignore中\ngit rm --cached filename\n\n\n3.12 diff 比较\n# 更旧的放前面,新的放后面,想看commit2 相对commit1做了哪些更改\n# 可以是不同的分支的commit id哦\ngit diff commit1 commit2 filename\n#查看将要推送的内容, (比较本地的dev分支对 远程dev做了哪些修改)\ngit diff origin/dev..dev\n# 实际与 git diff HEAD~~ HEAD 一样\ngit diff HEAD~~..HEAD~\n\n# 比较tmp分支和master分支 a.txt文件的区别\ngit diff tmp master -- a.txt\n# 直接用commit_id 来比较 也是一样的\n# 因为实际上分支名比较的原理就是 就是因为分支名指向的就是该分支最新的一次提交,还是commit_id\ngit diff tmp_commit_id master_commit_id -- a.txt\n\n\n3.13 冲突\n\n\nworld.txt(merge 冲突后的文件)\n\nwoxld\n&lt;&lt;&lt;&lt;&lt;&lt;&lt; ours\noyo\n=======\nomo\n&gt;&gt;&gt;&gt;&gt;&gt;&gt; theirs\n\n一般情况下 会看到 上面 一个是我们分支的版本 一个是你想要merge的分支的版本\noyo 是我们的版本的修改\nomo 是别人的版本的修改\n\n\n\n\n\n\nImportant\n\n\n\n可以通过设置 merge.conflictstyle 选项为 diff3 来做为以后合并冲突的默认选项 git config --global merge.conflictstyle diff3 merge 是默认选项, diff3 就会生成3方内容来对比\n\n\n\n\n增加原始版本\n\ngit checkout --conflict=diff3 world.txt\n\n&lt;&lt;&lt;&lt;&lt;&lt;&lt; ours\noyo\n||||||| base\nooo\n=======\nomo\n&gt;&gt;&gt;&gt;&gt;&gt;&gt; theirs\n\nooo是原来的情况\n#假设我们决定使用我们的版本来作为解决冲突,那么可以\ngit co --ours world.txt\n\n#想要使用他们的\ngit co --theirs world.txt\n\ngit diff --ours # 查看相对于我们本地的版本 做了哪些更改\ngit diff --ours filename\ngit diff --theirs # 查看相对于他们的版本 做了哪些更改\n\n\n3.14 log\n# 查看项目的提交记录\ngit lg\ngit lg 文件名  #(查看该文件的提交记录 log)\ngit lg commit_id  #(查看这个commit_id 以及之前的提交记录log)\n#-p 按补丁格式显示每个更新之间的差异。\n# 会显示提交的内容\ngit lg -p commit_id # (查看这个commit_id 以及之前所有的提交内容)\ngit lg -p #(查看提交内容  相比git lg, 多了内容的查看)\ngit lg -p    + 文件名 #（可查看该文件以前每一次commit的修改内容）\ngit lg -p -1 + 文件名 #（只查看该文件当前这一次的commit内容）\ngit lg -p dev..fix/one # 查看你的分支相对于本地dev分支做了哪些修改\ngit lg -p origin/master..HEAD # 当前分支最新代码对与远程master分支做了哪些修改\n\n\n3.15 rebase\ngit rebase -i commit_id\n# git rebase -i 无法把第一个commit进行合并等操作\n# 这个可以 将所有commit 合并为一个.\ngit rebase -i --root\n\n\n3.16 shortlog 显示发布简报\n\n\n\n\n\n\nTip\n\n\n\n可用于显示这次发布,更新了哪些东西\n\n\n# v1.1.2 是你上次发布的版本.这里就显示 这次更新了哪些东西.\n# 会显示用户 提交的 commit message\ngit shortlog --no-merges v1.1.2..master\ngit shortlog --no-merges master --not v1.1.2\n\n\n3.17 blame\ngit blame world.txt\n# 查看 world.txt 99-120行 的代码情况 . 最后更新人与时间\ngit blame -L 99,120 world.txt\n\n\n3.18 bundle 打包\n# 打包整个master 分支\ngit bundle create x.repo HEAD master\n# 根据打的包 clone 仓库 到 tmp_dir 目录\ngit clone x.repo tmp_dir\n\n#打包几个提交\n#打包当前我们新增加的几个提交,本地fix/one分支相对于远程提交了哪些\ngit bundle create ../new_commit.bundle origin/dev..fix/one\n\n\n# 切换到dev分支,拉取最新,然后校验看是否能更新ok\ngit co dev\ngit pull\ngit bundle verify ../new_commit.bundle\n# 将fix/one里的提交 ,导入到wip 分支\ngit pull ../new_commit.bundle   fix/one:wip\n\n\n3.19 tag\n# 列显已有的标签\ngit tag\n# 过滤显示\ngit tag -l 'v1.4.2.*'\n    v1.4.2.1\n    v1.4.2.2\n    v1.4.2.3\n# 新建标签,以当前commit为准 打上\ngit tag -a v1.4 -m 'my version 1.4'\ngit show v1.4\n#轻量级 打标签\ngit tag v1.4\n\n# 为某个commit 打上tag\ngit tag -a v1.2 9fceb02\n# 推送标签到远程\ngit push origin v1.5\n# 推送所有标签到远程\ngit push origin --tags",
    "crumbs": [
      "git"
    ]
  },
  {
    "objectID": "docs/developer/git/git.html#进阶技巧",
    "href": "docs/developer/git/git.html#进阶技巧",
    "title": "git 入门到精通",
    "section": "4 进阶技巧",
    "text": "4 进阶技巧\n\n4.1 hook2\n\n4.1.1 基础\n\n\n4.1.2 pre-commit framework\n\n\n\n\n\n\nImportant\n\n\n\ntodo…\n\n\npip install pre-commit\n# 然后在 你的git 仓库中添加 配置文件 .pre-commit-config.yaml\n# 更新yaml 里设置的repo的设置的rev版本\npre-commit autoupdate\n# 执行该命令会将 hook 写到 .git/hooks/pre-commit, 这样每次你commit 就会自动执行了\npre-commit install\n# 比如这样, 你就会看到 Initializing environment for ... 这类初始化信息\n# 我们去 ~/.cache/pre-commit ,可以看到比如 .pre-commit-config.yaml 里设置的 repo,会git clone 到这个目录\n# 首次会 初始化, 以后就不用了, 然后会执行 commit hook 检查\ngit ci -m 'up'\n\n\n\n4.2 CHANGELOG\n\n4.2.1 git cliff3\nTODO\n生成changelog 工具\n# 使用cargo (rust工具) 来安装\ncargo install git-cliff\n# 初始化配置文件 cliff.toml, 再自行修改\ngit cliff --init\n\n\ncliff.toml 修改其中的postprocessors 配置\n\npostprocessors = [\n    { pattern = '\\$REPO', replace = \"改成你的项目git仓库地址\" }, # replace repository URL\n]\n\n# 生成changelog 文件\ngit cliff -o CHANGELOG.md\n\n\n4.2.2 git-chglog4\n\n\n\n4.3 子模块\n\n4.3.1 subtree\n\n\n4.3.2 submodule\n\n4.3.2.1 修改.gitmodules仓库url后需要的操作\n[submodule \"themes/docsy\"]\n    path = themes/docsy\n    url = https://github.com/google/docsy.git\n    branch = v0.2.0\n后来这个地址变更了,拉取最新, .gitmodules 是变更了\n\n\n.gitmodules 变更后的结果\n\n[submodule \"themes/docsy\"]\n    path = themes/docsy\n    url = https://github.com/google/docsy2.git\n    branch = v0.2.0\n\n# 发现还是 用的老地址 进行clone\ngit submodule update --init --recursive --depth 1\n\n\n需要更新到本地的配置\n\n# 会将.gitmodules 的配置更新到 .git/config中去, 实际用到的仓库url在本地配置里\ngit submodule sync --recursive\n# 查看\ncat .git/config # 可以看到更新了\n# 可以了\ngit submodule update --init --recursive --depth 1\n\n\n\n\n\n4.4 git filter-repo\n\n\n\n\n\n\nImportant\n\n\n\n比如commit了一个可执行文件,推送到了远程,然后下个commit你将它删除,推送,实际上这个文件还是存在的. 如何彻底删除它?\n\n\n安装5\n# 只保留README.md文件 和 guides/目录和 tools/releases目录 ,相对于根目录位置的文件\ngit filter-repo --path README.md --path guides/ --path tools/releases\n# 与上面刚好相反, 只删除这几个 东西 , 相对于根目录位置的文件\ngit filter-repo --path README.md --path guides/ --path tools/releases --invert-paths\n#--path-glob '*.DS_Store' 指定这个的话 , 相比path,这个会 包含这类foo.DS_Store or bar/baz.DS_Store\n#--path 基于根目录的\n\n#使用这个命令后, 不需要再 清理reflog 和original里的东西 (git filter-branch 这个官方的需要这么做), 因为已经帮你做了\n#直接\ngit push -f --all\ngit push -f --tags\n\n4.4.1 实际仓库瘦身\n#执行命令, 会进行压缩打包, 在 .git/objects/pack 目录下生成一个pack文件,\n# objects/ 原本好多的文件夹都不见了. 都压缩打包到了这里\ngit gc\n\n#可以看到pack打包的文件里 具体是什么文件\ngit verify-pack -v .git/objects/pack/*.idx\n\n#查看当前所有的文件.  多次commit 都会显示哦\ngit rev-list --objects --all\n\n#-k 3 对第三列的字段进行排序.  -n 表示用数值排序\ngit verify-pack -v .git/objects/pack/*.idx | sort -k 3 -n  \n\n#找到占用空间比较大的文件名\ngit rev-list --objects --all | grep \"$(git verify-pack -v .git/objects/pack/*.idx | sort -k 3 -n | tail -15 | awk '{print$1}')\"\n\n#下方命令中的 path/to/large/files 是大文件所在的路径，千万不要弄错！\ngit filter-branch --tree-filter 'rm -f path/to/large/files' --tag-name-filter cat -- --all\n\n\n#如果提示\nCannot create a new backup.\nA previous backup already exists in refs/original/\nForce overwriting the backup with -f\n就\ngit filter-branch -f --tree-filter 'rm -f path/to/large/files' --tag-name-filter cat -- --all\n\n# 运行后\n提示 所有分支都重写了. 所有分支里的这个文件 都没有了哦\nRef 'refs/heads/master' was rewritten\nRef 'refs/heads/x' was rewritten\nRef 'refs/remotes/origin/master' was rewritten\nRef 'refs/remotes/origin/x' was rewritten\n\n# 提交\n\ngit push origin --tags --force\ngit push origin --all --force\n\n# 其他开发人员\ngit pull --rebase\n\n\n4.4.2 提升目录为根目录\n\n\n仓库当前目录结果\n\nmodule/\n   foo.c\n   bar.c\notherDir/\n   blah.config\n   stuff.txt\nzebra.jpg\n\n\n\n只保留module下的文件, 并且将module下的所有文件移动到根目录下\n\ngit filter-repo --subdirectory-filter module/\n\n\n\n执行完后的仓库目录结构,其他都没了\n\nfoo.c\nbar.c\n\n\n\n4.4.3 移动所有文件到其他目录下\n\n\n仓库当前目录结果\n\nmodule/\n   foo.c\n   bar.c\notherDir/\n   blah.config\n   stuff.txt\nzebra.jpg\n\ngit filter-repo --to-subdirectory-filter my-module/\n\n\n执行后的目录结构\n\nmy-module/\n   module/\n      foo.c\n      bar.c\n   otherDir/\n      blah.config\n      stuff.txt\n   zebra.jpg\n\n\n\n\n4.5 commit message\n\n4.5.1 commitizen6\n\n\n4.5.2 commitizen-go7",
    "crumbs": [
      "git"
    ]
  },
  {
    "objectID": "docs/developer/git/git.html#footnotes",
    "href": "docs/developer/git/git.html#footnotes",
    "title": "git 入门到精通",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nhttps://github.com/github/gitignore↩︎\npre-commit↩︎\nchangelog git-cliff\n\ngithub\nhttps://git-cliff.org/\ndoc\n\n↩︎\ngit-chglog↩︎\nhttps://github.com/newren/git-filter-repo/blob/main/INSTALL.md#installation-via-package-manager↩︎\ncommitizen  document  getting started↩︎\ncommitizen-go↩︎",
    "crumbs": [
      "git"
    ]
  },
  {
    "objectID": "docs/developer/site.html",
    "href": "docs/developer/site.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "iconify icones 阿里巴巴图标库 字节跳动iconPark图标库\n\n\n\n高清图片素材unsplash 视频素材mixkit pexels pixabay picjumbo foodiesfeed美食图片 stocksnap isorepublic 日本的pakutaso 图片压缩"
  },
  {
    "objectID": "docs/developer/site.html#设计",
    "href": "docs/developer/site.html#设计",
    "title": "斯巴拉稀",
    "section": "",
    "text": "iconify icones 阿里巴巴图标库 字节跳动iconPark图标库\n\n\n\n高清图片素材unsplash 视频素材mixkit pexels pixabay picjumbo foodiesfeed美食图片 stocksnap isorepublic 日本的pakutaso 图片压缩"
  },
  {
    "objectID": "docs/developer/site.html#在线编辑器",
    "href": "docs/developer/site.html#在线编辑器",
    "title": "斯巴拉稀",
    "section": "2 在线编辑器",
    "text": "2 在线编辑器\nstackblitz"
  },
  {
    "objectID": "docs/developer/site.html#其他",
    "href": "docs/developer/site.html#其他",
    "title": "斯巴拉稀",
    "section": "3 其他",
    "text": "3 其他\n免费的共用账号"
  },
  {
    "objectID": "docs/developer/site.html#技术网站",
    "href": "docs/developer/site.html#技术网站",
    "title": "斯巴拉稀",
    "section": "4 技术网站",
    "text": "4 技术网站\nhacker news"
  },
  {
    "objectID": "docs/developer/tool.html",
    "href": "docs/developer/tool.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "# 当前文件目录下 创建一个文件\nfile.txt\n# 里面的内容是\n    file 'a.mp4'\n    file 'out.mp4'\n# 将2个视频合并成了一个\nffmpeg -f concat -i file.txt  -c copy c.mp4\n\n\n\nffmpeg -i a.mp4  -ss 00:01:00 -to 02:00:00 -c copy out.mp4"
  },
  {
    "objectID": "docs/developer/tool.html#ffmpeg",
    "href": "docs/developer/tool.html#ffmpeg",
    "title": "斯巴拉稀",
    "section": "",
    "text": "# 当前文件目录下 创建一个文件\nfile.txt\n# 里面的内容是\n    file 'a.mp4'\n    file 'out.mp4'\n# 将2个视频合并成了一个\nffmpeg -f concat -i file.txt  -c copy c.mp4\n\n\n\nffmpeg -i a.mp4  -ss 00:01:00 -to 02:00:00 -c copy out.mp4"
  },
  {
    "objectID": "docs/developer/tool.html#终端录制工具asciinema",
    "href": "docs/developer/tool.html#终端录制工具asciinema",
    "title": "斯巴拉稀",
    "section": "2 终端录制工具asciinema",
    "text": "2 终端录制工具asciinema"
  },
  {
    "objectID": "docs/developer/tool.html#i",
    "href": "docs/developer/tool.html#i",
    "title": "斯巴拉稀",
    "section": "3 i",
    "text": "3 i\n#查看外部连接Foreign Address 那一栏 ip ,如果不是0 , 就可能电脑被人监听了\nnetstat -an|grep LISTEN"
  },
  {
    "objectID": "docs/developer/vscode.html",
    "href": "docs/developer/vscode.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "前面设置同步后, 想看看同步到哪个账号\n\n点击打开云更改, 也可以看到账号, 还可以登录新的账号来同步"
  },
  {
    "objectID": "docs/developer/vscode.html#官方同步方案",
    "href": "docs/developer/vscode.html#官方同步方案",
    "title": "斯巴拉稀",
    "section": "",
    "text": "前面设置同步后, 想看看同步到哪个账号\n\n点击打开云更改, 也可以看到账号, 还可以登录新的账号来同步"
  },
  {
    "objectID": "docs/developer/env.html",
    "href": "docs/developer/env.html",
    "title": "程序员开放环境",
    "section": "",
    "text": "# 下载你要的字体\nwget https://ghproxy.com/https://github.com/ryanoasis/nerd-fonts/releases/download/v2.3.3/FiraCode.zip\nwget https://raw.fastgit.org/ryanoasis/nerd-fonts/master/install.sh\nchmod +x install.sh\nmkdir -p patched-fonts/FiraCode\nunzip -d patched-fonts/FiraCode FiraCode.zip\n./install.sh FiraCode\n\n\n\ngithub ### Rec Mono Casual OperatorMonoSSm-Book,Hack Nerd Font,Cascadia Code,menlo,JetBrains Mono,Fira Code Rec Mono\n\n\n\nmonaspace"
  },
  {
    "objectID": "docs/developer/env.html#编程字体",
    "href": "docs/developer/env.html#编程字体",
    "title": "程序员开放环境",
    "section": "",
    "text": "# 下载你要的字体\nwget https://ghproxy.com/https://github.com/ryanoasis/nerd-fonts/releases/download/v2.3.3/FiraCode.zip\nwget https://raw.fastgit.org/ryanoasis/nerd-fonts/master/install.sh\nchmod +x install.sh\nmkdir -p patched-fonts/FiraCode\nunzip -d patched-fonts/FiraCode FiraCode.zip\n./install.sh FiraCode\n\n\n\ngithub ### Rec Mono Casual OperatorMonoSSm-Book,Hack Nerd Font,Cascadia Code,menlo,JetBrains Mono,Fira Code Rec Mono\n\n\n\nmonaspace"
  },
  {
    "objectID": "docs/developer/env.html#手写体",
    "href": "docs/developer/env.html#手写体",
    "title": "程序员开放环境",
    "section": "2 手写体",
    "text": "2 手写体\n\n2.1 Shantell_Sans\nshantell-sans"
  },
  {
    "objectID": "docs/developer/env.html#terminal",
    "href": "docs/developer/env.html#terminal",
    "title": "程序员开放环境",
    "section": "3 terminal",
    "text": "3 terminal\n\n3.1 zsh+ohmyzsh\n\n\n3.2 iterm2\n\n3.2.1 发送命令到所有窗口\ncommand+shift+i 点击确定\ncommand+shift+i 点击取消即可 (如果上面已经点击不用提示的话,这里 不会有东西弹出来, 直接就已经取消发送到多个窗口了)\n\n\n\n3.3 MobaXTerm\n\n\n3.4 tabby1\n\n\n3.5 WindTerm\nhttps://github.com/kingToolbox/WindTerm/releases"
  },
  {
    "objectID": "docs/developer/env.html#快捷键",
    "href": "docs/developer/env.html#快捷键",
    "title": "程序员开放环境",
    "section": "4 快捷键",
    "text": "4 快捷键\ncommand+r 正常刷新，使用缓存数据 command+shift+r 强制刷新,强制浏览器重新下载并加载内容"
  },
  {
    "objectID": "docs/developer/env.html#国内源",
    "href": "docs/developer/env.html#国内源",
    "title": "程序员开放环境",
    "section": "5 国内源",
    "text": "5 国内源\nhttps://mirrors.huaweicloud.com/home"
  },
  {
    "objectID": "docs/developer/env.html#macos",
    "href": "docs/developer/env.html#macos",
    "title": "程序员开放环境",
    "section": "6 macOS",
    "text": "6 macOS\n\n6.1 brew2\n\n6.1.1 使用国内源来安装homebrew\nexport HOMEBREW_BREW_GIT_REMOTE=\"https://mirrors.ustc.edu.cn/brew.git\"\nexport HOMEBREW_CORE_GIT_REMOTE=\"https://mirrors.ustc.edu.cn/homebrew-core.git\"\nexport HOMEBREW_BOTTLE_DOMAIN=\"https://mirrors.ustc.edu.cn/homebrew-bottles\"\nexport HOMEBREW_API_DOMAIN=\"https://mirrors.ustc.edu.cn/homebrew-bottles/api\"\n\n/bin/bash -c \"$(curl -fsSL https://github.com/Homebrew/install/raw/HEAD/install.sh)\"\n# 或\n/bin/bash -c \"$(curl -fsSL https://mirrors.ustc.edu.cn/misc/brew-install.sh)\"\n\n\n6.1.2 brew 国内源配置\n\n\n4.0版本\n\nexport HOMEBREW_BREW_GIT_REMOTE=\"https://mirrors.ustc.edu.cn/brew.git\"\nbrew update\necho 'export HOMEBREW_BREW_GIT_REMOTE=\"https://mirrors.ustc.edu.cn/brew.git\"' &gt;&gt; ~/.zshrc\necho 'export HOMEBREW_BOTTLE_DOMAIN=\"https://mirrors.ustc.edu.cn/homebrew-bottles\"' &gt;&gt; ~/.zshrc\necho 'export HOMEBREW_API_DOMAIN=\"https://mirrors.ustc.edu.cn/homebrew-bottles/api\"' &gt;&gt; ~/.zshrc\necho 'export HOMEBREW_CORE_GIT_REMOTE=\"https://mirrors.ustc.edu.cn/homebrew-core.git\"' &gt;&gt; ~/.zshrc\nbrew tap --custom-remote --force-auto-update homebrew/services https://mirrors.ustc.edu.cn/homebrew-services.git\n# brew tap --custom-remote --force-auto-update homebrew/cask https://mirrors.ustc.edu.cn/homebrew-cask.git\n# brew tap --custom-remote --force-auto-update homebrew/cask-versions https://mirrors.ustc.edu.cn/homebrew-cask-versions.git\n\n\n\n6.1.3 取消brew install 提示升级\nexport HOMEBREW_NO_AUTO_UPDATE=true\n\n\n6.1.4 命令\n# 查看已安装包列表\nbrew list\n# 查询可用包\nbrew search &lt;packageName&gt;\nbrew install node\nbrew uninstall git\nbrew -v\n# 安装mysql指定版本,根据上面的search 可以找到\nbrew install mysql@5.7\n# 启动和停止服务\nbrew services stop redis\nbrew services start redis\n\n\n\n6.2 Term2里lrzsz支持文件上传\nbrew install lrzsz\n创建2个bash脚本\n\n\n/usr/local/bin/term_send.sh\n\n#!/bin/bash\n# Author: Matt Mastracci (matthew@mastracci.com)\n# AppleScript from http://stackoverflow.com/questions/4309087/cancel-button-on-osascript-in-a-bash-script\n# licensed under cc-wiki with attribution required\n# Remainder of script public domain\n\nFILE=`osascript -e 'tell application \"iTerm\" to activate' -e 'tell application \"iTerm\" to set thefile to choose file with prompt \"Choose a file to send\"' -e \"do shell script (\\\"echo \\\"&(quoted form of POSIX path of thefile as Unicode text)&\\\"\\\")\"`\nif [[ -z \"$FILE\" ]]; then\n    echo Cancelled.\n    # Send ZModem cancel\n    echo -e \\\\x18\\\\x18\\\\x18\\\\x18\\\\x18\n    sleep 1\n        echo\n    echo \\# Cancelled transfer\nelse\n    echo $FILE\n    /usr/local/bin/sz \"$FILE\" -E -e -b\n    sleep 1\n    echo \\# Received $FILE\nfi\n\n\n\n/usr/local/bin/term_recv.sh\n\n#!/usr/bin/env bash\n# vim: fdm=marker foldlevel=0 sw=2 ts=2 sts=2\n\nFILE=`osascript -e 'tell application \"iTerm\" to activate' -e 'tell application \"iTerm\" to set thefile to choose folder with prompt \"Choose a folder to place received files in\"' -e \"do shell script (\\\"echo \\\"&(quoted form of POSIX path of thefile as Unicode text)&\\\"\\\")\"`\n\nif [[ -z \"$FILE\" ]]; then\n  echo \" Cancelled\"\n  # Send ZModem cancel\n  echo -e \\\\x18\\\\x18\\\\x18\\\\x18\\\\x18\n  sleep 1\n  echo\n  echo \" # Cancelled transfer\"\nelse\n  cd \"$FILE\"\n  \"${HOMEBREW_PREFIX:-/usr/local}/bin/rz\" -E -e -b\n  sleep 1\n  echo\n  echo \" # Sent -&gt; $FILE\"\n  echo\nfi\n\n设置Iterm2的Tirgger特性，profiles-&gt;default-&gt;editProfiles-&gt;Advanced中的Tirgger\n添加两条trigger，分别设置 Regular expression，Action，Parameters，Instant如下：\n\n\n第一个trigger\n\nRegular expression: rz waiting to receive.\\*\\*B0100\nAction: Run Silent Coprocess\nParameters: /usr/local/bin/term_send.sh\nInstant: checked\n\n\n\n第二个\n\nRegular expression: \\*\\*B00000000000000\nAction: Run Silent Coprocess\nParameters: /usr/local/bin/term_recv.sh\nInstant: checked\n\n\n\n6.3 文件选择框打开隐藏目录\n打开选择框后 按下cmd+shift+g 即可 ### 终端快捷键\n\n\n\n\n\n\n\n快捷键\n功能\n\n\n\n\n++command+k++\n清屏 ,无法再看之前的输出屏幕\n\n\n++ctrl+l++\n清屏,终端光标移到到屏幕上方..\n\n\n\n\n\n6.4 U盘和有些移动硬盘\n一般我们的u盘的文件格式是ntfs,而mac不支持\n# 插入u盘或移动硬盘后\ndiskutil list\n# 看到如下的盘符\n# Microsoft Basic Data 之后的就是你的盘符的名称了\n# 有多少个你都记下来( 一般我们会将移动硬盘分区,就是分区的名称了)\n/dev/disk2 (external, physical):\nMicrosoft Basic Data XYZ       1.0 TB     disk2s1\n修改/etc/fstab, 添加如下 = 号右边的第一个就是写你的盘符名称,有多少个,就有多少行\nLABEL=OPQ none ntfs rw,auto,nobrowse\nLABEL=XYZ none ntfs rw,auto,nobrowse\n映射盘符,将盘符映射到桌面快捷键方式一样\nsudo ln -s /Volumes/XYZ ~XYZsktop/XYZ\n重启电脑\n\n6.4.1 遇到复制到u盘文件变灰色\n# 表示删除文件或者文件夹里面的文件的 属性 com.apple.FinderInfo\n# -d 表示删除, -r递归\nxattr -d -r com.apple.FinderInfo *\n\n\n6.4.2 聚焦搜索\n# 打开\nsudo mdutil -a -i on\n# 关闭, 这样会搜不到软件\nsudo mdutil -a -i off"
  },
  {
    "objectID": "docs/developer/env.html#windows",
    "href": "docs/developer/env.html#windows",
    "title": "程序员开放环境",
    "section": "7 Windows",
    "text": "7 Windows\n\n7.1 命令永久修改环境变量\nsetx PATH \"%PATH%;c:\\go\\bin\""
  },
  {
    "objectID": "docs/developer/env.html#footnotes",
    "href": "docs/developer/env.html#footnotes",
    "title": "程序员开放环境",
    "section": "Footnotes",
    "text": "Footnotes\n\n\n科大源↩︎\nhttps://brew.sh/↩︎"
  },
  {
    "objectID": "docs/middleware/mysql/backup-recovery.html",
    "href": "docs/middleware/mysql/backup-recovery.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "Caution\n\n\n\ntodo…",
    "crumbs": [
      "备份与恢复"
    ]
  },
  {
    "objectID": "docs/middleware/mysql/backup-recovery.html#查看默认配置文件位置",
    "href": "docs/middleware/mysql/backup-recovery.html#查看默认配置文件位置",
    "title": "斯巴拉稀",
    "section": "1 查看默认配置文件位置",
    "text": "1 查看默认配置文件位置\nmysql --help|grep 'my.cnf'",
    "crumbs": [
      "备份与恢复"
    ]
  },
  {
    "objectID": "docs/middleware/mysql/backup-recovery.html#备份",
    "href": "docs/middleware/mysql/backup-recovery.html#备份",
    "title": "斯巴拉稀",
    "section": "2 备份",
    "text": "2 备份\n\n2.1 –compact测试导出结果\n# --compact\nmysqldump -uroot -p12345 --compact -B dbname\n\n\n2.2 开发常用的命令\n# 导出 需要的库与表的创建语句 ,所以我们一般不用-A\n# 包含event 存储过程等\nmysqldump -uroot -p123456 -B -d --triggers -R -E  db1 db2&gt; db_struct.sql\n\n# 导出需要初始化的表数据\n# 含有 db的create 和use 语句的\nmysqldump -uroot -p12345 -B --hex-blob -t mysql db1 db2&gt; dbdata.sql\nmysqldump -uroot -p12345 --hex-blob -t dbname table1 table2  &gt; sometable.sql\n\n# 先导入mysql\nmysql -uroot -p123456 &lt; db_struct.sql\nmysql -uroot -p123456 &lt; dbdata.sql\nmysql -uroot -p123456 dbname &lt; sometable.sql\n\n\n2.3 生产环境命令\n# -E --events\n# -R --routines\n# -F --flush-logs\nmysqldump -uroot -p123456 -A --flush-privileges --single-transaction --master-data=1(或者2) -F --triggers -R -E --hex-blob |gzip &gt;xx.sql.gz\n\n\n2.4 备份单个与多个数据库\n默认是导出表创建语句和数据的\n# -B  会有create db 语句,和 use db 语句. 这样导入时不需要指定 数据库\nmysqldump -uroot -p12345  -B dbname \nmysqldump -uroot -p12345  -B dbname  dbname2\n\n\n2.5 备份单表和多个表\nmysqldump -uroot -p12345 dbname school &gt; school.sql\nmysqldump -uroot -p12345 dbname city school &gt; city_school.sql\n\n\n2.6 只导出表结构\n# 一个库 (包含库创建语句和所有表的创建语句)\nmysqldump -uroot -p12345 -B -d dbname &gt; dbname.sql\n\n# 多个表的创建语句\nmysqldump -uroot -p12345 -d dbname table1 table2 &gt; dbname.sql\n\n\n2.7 只导出数据\nmysqldump -uroot -p12345 -t dbname &gt; dbname.sql\nmysqldump -uroot -p12345 -t dbname table1 table2 &gt; dbname.sql",
    "crumbs": [
      "备份与恢复"
    ]
  },
  {
    "objectID": "docs/middleware/mysql/ha.html",
    "href": "docs/middleware/mysql/ha.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "Back to top"
  },
  {
    "objectID": "docs/middleware/mysql/optimization.html",
    "href": "docs/middleware/mysql/optimization.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "!!! note “什么是驱动表” 在join连表查询时,用来最先获得数据，并以此表的数据为依据，逐步获得其他表的数据，直至最终查询到所有满足条件的数据的第一个表\n```title=“2个表 id主键” select * from a; +—-+——+——+ | id | name | age | +—-+——+——+ | 1 | tom | 20 | | 2 | jack | 22 | +—-+——+——+\nselect * from b; +—-+——–+ | id | class | +—-+——–+ | 1 | class1 | | 2 | class2 | | 3 | class3 | +—-+——–+\n```sql\n-- 连表查询\nselect * from a,b where a.id=b.id\n!!! note 这就好比来了2个人,去你上学的班级里找和他们同名的同学. 你总不至于用你班级的人的名字一个一个去和这2个人对比吧? 直接用2个人的名字 从你班级里找就是了.只需要2次\nfor each row in 驱动表 do\n    lookup 驱动表的each row的索引 in  内表 index\n        if 如果在内表里找到了该索引\n+----+-------------+-------+---------------+------+----------+----------------------------------------------------+\n| id | select_type | table | possible_keys | rows | filtered | Extra                                              |\n+----+-------------+-------+---------------+------+----------+----------------------------------------------------+\n|  1 | SIMPLE      | a     | PRIMARY       |    2 |   100.00 | NULL                                               |\n|  1 | SIMPLE      | b     | PRIMARY       |    3 |    33.33 | Using where; Using join buffer (Block Nested Loop) |\n+----+-------------+-------+---------------+------+----------+----------------------------------------------------+"
  },
  {
    "objectID": "docs/middleware/mysql/optimization.html#系统默认的优化",
    "href": "docs/middleware/mysql/optimization.html#系统默认的优化",
    "title": "斯巴拉稀",
    "section": "",
    "text": "!!! note “什么是驱动表” 在join连表查询时,用来最先获得数据，并以此表的数据为依据，逐步获得其他表的数据，直至最终查询到所有满足条件的数据的第一个表\n```title=“2个表 id主键” select * from a; +—-+——+——+ | id | name | age | +—-+——+——+ | 1 | tom | 20 | | 2 | jack | 22 | +—-+——+——+\nselect * from b; +—-+——–+ | id | class | +—-+——–+ | 1 | class1 | | 2 | class2 | | 3 | class3 | +—-+——–+\n```sql\n-- 连表查询\nselect * from a,b where a.id=b.id\n!!! note 这就好比来了2个人,去你上学的班级里找和他们同名的同学. 你总不至于用你班级的人的名字一个一个去和这2个人对比吧? 直接用2个人的名字 从你班级里找就是了.只需要2次\nfor each row in 驱动表 do\n    lookup 驱动表的each row的索引 in  内表 index\n        if 如果在内表里找到了该索引\n+----+-------------+-------+---------------+------+----------+----------------------------------------------------+\n| id | select_type | table | possible_keys | rows | filtered | Extra                                              |\n+----+-------------+-------+---------------+------+----------+----------------------------------------------------+\n|  1 | SIMPLE      | a     | PRIMARY       |    2 |   100.00 | NULL                                               |\n|  1 | SIMPLE      | b     | PRIMARY       |    3 |    33.33 | Using where; Using join buffer (Block Nested Loop) |\n+----+-------------+-------+---------------+------+----------+----------------------------------------------------+"
  },
  {
    "objectID": "docs/middleware/mysql/optimization.html#sql编写优化",
    "href": "docs/middleware/mysql/optimization.html#sql编写优化",
    "title": "斯巴拉稀",
    "section": "2 SQL编写优化",
    "text": "2 SQL编写优化\n\n2.1 最左前缀法则\n\n\n2.2 不在索引列上做任何操作\n\n\n2.3 少用or或in,使用union\n\n\n2.4 字符串要加单引号\n\n\n2.5 != 和 null 判断 都会使索引失效\n\n\n2.6 order by 优化\n\n\n2.7 分页查询优化\n\n\n2.8 in & exists"
  },
  {
    "objectID": "docs/middleware/mysql/lock.html",
    "href": "docs/middleware/mysql/lock.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "Back to top"
  },
  {
    "objectID": "docs/middleware/mysql/sql.html",
    "href": "docs/middleware/mysql/sql.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "Warning\n\n\n\ntodo…",
    "crumbs": [
      "SQL语句"
    ]
  },
  {
    "objectID": "docs/middleware/mysql/sql.html#常用函数",
    "href": "docs/middleware/mysql/sql.html#常用函数",
    "title": "斯巴拉稀",
    "section": "1 常用函数",
    "text": "1 常用函数\n-- 获取一个uuid\nselect uuid();\n-- 当前时间\nselect now();",
    "crumbs": [
      "SQL语句"
    ]
  },
  {
    "objectID": "docs/middleware/mysql/sql.html#配置相关",
    "href": "docs/middleware/mysql/sql.html#配置相关",
    "title": "斯巴拉稀",
    "section": "2 配置相关",
    "text": "2 配置相关\n\n2.1 查看mysql相关信息\n\n-- 进入mysql控制台后 (mysql -uroot .. 命令连接后的界面) 输入 \\s 后回车\n\\s\n\n\n\n\n\n\n点击查看执行结果\n\n\n\n\n\n--------------\nmysql  Ver 5.7.41-0ubuntu0.20.04.2 for Linux on x86_64 ((Ubuntu))\n\nConnection id:      3\nCurrent database:   test\nCurrent pager:      stdout\nUsing outfile:      ''\nUsing delimiter:    ;\nServer version:     5.7.41 MySQL Community Server (GPL)\nProtocol version:   10\nConnection:     192.168.1.100 via TCP/IP\nServer characterset:    latin1\nDb     characterset:    latin1\nClient characterset:    latin1\nConn.  characterset:    latin1\nTCP port:       3306\nBinary data as:     Hexadecimal\nUptime:         43 min 23 sec\n--------------\n\n\n\n\n\n\n2.2 查看会话与全局变量\n-- 进入mysql后 查看会话变量\nselect @@autocommit;\n-- 查看全局\nselect @@global.autocommit;\n-- 我们平常设置变量 ,下面的只对当前会话有效\n-- 其实是省略了set session autocommit=1; 中的session\nset autocommit=1;\n\n-- 这样设置后,我们查看select @@autocommit 发现还是1,\n-- global只对以后的会话有效,对当前无效,当前的还是保持原来的\nset global autocommit=0;\n-- 模糊查看变量\nshow variables like \"%log%\";\n\n\n2.3 查看字符集\n\nshow character set like '%utf%';\n\n\n\n\n\n\n点击查看执行结果\n\n\n\n\n\n+---------+------------------+--------------------+--------+\n| Charset | Description      | Default collation  | Maxlen |\n+---------+------------------+--------------------+--------+\n| utf8    | UTF-8 Unicode    | utf8_general_ci    |      3 |\n| utf8mb4 | UTF-8 Unicode    | utf8mb4_general_ci |      4 |\n| utf16   | UTF-16 Unicode   | utf16_general_ci   |      4 |\n| utf16le | UTF-16LE Unicode | utf16le_general_ci |      4 |\n| utf32   | UTF-32 Unicode   | utf32_general_ci   |      4 |\n+---------+------------------+--------------------+--------+\n\n\n\n\n\n\n2.4 隔离级别\nshow variables like '%tx%';",
    "crumbs": [
      "SQL语句"
    ]
  },
  {
    "objectID": "docs/middleware/mysql/sql.html#权限设置",
    "href": "docs/middleware/mysql/sql.html#权限设置",
    "title": "斯巴拉稀",
    "section": "3 权限设置",
    "text": "3 权限设置\n-- 角色,mysql中没有角色,用的一种叫代理的方式  这个只有5.7支持\n-- 官方叫 role like 机制\nshow grants;\ncreate user 'dba'@'127.0.0.1';\ncreate user 'xyz'@'::1';\ngrant proxy on 'dba'@'127.0.0.1' to 'xyz'@'::1';\ngrant select on mysql.* to 'dba'@'127.0.0.1';\n\n-- 查看该用户的权限\nshow grants for 'dba'@'127.0.0.1';\n\n-- 可以查看到\nselect * from mysql.proxies_priv;",
    "crumbs": [
      "SQL语句"
    ]
  },
  {
    "objectID": "docs/middleware/mysql/sql.html#database",
    "href": "docs/middleware/mysql/sql.html#database",
    "title": "斯巴拉稀",
    "section": "4 database",
    "text": "4 database\n-- mysql中database与schema 是一模一样的.\n-- 其他数据库可能是一个database有多个schema.\n-- mysql估计是为了和其他数据库保持一致,好理解所以有了schema\n-- 下面2个操作结果一样\nshow databases;\nshow schemas;\n\n-- 选择database,进行查询时,需要先选择你的db\nuse database_name;\n\n-- 每一个数据库对应data dir目录里的是一个文件夹.但是information_schema 不在里面\nuse information_schema;\n-- 我们发现这些个表的引擎都是memory,所以..没有\nshow table status;",
    "crumbs": [
      "SQL语句"
    ]
  },
  {
    "objectID": "docs/middleware/mysql/sql.html#table",
    "href": "docs/middleware/mysql/sql.html#table",
    "title": "斯巴拉稀",
    "section": "5 table",
    "text": "5 table\n\n5.1 查看创建信息\n-- 查看当前db下的所有表信息\nshow table status;\n-- 某个表的一些信息\nshow table status like 'table_name';\n-- 显示创建表的语句\nshow create table table_name;\n\n\n5.2 索引\n-- 删除主键\nalter table table_name drop primary key;\n-- 删除一般索引\nalter table table_name drop index index_name;\n\n\n5.3 临时表\n\n\n\n\n\n\nCaution\n\n\n\n\n创建的临时表是基于会话的,你另外开一个会话,你看不到你创建的临时表\n临时表可以与实体表重名\n在有重名的情况下, 你select * from a实际查询的是临时表,而不是实体表\n\n\n\n\n创建临时表\n\ncreate temporary table  tmp_a (id int);\n\n\n\n查看临时表的默认存储引擎\n\nshow variables like '%default_tmp%';\n\n\n\n\n\n\n\n点击查看执行结果\n\n\n\n\n\n+----------------------------+--------+\n| Variable_name              | Value  |\n+----------------------------+--------+\n| default_tmp_storage_engine | InnoDB |\n+----------------------------+--------+\n\n\n\n\n\n\n\n查看 临时表的状态\n\n-- 可以看到系统里有创建了多少个临时表\nshow global status like '%tmp_tables%';\n-- 当前会话里的情况\nshow status like '%tmp_tables%';\n\n\n\n\n\n\n\n点击查看执行结果\n\n\n\n\n\n+--------------------+-------+\n| Variable_name      | Value |\n+--------------------+-------+\n| Created_tmp_tables | 6     |\n+--------------------+-------+\n\n\n\n\n\n\n表结构存放目录\n\nshow variables like 'tmpdir';\n\n-- 如果你是在mysql所在服务器 用的mysql命令连接可以直接使用如下命令查看\n-- 可以看到.frm的文件\n-- 退出当前mysql 会话, 这个表空间文件会删除的.\nsystem ls /tmp\n\n\n\n\n\n\n临时表表结构文件命名方式\n\n\n\n\n临时表的表结构文件.frm 命名方式是 #sql{进程id}_{线程id}_序列号\n线程id 通过 show processlist 的ID列获得.\n\n\n\n\n\n\n表空间的存放目录\n\nshow variables like \"%data%\";\n\n\n\n\n\n\n\n点击查看执行结果\n\n\n\n\n\n+---------------------------------------+------------------------+\n| Variable_name                         | Value                  |\n+---------------------------------------+------------------------+\n2| datadir                               | /var/lib/mysql/        |\n| innodb_data_file_path                 | ibdata1:12M:autoextend |\n| innodb_data_home_dir                  |                        |\n1| innodb_temp_data_file_path            | ibtmp1:12M:autoextend  |\n+---------------------------------------+------------------------+\n\n1\n\n创建的文件名是 ibtmp1,放在 innodb_data_home_dir 目录下\n\n2\n\n如果 innodb_data_home_dir 是空的, 就放到datadir 下\n\n\n-- 可以看到\nsystem ls /var/lib/mysql/ibtmp1\n\n\n\n\n\n\n5.4 增\n\n\n5.5 删\n\n\n5.6 改\n\n\n5.7 查",
    "crumbs": [
      "SQL语句"
    ]
  },
  {
    "objectID": "docs/middleware/mysql/sql.html#奇技",
    "href": "docs/middleware/mysql/sql.html#奇技",
    "title": "斯巴拉稀",
    "section": "6 奇技",
    "text": "6 奇技\n\n6.1 导出csv,带字段名\n# 默认导出没有标题. 所以用union 来完成效果\nmysql -uroot -proot test -e \"select 'a','b','c' from dual union select a,b,c from test  into outfile '/tmp/x.csv' CHARACTER SET gbk fields terminated by ',' optionally enclosed by '\\\"' lines terminated by '\\r\\n'; \"\n\n\n\n\n\n\nTip\n\n\n\n\noptionally enclosed by ‘\"’ 这样 字段内容有, 号的 就不会被分成2个了.\nsecure_file_priv=/tmp/ 这个参数影响 导出文件的位置,以及是否可导出\n如果 上面的参数为空, 去 /tmp/xxxxx-mariadb/tmp 看看",
    "crumbs": [
      "SQL语句"
    ]
  },
  {
    "objectID": "docs/middleware/mysql/sql.html#null",
    "href": "docs/middleware/mysql/sql.html#null",
    "title": "斯巴拉稀",
    "section": "7 null",
    "text": "7 null\n\n\n\n\n\n\n注意\n\n\n\n\n任何值与null进行=比较,得到的都是null\n用is 来判断\n\n\n\nselect null=1;\nselect 1=null;\nselect null in (1,null);",
    "crumbs": [
      "SQL语句"
    ]
  },
  {
    "objectID": "docs/middleware/kafka/install.html",
    "href": "docs/middleware/kafka/install.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "修改bin/kafka-run-class.sh\n\n添加 LOG_DIR=/新的位置\n\n修改kafka_2.12-2.3.0/config/log4j.properties\n\n配置 /var/log/kafka位置 添加 kafka.logs.dir=/新的位置\n\n\n\nlog.dirs=/tmp/kafka-logs\n/infusion-server/kafka_2.12-2.3.0/config/server.properties\nlog.retention.hours 本身就已经设置 168个小时,保留7天.\n修改后, 停止kafka 将原本的数据目录 复制到新的位置, 重启. 数据迁移"
  },
  {
    "objectID": "docs/middleware/kafka/install.html#配置",
    "href": "docs/middleware/kafka/install.html#配置",
    "title": "斯巴拉稀",
    "section": "",
    "text": "修改bin/kafka-run-class.sh\n\n添加 LOG_DIR=/新的位置\n\n修改kafka_2.12-2.3.0/config/log4j.properties\n\n配置 /var/log/kafka位置 添加 kafka.logs.dir=/新的位置\n\n\n\nlog.dirs=/tmp/kafka-logs\n/infusion-server/kafka_2.12-2.3.0/config/server.properties\nlog.retention.hours 本身就已经设置 168个小时,保留7天.\n修改后, 停止kafka 将原本的数据目录 复制到新的位置, 重启. 数据迁移"
  },
  {
    "objectID": "docs/middleware/redis/persistence.html",
    "href": "docs/middleware/redis/persistence.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "Caution\n\n\n\n未完待续",
    "crumbs": [
      "基础",
      "数据持久化"
    ]
  },
  {
    "objectID": "docs/middleware/redis/persistence.html#rdb",
    "href": "docs/middleware/redis/persistence.html#rdb",
    "title": "斯巴拉稀",
    "section": "1 RDB",
    "text": "1 RDB\n\n\n\n\n\n\nTip\n\n\n\n\nsnapshot,快照\n二进制格式\n早期redis版本的默认方式\n按照事先指定的频率,周期性都保存到磁盘\n默认文件是dump.rdb\n宕机后,数据会丢失一部分\n\n\n\n\n\nredis.conf\n\nsave 900 1  #900秒内如果有&gt;=1个key发生变化(set写入的操作),则写入磁盘\nsave 300 10 #300秒内如果有&gt;=10个key,则不用等待900秒 写入\nsave 60 10000  #如果60秒内有&gt;=10000个 则写入\n\n\n\n\n\n\n\nCaution\n\n\n\n如果你在60秒内 做了 999次操作, 然后这个时候redis服务器宕机了. 那么数据就不会写入磁盘,也就是说丢失了.\n\n\n\n1.1 主动生成rdb快照\n进入客户端\n# 每次执行这样的命令都会将所有redis内存快照到一个新的rdb文件,并覆盖原有快照文件\nsave 或 bgsave  \n\nsavebgsave\n\n\n同步方式,在主线程中保存快照, 所以这个时候所有操作会阻塞,因为主线程就是用来执行client的请求的\n\n\n\nbackground save ,异步方式,client请求不会阻塞\n调用fork创建一个子进程,父进程继续处理各个请求\nlinux的写时复制cow特点,父子进程共享同一个物理空间,父进程会将操作的页面创建一个副本,而子进程的数据还是要开始保存的那个时间点\n子进程负责将内存中的内容保存到临时文件,只有当其保存ok后,才会保存到真正的文件\n执行完后,子进程退出\n\n\n\n\n\n\n1.2 重放\n\n就是将dump.rdb 重新加载到内存\nrdb比aof的重放速度快,直接文件重新写入 ,aof是重新执行命令",
    "crumbs": [
      "基础",
      "数据持久化"
    ]
  },
  {
    "objectID": "docs/middleware/redis/persistence.html#aof",
    "href": "docs/middleware/redis/persistence.html#aof",
    "title": "斯巴拉稀",
    "section": "2 AOF",
    "text": "2 AOF\n\nappend only file\n记录每一次的写操作,几乎不会丢失数据,但是 这样性能肯定就没那么好了\n\n因为写入磁盘本身 是先写到缓存的? 操作系统..\n\n就是将你执行的redis命令 添加到指定的文件\n文件会比较大\n重启时,可以通过重新执行文件中的命令在内存中重建数据\n\n\n\nredis.conf中开启aof\n\nappendonly no # 设置为yes 开启\nappendfilename \"appendonly.aof\"  # 文件名\ndir /usr/local/var/db/redis/  # 存放的目录在这里\n\n\n2.1 写入策略\n# appendfsync always  # 每写一条命令,就写入, 这个性能最不好\n# 每1秒,redis内部本身也是先写到缓存中,到达1秒后,写入磁盘\n# 故障时 只会丢失1秒钟的数据\nappendfsync everysec\n# appendfsync no      # 将数据交给操作系统来处理.\n\n#表示重写的时候,父进程的新的操作不同步到文件\nno-appendfsync-on-rewrite no\n#可以用config set parma value 来修改\n但是如果要永久话,需要 config rewirte\n\n\n2.2 重写优化\n我们知道当redis重启时, 会将aof文件里的命令重新执行来达到重建数据的目的\n\naof重写的问题\n\naof 是重新执行了一遍命令, 肯定比rdb 重放慢\n由于可能有很多无用的命令, 这个很好理解, 就是你后面的命令 直接覆盖了前面的, set a 1 ,set a 2,第一条命令实际就是没用的\n比如你执行了100次的操作,可能只要一次就行了,但是保存的还是100语句\n\n手动重写命令 bgrewirteaof 命令可以重写aof文件,合并一些操作\n\n不会读取旧的aof文件\n比如内存中的结果直接变成 它所对应的语句 写到临时文件\n将内存中的文件保存到临时文件,最后替换真正的文件\n过程\n\n主进程通过fork 生成子进程\n子进程根据内存中的数据创建数据库重建命令序列与临时文件中\n父进程继续接收client的请求,会把这些请求的命令追加于原来的aof文件,为了防止重写失败,额外的会把这些新的请求写于一个缓冲队列中\n子进程写完临时文件后,会通知父进程,父进程会把缓冲队列中的命令写到临时文件中\n最后 父进程?用临时文件替换老的aof文\n\n\n\n\n\n2.3 重写策略\n# 当你的文件 自上一次重写后 大小增加了100%后, 会触发重写\n#当现在得aof文件是上次重写后的文件的2倍大小时,再次重写\nauto-aof-rewrite-percentage 100\n# 表示当文件至少达到64m的时候才会自动重写, 因为文件太小 本身加载到内存就很快.\nauto-aof-rewrite-min-size 64mb",
    "crumbs": [
      "基础",
      "数据持久化"
    ]
  },
  {
    "objectID": "docs/middleware/redis/persistence.html#redis-4.0以后-混合持久化",
    "href": "docs/middleware/redis/persistence.html#redis-4.0以后-混合持久化",
    "title": "斯巴拉稀",
    "section": "3 redis 4.0以后 混合持久化",
    "text": "3 redis 4.0以后 混合持久化\n重启 Redis 时，我们很少使用 RDB来恢复内存状态，因为会丢失大量数据。我们通常使用 AOF 日志重 放，但是重放 AOF 日志性能相对 RDB来说要慢很多，这样在 Redis 实例很大的情况下，启动需要花费很 长的时间。 Redis 4.0 为了解决这个问题，带来了一个新的持久化选项——混合持久化\n\n就是结合了上面的2个\n开启\n\naof-use-rdb-preamble yes\n\nAOF在重写时，不再是单纯将内存数据转换为RESP命令写入AOF文件，而是将 重写这一刻之前的内存做RDB快照处理，并且将RDB快照内容和增量的AOF修改内存数据的命令存在一 起，都写入新的AOF文件，新的文件一开始不叫appendonly.aof，等到重写完新的AOF文件才会进行改 名，原子的覆盖原有的AOF文件，完成新旧两个AOF文件的替换。\n于是在 Redis 重启的时候，可以先加载 RDB 的内容，然后再重放增量 AOF 日志就可以完全替代之前的 AOF 全量文件重放，因此重启效率大幅得到提升。\n\n\n\nbgrewirteaof 后看下 aof文件,然后 set 写入 ,再看看文件里的内容",
    "crumbs": [
      "基础",
      "数据持久化"
    ]
  },
  {
    "objectID": "docs/middleware/redis/principle.html",
    "href": "docs/middleware/redis/principle.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "Back to top"
  },
  {
    "objectID": "docs/middleware/redis/source-code.html",
    "href": "docs/middleware/redis/source-code.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "Caution\n\n\n\n未完待续",
    "crumbs": [
      "源码分析",
      "环境准备"
    ]
  },
  {
    "objectID": "docs/middleware/redis/source-code.html#vscode-debug-环境搭建",
    "href": "docs/middleware/redis/source-code.html#vscode-debug-环境搭建",
    "title": "斯巴拉稀",
    "section": "1 vscode debug 环境搭建",
    "text": "1 vscode debug 环境搭建\n\n添加配置\n\n\nmac 环境选择lldb, 然后修改部分配置,如下\n\n\nlaunch.json\n\n{\n    \"version\": \"0.2.0\",\n    \"configurations\": [\n        {\n            \"name\": \"(lldb) 启动\",\n            \"type\": \"cppdbg\",\n            \"request\": \"launch\",\n            \"program\": \"${workspaceFolder}/src/redis-server\",\n            \"args\": [\n                \"./redis.conf\"\n            ],\n            \"stopAtEntry\": false,\n            \"cwd\": \"${workspaceFolder}\",\n            \"environment\": [],\n            \"externalConsole\": false,\n            \"MIMode\": \"lldb\"\n        }\n\n    ]\n}\n\n\n编译\n\n# 编译\n# -O0 参数表示告诉编译器不要优化代码, 防止你在 Debug 的时候,IDE 里面的 Redis 源码与实际运行的代码对应不上.\n# MALLOC=jemalloc,指定在 Mac OS 系统上 Redis 使用 jemalloc 内存分配器,\n# Linux 默认使用该分配器，如果是 Linux 系统,无需指定该参数\nmake CFLAGS=\"-g -O0\" MALLOC=jemalloc\n\n开始调试 (快捷键F5)\n\n\n\nsrc/server.c main()主函数 打个断点 \n\nint main(int argc, char **argv) {\n    struct timeval tv;\n    int j;\n    char config_from_stdin = 0;\n    ...\n    ...\n}",
    "crumbs": [
      "源码分析",
      "环境准备"
    ]
  },
  {
    "objectID": "docs/middleware/redis/source-code.html#总体流程",
    "href": "docs/middleware/redis/source-code.html#总体流程",
    "title": "斯巴拉稀",
    "section": "2 总体流程",
    "text": "2 总体流程\n\n2.1 服务启动\n\n\nserver.c入口redisCommandTableinitServer()\n\n\n\n\nserver.c\n\n// 入口\nint main(int argc, char **argv) {\n    // ...\n    initServerConfig();\n    // ...\n    initServer();\n    // ...\n}\n\n\n\nstruct redisCommand redisCommandTable[] = {\n    {\"module\",moduleCommand,-2,\n    \"admin no-script\",\n    0,NULL,0,0,0,0,0,0},\n\n    {\"get\",getCommand,2,\n    \"read-only fast @string\",\n    0,NULL,1,1,1,0,0,0},\n    ...\n}\n\n\nvoid initServer(void) {\n    // ...\n    server.db = zmalloc(sizeof(redisDb)*server.dbnum);\n    // ...\n    \n    /* 创建并初始化数据库结构 dbnum=16  我们select 0 选择数据库*/\n    for (j = 0; j &lt; server.dbnum; j++) {\n        server.db[j].dict = dictCreate(&dbDictType,NULL);\n        server.db[j].expires = dictCreate(&dbExpiresDictType,NULL);\n        server.db[j].expires_cursor = 0;\n        server.db[j].blocking_keys = dictCreate(&keylistDictType,NULL);\n        server.db[j].ready_keys = dictCreate(&objectKeyPointerValueDictType,NULL);\n        server.db[j].watched_keys = dictCreate(&keylistDictType,NULL);\n        server.db[j].id = j;\n        server.db[j].avg_ttl = 0;\n        server.db[j].defrag_later = listCreate();\n        listSetFreeMethod(server.db[j].defrag_later,(void (*)(void*))sdsfree);\n    }\n\n}",
    "crumbs": [
      "源码分析",
      "环境准备"
    ]
  },
  {
    "objectID": "docs/middleware/redis/source-code.html#set-age-11-的过程doing",
    "href": "docs/middleware/redis/source-code.html#set-age-11-的过程doing",
    "title": "斯巴拉稀",
    "section": "3 set age 11 的过程(doing)",
    "text": "3 set age 11 的过程(doing)\n\ntypedef struct redisDb {\n    /* The keyspace for this DB */\n    dict *dict;                 \n    /* Timeout of keys with a timeout set */\n    dict *expires;           \n    /* Keys with clients waiting for data (BLPOP)*/\n    dict *blocking_keys;   \n    /* Blocked keys that received a PUSH */\n    dict *ready_keys;          \n    /* WATCHED keys for MULTI/EXEC CAS */\n    dict *watched_keys;         \n    /* Database ID */\n    int id;                     \n    /* Average TTL, just for stats */\n    long long avg_ttl;\n    /* Cursor of the active expire cycle. */\n    unsigned long expires_cursor; \n    /* List of key names to attempt to defrag one by one, gradually. */\n    list *defrag_later;         \n} redisDb;",
    "crumbs": [
      "源码分析",
      "环境准备"
    ]
  },
  {
    "objectID": "docs/middleware/redis/env.html",
    "href": "docs/middleware/redis/env.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "Caution\n\n\n\n未完待续",
    "crumbs": [
      "基础",
      "快速入门"
    ]
  },
  {
    "objectID": "docs/middleware/redis/env.html#安装",
    "href": "docs/middleware/redis/env.html#安装",
    "title": "斯巴拉稀",
    "section": "1 安装",
    "text": "1 安装",
    "crumbs": [
      "基础",
      "快速入门"
    ]
  },
  {
    "objectID": "docs/middleware/redis/env.html#配置",
    "href": "docs/middleware/redis/env.html#配置",
    "title": "斯巴拉稀",
    "section": "2 配置",
    "text": "2 配置\n\n\n/usr/local/etc/redis.conf\n\n...\ndaemonize no # 是否守护, 一般正式用的话 是yes,你测试的时候可以是no\nport 6379\nlogfile \"6379.log\" # 文件会存放到dir指定的目录\ndir /usr/local/var/db/redis/ #工作目录 数据都会保存在这里, (rdb文件和aof文件)\n...\n\n\n\n命令查看相关配置\n\ninfo\ninfo server #看下redis的版本,配置文件路径啊之类的\nconfig get port #查看端口\n        1) \"port\"\n        2) \"6379\"\nconfig get *\n# 支持的最大连接数\nconfig get maxclients",
    "crumbs": [
      "基础",
      "快速入门"
    ]
  },
  {
    "objectID": "docs/middleware/redis/env.html#基础命令",
    "href": "docs/middleware/redis/env.html#基础命令",
    "title": "斯巴拉稀",
    "section": "3 基础命令",
    "text": "3 基础命令\n# 客户端连接服务端\nredis-cli -h 127.0.0.1 -p 6379\n# 直接执行 命令 set age\nredis-cli -p 6378 set age 11\n# 直接输入ping 命令, ok的话, pong 回应\nping\n\n# set string\nset name \"hei\"\nget name\n# 判断key是否存在\nexists name\n# 判断key是什么类型\ntype name\n## 返回值\n    #- none 表示没有这个key\n    #- string\n    #- hash\n    #- set 集合\n    #- zset 有序集合\n    #- list\n# 查看当前db 有多少key,key的总数\ndbsize # 他实际是一个计数器,不是计算key的总数 的操作的\n# 遍历所有key, 显示所有key\nkeys *\n# 可以使用正则\nkeys na* #遍历所有na开头的key\n#删除key\ndel name\ndel name age #多个删除\n\n# 过期设置\nexpire name 5 #单位是秒,5秒后过期\n# 查看key的过期\nttl name #返回-2 表示已经不存在了\n#取消过期时间设置 (就是没有过期时间了)\npersist name\n#再次 查看\nttl name #返回-1 表示key没有设置过期时间",
    "crumbs": [
      "基础",
      "快速入门"
    ]
  },
  {
    "objectID": "docs/middleware/redis/env.html#redis生命周期",
    "href": "docs/middleware/redis/env.html#redis生命周期",
    "title": "斯巴拉稀",
    "section": "4 redis生命周期",
    "text": "4 redis生命周期\n\n客户端发送命令,向服务端发送请求\n在redis服务端,redis是单线程的,所以可以想象成有一个队列在维护客户端发送来的请求命令\n服务端一个一个的执行队列里的命令\n返回结果给客户端",
    "crumbs": [
      "基础",
      "快速入门"
    ]
  },
  {
    "objectID": "docs/middleware/redis/env.html#流水线pipeline",
    "href": "docs/middleware/redis/env.html#流水线pipeline",
    "title": "斯巴拉稀",
    "section": "5 流水线pipeline",
    "text": "5 流水线pipeline",
    "crumbs": [
      "基础",
      "快速入门"
    ]
  },
  {
    "objectID": "docs/middleware/redis/env.html#慢查询",
    "href": "docs/middleware/redis/env.html#慢查询",
    "title": "斯巴拉稀",
    "section": "6 慢查询",
    "text": "6 慢查询\n\nmysql 有慢查询, redis 也有, 就是服务端真正执行命令所花费的时间 比较慢的 语句\nredis把慢查询的命令存放到一个队列中,这个队列有一个长度,如果超过了这个长度,则会踢掉,先进先踢\n\n\n\nredis.conf\n\n# 如果设置为0 ,表示记录所有命令\n# 如果设置 &lt; 0 则表示 不记录任何命令\nslowlog-log-slower-than 10000  # 这里是1s,执行时间超过1s则认为是慢查询\nslowlog-max-len 128            # 队列中的慢查询个数 超过这个,旧的慢查询就会从队列中删除\n\n应该定期持久化慢查询 ,可以使用slowlog get等命令将慢查询写入到mysql等数据库\n# 获取最新的n条慢查询记录\nslowlog get n\n# 获取慢查询队列长度\nslowlog len\n# 清空慢查询队列\nslowlog reset",
    "crumbs": [
      "基础",
      "快速入门"
    ]
  },
  {
    "objectID": "docs/middleware/redis/env.html#客户端工具",
    "href": "docs/middleware/redis/env.html#客户端工具",
    "title": "斯巴拉稀",
    "section": "7 客户端工具",
    "text": "7 客户端工具\ninsight1",
    "crumbs": [
      "基础",
      "快速入门"
    ]
  },
  {
    "objectID": "docs/middleware/redis/env.html#footnotes",
    "href": "docs/middleware/redis/env.html#footnotes",
    "title": "斯巴拉稀",
    "section": "Footnotes",
    "text": "Footnotes\n\n\ninsight↩︎",
    "crumbs": [
      "基础",
      "快速入门"
    ]
  },
  {
    "objectID": "add-table.html",
    "href": "add-table.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "Sample grid table.\n\n\n\n\n\n\n\nFruit\nPrice\nAdvantages\n\n\n\n\nBananas\n$1.34\n\nbuilt-in wrapper\nbright color\n\n\n\nOranges\n$2.10\n\ncures scurvy\ntasty\n\n\n\n\n在vscode中 右键 点击 Edit in visual mode ,然后插入table , 直接编辑它就行, 最后复制"
  },
  {
    "objectID": "add-table.html#添加这种格式的table-的方式",
    "href": "add-table.html#添加这种格式的table-的方式",
    "title": "斯巴拉稀",
    "section": "",
    "text": "Sample grid table.\n\n\n\n\n\n\n\nFruit\nPrice\nAdvantages\n\n\n\n\nBananas\n$1.34\n\nbuilt-in wrapper\nbright color\n\n\n\nOranges\n$2.10\n\ncures scurvy\ntasty\n\n\n\n\n在vscode中 右键 点击 Edit in visual mode ,然后插入table , 直接编辑它就行, 最后复制"
  },
  {
    "objectID": "index.rust.html",
    "href": "index.rust.html",
    "title": ":   ",
    "section": "",
    "text": ":   \n\n\n\n\n\n\n最后的最后就再折腾2个\n\n\n\n\n doing \n todo\n\n\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "docs/middleware/redis/cache.html",
    "href": "docs/middleware/redis/cache.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "Back to top"
  },
  {
    "objectID": "docs/middleware/redis/architecture.html#哨兵",
    "href": "docs/middleware/redis/architecture.html#哨兵",
    "title": "斯巴拉稀",
    "section": "2 哨兵",
    "text": "2 哨兵"
  },
  {
    "objectID": "docs/middleware/redis/architecture.html#集群",
    "href": "docs/middleware/redis/architecture.html#集群",
    "title": "斯巴拉稀",
    "section": "3 集群",
    "text": "3 集群"
  },
  {
    "objectID": "docs/middleware/redis/data-type.html",
    "href": "docs/middleware/redis/data-type.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "未完待续",
    "crumbs": [
      "基础",
      "数据类型"
    ]
  },
  {
    "objectID": "docs/middleware/redis/data-type.html#五大基本类型",
    "href": "docs/middleware/redis/data-type.html#五大基本类型",
    "title": "斯巴拉稀",
    "section": "1 五大基本类型",
    "text": "1 五大基本类型\n\n1.1 strings\n\n1.1.1 基本命令\n\n增改查自增减删除\n\n\nset age 20 # 不管这个key 存不存在都设置\n# SETNX = SET if Not eXists, 不存在才设置\n# 现在用 set key value NX 来替代\nset age 30 nx # 不存在才设置,相当于创建\nset age 34 xx # age存在才设置,相当于更新\nget age # 查看key,不存在返回nil\n\n# SET key value EX seconds\n# ex expire , 设置key 5秒后过期, 会删除\nset age 10 EX 5\n\n# MSET key value [key value ...]\n# n次get命令,需要n次网络时间,和n次命令时间\n# mget 只需要一次,一次会传递所有的命令给, 执行要么全部成功,要么都失败\nmset name tom age 10\nmget name age\n\n# 设置新的值,会返回旧的name的值\ngetset name tom\n# 追加字符串到key的值后面\nappend name cat\n# ==&gt; tomcat\n# strlen 也是o(1)的复杂度, 就是说 不是实时计算key的长度的,\n# 而是 有计数器统计该key的长度 做了记录的\nstrlen name # 获取长度\n\nsetrange name 1 x\n# tomcat ==&gt; txmcat\ngetrange name 1 3\n# ==&gt;xmc\n\n\n# 如果key不存在,那么该key是int型,初始值是0, 则自增1, 就变成了1, 返回值就是age的值\nincr age\n# 如果不存在该key, 值变为-1 同上\ndecr age\n\nincrby age 2 # 表示age 增加2\ndecrby age 2 # -2\nincrbyfloat age 1.2\n# 使用负数来实现 decr 的\nincrbyfloat age -1.2\n\n\ndel name\n\n\n\n\n\n1.1.2 应用场景\n分布式id 生成器 利用redis的单线程特性, 多个服务可能要来请求,使用incr 就可以来搞出一个自增的id\n\n\n\n1.2 lists\n有序的,可以做左边插入,弹出,右边插入,弹出的操作\n\n1.2.1 基本命令\n\npush/pop查指定元素前后插入删除根据索引修改元素根据索引截取元素\n\n\n# 从右边插入,可插入多个\nrpush names tom jack\n# 从左边插入\nlpush names bob stark\n\nlpop names #左边弹出\nrpop names #右边弹出\n# 上面我们的lpop 和rpop 都是非阻塞的,直接给出结果,如果没有元素的话,返回的是nil\n# 这里的blpop和brpop是阻塞版本\n# 如果key列表里面有值,则马上返回,不管你的timeout是啥\n# 如果key里面没有元素,则等待timeout秒, 还没有结果则退出\n# 如果timeout=0,则会永远的等待下去,直到列表里 有新的元素\nblpop key timeout\n\n\n# lrange key start end # 包含end\n# start end 如果是 负数\n# 比如 lrange key -6  -1    :-1 表示最右边的那个元素, -2 表示 -1那个的左边元素\nlrange names 0 -1 # 查看所有的元素\n# 获取 索引位置的元素\nlindex names 2\n# 列表长度 (元素个数)\nllen names\n\n\n# 在\n# 下面2个的时间复杂度是o(n),因为需要遍历\ninsert after bob bob2\ninsert before bob marry\n\n\n# 如果count &gt;0 则表示从左到右删除count个 相同的value(因为list可以存放相同的元素)\n# 如果count &lt;0 则表示从右到左\n# count=0 删除所有\nlrem key count value\n\n\n# 设置索引位置1 的元素为 trump\nlset names 1 trump\n\n\n# names a b c d e\nltrim names 1 3 # 截取索引1-3 包含3 的元素\nlrange names 0 -1 # ==&gt; b c d\n\n\n\n\n\n\n1.3 hashes\n类似下面这样,就是key对应的是个map\n\"tom\":{\n    \"name\":\"tom\",\n    \"age\":20,\n    \"sex\":\"boy\"\n}\n可以理解为 一张表的一条记录 比如user表,无法给单独的field 设置过期时间\n\n1.3.1 基本命令\n\n增改查删\n\n\n# u:1 叫key ,name 叫field\nhset u:1 name tom\n# 多个field, #原本的多个field的命令 hmset 说是将被废弃,现在还可以用\nhset u:1 name tom age 22 sex boy\n# 只能设置一个field ,  这搞的. 不如就保留 hmset , 不要在 hset 里可以设置多个field.\nHSETNX  u:1 name jack # 不存在才设置\n\n# field 自增\nhincrby u:1 age 1\n\n\n# 获取field,只能一个field\nhget u:1 name\n# 多个field .. 服了. 和上面的感觉..\nhmget u:1 name age\nhgetall u:1 #返回所有field 和value\n\n# 判断field是否存在\nhexists u:1 name\n# 如果说判断 u1 是否存在\nhlen u:1 # 返回 u1 有多少个field\n\nhkeys u:1 # 返回所有的field\nhvals u:1 # 返回所有的value\n\n\nhdel u:1 name\nhdel u:1 age sex #删除多个field\n\n\n\n\n\n1.3.2 应用场景\n使用user:id值 作为key, 里面再存map 比如name 啊, pv(主页访问量),这样一个key 存放很多用户的信息\n\n\n\n1.4 sets 集合\n无序,无重复\n\n1.4.1 基本命令\n\n添加删除查看集合运算\n\n\n# 添加元素\nsadd country china\n\n\n# 删除元素\nsrem country japan\n\n\n# 计算集合元素个数\nscard animal\n# 获取集合所有元素\nsmembers animal\n# 判断元素是否在集合内\nSISMEMBER animal cow\n# 随机返回一个元素\nSRANDMEMBER animal\n# 随机弹出一个元素\nSPOP animal\n\n\nsdiff  user:1:playing_game  user:2:playing_game #差集\nsinter user:1:playing_game  user:2:playing_game #交集\nsunion user:1:playing_game  user:2:playing_game #并集\n\n\n\n\n\n1.4.2 应用场景\n\n抽奖可以用srandmember/spop\n用户点赞某个帖子 ( 帖子id作为key,里面存发用户id表示点赞)\n给用户添加标签, 还要知道一个标签对应了那些用户,都可以用集合来\n微博用户之间的共同关注\n\n\n\n\n1.5 sorted sets 有序集合\nset 存放的就是元素 zset 存放的 需要一个score分值(用来排序的,可以重复) 和 元素 时间复杂度是 o(logN)\n\n1.5.1 基本命令\n\n增改删查集合运算\n\n\n# zadd key score element1 score2 element2 ...\nzadd student 80 xiaoming\nzadd student 80 xiaoming 90 tom\n# 增加或减少(使用负数) 元素的分数\nzincrby student 3 xiaoming\n\n\n# 指定元素删除 可以删除多个元素\nzrem student xiaoming xiaobai\n# 根据排名范围来删除元素\nZREMRANGEBYRANK student 1 2\n# 柑橘分数范围来删除元素\nZREMRANGEBYscore student 71  89\n\n\n# 获取元素的分数\nzscore student xiaoming\n\n# 返回元素总数\nzcard student\n# 按照分数升序, 返回元素的排名,\n# 0 表示第一位, 也就是分数最小的那一位\nzrank student xiaoming\n# 按照分数降序,返回元素的排名\n# 0 表示第一位, 也就是分数最大的那一位\nzrevrank student xiaohei\n\n# range 按照分数升序,返回索引范围内的元素\nzrange student 0 -1\n# withscores 表示显示分数\nzrange student 0 -1 withscores\n# 返回指定分数范围内的元素\nzrangebyscore student 70 90 [withscores]\n\n# 按照分数降序\nzrevrange student 0 -1\n# 指定分数范围, 先指定大 后小\nzrevrangebyscore student 100 50 [withscores]\n\n\n# 指定分数范围内有多少个元素\nzcount key minScore maxScore\n\n\nzadd stu1 77 tom 80 jack 50 karen\nzadd stu2 10 tom 60 jack 80 kelly\n\n# 交集\n# ZINTERSTORE destination numkeys key [key ...] [WEIGHTS weight [weight ...]] [AGGREGATE &lt;SUM | MIN | MAX&gt;]\n# destination 会将交集的结果写入 这个key\n# numkeys 2 表示有2个key 参与交集运算, 必须指定\n# WEIGHTS 默认是1, 也就是说你的分数的权重, 比如权重是10,如果你的分数是1, 那么等同于是10分的分量\n# AGGREGATE 交集后对于元素分数的处理, 默认是SUM,各集合该元素的分数*权重 的和\nzinterstore res_stu 2 stu1 stu2 # 交集后 tom 元素的分数是 77*1+10*1 =87\nzrange res_stu  0 -1 withscores\n\nzrange res_stu  0 -1 withscores\n\n\n执行结果\n\ntom\n87\njack\n140\n\n\n# 权重需要分别指定\nzinterstore res_stu 2 stu1 stu2 WEIGHTS 5 1 AGGREGATE SUM\n\n# 并集 ,其他参数等 同交集的处理\nZUNIONSTORE res_stu 2 stu1 stu2\n\n\n\n\n\n1.5.2 应用场景\n什么什么各种排行版 可以使用有序集合",
    "crumbs": [
      "基础",
      "数据类型"
    ]
  },
  {
    "objectID": "docs/middleware/redis/data-type.html#扩展类型",
    "href": "docs/middleware/redis/data-type.html#扩展类型",
    "title": "斯巴拉稀",
    "section": "2 扩展类型",
    "text": "2 扩展类型\n\n2.1 bitmaps 位图\n\n2.1.1 基本命令\n\n\n\n\n\n\nTip\n\n\n\nbitmaps are an extension of the string data type\n\n\n\n位的设置与获取位运算\n\n\n字母A 对应的ascii码是 65 对应的二进制 0100 0001\n# 注意索引从0开始,从高位往低位这样算,从左到右.\n#  65二进制的高位第6位(从0开始算)是1,这里索引是1\nsetbit x 1 1 #命令的返回结果 是之前这个位置的值 (值:0或1)\nsetbit x 7 1 # 这个设置的是低位的1, 也就是二进制的第0位\n# 通过以上的设置A这个key 的结果就是 0100 0001\nget x\n# 结果就是A\n# 获取key 第二个位置的 bit值\ngetbit x 1\n\n# 获取bit为1的个数, 可以指定bit范围\nbitcount A [start end]\n\nset z 65 # 注意我们的值是字符串,是一个字节一个字节进行\"解析\"的\nstrlen z # 可以看到长度\n# \"65\"的 ascii是 6是54  0011 0110,在内存的低地址,  5 是53  0011 0101 在内存上地址比\"6\" 的大一个字节\n# 再强调一下 字符串是一个字节一个字节进行\"解析\"的\n# 那么0-7的索引是 \"6\"的位 , 8-15是\"5\"的位\n# setbit 索引本身就是从低地址到高地址, 只不过每个字节上 (字节的高位在小的索引上)\ngetbit z 6 # 1\ngetbit z 15 # 1\n\n\ngo代码验证字符串左边是放在低地址\n\na := \"654\"\nb := (*reflect.StringHeader)(unsafe.Pointer(&a))\nprintln(b.Len, b.Data)\nc := (*[3]int8)(unsafe.Pointer(b.Data))\nprintln(c[0], c[1], c[2])\nprintln(&c[0], &c[1], &c[2])\n\n\n\nsetbit tmp 6 1\nsetbit tmp 7 1\n# bitop= bit + operate + 后面的 and与,or或,not非,xor异或 等\n# 位的或操作,将结果给到new_str这个key\nbitop or new_str A tmp\n# new_str的value结果是 \"C\"\n\n\n\n\n\n2.1.2 应用场景\n用来统计登录用户,或者说有多少用户\n\n假设有1亿个用户, 那么需要1亿个位,也不过10M多, setbit login_user user_id 1 该用户在线了\n如果有的设计上用户的id初始就非常巨大. 第一个用户是100亿.以后依次递增, 那么我们完全可以-100亿后的数字 作为索引进行设置1\n\n\n\n\n2.2 GEO\ntype city  # 是zset类型\ngeoadd key 经度 纬度 成员\ngeoadd city 116.20 39.56 beijing\n# 可以添加多个\nGEOADD city 116.20 39.56 beijing 120.12 30.16 hangzhou \n# 获取某个成员经纬度\ngeopos city hangzhou\n# 计算2个位置之间的距离,默认单位是m, 可以在后面带上(km千米,mi英里,ft尺)\nGEODIST city hangzhou beijing km\n\n# georadius 获取指定范围内的地理位置\ngeoradius city 116 39 100 km # --&gt; beijing\n\n\n2.3 hyperLogLog\n\n\n\n\n\n\nNote\n\n\n\n\n如果让你统计一个数据集里不同元素的数量,比如日活用户\n你可能会说统计这个, 放进set ,然后scard 不就行了\n如果数据量巨大呢, 都放进set吗, 所以这种情况set肯定不行.\n用bitmap? 1000万也才1M多, 挺不错的. 有没有占用更少的呢.\nhyperLogLog就可以解决这个问题\n基于hyperLogLog(HLL)算法,使用极小的空间,完成数量统计, ==本质是字符串==\nHyperLogLog（HLL）是一种基数({==一个集合中不同元素的数量==})估计算法. HLL算法可以在{==极少的内存使用下==},快速准确地估计一个大型数据集的基数.\n每个HyperLogLog键只占用12KB内存,就可以计算接近2^64个不同元素的基数\n\n\n\n# 添加多个\n# key不存在,则添加成功返回1\n# 如key已经存在, 然后添加的元素 也都已经有了, 则返回0, 表示添加无效.\nPFADD login_yesterday 1 2 3 4 2\ntype login_yesterday # 本质是字符串\n# 计算基数 (不同元素的数量) 插入大量数据时,统计可能不那么准确, 因为本身就是预估\nPFCOUNT login_yesterday # 4个\npfadd login_today 1 2 5 7\nPFMERGE login login_today login_yesterday # 将合并的结果设置到login 这个key中\nPFCOUNT login_yesterday login_today # 直接合并计算\n\n2.3.1 应用场景\n\n\n\n\n\n\nTip\n\n\n\nhyperLogLog 本身不保存实际的数据,只是用来统计\n\n\n\n统计日活,月活数据\n\n\n\n\n2.4 Bloom Filter 布隆过滤器\n\n\n\n\n\n\nCaution\n\n\n\n这个不是数据类型. 不过我暂时放在这里\n\n\n原理就是: 一个很长的二进制 (初始位的值都是0,像bitmap)和诺干个hash函数 比如一个电话号码 给哈希函数(多个)计算过后的值,在二进制的相应位置的位上改成1, 比如我们要判断这个电话号码是否在这10亿号码中, 先将10亿个号码这样处理, 然后我们计算这个电话号码的哈希,看对应位上是否都是1\n误差率\n\nm个二进制位\nn个预备数据\nk个哈希函数\n\n\n2.4.1 应用场景\n垃圾邮件过滤等\n\n\n\n2.5 bitfields(todo)\n\n\n2.6 Streams(todo)",
    "crumbs": [
      "基础",
      "数据类型"
    ]
  },
  {
    "objectID": "docs/middleware/mongodb/install.html",
    "href": "docs/middleware/mongodb/install.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "Back to top"
  },
  {
    "objectID": "docs/middleware/mysql/binlog.html",
    "href": "docs/middleware/mysql/binlog.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "Caution\n\n\n\ntodo…",
    "crumbs": [
      "二进制日志"
    ]
  },
  {
    "objectID": "docs/middleware/mysql/binlog.html#配置信息",
    "href": "docs/middleware/mysql/binlog.html#配置信息",
    "title": "斯巴拉稀",
    "section": "1 配置信息",
    "text": "1 配置信息\n\n\nmy.cnf\n\nserver-id               = 1\nlog_bin                 = mysql-bin\n\n+-----------------------------------------+---------------------+\n| Variable_name               | Value                           |\n+-----------------------------------------+---------------------+\n| log_bin                     | ON                              |  -- 是否开启\n| log_bin_basename            | /var/lib/mysql/mysql-bin        |\n| log_bin_index               | /var/lib/mysql/mysql-bin.index  |\n| max_binlog_size             | 104857600                       |  -- binlog文件的最大值,达到最大值,则重新生成一个新的\n| binlog_format               | ROW                             |  -- 有三种 statement(记录sql语句), row(每一行数据) , mixed\n+-----------------------------------------+---------------------+\n\nshow master status;\n\n\n执行结果\n\n+------------------+----------+\n| File             | Position |\n+------------------+----------+\n| mysql-bin.000001 |      154 |\n+------------------+----------+\n\n\n我们发现 mysql-bin.000001的文件大小 154 字节数就是上面的position\nll mysql-bin*\n-rw-r----- 1 mysql mysql 154 Sep  3 14:36 mysql-bin.000001\n-rw-r----- 1 mysql mysql  19 Sep  3 14:36 mysql-bin.index\n\n\n\n查看binlog更具体的内容\n\nshow binlog events in 'mysql-bin.000001'\\G\n\n\n\n\n\n\n\n点击查看执行结果\n\n\n\n\n\n*************************** 1. row ***************************\n   Log_name: mysql-bin.000001\n        Pos: 4\n Event_type: Format_desc\n  Server_id: 1\nEnd_log_pos: 123\n       Info: Server ver: 5.7.17-0ubuntu0.16.04.1-log, Binlog ver: 4\n*************************** 2. row ***************************\n   Log_name: mysql-bin.000001\n        Pos: 123\n Event_type: Previous_gtids\n  Server_id: 1\nEnd_log_pos: 154\n       Info:\n\n\n\n\n\n\n刷新日志,会重新生成一个二进制文件\n\nflush binary logs;\nshow master status;\n+------------------+----------+\n| File             | Position |\n+------------------+----------+\n| mysql-bin.000002 |      154 |\n+------------------+----------+",
    "crumbs": [
      "二进制日志"
    ]
  },
  {
    "objectID": "docs/middleware/mysql/binlog.html#binlog_format",
    "href": "docs/middleware/mysql/binlog.html#binlog_format",
    "title": "斯巴拉稀",
    "section": "2 binlog_format",
    "text": "2 binlog_format\n\n\n\n\n\n\n\nformat\ndescription\n\n\n\n\nstatement\n记录操作的sql文  不支持不确定的sql语句,比如update ....  limit 3\n\n\nrow\n记录操作的每一行数据,每张表一定要有主键\n\n\nmixed",
    "crumbs": [
      "二进制日志"
    ]
  },
  {
    "objectID": "docs/middleware/mysql/binlog.html#查看binlog文件里的sql语句",
    "href": "docs/middleware/mysql/binlog.html#查看binlog文件里的sql语句",
    "title": "斯巴拉稀",
    "section": "3 查看binlog文件里的sql语句",
    "text": "3 查看binlog文件里的sql语句\n#这个可以看到具体的sql文件\nmysqlbinlog mysql-bin.000001 -vv\n#-----------------------------------------------------\n### INSERT INTO `test`.`mm`\n### SET\n###   @1=5 /* INT meta=0 nullable=0 is_null=0 */\n###   @2=5 /* INT meta=0 nullable=1 is_null=0 */\n#-----------------------------------------------------\n@1 表示第一列\n@2 表示第二列\nmysqlbinlog mysql-bin.000001 --base64-output=decode-row -v\nhelp show binlog events;",
    "crumbs": [
      "二进制日志"
    ]
  },
  {
    "objectID": "docs/middleware/mysql/env.html",
    "href": "docs/middleware/mysql/env.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "# 我们在my.cnf 其实是可以配置的,但是明文,不好\n# mysql提供了一个命令,设置一个标签my (名字随便起)来登录\n# 这个命令实际上生成了一个二进制文件,路径是 ~/.mylogin.cnf\n# -G my 后面是你的连接参数, 需要什么就加什么, 比如 -h -P\nmysql_config_editor set -G my -uroot -p\nEnter password:   这里你输入密码\n# 然后我们打印一下\nmysql_config_editor print --all\n# 显示的密码不是明文\n  [my]\n  user = root\n  password = *****\n# 使用该标签登录\nmysql --login-path=my",
    "crumbs": [
      "环境准备"
    ]
  },
  {
    "objectID": "docs/middleware/mysql/env.html#免密登录mysql",
    "href": "docs/middleware/mysql/env.html#免密登录mysql",
    "title": "斯巴拉稀",
    "section": "",
    "text": "# 我们在my.cnf 其实是可以配置的,但是明文,不好\n# mysql提供了一个命令,设置一个标签my (名字随便起)来登录\n# 这个命令实际上生成了一个二进制文件,路径是 ~/.mylogin.cnf\n# -G my 后面是你的连接参数, 需要什么就加什么, 比如 -h -P\nmysql_config_editor set -G my -uroot -p\nEnter password:   这里你输入密码\n# 然后我们打印一下\nmysql_config_editor print --all\n# 显示的密码不是明文\n  [my]\n  user = root\n  password = *****\n# 使用该标签登录\nmysql --login-path=my",
    "crumbs": [
      "环境准备"
    ]
  },
  {
    "objectID": "docs/middleware/mysql/transaction.html",
    "href": "docs/middleware/mysql/transaction.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "Back to top"
  },
  {
    "objectID": "docs/middleware/mysql/index.html",
    "href": "docs/middleware/mysql/index.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "Warning\n\n\n\n未完待续",
    "crumbs": [
      "索引底层"
    ]
  },
  {
    "objectID": "docs/middleware/mysql/index.html#红黑树-red-black-trees",
    "href": "docs/middleware/mysql/index.html#红黑树-red-black-trees",
    "title": "斯巴拉稀",
    "section": "1 红黑树 Red-Black Trees",
    "text": "1 红黑树 Red-Black Trees\n\n\n\n\n\n\n\nn层最多能存放多少数据?\n\n\n\n\n红黑树解决了二叉树插入有序数据导致所有的节点都会在根节点的右侧或左侧,变成了链表的问题, 插入一条数据后,会自动调整\n那么能不能用这个结构来存储mysql数据呢?\nn层的话, 总共能放 total = 2⁰ + 2¹ +2² +… 2ⁿ⁻¹\n2total = 2¹ +2² +… 2ⁿ = 2⁰ + 2¹ +2² +… 2ⁿ⁻¹+ 2ⁿ - 2⁰ = total + 2ⁿ - 2⁰\n2total = total + 2ⁿ - 2⁰\n结果: total = 2ⁿ-1",
    "crumbs": [
      "索引底层"
    ]
  },
  {
    "objectID": "docs/middleware/mysql/redo.html",
    "href": "docs/middleware/mysql/redo.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "Back to top"
  },
  {
    "objectID": "docs/middleware/mysql/undo.html",
    "href": "docs/middleware/mysql/undo.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "Back to top"
  },
  {
    "objectID": "docs/middleware/es/env.html",
    "href": "docs/middleware/es/env.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "Back to top"
  },
  {
    "objectID": "docs/developer/rime.html",
    "href": "docs/developer/rime.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "!!! tips vim中 ESC后就会自动切换到英文模式"
  },
  {
    "objectID": "docs/developer/rime.html#rime",
    "href": "docs/developer/rime.html#rime",
    "title": "斯巴拉稀",
    "section": "",
    "text": "!!! tips vim中 ESC后就会自动切换到英文模式"
  },
  {
    "objectID": "docs/developer/rime.html#双拼输入法",
    "href": "docs/developer/rime.html#双拼输入法",
    "title": "斯巴拉稀",
    "section": "2 双拼输入法",
    "text": "2 双拼输入法"
  },
  {
    "objectID": "docs/developer/vim.html",
    "href": "docs/developer/vim.html",
    "title": "vim",
    "section": "",
    "text": "Caution\n\n\n\ntodo…",
    "crumbs": [
      "vim"
    ]
  },
  {
    "objectID": "docs/developer/vim.html#配置",
    "href": "docs/developer/vim.html#配置",
    "title": "vim",
    "section": "1 配置",
    "text": "1 配置\n\n\n~/.vimrc\n\n\" basic settings\nset history=500\nset shortmess=atI   \" 启动的时候不显示那个援助乌干达儿童的提示 \n\" Use Vim settings, rather than Vi settings (much better!).\n\" This must be first, because it changes other options as a side effect.\nset nocompatible  \"去掉讨厌的有关vi一致性模式，避免以前版本的一些bug和局限\nset nobackup \"不备份\nset ruler       \" show the cursor position all the time\nset showcmd     \" display incomplete commands\nset incsearch       \" do incremental searching\nset nu\nset foldenable      \" 允许折叠  \nset foldmethod=manual   \" 手动折叠 \n\"Always show current position\nset ruler\n\" Height of the command bar\nset cmdheight=2\nsyntax on\n\nlet $LANG='en'\nset langmenu=en\nlet g:coc_global_extensions = [\n  \\  \"coc-explorer\",\n  \\  \"coc-translator\",\n  \\  \"coc-python\",\n  \\  \"coc-vimlsp\",\n  \\ \"coc-gitignore\",\n  \\  \"coc-json\",\n  \\  \"coc-rust-analyzer\",\n  \\  \"coc-go\",\n  \\  \"coc-yaml\",\n  \\  \"coc-syntax\",\n  \\  \"coc-html\"\n\\ ]\nautocmd BufWritePre *.go :silent call CocAction('runCommand', 'editor.action.organizeImport')\ninoremap &lt;silent&gt;&lt;expr&gt; &lt;TAB&gt;\n      \\ pumvisible() ? \"\\&lt;C-n&gt;\" :\n      \\ &lt;SID&gt;check_back_space() ? \"\\&lt;TAB&gt;\" :\n      \\ coc#refresh()\ninoremap &lt;expr&gt;&lt;S-TAB&gt; pumvisible() ? \"\\&lt;C-p&gt;\" : \"\\&lt;C-h&gt;\"\nfunction! s:check_back_space() abort\n  let col = col('.') - 1\n  return !col || getline('.')[col - 1]  =~# '\\s'\nendfunction\n\" 提示 主动的快捷键\nif has('nvim')\n  inoremap &lt;silent&gt;&lt;expr&gt; &lt;c-o&gt; coc#refresh()\nelse\n  inoremap &lt;silent&gt;&lt;expr&gt; &lt;c-o&gt; coc#refresh()\nendif\nnmap &lt;silent&gt; [g &lt;Plug&gt;(coc-diagnostic-prev)\nnmap &lt;silent&gt; ]g &lt;Plug&gt;(coc-diagnostic-next)\ninoremap &lt;silent&gt;&lt;expr&gt; &lt;cr&gt; pumvisible() ? coc#_select_confirm()\n                              \\: \"\\&lt;C-g&gt;u\\&lt;CR&gt;\\&lt;c-r&gt;=coc#on_enter()\\&lt;CR&gt;\"\n\" GoTo code navigation.\nnmap &lt;silent&gt; gd &lt;Plug&gt;(coc-definition)\nnmap &lt;silent&gt; gy &lt;Plug&gt;(coc-type-definition)\nnmap &lt;silent&gt; gi &lt;Plug&gt;(coc-implementation)\nnmap &lt;silent&gt; gr &lt;Plug&gt;(coc-references)\n\n\" Use K to show documentation in preview window.\n\"nnoremap &lt;silent&gt; &lt;LEADER&gt;h :call &lt;SID&gt;show_documentation()&lt;CR&gt;\n\nnnoremap &lt;silent&gt; K :call &lt;SID&gt;show_documentation()&lt;CR&gt;\nnnoremap tt :CocCommand explorer&lt;CR&gt;\n\" coc-translator\nnmap ts &lt;Plug&gt;(coc-translator-p)\nfunction! s:show_documentation()\n  if (index(['vim','help'], &filetype) &gt;= 0)\n    execute 'h '.expand('&lt;cword&gt;')\n  elseif (coc#rpc#ready())\n    call CocActionAsync('doHover')\n  else\n    execute '!' . &keywordprg . \" \" . expand('&lt;cword&gt;')\n  endif\nendfunction\nxmap &lt;leader&gt;a  &lt;Plug&gt;(coc-codeaction-selected)\nnmap &lt;leader&gt;a  &lt;Plug&gt;(coc-codeaction-selected)\n\" Highlight the symbol and its references when holding the cursor.\nautocmd CursorHold * silent call CocActionAsync('highlight')\n\n\" Symbol renaming.\nnmap &lt;leader&gt;rn &lt;Plug&gt;(coc-rename)\n\n\" Formatting selected code.\nxmap &lt;leader&gt;f  &lt;Plug&gt;(coc-format-selected)\nnmap &lt;leader&gt;f  &lt;Plug&gt;(coc-format-selected)\n\naugroup mygroup\n  autocmd!\n  \" Setup formatexpr specified filetype(s).\n  autocmd FileType typescript,json setl formatexpr=CocAction('formatSelected')\n  \" Update signature help on jump placeholder.\n  autocmd User CocJumpPlaceholder call CocActionAsync('showSignatureHelp')\naugroup end\n\n\" Applying codeAction to the selected region.\n\" Example: `&lt;leader&gt;aap` for current paragraph\nxmap &lt;leader&gt;a  &lt;Plug&gt;(coc-codeaction-selected)\nnmap &lt;leader&gt;a  &lt;Plug&gt;(coc-codeaction-selected)\n\n\" Remap keys for applying codeAction to the current buffer.\nnmap &lt;leader&gt;ac  &lt;Plug&gt;(coc-codeaction)\n\" Apply AutoFix to problem on the current line.\nnmap &lt;leader&gt;qf  &lt;Plug&gt;(coc-fix-current)\n\n\" Run the Code Lens action on the current line.\nnmap &lt;leader&gt;cl  &lt;Plug&gt;(coc-codelens-action)\n\n\" Map function and class text objects\n\" NOTE: Requires 'textDocument.documentSymbol' support from the language server.\nxmap if &lt;Plug&gt;(coc-funcobj-i)\nomap if &lt;Plug&gt;(coc-funcobj-i)\nxmap af &lt;Plug&gt;(coc-funcobj-a)\nomap af &lt;Plug&gt;(coc-funcobj-a)\nxmap ic &lt;Plug&gt;(coc-classobj-i)\nomap ic &lt;Plug&gt;(coc-classobj-i)\nxmap ac &lt;Plug&gt;(coc-classobj-a)\nomap ac &lt;Plug&gt;(coc-classobj-a)\n\n\" Remap &lt;C-f&gt; and &lt;C-b&gt; for scroll float windows/popups.\nif has('nvim-0.4.0') || has('patch-8.2.0750')\n  nnoremap &lt;silent&gt;&lt;nowait&gt;&lt;expr&gt; &lt;C-f&gt; coc#float#has_scroll() ? coc#float#scroll(1) : \"\\&lt;C-f&gt;\"\n  nnoremap &lt;silent&gt;&lt;nowait&gt;&lt;expr&gt; &lt;C-b&gt; coc#float#has_scroll() ? coc#float#scroll(0) : \"\\&lt;C-b&gt;\"\n  inoremap &lt;silent&gt;&lt;nowait&gt;&lt;expr&gt; &lt;C-f&gt; coc#float#has_scroll() ? \"\\&lt;c-r&gt;=coc#float#scroll(1)\\&lt;cr&gt;\" : \"\\&lt;Right&gt;\"\n  inoremap &lt;silent&gt;&lt;nowait&gt;&lt;expr&gt; &lt;C-b&gt; coc#float#has_scroll() ? \"\\&lt;c-r&gt;=coc#float#scroll(0)\\&lt;cr&gt;\" : \"\\&lt;Left&gt;\"\n  vnoremap &lt;silent&gt;&lt;nowait&gt;&lt;expr&gt; &lt;C-f&gt; coc#float#has_scroll() ? coc#float#scroll(1) : \"\\&lt;C-f&gt;\"\n  vnoremap &lt;silent&gt;&lt;nowait&gt;&lt;expr&gt; &lt;C-b&gt; coc#float#has_scroll() ? coc#float#scroll(0) : \"\\&lt;C-b&gt;\"\nendif\n\n\" Use CTRL-S for selections ranges.\n\" Requires 'textDocument/selectionRange' support of language server.\nnmap &lt;silent&gt; &lt;C-s&gt; &lt;Plug&gt;(coc-range-select)\nxmap &lt;silent&gt; &lt;C-s&gt; &lt;Plug&gt;(coc-range-select)\n\n\" Add `:Format` command to format current buffer.\ncommand! -nargs=0 Format :call CocActionAsync('format')\n\n\" Add `:Fold` command to fold current buffer.\ncommand! -nargs=? Fold :call     CocAction('fold', &lt;f-args&gt;)\n\n\" Add `:OR` command for organize imports of the current buffer.\ncommand! -nargs=0 OR   :call     CocActionAsync('runCommand', 'editor.action.organizeImport')\n\n\" Add (Neo)Vim's native statusline support.\n\" NOTE: Please see `:h coc-status` for integrations with external plugins that\n\" provide custom statusline: lightline.vim, vim-airline.\nset statusline^=%{coc#status()}%{get(b:,'coc_current_function','')}\n\n\" Mappings for CoCList\n\" Show all diagnostics.\nnnoremap &lt;silent&gt;&lt;nowait&gt; &lt;space&gt;a  :&lt;C-u&gt;CocList diagnostics&lt;cr&gt;\n\" Manage extensions.\nnnoremap &lt;silent&gt;&lt;nowait&gt; &lt;space&gt;e  :&lt;C-u&gt;CocList extensions&lt;cr&gt;\n\" Show commands.\nnnoremap &lt;silent&gt;&lt;nowait&gt; &lt;space&gt;c  :&lt;C-u&gt;CocList commands&lt;cr&gt;\n\" Find symbol of current document.\nnnoremap &lt;silent&gt;&lt;nowait&gt; &lt;space&gt;o  :&lt;C-u&gt;CocList outline&lt;cr&gt;\n\" Search workspace symbols.\nnnoremap &lt;silent&gt;&lt;nowait&gt; &lt;space&gt;s  :&lt;C-u&gt;CocList -I symbols&lt;cr&gt;\n\" Do default action for next item.\nnnoremap &lt;silent&gt;&lt;nowait&gt; &lt;space&gt;j  :&lt;C-u&gt;CocNext&lt;CR&gt;\n\" Do default action for previous item.\nnnoremap &lt;silent&gt;&lt;nowait&gt; &lt;space&gt;k  :&lt;C-u&gt;CocPrev&lt;CR&gt;\n\" Resume latest coc list.\nnnoremap &lt;silent&gt;&lt;nowait&gt; &lt;space&gt;p  :&lt;C-u&gt;CocListResume&lt;CR&gt;\n\"set clipboard+=unnamed\n\n\" Turn on the WiLd menu\n\"set wildmenu\n\n\" Ignore compiled files\n\"set wildignore=*.o,*~,*.pyc\n\"if has(\"win16\") || has(\"win32\")\n\"    set wildignore+=.git\\*,.hg\\*,.svn\\*\n\"else\n\"    set wildignore+=*/.git/*,*/.hg/*,*/.svn/*,*/.DS_Store\n\"endif\n\n\n\" When started as \"evim\", evim.vim will already have done these settings.\nif v:progname =~? \"evim\"\n  finish\nendif\n\n\n\" allow backspacing over everything in insert mode\nset backspace=indent,eol,start\n  \"set undofile     \" keep an undo file (undo changes after closing)\n\n\" Don't use Ex mode, use Q for formatting\nmap Q gq\n\n\" CTRL-U in insert mode deletes a lot.  Use CTRL-G u to first break undo,\n\" so that you can undo CTRL-U after inserting a line break.\ninoremap &lt;C-U&gt; &lt;C-G&gt;u&lt;C-U&gt;\n\" In many terminal emulators the mouse works just fine, thus enable it.\nif has('mouse')\n  \"set mouse=a\nendif\n\" Switch syntax highlighting on, when the terminal has colors\n\" Also switch on highlighting the last used search pattern.\nif &t_Co &gt; 2 || has(\"gui_running\")\n  syntax on\n  set hlsearch\nendif\n\n\" Only do this part when compiled with support for autocommands.\nif has(\"autocmd\")\n\n  \" Enable file type detection.\n  \" Use the default filetype settings, so that mail gets 'tw' set to 72,\n  \" 'cindent' is on in C files, etc.\n  \" Also load indent files, to automatically do language-dependent indenting.\n  filetype plugin indent on\n\n  \" Put these in an autocmd group, so that we can delete them easily.\n  augroup vimrcEx\n  au!\n\n  \" For all text files set 'textwidth' to 78 characters.\n  autocmd FileType text setlocal textwidth=78\n\n  \" When editing a file, always jump to the last known cursor position.\n  \" Don't do it when the position is invalid or when inside an event handler\n  \" (happens when dropping a file on gvim).\n  \" Also don't do it when the mark is in the first line, that is the default\n  \" position when opening a file.\n  autocmd BufReadPost *\n    \\ if line(\"'\\\"\") &gt; 1 && line(\"'\\\"\") &lt;= line(\"$\") |\n    \\   exe \"normal! g`\\\"\" |\n    \\ endif\n\n  augroup END\n\nelse\n\n  set autoindent        \" always set autoindenting on\n\nendif \" has(\"autocmd\")\n\n\" Convenient command to see the difference between the current buffer and the\n\" file it was loaded from, thus the changes you made.\n\" Only define it when not defined already.\nif !exists(\":DiffOrig\")\n  command DiffOrig vert new | set bt=nofile | r ++edit # | 0d_ | diffthis\n          \\ | wincmd p | diffthis\nendif\n\" rust\nautocmd Filetype rust set foldmethod=syntax\n\n\" SYNTAX HIGHLIGHTING:\nset t_Co=256\n\"syntax on\n\"colorscheme ir_black\nset bs=2\nfiletype off                  \" required\n\" set the runtime path to include Vundle and initialize\n\"set rtp+=~/.vim/bundle/Vundle.vim\n\"call vundle#begin()\n\"call vundle#begin('~/some/path/here')\ncall plug#begin()\n\"Plugin 'VundleVim/Vundle.vim'\nPlug 'jiangmiao/auto-pairs'\nPlug 'tomtom/tcomment_vim'  \"in &lt;space&gt;cn to comment a line\n\" type yskw' to wrap the word with '' or type cs'` to change 'word' to `word`\nPlug 'tpope/vim-surround' \n\" in Visual mode, type k' to select all text in '', or type k) k] k} kp\nPlug 'gcmt/wildfire.vim' \nPlug 'ryanoasis/vim-devicons'\nPlug 'tpope/vim-fugitive'\nPlug 'bling/vim-airline'\n\" 在 Vim 中快速导航文件,好像需要ruby支持,暂时不按照\n\" Plugin 'git://git.wincent.com/command-t.git'\n\"Plug 'rstacruz/sparkup', {'rtp': 'vim/'}\nPlug 'rust-lang/rust.vim'\n\"Bundle 'Rykka/riv.vim'\nPlug 'ctrlpvim/ctrlp.vim'\nPlug 'nvim-treesitter/nvim-treesitter'\n\" pretty dress\nPlug 'theniceboy/nvim-deus'\nPlug 'scrooloose/nerdtree'\nPlug 'neoclide/coc.nvim', {'branch': 'release'}\nPlug 'wellle/tmux-complete.vim'\n\n\" 这个插件可以显示文件的 Git 增删状态\nPlug 'Xuyuanp/nerdtree-git-plugin'\n\"Plugin 'user/L9', {'name': 'newL9'}\n\"Plug 'scrooloose/syntastic'\nPlug 'tpope/vim-markdown'\nPlug 'mattn/emmet-vim'\nPlug 'kien/rainbow_parentheses.vim'\nPlug 'godlygeek/tabular'\nPlug 'Yggdroot/indentLine'\nPlug 'majutsushi/tagbar'\nPlug 'junegunn/fzf', { 'do': { -&gt; fzf#install() } }\ncall plug#end()\n\n\n\n\"call vundle#end()            \" required\nfiletype plugin indent on    \" required\nset guifont=Droid\\ Sans\\ Mono\\ for\\ Powerline\\ Plus\\ Nerd\\ File\\ Types\\ 12\nset nu\nlet mapleader=';'\nautocmd InsertLeave * if pumvisible() == 0|pclose|endif \"离开插入模式后自动关闭预览窗口\n\"autocmd FileType php set omnifunc=phpcomplete#CompletePHP\nset shiftwidth=4\nset tabstop=4\nset softtabstop=4\nset expandtab                  \"将tab替换为相应数量空格\nset smartindent\nset encoding=utf8               \"设置内部编码为utf8\nset fileencoding=utf8            \"当前编辑的文件编码\nset fileencodings=uft8-bom,utf8,gbk,gb2312,big5   \"打开支持编码的文件\nset backspace=2               \"可随时用倒退键删除\n\"imap ;; &lt;ESC&gt;\n\"cmap ;; &lt;ESC&gt;\nvmap &lt;C-c&gt; \"+y\nset cursorline\nset hlsearch\nset incsearch\nset showmatch\nset report=0\nset laststatus=2\nlet g:airline_powerline_fonts = 1\n\"let g:airline_symbols\n\"let g:airline_left_sep='▶'\n\"let g:airline_right_sep='◀'\nlet g:airline#extensions#tabline#enabled = 1\nsyntax enable\n\" 如果是在xshell下vim 这里需要打开\n\" 百度搜索 xshell vim solarized\nlet g:solarized_termcolors=256\nset background=dark\ncolorscheme solarized\nlet g:ctrlp_map = '&lt;c-p&gt;'\nlet g:ctrlp_cmd = 'CtrlP'\nlet g:ctrlp_working_path_mode = 'ra'\nset wildignore+=*/tmp/*,*.so,*.swp,*.zip     \" MacOSX/Linux\nset wildignore+=*\\\\tmp\\\\*,*.swp,*.zip,*.exe  \" Windows\n\n\"let g:ctrlp_custom_ignore = '\\v[\\/]\\.(git|hg|svn)$'\nlet g:ctrlp_custom_ignore = {\n  \\ 'dir':  '\\v[\\/]\\.(git|hg|svn)$',\n  \\ 'file': '\\v\\.(exe|so|dll)$',\n  \\ 'link': 'some_bad_symbolic_links',\n  \\}\nmap &lt;F3&gt; :NERDTreeToggle&lt;CR&gt;\n\" 可直接复制到系统剪贴板\nset clipboard=unnamed\n\"autocmd vimenter * NERDTree\nlet g:NERDTreeDirArrowExpandable = '❤'\nlet g:NERDTreeDirArrowCollapsible = '▼'\nlet g:NERDTreeGitStatusIndicatorMapCustom= {\n    \\ \"Modified\"  : \"✹\",\n    \\ \"Staged\"    : \"✚\",\n    \\ \"Untracked\" : \"✭\",\n    \\ \"Renamed\"   : \"➜\",\n    \\ \"Unmerged\"  : \"═\",\n    \\ \"Deleted\"   : \"✖\",\n    \\ \"Dirty\"     : \"✗\",\n    \\ \"Clean\"     : \"✔︎\",\n    \\ \"Unknown\"   : \"?\"\n    \\ }\nlet g:autoclose_vim_commentmode = 1\nset statusline+=%#warningmsg#\nset statusline+=%{SyntasticStatuslineFlag()}\nset statusline+=%*\n\nlet g:syntastic_always_populate_loc_list = 1\nlet g:syntastic_auto_loc_list = 1\nlet g:syntastic_check_on_open = 1\nlet g:syntastic_check_on_wq = 0\nlet g:user_emmet_install_global = 0\nlet g:syntastic_ignore_files=[\".*\\.rst$\"]\nautocmd FileType html,css EmmetInstall\nlet g:rbpt_colorpairs = [\n    \\ ['brown',       'RoyalBlue3'],\n    \\ ['Darkblue',    'SeaGreen3'],\n    \\ ['darkgray',    'DarkOrchid3'],\n    \\ ['darkgreen',   'firebrick3'],\n    \\ ['darkcyan',    'RoyalBlue3'],\n    \\ ['darkred',     'SeaGreen3'],\n    \\ ['darkmagenta', 'DarkOrchid3'],\n    \\ ['brown',       'firebrick3'],\n    \\ ['gray',        'RoyalBlue3'],\n    \\ ['black',       'SeaGreen3'],\n    \\ ['darkmagenta', 'DarkOrchid3'],\n    \\ ['Darkblue',    'firebrick3'],\n    \\ ['darkgreen',   'RoyalBlue3'],\n    \\ ['darkcyan',    'SeaGreen3'],\n    \\ ['darkred',     'DarkOrchid3'],\n    \\ ['red',         'firebrick3'],\n    \\ ]\nlet g:rbpt_max = 36\nlet g:rbpt_loadcmd_toggle = 0\nau VimEnter * RainbowParenthesesToggle\nau Syntax * RainbowParenthesesLoadRound\nau Syntax * RainbowParenthesesLoadSquare\nau Syntax * RainbowParenthesesLoadBraces\n\"let g:indent_guides_auto_colors = 1\n\"let g:indent_guides_enable_on_vim_startup = 1\nlet g:indentLine_color_term = 239\nlet g:indentLine_enabled = 1\n\"ctrlp\nnnoremap &lt;silent&gt; &lt;Leader&gt;f :CtrlPMRU&lt;CR&gt;\nnnoremap &lt;silent&gt; &lt;Leader&gt;b :CtrlPBuffer&lt;CR&gt;\n\" 窗口切换\nnnoremap &lt;c-h&gt; &lt;c-w&gt;h\nnnoremap &lt;c-l&gt; &lt;c-w&gt;l\nnnoremap &lt;c-j&gt; &lt;c-w&gt;j\nnnoremap &lt;c-k&gt; &lt;c-w&gt;k\n\n\"设置撤销的目录\nset undodir=/tmp/vimundodir \nnnoremap &lt;Leader&gt;w :w&lt;CR&gt;\nnnoremap &lt;Leader&gt;q :q&lt;CR&gt;\ninoremap &lt;c-a&gt; &lt;ESC&gt;0i\n\"inoremap &lt;c-e&gt; &lt;ESC&gt;$a\n\"map &lt;F5&gt; :!javac %&&java %:r &lt;CR&gt;\nhi MatchParen cterm=bold ctermbg=none ctermfg=magenta\nlet g:UltiSnipsExpandTrigger=\"&lt;c-y&gt;\"\n\"let g:vimim_cloud = 'sogou'\n\n\"tagbar settings\n\" vim php文件时,按下F8即可\n\" http://ctags.sourceforge.net/\n\" 进入某个code目录 ctags -R 生成tags\n\" \" 进入代码目录 ctags -R 生成tags文件\n\" 打开代码  F8 即可打开右侧\n\" ctrl + ] 跳转定义\n\" ctrl + t 调回原来的地方\n\" nmap 表示 正常模式, n normal\n\"nmap &lt;M-d&gt; &lt;ctrl-]&gt; \n\" 配置插入模式下 也使用ctrl+] 来跳转\nimap &lt;c-]&gt; &lt;Esc&gt;&lt;c-]&gt;\nnmap &lt;F8&gt; :TagbarToggle&lt;CR&gt;\nlet g:tagbar_ctags_bin = 'ctags'\nlet g:tagbar_width = 30\n\" 需要复制一堆东西到vim打开的文件时,会乱了格式,这个就是解决这个问题\n\" F10 来切换\nset pastetoggle=&lt;F10&gt;\n\"inoremap ( ()&lt;ESC&gt;i\n\"inoremap [ []&lt;ESC&gt;i\n\"inoremap { {}&lt;ESC&gt;i\n\"inoremap &lt; &lt;&gt;&lt;ESC&gt;i",
    "crumbs": [
      "vim"
    ]
  },
  {
    "objectID": "docs/developer/vim.html#vimdiff时的快捷键",
    "href": "docs/developer/vim.html#vimdiff时的快捷键",
    "title": "vim",
    "section": "2 vimdiff时的快捷键",
    "text": "2 vimdiff时的快捷键\n\n\n\n快捷键\n功能\n\n\n\n\nctrl + w ,再按 l 切换到右侧\n切换到右边的窗口\n\n\nctrl + w ,再按 h 切换到左侧\n切换到左边的窗口",
    "crumbs": [
      "vim"
    ]
  },
  {
    "objectID": "docs/developer/vim.html#ipad-esc-键怎么按",
    "href": "docs/developer/vim.html#ipad-esc-键怎么按",
    "title": "vim",
    "section": "3 ipad esc 键怎么按",
    "text": "3 ipad esc 键怎么按\n\n没有 这个键， 用 ctrl+[ 或 cmd+.来代替 ESC键\n或者在 设置中 通用-&gt;键盘-&gt;实体键盘-&gt;修饰键 改大写锁定键=&gt;ESC",
    "crumbs": [
      "vim"
    ]
  },
  {
    "objectID": "docs/developer/vim.html#nerdtree",
    "href": "docs/developer/vim.html#nerdtree",
    "title": "vim",
    "section": "4 nerdtree",
    "text": "4 nerdtree\n\n窗口切换快捷键\n\nctrl + w ,再按 h 切换到左侧\nctrl + w ,再按 l 切换到右侧\nctrl + w ,再按 w 自动切换到另外一边\n\n窗口设置大小\n\n\n\nvimrc中添加\n\n# 设置左侧拦宽度\nlet g:NERDTreeWinSize = 20",
    "crumbs": [
      "vim"
    ]
  },
  {
    "objectID": "docs/developer/vim.html#直接运行bash命令",
    "href": "docs/developer/vim.html#直接运行bash命令",
    "title": "vim",
    "section": "5 直接运行bash命令",
    "text": "5 直接运行bash命令\n:!command\n比如\n:!ls -l",
    "crumbs": [
      "vim"
    ]
  },
  {
    "objectID": "docs/developer/vim.html#vim修改二进制文件",
    "href": "docs/developer/vim.html#vim修改二进制文件",
    "title": "vim",
    "section": "6 vim修改二进制文件",
    "text": "6 vim修改二进制文件\n vim -b test.bin\n# 输入下面执行, 然后才去修改文件\n:%!xxd\n# 修改完毕后\n:%!xxd -r\n:wq",
    "crumbs": [
      "vim"
    ]
  },
  {
    "objectID": "docs/developer/weird.html",
    "href": "docs/developer/weird.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "!!! note 比如你要输入3的平方\n先输入3 然后 按下 ++ctrl+command+space++ 然后你可以输入2这个数字,再选择上标的那个形式即可"
  },
  {
    "objectID": "docs/developer/weird.html#mac上打出平方打出上标",
    "href": "docs/developer/weird.html#mac上打出平方打出上标",
    "title": "斯巴拉稀",
    "section": "",
    "text": "!!! note 比如你要输入3的平方\n先输入3 然后 按下 ++ctrl+command+space++ 然后你可以输入2这个数字,再选择上标的那个形式即可"
  },
  {
    "objectID": "docs/developer/weird.html#使用命令查看wifi密码",
    "href": "docs/developer/weird.html#使用命令查看wifi密码",
    "title": "斯巴拉稀",
    "section": "2 使用命令查看wifi密码",
    "text": "2 使用命令查看wifi密码\n=== “windows” batch     #key=clear 表示显示密码     netsh wlan show profile     netsh wlan show profile name=\"wifi的名称\" key=clear === “linux” bash     cd /etc/NetworkManager/system_connections     ls ## 查看文件md5 sha256 === “windows” batch     certutil -hashfile filename MD5     certutil -hashfile filename SHA1     certutil -hashfile filename SHA256 === “linux” bash     openssl dgst  -sha256 filename     openssl dgst  -sha1 filename     openssl dgst  -md5 filename     # 下面的更方便     md5 filename     sha1sum filename     sha256sum filename"
  },
  {
    "objectID": "docs/developer/tcpdump.html",
    "href": "docs/developer/tcpdump.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "Caution\n\n\n\ntodo…"
  },
  {
    "objectID": "docs/developer/tcpdump.html#tcpxtract",
    "href": "docs/developer/tcpdump.html#tcpxtract",
    "title": "斯巴拉稀",
    "section": "1 tcpxtract",
    "text": "1 tcpxtract\ntcpxtract (sourceforge.net)\napt-get install tcpxtract\nyum install tcpxtract\n\n# 只有这个pcap里是传输文件的时候才会显示东西. 或者导出文件到本地\ntcpxtract -f xx.pcap"
  },
  {
    "objectID": "docs/developer/tcpdump.html#wiresharktshark-抓包分析",
    "href": "docs/developer/tcpdump.html#wiresharktshark-抓包分析",
    "title": "斯巴拉稀",
    "section": "2 wireshark(tshark) 抓包分析",
    "text": "2 wireshark(tshark) 抓包分析\n安装wireshark 后 无需安装它的gui ,就能使用tshark 命令行工具, 之前一直用以为命令是wireshark ,实际不是\nyum install wireshark\ntshark -r xxx.pcap\n\n#-s 512 :只抓取前512个字节数据\n#-i eth0 :监听eth0网卡\n#-n :禁止域名解析\n#-f ‘tcp dst port 3306’ :只捕捉协议为tcp,目的端口为3306的数据包\n#-R ‘mysql.query’ :过滤出mysql.query查询语句的报文\n#-T fields -e mysql.query :打印mysql查询语句\ntshark -s 512 -i eth1 -n -f 'tcp dst port 3306' -R 'mysql.query' -T fields -e mysql.query\n# 在服务器上, 运行, host表示 来访问服务器的 客户端的ip,我们要过滤出这样的数据\n# 这个也是可以在客户端上用, 会抓取到 你客户端访问 目标9999 端口的 数据的\ntcpdump -XX -e -vvv -S -n -i eno1  host 172.16.1.14 and tcp port   9999 -w aaaa.pcap"
  },
  {
    "objectID": "docs/developer/plantuml.html",
    "href": "docs/developer/plantuml.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "plantuml-mindmap\nplantuml title=\"通用模板\" @startmindmap &lt;style&gt; ' 通用设置 node {     Padding 12     Margin 10     HorizontalAlignment center     LineColor black     LineThickness 1.0     BackgroundColor #eab8de     RoundCorner 15     ' 自动换行, 每行最大长度     MaximumWidth 100     Shadowing 6.0     ' leafNode的优先级更高'     :depth(3) {         BackGroundColor white     } } ' 在外层也可以 好像只影响node 的样式 :depth(3) {     BackGroundColor white } rootNode {     ' LineStyle 8.0;3.0     RoundCorner 15     Padding 12     BackgroundColor #a8eb99 } leafNode {     LineColor gold     RoundCorner 15     ' Padding 12     LineColor black     Shadowing 4.0     BackgroundColor #fbe972 } arrow {     LineStyle 5     LineThickness 1.0     LineColor green     ' 可设置 层级的 箭头样式     :depth(1) {       LineColor red     } } ' ***_ 无框框的节点的样式 boxless {     FontColor darkgreen } legend{     LineStyle 4     RoundCorner 1     BackGroundColor #f3fbec     LineColor #f3fbec     Padding 10     FontColor grey } ' 配置一个class(当成class) 这样可以修改某个node的样式 ' 然后在 node 后面的 ; 后面 使用 &lt;&lt;rose&gt;&gt; 即可 .rose {     BackgroundColor #FFBBCC     RoundCorner 1 } ' 影响该节点以及它的所有子孙节点 .LightCyan *{     BackgroundColor LightCyan } .lightyellow *{     BackgroundColor  LightYellow     ' 可以使用这种方式来 调颜色, 对应还有 darken'     ' BackgroundColor %lighten(LightYellow, 1) } .yellow *{     BackgroundColor #fbe972     ' 再设置它自己的各个层级的背景     ' :depth(2) {     '   BackgroundColor #89c6fa     ' }     ' :depth(3) {     '   BackgroundColor gold     ' } } .lightgreen *{     BackgroundColor  #94c644 } .gold *{     BackgroundColor gold } &lt;/style&gt; caption figure 1 title My super title * aaa ** bbb &lt;&lt;rose&gt;&gt; ***_ ccc * dd ** ee *** ff &lt;&lt;green&gt;&gt; ****: hello world; header My super header endheader center footer My super footer legend right Short endlegend @endmindmap"
  },
  {
    "objectID": "docs/developer/plantuml.html#mindmap",
    "href": "docs/developer/plantuml.html#mindmap",
    "title": "斯巴拉稀",
    "section": "",
    "text": "plantuml-mindmap\nplantuml title=\"通用模板\" @startmindmap &lt;style&gt; ' 通用设置 node {     Padding 12     Margin 10     HorizontalAlignment center     LineColor black     LineThickness 1.0     BackgroundColor #eab8de     RoundCorner 15     ' 自动换行, 每行最大长度     MaximumWidth 100     Shadowing 6.0     ' leafNode的优先级更高'     :depth(3) {         BackGroundColor white     } } ' 在外层也可以 好像只影响node 的样式 :depth(3) {     BackGroundColor white } rootNode {     ' LineStyle 8.0;3.0     RoundCorner 15     Padding 12     BackgroundColor #a8eb99 } leafNode {     LineColor gold     RoundCorner 15     ' Padding 12     LineColor black     Shadowing 4.0     BackgroundColor #fbe972 } arrow {     LineStyle 5     LineThickness 1.0     LineColor green     ' 可设置 层级的 箭头样式     :depth(1) {       LineColor red     } } ' ***_ 无框框的节点的样式 boxless {     FontColor darkgreen } legend{     LineStyle 4     RoundCorner 1     BackGroundColor #f3fbec     LineColor #f3fbec     Padding 10     FontColor grey } ' 配置一个class(当成class) 这样可以修改某个node的样式 ' 然后在 node 后面的 ; 后面 使用 &lt;&lt;rose&gt;&gt; 即可 .rose {     BackgroundColor #FFBBCC     RoundCorner 1 } ' 影响该节点以及它的所有子孙节点 .LightCyan *{     BackgroundColor LightCyan } .lightyellow *{     BackgroundColor  LightYellow     ' 可以使用这种方式来 调颜色, 对应还有 darken'     ' BackgroundColor %lighten(LightYellow, 1) } .yellow *{     BackgroundColor #fbe972     ' 再设置它自己的各个层级的背景     ' :depth(2) {     '   BackgroundColor #89c6fa     ' }     ' :depth(3) {     '   BackgroundColor gold     ' } } .lightgreen *{     BackgroundColor  #94c644 } .gold *{     BackgroundColor gold } &lt;/style&gt; caption figure 1 title My super title * aaa ** bbb &lt;&lt;rose&gt;&gt; ***_ ccc * dd ** ee *** ff &lt;&lt;green&gt;&gt; ****: hello world; header My super header endheader center footer My super footer legend right Short endlegend @endmindmap"
  },
  {
    "objectID": "docs/developer/plantuml.html#color",
    "href": "docs/developer/plantuml.html#color",
    "title": "斯巴拉稀",
    "section": "2 color",
    "text": "2 color\n@startuml\ncolors\n@enduml"
  },
  {
    "objectID": "docs/developer/git/principle.html",
    "href": "docs/developer/git/principle.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "Back to top"
  },
  {
    "objectID": "docs/developer/ssh.html",
    "href": "docs/developer/ssh.html",
    "title": "ssh",
    "section": "",
    "text": "#本地 执行 ,生成密钥对\nssh-keygen\n\n# 将公钥上传至远程服务器, 这个命令需要能用密码远程登录..\n# -i 指定公钥路径\nssh-copy-id  -i ~/.ssh/id_rsa.pub  remote_user@remote_ip -p22\n# 执行完后,实际会将该公钥内容 放到远程服务端上的 ~/.ssh/authorized_keys 里,\n# 你可以手动将本机的公钥内容复制到这个文件里\n# 注意如果是手动修改, 请确保文件权限最后是600\nchmod 600 ~/.ssh/authorized_keys\n#-rw------- 1 root root  393 Oct 11 22:48 authorized_keys",
    "crumbs": [
      "ssh"
    ]
  },
  {
    "objectID": "docs/developer/ssh.html#密钥生成与上传",
    "href": "docs/developer/ssh.html#密钥生成与上传",
    "title": "ssh",
    "section": "",
    "text": "#本地 执行 ,生成密钥对\nssh-keygen\n\n# 将公钥上传至远程服务器, 这个命令需要能用密码远程登录..\n# -i 指定公钥路径\nssh-copy-id  -i ~/.ssh/id_rsa.pub  remote_user@remote_ip -p22\n# 执行完后,实际会将该公钥内容 放到远程服务端上的 ~/.ssh/authorized_keys 里,\n# 你可以手动将本机的公钥内容复制到这个文件里\n# 注意如果是手动修改, 请确保文件权限最后是600\nchmod 600 ~/.ssh/authorized_keys\n#-rw------- 1 root root  393 Oct 11 22:48 authorized_keys",
    "crumbs": [
      "ssh"
    ]
  },
  {
    "objectID": "docs/developer/ssh.html#ssh快捷连接服务器",
    "href": "docs/developer/ssh.html#ssh快捷连接服务器",
    "title": "ssh",
    "section": "2 ssh快捷连接服务器",
    "text": "2 ssh快捷连接服务器\n\n\n~/.ssh/config配置文件添加\n\nHost dev\n  HostName 192.168.1.100\n  Port 22\n  User root\n  IdentityFile ~/.ssh/id_rsa\n\n\n\n简单的命令就连接服务器\n\nssh dev",
    "crumbs": [
      "ssh"
    ]
  },
  {
    "objectID": "docs/developer/ssh.html#多个github账号如何连接",
    "href": "docs/developer/ssh.html#多个github账号如何连接",
    "title": "ssh",
    "section": "3 多个github账号如何连接",
    "text": "3 多个github账号如何连接\n\n\n\n\n\n\nNote\n\n\n\n其实和上面是一样的, 不同的github账号在github上不能使用同一个公钥,而你又需要在一个机器上提交东西到不同的github账号的仓库\n\n\n# 如果不带 -f 指定文件名 ,那么回车,需要填入一个名称,否则文件名都是id_rsa ,会导致覆盖原有的 id_rsa\nssh-keygen -t rsa -C \"注释信息,你可以写你的邮箱等\" -f \"文件名\"\n\n\n~/.ssh/config配置文件添加\n\nHost gh1\n  HostName github.com\n  Port 22\n  User root\n  IdentityFile ~/.ssh/gh1.id_rsa  # 生成的私钥1\n\nHost gh2\n  HostName github.com\n  Port 22\n  User root\n  IdentityFile ~/.ssh/gh2.id_rsa #生成的私钥2\n\n# 需要将 根据你的仓库地址,将github.com 改成gh1或gh2\ngit clone git@github.com:tom/abc.git\n#==&gt; 这样就会区gh1配置里使用的密钥对,去对应的github帐号clone\ngit clone git@gh1:tom/abc.git",
    "crumbs": [
      "ssh"
    ]
  },
  {
    "objectID": "docs/developer/ssh.html#通过ssh隧道-连接mysql",
    "href": "docs/developer/ssh.html#通过ssh隧道-连接mysql",
    "title": "ssh",
    "section": "4 通过ssh隧道 连接mysql",
    "text": "4 通过ssh隧道 连接mysql\n\n\n\n\n\n\n服务器说明\n\n\n\n\n远程服务器A, 这个你可以ssh连接的\nmysql服务器, 你无法外部访问, 服务器A可以访问mysql服务器\n你想要在本地连接这个mysql, 比如用navicat直接看,怎么办呢?\n\n\n\nnavicat 本身可以设置ssh隧道. 这里我用本地映射的方式\n# -f 必须带上, 表示转到后台\n# 将远程的mysql端口映射到本地的3307,这样本地就可以直接连了\nssh -fN -L3307:remotemysqlip:3306 A服务器用户名@A的ip\nlsof -i:3307 # 查看",
    "crumbs": [
      "ssh"
    ]
  },
  {
    "objectID": "docs/developer/ssh.html#通过堡垒机连接内部服务器",
    "href": "docs/developer/ssh.html#通过堡垒机连接内部服务器",
    "title": "ssh",
    "section": "5 通过堡垒机连接内部服务器",
    "text": "5 通过堡垒机连接内部服务器\n\n\n\n\n\n\nNote\n\n\n\n一般情况下, 你需要登录网页,输入密码, 然后选择你要连接的服务器 很麻烦. 这里设置 直接本地 ssh dev 即可连接 (如果需要vpn的, 那么vpn得先连上)\n\n\n\n\n配置~/.ssh/config文件 增加\n\nHost baolei\n    HostName 堡垒机ip\n    User 堡垒机账户\n    Port 连接堡垒机的端口\n    IdentityFile ~/.ssh/id_rsa  # 上传给堡垒机公钥对应的私钥\nHost dev\n    HostName 堡垒机可以连接的内部服务器ip\n    User 堡垒机连接内部服务器的用户\n    Port 堡垒机连接内部服务器使用的端口\n    #这个不需要设置 堡垒机估计已经设置 ssh 直接访问 dev服务器. 所以不用\n    #IdentityFile ~/.ssh/id_rsa\n    ProxyCommand ssh 堡垒机账户@baolei -W %h:%p",
    "crumbs": [
      "ssh"
    ]
  },
  {
    "objectID": "docs/devops/docker/union-fs.html",
    "href": "docs/devops/docker/union-fs.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "Back to top",
    "crumbs": [
      "底层原理(todo...)",
      "union fs"
    ]
  },
  {
    "objectID": "docs/devops/docker/cgroup.html",
    "href": "docs/devops/docker/cgroup.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "Back to top",
    "crumbs": [
      "底层原理(todo...)",
      "cgroup"
    ]
  },
  {
    "objectID": "docs/devops/docker/network.html",
    "href": "docs/devops/docker/network.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "Back to top",
    "crumbs": [
      "底层原理(todo...)",
      "network"
    ]
  },
  {
    "objectID": "docs/devops/docker/ip.html",
    "href": "docs/devops/docker/ip.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "0.1 启动容器\ndocker run -itd --name nginx -p 80:80 nginx\n\n\n0.2 打开iptables调试功能\n通过调试可以看 iptables 几个表 (raw mangle nat filter ) 的顺序,谁先谁后, 可以自己测试一下.\nmodprobe ipt_LOG #centos6\nmodprobe nf_log_ipv4 #centos7\n# 查看\nsysctl net.netfilter.nf_log.2\n   #centos 7\n     net.netfilter.nf_log.2 = nf_log_ipv4\n# raw 表 添加规则, 打开调试. \niptables -t raw -A PREROUTING -p tcp --dport 80 -j TRACE \niptables -t raw -A OUTPUT -p tcp --dport 80 -j TRACE\niptables -t raw -nL\n\n\n0.3 查看 NAT 表\niptables -t nat -nvL --line-numbers\n\n\n\n\n\n\n查看执行结果\n\n\n\n\n\nChain PREROUTING (policy ACCEPT 0 packets, 0 bytes)\nnum   pkts bytes target     prot opt in     out     source               destination\n1        0     0 DOCKER     all  --  *      *       0.0.0.0/0            0.0.0.0/0            ADDRTYPE match dst-type LOCAL\n\nChain INPUT (policy ACCEPT 0 packets, 0 bytes)\nnum   pkts bytes target     prot opt in     out     source               destination\n\nChain OUTPUT (policy ACCEPT 12 packets, 883 bytes)\nnum   pkts bytes target     prot opt in     out     source               destination\n1        0     0 DOCKER     all  --  *      *       0.0.0.0/0           !127.0.0.0/8          ADDRTYPE match dst-type LOCAL\n\nChain POSTROUTING (policy ACCEPT 12 packets, 883 bytes)\nnum   pkts bytes target     prot opt in     out     source               destination\n1        0     0 MASQUERADE  all  --  *      !docker0  172.17.0.0/16        0.0.0.0/0\n2        0     0 MASQUERADE  tcp  --  *      *       172.17.0.2           172.17.0.2           tcp dpt:80\n\nChain DOCKER (2 references)\nnum   pkts bytes target     prot opt in     out     source               destination\n1        0     0 RETURN     all  --  docker0 *       0.0.0.0/0            0.0.0.0/0\n2        0     0 DNAT       tcp  --  !docker0 *       0.0.0.0/0            0.0.0.0/0            tcp dpt:80 to:172.17.0.2:80\n\n\n\n\n\n0.4 查看 filter 表\niptables -t filter -nvL --line-numbers\n\n\n\n\n\n\n查看执行结果\n\n\n\n\n\nChain INPUT (policy ACCEPT 523 packets, 31567 bytes)\nnum   pkts bytes target     prot opt in     out     source               destination\n\nChain FORWARD (policy ACCEPT 0 packets, 0 bytes)\nnum   pkts bytes target     prot opt in     out     source               destination\n1       40  7071 DOCKER-USER  all  --  *      *       0.0.0.0/0            0.0.0.0/0\n2       40  7071 DOCKER-ISOLATION-STAGE-1  all  --  *      *       0.0.0.0/0            0.0.0.0/0\n3       15   833 ACCEPT     all  --  *      docker0  0.0.0.0/0            0.0.0.0/0            ctstate RELATED,ESTABLISHED\n4        3   156 DOCKER     all  --  *      docker0  0.0.0.0/0            0.0.0.0/0\n5       22  6082 ACCEPT     all  --  docker0 !docker0  0.0.0.0/0            0.0.0.0/0\n6        0     0 ACCEPT     all  --  docker0 docker0  0.0.0.0/0            0.0.0.0/0\n\nChain OUTPUT (policy ACCEPT 274 packets, 92208 bytes)\nnum   pkts bytes target     prot opt in     out     source               destination\n\nChain DOCKER (1 references)\nnum   pkts bytes target     prot opt in     out     source               destination\n1        3   156 ACCEPT     tcp  --  !docker0 docker0  0.0.0.0/0            172.17.0.2           tcp dpt:80\n\nChain DOCKER-ISOLATION-STAGE-1 (1 references)\nnum   pkts bytes target     prot opt in     out     source               destination\n1       22  6082 DOCKER-ISOLATION-STAGE-2  all  --  docker0 !docker0  0.0.0.0/0            0.0.0.0/0\n2       40  7071 RETURN     all  --  *      *       0.0.0.0/0            0.0.0.0/0\n\nChain DOCKER-ISOLATION-STAGE-2 (1 references)\nnum   pkts bytes target     prot opt in     out     source               destination\n1        0     0 DROP       all  --  *      docker0  0.0.0.0/0            0.0.0.0/0\n2       22  6082 RETURN     all  --  *      *       0.0.0.0/0            0.0.0.0/0\n\nChain DOCKER-USER (1 references)\nnum   pkts bytes target     prot opt in     out     source               destination\n1       40  7071 RETURN     all  --  *      *       0.0.0.0/0            0.0.0.0/\n\n\n\n\n\n0.5 watch 日志\n\ntail -f /var/log/kern.log\n# 或 ?\ntail -f /var/log/messages\n#或 ?\ndmesg --follow\n\n\n0.6 外部浏览器访问 nginx\n上面我的操作我是在虚拟机里的.\n\n\n0.7 观察日志\n流量进来先走 nat:PREROUTING -&gt; 如果有转发就走filter:FORWARD-&gt;nat:POSTROUTING\n\n\n\n\n\n\n查看执行结果\n\n\n\n\n\nTRACE: raw:PREROUTING:policy:2 IN=eth0 OUT=\n# nat:PREROUTING:rule:1 找 nat:PREROUTING 第一条规则, target 是 DOCKER\nTRACE: nat:PREROUTING:rule:1 IN=eth0 OUT=\n#  nat:DOCKER: 的第一条规则 in 不匹配, 所以 继续下一条规则. 第2条匹配了.\nTRACE: nat:DOCKER:rule:2 IN=eth0 OUT=\n# 走filter 的 forward(因为前面的规则里nat:DOCKER:rule:2  再根据路由)\n# 跳转到 DOCKER-USER\nTRACE: filter:FORWARD:rule:1 IN=eth0 OUT=docker0 \n# 跳这DOCKER-USER 第一条. 是个return (return的意思是,结束子chains,返回到原来的chains 继续它的下一条)\n# 可以理解为 main函数里 调用了 A 函数, A函数里面return了. 你到了main ,执行 A函数后面的语句.\nTRACE: filter:DOCKER-USER:return:1 IN=eth0 OUT=docker0\n# 回到forward的第二条 发现是跳 DOCKER-ISOLATION-STAGE-1\nTRACE: filter:FORWARD:rule:2 IN=eth0 OUT=docker0\n# DOCKER-ISOLATION-STAGE-1的第一条 没有符合规则, 继续第二条看是否匹配, 匹配了.\n# 第二条是个return \nTRACE: filter:DOCKER-ISOLATION-STAGE-1:return:2 IN=eth0 OUT=docker0\n# 继续回到forward.  (看第3条规则没匹配,因为是还没有建立连接)\nTRACE: filter:FORWARD:rule:4 IN=eth0 OUT=docker0\n# accept 了..\nTRACE: filter:DOCKER:rule:1 IN=eth0 OUT=docker0\nTRACE: nat:POSTROUTING:policy:3 IN= OUT=docker0\n# 后续\nTRACE: filter:FORWARD:rule:1 IN=eth0 OUT=docker0\nTRACE: filter:DOCKER-USER:return:1 IN=eth0 OUT=docker0\nTRACE: filter:FORWARD:rule:2 IN=eth0 OUT=docker0\nTRACE: filter:DOCKER-ISOLATION-STAGE-1:return:2 IN=eth0 OUT=docker0\n# 看 这个时候匹配上了. 因为已经建立连接了.\nTRACE: filter:FORWARD:rule:3 IN=eth0 OUT=docker0\n\n\n\n\n\n\n\n Back to top",
    "crumbs": [
      "基础",
      "流量走向分析"
    ]
  },
  {
    "objectID": "docs/devops/docker/podman.html",
    "href": "docs/devops/docker/podman.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "podman machine init\n# podman machine set --rootful --storage-path /data/podman\npodman machine list\n\npodman system connection list\n\npodman machine start\npodman machine ssh # ssh到 podman 虚拟机\n# podman 默认是用的qemu 来创建虚拟机的\n/usr/local/bin/qemu-system-x86_64  --version\n\npodman machine stop\npodman machine rm podman-machine-default\n\npodman ps # 许多命令同docker, 略\n\n# 也是用 docker-compose.yaml 就可以\npodman compose up -d\npodman compose stop\npodman compose start\npodman run -it --rm --name alpine-podman alpine",
    "crumbs": [
      "基础",
      "podman"
    ]
  },
  {
    "objectID": "docs/devops/docker/podman.html#常用命令",
    "href": "docs/devops/docker/podman.html#常用命令",
    "title": "斯巴拉稀",
    "section": "",
    "text": "podman machine init\n# podman machine set --rootful --storage-path /data/podman\npodman machine list\n\npodman system connection list\n\npodman machine start\npodman machine ssh # ssh到 podman 虚拟机\n# podman 默认是用的qemu 来创建虚拟机的\n/usr/local/bin/qemu-system-x86_64  --version\n\npodman machine stop\npodman machine rm podman-machine-default\n\npodman ps # 许多命令同docker, 略\n\n# 也是用 docker-compose.yaml 就可以\npodman compose up -d\npodman compose stop\npodman compose start\npodman run -it --rm --name alpine-podman alpine",
    "crumbs": [
      "基础",
      "podman"
    ]
  },
  {
    "objectID": "docs/devops/docker/podman.html#配置",
    "href": "docs/devops/docker/podman.html#配置",
    "title": "斯巴拉稀",
    "section": "2 配置",
    "text": "2 配置\n\n\n设置国内源  ~/.config/containers/registries.conf\n\nunqualified-search-registries = [\"docker.io\"]\n\n[[registry]]\nprefix = \"docker.io\"\nlocation = \"registry.docker-cn.com\"\n\n[[registry.mirror]]\nlocation = \"hub-mirror.c.163.com\"\n[[registry.mirror]]\nlocation = \"docker.m.daocloud.io\"\n[[registry.mirror]]\nlocation = \"mirror.baidubce.com\"\n[[registry.mirror]]\nlocation = \"docker.nju.edu.cn\"\n[[registry.mirror]]\nlocation = \"hub-mirror.c.163.com\"",
    "crumbs": [
      "基础",
      "podman"
    ]
  },
  {
    "objectID": "docs/devops/k8s/ecosystem/istio/index.html",
    "href": "docs/devops/k8s/ecosystem/istio/index.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "Back to top"
  },
  {
    "objectID": "docs/devops/k8s/basics/architecture.html",
    "href": "docs/devops/k8s/basics/architecture.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "Back to top",
    "crumbs": [
      "基础",
      "架构总览"
    ]
  },
  {
    "objectID": "docs/devops/k8s/develop/client-go/client-go.html",
    "href": "docs/devops/k8s/develop/client-go/client-go.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "# go 代码中\ngo mod init go-k8s-namespace\n# 添加指定版本\ngo get k8s.io/client-go@v0.23.17\ngo get k8s.io/api@v0.23.17\ngo get k8s.io/apimachinery@v0.23.17\n\n# 找到client-go的例子, 这里我们用out-of-cluster,因为我是在自己的主机上连接虚拟机里的k8s集群\nclient-go/examples/out-of-cluster-client-configuration",
    "crumbs": [
      "二次开发",
      "client-go",
      "client-go"
    ]
  },
  {
    "objectID": "docs/devops/k8s/develop/client-go/client-go.html#准备",
    "href": "docs/devops/k8s/develop/client-go/client-go.html#准备",
    "title": "斯巴拉稀",
    "section": "",
    "text": "# go 代码中\ngo mod init go-k8s-namespace\n# 添加指定版本\ngo get k8s.io/client-go@v0.23.17\ngo get k8s.io/api@v0.23.17\ngo get k8s.io/apimachinery@v0.23.17\n\n# 找到client-go的例子, 这里我们用out-of-cluster,因为我是在自己的主机上连接虚拟机里的k8s集群\nclient-go/examples/out-of-cluster-client-configuration",
    "crumbs": [
      "二次开发",
      "client-go",
      "client-go"
    ]
  },
  {
    "objectID": "docs/devops/k8s/develop/client-go/client-go.html#样例",
    "href": "docs/devops/k8s/develop/client-go/client-go.html#样例",
    "title": "斯巴拉稀",
    "section": "2 样例",
    "text": "2 样例\npackage main\n\nimport (\n    \"context\"\n    \"flag\"\n    \"fmt\"\n    \"path/filepath\"\n\n    // corev1 \"k8s.io/api/core/v1\"\n\n    // corev1 \"k8s.io/api/core/v1\"\n\n    \"k8s.io/apimachinery/pkg/api/errors\"\n    metav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n    \"k8s.io/client-go/kubernetes\"\n    \"k8s.io/client-go/tools/clientcmd\"\n    \"k8s.io/client-go/util/homedir\"\n    // storagev1 \"k8s.io/api/storage/v1\"\n    // storagev1 \"k8s.io/api/storage/v1\"\n    // storagev1 \"k8s.io/api/storage/v1\"\n    //\n    // Uncomment to load all auth plugins\n    // _ \"k8s.io/client-go/plugin/pkg/client/auth\"\n    //\n    // Or uncomment to load specific auth plugins\n    // _ \"k8s.io/client-go/plugin/pkg/client/auth/azure\"\n    // _ \"k8s.io/client-go/plugin/pkg/client/auth/gcp\"\n    // _ \"k8s.io/client-go/plugin/pkg/client/auth/oidc\"\n    // _ \"k8s.io/client-go/plugin/pkg/client/auth/openstack\"\n)\n\nfunc main() {\n    var kubeconfig *string\n    if home := homedir.HomeDir(); home != \"\" {\n        // ~/.kube/config 确保你家目录下有k8s的配置文件\n        // 你本地可以用kubectl get po 进行查询.\n        kubeconfig = flag.String(\"kubeconfig\", filepath.Join(home, \".kube\", \"config\"), \"(optional) absolute path to the kubeconfig file\")\n    } else {\n        kubeconfig = flag.String(\"kubeconfig\", \"\", \"absolute path to the kubeconfig file\")\n    }\n    flag.Parse()\n\n    // 使用指定的kubeconfig文件创建一个Config对象\n    config, err := clientcmd.BuildConfigFromFlags(\"\", *kubeconfig)\n    if err != nil {\n        panic(err.Error())\n    }\n\n    // 创建一个新的Kubernetes客户端\n    clientset, err := kubernetes.NewForConfig(config)\n    if err != nil {\n        panic(err.Error())\n    }\n\n    // k get po -A\n    pods, err := clientset.\n        CoreV1().\n        Pods(\"\"). // Pods(namespace) \"\" 表示所有命名空间\n        List(context.TODO(), metav1.ListOptions{})\n    if err != nil {\n        panic(err.Error())\n    }\n    fmt.Printf(\"There are %d pods in the cluster\\n\", len(pods.Items))\n\n    // 错误处理\n    namespace := \"default\"\n    podName := \"pod-vol-empty-dir\"\n    pod, err := clientset.\n        CoreV1().\n        Pods(namespace). // 传递命名空间\n        Get(context.TODO(), podName, metav1.GetOptions{})\n\n    if errors.IsNotFound(err) { // 使用k8s apimachinery的errors包 ,这里表示 没有找到 这个pod\n        fmt.Printf(\"Pod %s in namespace %s not found\\n\", podName, namespace)\n    } else if statusError, isStatus := err.(*errors.StatusError); isStatus {\n        fmt.Printf(\"Error getting pod %s in namespace %s: %v\\n\",\n            podName, namespace, statusError.ErrStatus.Message)\n    } else if err != nil {\n        panic(err.Error())\n    } else {\n        fmt.Printf(\"Found pod %s in namespace %s\\n\", podName, namespace)\n        fmt.Println(pod.TypeMeta)\n        fmt.Println(pod.ObjectMeta.Name)\n        fmt.Println(pod.Spec.NodeName)\n        fmt.Println(pod.Status.PodIP)\n    }\n\n}",
    "crumbs": [
      "二次开发",
      "client-go",
      "client-go"
    ]
  },
  {
    "objectID": "docs/devops/k8s/develop/client-go/client-go.html#pod",
    "href": "docs/devops/k8s/develop/client-go/client-go.html#pod",
    "title": "斯巴拉稀",
    "section": "3 pod",
    "text": "3 pod\n\nlistcreateupdatepatchdeletewatch\n\n\npods, err := clientset.\n    CoreV1().\n    Pods(\"\"). // Pods(namespace) \"\" 表示所有命名空间\n    List(context.TODO(), metav1.ListOptions{})\nfmt.Printf(\"There are %d pods in the cluster\\n\", len(pods.Items))\n\n\n使用ResourceVersion\n\npods, err := clientset.\n    CoreV1().\n    Pods(\"default\").\n    List(context.TODO(),\n        metav1.ListOptions{\n            ResourceVersion: \"2802779\",\n            // 注意使用limit 和去掉的效果\n            Limit:           50,\n        })\nif err != nil {\n    panic(err.Error())\n}\nfor _, item := range pods.Items {\n    fmt.Println(item.Labels)\n}\n\n配合文档 resourceVersion #### detail\nnamespace := \"default\"\npodName := \"pod-vol-empty-dir\"\npod, err := clientset.\n    CoreV1().\n    Pods(namespace). // 传递命名空间\n    Get(context.TODO(), podName, metav1.GetOptions{})\nfmt.Println(pod.TypeMeta)\nfmt.Println(pod.ObjectMeta.Name)\nfmt.Println(pod.Spec.NodeName)\nfmt.Println(pod.Status.PodIP)\n\n\n\n\n\n\n\n\nTip\n\n\n\n可是在创建的使用先用DryRun ,看是否有错误. 实际工作中, 先判断是否有这个pod等等.\n\n\nimport (\n    corev1 \"k8s.io/api/core/v1\"\n)\n//.....\n// 创建一个Pod对象\npod1 := &corev1.Pod{\n    ObjectMeta: metav1.ObjectMeta{\n        Name:      \"my-pod\",\n        Namespace: \"default\",\n    },\n    Spec: corev1.PodSpec{\n        Containers: []corev1.Container{\n            {\n                Name:  \"my-container\",\n                Image: \"nginx:1.14.2\",\n                // Lifecycle: &corev1.Lifecycle{\n                //     PreStop: &corev1.LifecycleHandler{\n                //         Exec: &corev1.ExecAction{\n                //             Command: []string{\n                //                 \"/bin/sh\",\n                //                 \"-c\",\n                //                 \"sleep 20\",\n                //             },\n                //         },\n                //     },\n                // },\n            },\n        },\n    },\n}\n\n// 使用客户端创建Pod\ncreatedPod, err := clientset.\n    CoreV1().\n    Pods(\"default\").\n    Create(context.TODO(),\n        pod1,\n        metav1.CreateOptions{\n            DryRun: []string{metav1.DryRunAll}, // 相当于命令行执行 带上--dry-run=client\n        })\nif err != nil {\n    log.Fatal(err)\n}\n\nfmt.Printf(\"Created Pod: %s\\n\", createdPod.Name)\n\n\n\n\n\n\n\n\nWarning\n\n\n\nupdate操作只能更新一些属性, 你提交了很多属性要修改, 会报错. 可以先删除,再创建\n\n\npod1 := &corev1.Pod{\n    ObjectMeta: metav1.ObjectMeta{\n        Name:      \"my-pod\",\n        Namespace: \"default\",\n    },\n    Spec: corev1.PodSpec{\n        Containers: []corev1.Container{\n            {\n                Name:  \"my-container\",\n                Image: \"nginx:1.14.2\",\n                Lifecycle: &corev1.Lifecycle{\n                    PreStop: &corev1.LifecycleHandler{\n                        Exec: &corev1.ExecAction{\n                            Command: []string{\n                                \"/bin/sh\",\n                                \"-c\",\n                                \"sleep 20\",\n                            },\n                        },\n                    },\n                },\n            },\n        },\n    },\n}\n\n_, err = clientset.CoreV1().Pods(\"default\").Update(\n        context.TODO(),\n        pod1,\n        metav1.UpdateOptions{})\nif err != nil {\n    //pod updates may not change fields other than `spec.containers[*].image`, `spec.initContainers[*].image`, `spec.activeDeadlineSeconds`, `spec.tolerations` (only additions to existing tolerations) or `spec.terminationGracePeriodSeconds` (allow it to be set to 1 if it was previously negative)\n    log.Fatal(err) \n}\n\n\n\n\n\n\n\n\n几种类型的区别\n\n\n\ntodo\n\n\n\n\nStrategicMergePatchType\n\npatchBytes := []byte(`{\"metadata\":{\"labels\":{\"app\":\"nginx2\",\"run\":\"test\"}}}`)\n// patch := make(map[string]interface{})\n// patch[\"metadata\"] = map[string]interface{}{\n//  \"labels\": map[string]interface{}{\n//      \"app\": \"nginx\",\n//      \"run\": \"test\",\n//  },\n// }\n// patchBytes, err := json.Marshal(patch)\n_, err = clientset.CoreV1().Pods(\"default\").Patch(\n    context.TODO(),\n    \"my-pod\",\n    // 属性相同 就更新, 没有的当然是增加\n    types.StrategicMergePatchType,\n    patchBytes,\n    metav1.PatchOptions{})\n\n\n\nerr = clientset.\n        CoreV1().\n        Pods(\"default\").\n        Delete(context.TODO(), \"my-pod\", metav1.DeleteOptions{})\n\n\ncurl localhost:8001/api/v1/namespaces/default/pods?watch\n看看etcd的版本监听\npackage main\n\nimport (\n    \"context\"\n    \"flag\"\n    \"fmt\"\n    \"log\"\n    \"path/filepath\"\n    \"time\"\n\n    corev1 \"k8s.io/api/core/v1\"\n    \"k8s.io/apimachinery/pkg/api/errors\"\n    metav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n    \"k8s.io/apimachinery/pkg/watch\"\n    \"k8s.io/client-go/kubernetes\"\n    \"k8s.io/client-go/tools/clientcmd\"\n    \"k8s.io/client-go/util/homedir\"\n    //\n    // Uncomment to load all auth plugins\n    // _ \"k8s.io/client-go/plugin/pkg/client/auth\"\n    //\n    // Or uncomment to load specific auth plugins\n    // _ \"k8s.io/client-go/plugin/pkg/client/auth/azure\"\n    // _ \"k8s.io/client-go/plugin/pkg/client/auth/gcp\"\n    // _ \"k8s.io/client-go/plugin/pkg/client/auth/oidc\"\n    // _ \"k8s.io/client-go/plugin/pkg/client/auth/openstack\"\n)\n\nfunc main() {\n    var kubeconfig *string\n    if home := homedir.HomeDir(); home != \"\" {\n        kubeconfig = flag.String(\"kubeconfig\", filepath.Join(home, \".kube\", \"config\"), \"(optional) absolute path to the kubeconfig file\")\n    } else {\n        kubeconfig = flag.String(\"kubeconfig\", \"\", \"absolute path to the kubeconfig file\")\n    }\n    flag.Parse()\n\n    // 使用指定的kubeconfig文件创建一个Config对象\n    config, err := clientcmd.BuildConfigFromFlags(\"\", *kubeconfig)\n    if err != nil {\n        panic(err.Error())\n    }\n\n    // 创建一个新的Kubernetes客户端\n    clientset, err := kubernetes.NewForConfig(config)\n    if err != nil {\n        panic(err.Error())\n    }\n\n    // 创建一个Pod对象\n    pod1 := &corev1.Pod{\n        ObjectMeta: metav1.ObjectMeta{\n            Name:      \"my-pod\",\n            Namespace: \"default\",\n            Labels: map[string]string{\n                \"app\": \"pod-vol\",\n                \"run\": \"test\",\n            },\n        },\n        Spec: corev1.PodSpec{\n            Containers: []corev1.Container{\n                {\n                    Name:  \"my-container\",\n                    Image: \"nginx:1.14.2\",\n                    Lifecycle: &corev1.Lifecycle{\n                        PreStop: &corev1.LifecycleHandler{\n                            Exec: &corev1.ExecAction{\n                                Command: []string{\n                                    \"/bin/sh\",\n                                    \"-c\",\n                                    \"sleep 20\",\n                                },\n                            },\n                        },\n                    },\n                },\n            },\n        },\n    }\n    // 使用客户端创建Pod\n    createdPod, err := clientset.\n        CoreV1().\n        Pods(\"default\").\n        Create(context.TODO(),\n            pod1,\n            metav1.CreateOptions{\n                // DryRun: []string{metav1.DryRunAll}, // 相当于命令行执行 带上--dry-run=client\n            })\n    if err != nil {\n        log.Fatal(err)\n    }\n    fmt.Printf(\"ok: %s\\n\", createdPod.Name)\n    // 等待一会,不急着做删除操作, 命令行 k get po 看看\n    time.Sleep(10 * time.Second)\n\n    err = clientset.\n        CoreV1().\n        Pods(\"default\").Delete(context.TODO(), \"my-pod\", metav1.DeleteOptions{\n        // DryRun: []string{metav1.DryRunAll},\n    })\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    // 该Watcher将监听指定命名空间中的所有Pod对象的事件。\n    // 如果创建Watcher成功，它将返回一个watch.Interface对象和一个错误。\n    watcher, err := clientset.CoreV1().Pods(\"default\").Watch(context.TODO(), metav1.ListOptions{\n        LabelSelector: \"app=pod-vol,run=test\",\n    })\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    started := time.Now()\nLoop:\n    for {\n        select {\n            //watcher.ResultChan() 通道将传递Watcher接收到的事件\n        case event := &lt;-watcher.ResultChan():\n            pod, ok := event.Object.(*corev1.Pod)\n            if !ok {\n                fmt.Println(\"xxxx::\", pod)\n                continue\n            }\n            // 我们获取watcher 用的是labels 选择器, 可能有不同的pod\n            // 这里可以增加判断看是不是你想要处理的那个pod\n            fmt.Println(pod.Name)\n            if pod.Name != \"my-pod\" {\n                continue\n            }\n            switch event.Type {\n            case watch.Added:\n                fmt.Printf(\"Pod added: %s\\n\", event.Object)\n                // 处理Pod添加事件\n            case watch.Modified:\n                fmt.Printf(\"Pod modified: %s\\n\", event.Object)\n                // 处理Pod修改事件\n            case watch.Deleted:\n                fmt.Printf(\"Pod deleted: %s\\n\", pod.Name)\n                // 差不多20s,因为我们容器preStop sleep 20s\n                fmt.Println(\"duration:\", time.Since(started))\n                // 处理Pod删除事件\n                // 如果想在这里 (逻辑是 看删除了, 然后创建pod) ,那么你应该在前面增加一次判断,\n                // 查询pod看是否这个pod 已经不存在了. 因为有可能你执行watch 时 ,pod 已经删除了, 那么你永远都不会走到这了.\n\n            }\n        case &lt;-time.After(60 * time.Second):\n            fmt.Println(9999)\n            break Loop\n        }\n    }\n\n    // DryRun: []string{metav1.DryRunAll}, // 相当于命令行执行 带上--dry-run=client\n\n}",
    "crumbs": [
      "二次开发",
      "client-go",
      "client-go"
    ]
  },
  {
    "objectID": "docs/devops/k8s/develop/client-go/client-go.html#namespace",
    "href": "docs/devops/k8s/develop/client-go/client-go.html#namespace",
    "title": "斯巴拉稀",
    "section": "4 namespace",
    "text": "4 namespace\nlist, err := clientset.\n    CoreV1().\n    Namespaces().\n    List(context.TODO(), metav1.ListOptions{})\nfor _, item := range list.Items {\n    fmt.Println(item.Name)\n    fmt.Println(item.CreationTimestamp)\n    fmt.Println(string(item.Status.Phase))\n}",
    "crumbs": [
      "二次开发",
      "client-go",
      "client-go"
    ]
  },
  {
    "objectID": "docs/devops/k8s/develop/client-go/client-go.html#scheduler",
    "href": "docs/devops/k8s/develop/client-go/client-go.html#scheduler",
    "title": "斯巴拉稀",
    "section": "5 scheduler",
    "text": "5 scheduler\n\nnode listnode detail设置标签删除标签设置污点\n\n\nlist, err := clientset.CoreV1().Nodes().List(context.TODO(), metav1.ListOptions{})\nif err != nil {\n    panic(err.Error())\n}\nfor _, item := range list.Items {\n    fmt.Println(item.ObjectMeta.Name)\n    fmt.Println(item.ObjectMeta.Labels)\n    fmt.Println(item.TypeMeta)\n    // fmt.Println(item.Spec.Taints)\n    for _, v := range item.Spec.Taints {\n        fmt.Println(v.Key, \"=\", v.Value, \":\", v.Effect)\n    }\n    // node 状态\n    for _, v := range item.Status.Conditions {\n        fmt.Println(v.Type, v.Status, v.Reason)\n    }\n}\n\n\ndetail, err := clientset.CoreV1().Nodes().Get(context.TODO(), \"node1\", metav1.GetOptions{})\nif err != nil {\n    panic(err.Error())\n}\nfmt.Println(detail.ObjectMeta.Name)\nfmt.Println(detail.ObjectMeta.Labels)\nfmt.Println(detail.TypeMeta)\nfor _, v := range detail.Spec.Taints {\n    fmt.Println(v.Key, \"=\", v.Value, \":\", v.Effect)\n}\nfor _, v := range detail.Status.Conditions {\n    fmt.Println(v.Type, v.Status, v.Reason)\n}\n\n\n\n\n\n\n\n\nTip\n\n\n\n可以先获取node的label 然后有update的方式来更新.\n\n\npatchData := []byte(`{\"metadata\":{\"labels\":{\"app\":\"test\"}}}`)\n\n// 执行Patch操作, 有则更新, 无则添加\n_, err := clientset.\n    CoreV1().\n    Nodes().\n    Patch(context.TODO(), \"node1\", types.MergePatchType, patchData, metav1.PatchOptions{})\nif err != nil {\n    panic(err.Error())\n}\n\n\n// null 没有引号, 当然我们应该用map ,然后 json.Marshal来...\npatchData := []byte(`{\"metadata\":{\"labels\":{\"app1\":null}}}`)\n\n// 执行Patch操作\nupdatedNode, err := clientset.\n    CoreV1().\n    Nodes().\n    Patch(context.TODO(), \"node1\",\n        types.StrategicMergePatchType,\n        patchData, metav1.PatchOptions{})\nif err != nil {\n    panic(err.Error())\n}\n\n\n// 创建要设置的污点数据,\ntaints := []corev1.Taint{\n    {\n        Key:    \"hello\",\n        Value:  \"world\",\n        Effect: corev1.TaintEffectNoSchedule,\n    },\n}\n// 如果想要在原来的污点上 增加, 可以先获取节点的污点,然后...\n// k get no node1 -o yaml 可以看到节点的属性 spec.taints\npatchData, _ := json.Marshal(map[string]interface{}{\n    \"spec\": map[string]interface{}{\n        \"taints\": taints, //  这样写会覆盖原来已有的污点\n    },\n})\n\n// 执行Patch操作\n_, err = clientset.\n    CoreV1().\n    Nodes().\n    Patch(context.TODO(),\n        \"node1\",\n        types.MergePatchType,\n        patchData,\n        metav1.PatchOptions{})\nif err != nil {\n    panic(err.Error())\n}",
    "crumbs": [
      "二次开发",
      "client-go",
      "client-go"
    ]
  },
  {
    "objectID": "docs/devops/k8s/develop/client-go/client-go.html#pv",
    "href": "docs/devops/k8s/develop/client-go/client-go.html#pv",
    "title": "斯巴拉稀",
    "section": "6 pv",
    "text": "6 pv\n\nlistcreate\n\n\npvList, err := clientset.\n    CoreV1().\n    PersistentVolumes().\n    List(context.TODO(), metav1.ListOptions{})\nif err != nil {\n    panic(err.Error())\n}\n\n// 遍历 PV 列表\nfor _, pv := range pvList.Items {\n    fmt.Println(pv.ObjectMeta.Name)\n    fmt.Println(pv.Spec.StorageClassName)\n    fmt.Println(pv.Status.Phase)\n}\n\n\n// 创建持久卷\n// 仅作为pvc 选择pv 用\nstorageClassName := \"abc-no-defined-name\"\npv := &corev1.PersistentVolume{\n    ObjectMeta: metav1.ObjectMeta{\n        Name: \"pv-client-go\",\n        // Labels: map[string]string{\n        //  \"run\": \"pv\",\n        // },\n    },\n    Spec: corev1.PersistentVolumeSpec{\n        Capacity: corev1.ResourceList{\n            corev1.ResourceStorage: resource.MustParse(\"300Mi\"),\n        },\n        AccessModes: []corev1.PersistentVolumeAccessMode{\n            corev1.ReadWriteOnce,\n        },\n        PersistentVolumeReclaimPolicy: corev1.PersistentVolumeReclaimRetain,\n        StorageClassName:              storageClassName,\n        // 这里我用NFS\n        PersistentVolumeSource: corev1.PersistentVolumeSource{\n            NFS: &corev1.NFSVolumeSource{\n                Server:   \"102.168.66.110\",\n                Path:     \"/data/nfs\",\n                ReadOnly: false,\n            },\n        },\n    },\n}\n_, err = clientset.\n    CoreV1().\n    PersistentVolumes(). //pv 没有namespace概念\n    Create(context.TODO(), pv, metav1.CreateOptions{})\nif err != nil {\n    panic(err.Error())\n}",
    "crumbs": [
      "二次开发",
      "client-go",
      "client-go"
    ]
  },
  {
    "objectID": "docs/devops/k8s/develop/client-go/client-go.html#pvc",
    "href": "docs/devops/k8s/develop/client-go/client-go.html#pvc",
    "title": "斯巴拉稀",
    "section": "7 PVC",
    "text": "7 PVC\n\nlistcreate\n\n\n// 获取 PVC 列表\npvcList, err := clientset.\n    CoreV1().\n    PersistentVolumeClaims(\"default\").\n    List(context.TODO(), metav1.ListOptions{})\nif err != nil {\n    panic(err.Error())\n}\n\n// 遍历 PVC 列表\nfor _, pvc := range pvcList.Items {\n    fmt.Println(pvc.ObjectMeta.Name)\n    fmt.Println(pvc.Spec.VolumeName)\n    fmt.Println(pvc.Status.Phase)\n}\n\n\n// 创建pvc\nstorageClassName := \"abc-no-defined-name\"\npvc := &corev1.PersistentVolumeClaim{\n    ObjectMeta: metav1.ObjectMeta{\n        Name: \"pvc-client-go\",\n    },\n    Spec: corev1.PersistentVolumeClaimSpec{\n        AccessModes: []corev1.PersistentVolumeAccessMode{\n            corev1.ReadWriteOnce,\n        },\n        Resources: corev1.ResourceRequirements{\n            Requests: corev1.ResourceList{\n                corev1.ResourceStorage: resource.MustParse(\"220Mi\"),\n            },\n        },\n        StorageClassName: &storageClassName,\n        // Selector: &metav1.LabelSelector{\n        //  MatchLabels: map[string]string{\n        //      \"run\": \"pv\",\n        //  },\n        // },\n    },\n}\n_, err = clientset.\n    CoreV1().\n    PersistentVolumeClaims(\"default\").\n    Create(context.TODO(), pvc, metav1.CreateOptions{})\nif err != nil {\n    panic(err.Error())\n}",
    "crumbs": [
      "二次开发",
      "client-go",
      "client-go"
    ]
  },
  {
    "objectID": "docs/devops/k8s/develop/client-go/client-go.html#sc",
    "href": "docs/devops/k8s/develop/client-go/client-go.html#sc",
    "title": "斯巴拉稀",
    "section": "8 SC",
    "text": "8 SC\n\ncreatelist设置为默认delete\n\n\nimport (\n    \"k8s.io/utils/pointer\"\n\n    storagev1 \"k8s.io/api/storage/v1\"\n    // ....\n)\n\nvolumeBindingImmediate := storagev1.VolumeBindingImmediate\nsc := &storagev1.StorageClass{\n    ObjectMeta: metav1.ObjectMeta{\n        Name: \"sc-01-tmp\",\n    },\n    Provisioner:          \"example-nfs2\", // 替换为你的存储提供商的 Provisioner\n    VolumeBindingMode:    &volumeBindingImmediate,\n    AllowVolumeExpansion: pointer.BoolPtr(true),\n}\n\ncreatedSC, err := clientset.\n    StorageV1().\n    StorageClasses().\n    Create(context.TODO(), sc, metav1.CreateOptions{})\nif err != nil {\n    panic(err.Error())\n}\nfmt.Printf(\"OK: %s\\n\", createdSC.Name)\n\n\n//  获取 StorageClass 列表\nstorageClasses, _ := clientset.\n    StorageV1().\n    StorageClasses().\n    List(context.TODO(), metav1.ListOptions{})\n\n// 遍历 StorageClass 列表\nfor _, sc := range storageClasses.Items {\n    fmt.Println(sc.Name)\n    fmt.Println(sc.Provisioner)\n    fmt.Println(sc.Parameters)\n    fmt.Println(*sc.ReclaimPolicy)\n    fmt.Println(\"is-default-class: \", sc.Annotations[\"storageclass.kubernetes.io/is-default-class\"] == \"true\")\n}\n\n\nserverVersion, err := clientset.Discovery().ServerVersion()\nif err != nil {\n    panic(err)\n}\nmajorVersion, _ := strconv.Atoi(serverVersion.Major)\nminorVersion, _ := strconv.Atoi(serverVersion.Minor)\nif majorVersion &lt; 1 || (majorVersion == 1 && minorVersion &lt; 14) {\n    fmt.Println(\"这个版本不支持设置默认StorageClass\")\n    return\n}\n\nstorageClasses, _ := clientset.\n    StorageV1().\n    StorageClasses().\n    List(context.TODO(), metav1.ListOptions{})\n// 想要设置成默认的 StorageClass\ntargetStorageClassName := \"sc-01-tmp\"\ndefaultStorageAnnotation := \"storageclass.kubernetes.io/is-default-class\"\nfor _, sc := range storageClasses.Items {\n    fmt.Println(sc.Name)\n    fmt.Println(sc.Annotations)\n    if sc.Annotations[defaultStorageAnnotation] == \"true\" {\n        // 删除 default Storage Annotation key\n        delete(sc.Annotations, defaultStorageAnnotation)\n        // 更新 StorageClass\n        _, err = clientset.\n            StorageV1().\n            StorageClasses().\n            Update(context.TODO(), &sc, metav1.UpdateOptions{})\n        if err != nil {\n            panic(err.Error())\n        }\n    }\n    if sc.Name == targetStorageClassName &&\n        sc.Annotations[defaultStorageAnnotation] != \"true\" {\n        if sc.Annotations == nil {\n            sc.Annotations = make(map[string]string)\n        }\n        sc.Annotations[defaultStorageAnnotation] = \"true\"\n        // 更新 StorageClass\n        _, err = clientset.\n            StorageV1().\n            StorageClasses().\n            Update(context.TODO(), &sc, metav1.UpdateOptions{})\n        if err != nil {\n            panic(err.Error())\n        }\n    }\n\n}\n\n\nerr = clientset.\n    StorageV1().\n    StorageClasses().\n    Delete(context.TODO(), \"example-nfs\", metav1.DeleteOptions{})\nif err != nil {\n    panic(err)\n}",
    "crumbs": [
      "二次开发",
      "client-go",
      "client-go"
    ]
  },
  {
    "objectID": "docs/devops/k8s/develop/client-go/client-go.html#configmap",
    "href": "docs/devops/k8s/develop/client-go/client-go.html#configmap",
    "title": "斯巴拉稀",
    "section": "9 configmap",
    "text": "9 configmap\n\nlistdetailcreatedeletecreatePodWithConfigmap\n\n\nlist, err := clientset.\n    CoreV1().\n    ConfigMaps(\"default\").\n    List(context.TODO(), metav1.ListOptions{})\nif err != nil {\n    panic(err.Error())\n}\nfor _, item := range list.Items {\n    fmt.Println(\"name:\", item.ObjectMeta.Name)\n    fmt.Println(\"type:\", item.TypeMeta)\n    fmt.Println(\"immutable:\", *item.Immutable)\n    fmt.Println(\"data:\", item.Data)\n    fmt.Println(\"BinaryData:\", item.BinaryData)\n}\n\n\nitem, err := clientset.CoreV1().ConfigMaps(\"default\").Get(context.TODO(), \"mysql-config2\", metav1.GetOptions{})\nif err != nil {\n    // 找不到该configmap ,会报错\n    panic(err.Error())\n}\nfmt.Println(\"name:\", item.ObjectMeta.Name)\nfmt.Println(\"type:\", item.TypeMeta)\nfmt.Println(\"immutable:\", *item.Immutable)\nfmt.Println(\"data:\", item.Data)\nfmt.Println(\"BinaryData:\", item.BinaryData)\n\n\nimport (\n    \"context\"\n    \"flag\"\n    \"fmt\"\n    \"io/ioutil\"\n    \"os\"\n    \"path/filepath\"\n\n    corev1 \"k8s.io/api/core/v1\"\n    \"k8s.io/apimachinery/pkg/api/errors\"\n    metav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n    \"k8s.io/client-go/kubernetes\"\n    \"k8s.io/client-go/tools/clientcmd\"\n    \"k8s.io/client-go/util/homedir\"\n)\n//......\nnginxConfigData, err := ioutil.ReadFile(\"nginx.conf\")\nif err != nil {\n    fmt.Printf(\"err: %v\\n\", err)\n    return\n}\nconfigMap := &corev1.ConfigMap{\n    ObjectMeta: metav1.ObjectMeta{\n        Name:      \"mysql-config22\",\n        Namespace: \"default\",\n    },\n    Data: map[string]string{\n        \"user\":       \"root\",\n        \"password\":   \"123\",\n        \"nginx.conf\": string(nginxConfigData),\n    },\n}\n// 在 Kubernetes 中创建 ConfigMap\ncreatedConfigMap, err := clientset.\n    CoreV1().\n    ConfigMaps(\"default\").\n    Create(context.TODO(), configMap, metav1.CreateOptions{})\nif err != nil {\n    fmt.Printf(\"%v\\n\", err)\n    return\n}\n\nfmt.Printf(\"%s\\n\", createdConfigMap.Name)\n\n\nerr = clientset.\n    CoreV1().\n    ConfigMaps(\"default\").\n    Delete(context.TODO(), \"mysql-config2\", metav1.DeleteOptions{})\nif err != nil {\n    panic(err.Error())\n}\n\n\npod1 := &corev1.Pod{\n    ObjectMeta: metav1.ObjectMeta{\n        Name:      \"my-pod\",\n        Namespace: \"default\",\n        Labels: map[string]string{\n            \"app\": \"pod-vol\",\n            \"run\": \"test\",\n        },\n    },\n    Spec: corev1.PodSpec{\n        Containers: []corev1.Container{\n            {\n                Name:  \"my-container\",\n                Image: \"nginx:1.14.2\",\n                Env: []corev1.EnvVar{\n                    {\n                        Name: \"MYSQL_USER\",\n                        ValueFrom: &corev1.EnvVarSource{\n                            ConfigMapKeyRef: &corev1.ConfigMapKeySelector{\n                                LocalObjectReference: corev1.LocalObjectReference{\n                                    Name: \"mysql-config22\",\n                                },\n                                Key: \"user\",\n                            },\n                        },\n                    },\n                    {\n                        Name:  \"hello\",\n                        Value: \"world\",\n                    },\n                },\n            },\n        },\n    },\n}\ncreatedPod, err := clientset.\n    CoreV1().\n    Pods(\"default\").\n    Create(context.TODO(),\n        pod1,\n        metav1.CreateOptions{\n        })\nif err != nil {\n    log.Fatal(err)\n}\nfmt.Printf(\"%s\\n\", createdPod.Name)\nk exec my-pod  -- env",
    "crumbs": [
      "二次开发",
      "client-go",
      "client-go"
    ]
  },
  {
    "objectID": "docs/devops/k8s/develop/client-go/client-go.html#secret",
    "href": "docs/devops/k8s/develop/client-go/client-go.html#secret",
    "title": "斯巴拉稀",
    "section": "10 secret",
    "text": "10 secret\n\nlistdetailcreatedelete\n\n\nlist, err := clientset.CoreV1().Secrets(\"default\").List(context.TODO(), metav1.ListOptions{})\nif err != nil {\n    panic(err.Error())\n}\nfor _, item := range list.Items {\n    fmt.Println(\"name:\", item.ObjectMeta.Name)\n    fmt.Println(\"type:\", item.TypeMeta)\n    if item.Immutable != nil {\n        fmt.Println(\"immutable:\", *item.Immutable)\n    }\n    fmt.Println(\"data:\", item.Data)\n    fmt.Println(\"stringData:\", item.StringData)\n    fmt.Println(\"type:\", item.Type)\n}\n\n\nitem, err := clientset.CoreV1().Secrets(\"default\").Get(context.TODO(), \"mysql-root-password\", metav1.GetOptions{})\nif err != nil {\n    panic(err.Error())\n}\nfmt.Println(\"name:\", item.ObjectMeta.Name)\nfmt.Println(\"type:\", item.TypeMeta)\nif item.Immutable != nil {\n    fmt.Println(\"immutable:\", *item.Immutable)\n}\nfmt.Println(\"data:\", item.Data)\nfmt.Println(\"stringData:\", item.StringData)\nfmt.Println(\"type:\", item.Type)\n\n\nsecret := &corev1.Secret{\n    ObjectMeta: metav1.ObjectMeta{\n        Name:      \"secret-test\",\n        Namespace: \"default\",\n    },\n    StringData: map[string]string{\n        \"username\": \"root\",\n        \"password\": \"123456\",\n    },\n    Type: corev1.SecretTypeOpaque, // 不写默认就是这个类型\n}\ncreatedSecret, err := clientset.\n    CoreV1().\n    Secrets(\"default\").\n    Create(context.TODO(), secret, metav1.CreateOptions{})\nif err != nil {\n    fmt.Printf(\"err: %v\\n\", err)\n    return\n}\n\nfmt.Printf(\"ok: %s\\n\", createdSecret.Name)\n\n\nerr = clientset.CoreV1().Secrets(\"default\").Delete(context.TODO(), \"secret-test\", metav1.DeleteOptions{})\nif err != nil {\n    panic(err.Error())\n}",
    "crumbs": [
      "二次开发",
      "client-go",
      "client-go"
    ]
  },
  {
    "objectID": "docs/devops/k8s/develop/client-go/client-go.html#svc",
    "href": "docs/devops/k8s/develop/client-go/client-go.html#svc",
    "title": "斯巴拉稀",
    "section": "11 svc",
    "text": "11 svc\n\ncreate svccreate ep\n\n\nservice := &corev1.Service{\n    ObjectMeta: metav1.ObjectMeta{\n        Name:      \"svc-test\",\n        Namespace: namespace,\n    },\n    Spec: corev1.ServiceSpec{\n        Selector: map[string]string{\n            \"app\": \"pod-deploy-nginx2\",\n        },\n        Ports: []corev1.ServicePort{\n            {\n                Protocol:   corev1.ProtocolTCP,\n                Port:       8981,\n                TargetPort: intstr.FromInt(int(80)),\n            },\n        },\n    },\n}\n\ncreatedSVC, err := clientset.CoreV1().\n    Services(namespace).\n    Create(context.TODO(), service, metav1.CreateOptions{})\nif err != nil {\n    panic(err.Error())\n}\nfmt.Println(createdSVC.Name)\n\n\nendpoint := &corev1.Endpoints{\n    ObjectMeta: metav1.ObjectMeta{\n        Name:      \"svc-test-2\",\n        Namespace: namespace,\n    },\n    Subsets: []corev1.EndpointSubset{\n        {\n            Addresses: []corev1.EndpointAddress{\n                {\n                    IP: \"10.244.1.82\",\n                },\n                {\n                    IP: \"10.244.2.81\",\n                },\n            },\n            Ports: []corev1.EndpointPort{\n                {\n                    Protocol: corev1.ProtocolTCP,\n                    Port:     int32(80),\n                },\n            },\n        },\n    },\n}\n\nep, err := clientset.\n    CoreV1().\n    Endpoints(\"default\").\n    Create(context.TODO(), endpoint, metav1.CreateOptions{})\n\nif err != nil {\n    panic(err.Error())\n}\nfmt.Println(ep.Name)",
    "crumbs": [
      "二次开发",
      "client-go",
      "client-go"
    ]
  },
  {
    "objectID": "docs/devops/k8s/develop/index.html",
    "href": "docs/devops/k8s/develop/index.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "git clone https://github.com/kubernetes/kubernetes\ngit co -b v1.23.17 v1.23.17\nStandard Go Project Layout\ntree -L 1\n.\n├── Makefile -&gt; build/root/Makefile\n├── api\n├── build # 构建相关代码\n├── cluster\n├── cmd # 可执行文件入口\n    ├── kube-apiserver # 其他都类似这样的目录结果\n        ├── OWNERS\n        ├── apiserver.go\n        └── app\n├── docs\n├── hack # 构建和测试相关代码\n├── logo\n├── pkg # 核心库代码\n├── plugin\n├── staging # 部分核心库代码\n├── test\n├── third_party\n└── vendor #项目依赖的库, 一般是第三方库",
    "crumbs": [
      "二次开发",
      "介绍"
    ]
  },
  {
    "objectID": "docs/devops/k8s/develop/index.html#源码框架介绍",
    "href": "docs/devops/k8s/develop/index.html#源码框架介绍",
    "title": "斯巴拉稀",
    "section": "",
    "text": "git clone https://github.com/kubernetes/kubernetes\ngit co -b v1.23.17 v1.23.17\nStandard Go Project Layout\ntree -L 1\n.\n├── Makefile -&gt; build/root/Makefile\n├── api\n├── build # 构建相关代码\n├── cluster\n├── cmd # 可执行文件入口\n    ├── kube-apiserver # 其他都类似这样的目录结果\n        ├── OWNERS\n        ├── apiserver.go\n        └── app\n├── docs\n├── hack # 构建和测试相关代码\n├── logo\n├── pkg # 核心库代码\n├── plugin\n├── staging # 部分核心库代码\n├── test\n├── third_party\n└── vendor #项目依赖的库, 一般是第三方库",
    "crumbs": [
      "二次开发",
      "介绍"
    ]
  },
  {
    "objectID": "docs/devops/k8s/develop/index.html#组件源码",
    "href": "docs/devops/k8s/develop/index.html#组件源码",
    "title": "斯巴拉稀",
    "section": "2 组件源码",
    "text": "2 组件源码\ncobra教程\n├── cmd # 可执行文件入口\n    ├── kube-apiserver # 其他都类似这样的目录结果\n        ├── OWNERS\n        ├── apiserver.go\n        └── app",
    "crumbs": [
      "二次开发",
      "介绍"
    ]
  },
  {
    "objectID": "docs/devops/k8s/develop/index.html#相关库",
    "href": "docs/devops/k8s/develop/index.html#相关库",
    "title": "斯巴拉稀",
    "section": "3 相关库",
    "text": "3 相关库",
    "crumbs": [
      "二次开发",
      "介绍"
    ]
  },
  {
    "objectID": "docs/devops/k8s/develop/operator/kubebuilder.html",
    "href": "docs/devops/k8s/develop/operator/kubebuilder.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "Tip\n\n\n\n前面sample-controller的例子,虽然用了代码生成器,但是还有蛮多东西需要一个个手动编写, 会比较麻烦, 有没有什么工具呢?\n\n\ngit clone https://github.com/kubernetes-sigs/controller-tools\ncd controller-tools\ntree -L 2\n.\n├── Makefile\n├── boilerplate.go.txt\n├── cmd # 有3个工具\n│   ├── controller-gen\n│   ├── helpgen\n│   └── type-scaffold  # scaffold 是脚手架的意思,用来生成types.go \n├── go.mod\n├── go.sum\n├── pkg\n│   ├── crd # 根据这个,大概能想到,上面的那个工具应该能自动生成crd yaml文件\n│   ├── deepcopy # 同样\n│   ├── genall\n│   ├── loader\n│   ├── markers\n│   ├── rbac # 角色\n│   ├── schemapatcher\n│   ├── typescaffold\n│   ├── version\n│   └── webhook  # webhook 相关\n└── test.sh\n\n# 安装工具\ngo install sigs.k8s.io/controller-tools/cmd/controller-gen\ngo install sigs.k8s.io/controller-tools/cmd/type-scaffold\n\ntype-scaffold --kind CronTab\n\n\n\n\n\n\n点击查看执行结果: 可以看到和我们上面写的types.go一样的东西\n\n\n\n\n\n// CronTabSpec defines the desired state of CronTab\ntype CronTabSpec struct {\n        // INSERT ADDITIONAL SPEC FIELDS -- desired state of cluster\n}\n\n// CronTabStatus defines the observed state of CronTab.\n// It should always be reconstructable from the state of the cluster and/or outside world.\ntype CronTabStatus struct {\n        // INSERT ADDITIONAL STATUS FIELDS -- observed state of cluster\n}\n\n// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object\n\n// CronTab is the Schema for the crontabs API\n// +k8s:openapi-gen=true\ntype CronTab struct {\n        metav1.TypeMeta   `json:\",inline\"`\n        metav1.ObjectMeta `json:\"metadata,omitempty\"`\n\n        Spec   CronTabSpec   `json:\"spec,omitempty\"`\n        Status CronTabStatus `json:\"status,omitempty\"`\n}\n\n// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object\n\n// CronTabList contains a list of CronTab\ntype CronTabList struct {\n        metav1.TypeMeta `json:\",inline\"`\n        metav1.ListMeta `json:\"metadata,omitempty\"`\n        Items           []CronTab `json:\"items\"`\n}\n\n\n\n\n# 根据我们types.go的定义 (我们之前可以说是先定义了crd yaml ,然后来写types.go 文件)\n# 会在当前目录的manifests 下 生成自定义资源的crd yaml文件\ncontroller-gen crd paths=./...  output:crd:dir=manifests",
    "crumbs": [
      "二次开发",
      "operator",
      "kubebuilder"
    ]
  },
  {
    "objectID": "docs/devops/k8s/develop/operator/kubebuilder.html#controller-tools5",
    "href": "docs/devops/k8s/develop/operator/kubebuilder.html#controller-tools5",
    "title": "斯巴拉稀",
    "section": "",
    "text": "Tip\n\n\n\n前面sample-controller的例子,虽然用了代码生成器,但是还有蛮多东西需要一个个手动编写, 会比较麻烦, 有没有什么工具呢?\n\n\ngit clone https://github.com/kubernetes-sigs/controller-tools\ncd controller-tools\ntree -L 2\n.\n├── Makefile\n├── boilerplate.go.txt\n├── cmd # 有3个工具\n│   ├── controller-gen\n│   ├── helpgen\n│   └── type-scaffold  # scaffold 是脚手架的意思,用来生成types.go \n├── go.mod\n├── go.sum\n├── pkg\n│   ├── crd # 根据这个,大概能想到,上面的那个工具应该能自动生成crd yaml文件\n│   ├── deepcopy # 同样\n│   ├── genall\n│   ├── loader\n│   ├── markers\n│   ├── rbac # 角色\n│   ├── schemapatcher\n│   ├── typescaffold\n│   ├── version\n│   └── webhook  # webhook 相关\n└── test.sh\n\n# 安装工具\ngo install sigs.k8s.io/controller-tools/cmd/controller-gen\ngo install sigs.k8s.io/controller-tools/cmd/type-scaffold\n\ntype-scaffold --kind CronTab\n\n\n\n\n\n\n点击查看执行结果: 可以看到和我们上面写的types.go一样的东西\n\n\n\n\n\n// CronTabSpec defines the desired state of CronTab\ntype CronTabSpec struct {\n        // INSERT ADDITIONAL SPEC FIELDS -- desired state of cluster\n}\n\n// CronTabStatus defines the observed state of CronTab.\n// It should always be reconstructable from the state of the cluster and/or outside world.\ntype CronTabStatus struct {\n        // INSERT ADDITIONAL STATUS FIELDS -- observed state of cluster\n}\n\n// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object\n\n// CronTab is the Schema for the crontabs API\n// +k8s:openapi-gen=true\ntype CronTab struct {\n        metav1.TypeMeta   `json:\",inline\"`\n        metav1.ObjectMeta `json:\"metadata,omitempty\"`\n\n        Spec   CronTabSpec   `json:\"spec,omitempty\"`\n        Status CronTabStatus `json:\"status,omitempty\"`\n}\n\n// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object\n\n// CronTabList contains a list of CronTab\ntype CronTabList struct {\n        metav1.TypeMeta `json:\",inline\"`\n        metav1.ListMeta `json:\"metadata,omitempty\"`\n        Items           []CronTab `json:\"items\"`\n}\n\n\n\n\n# 根据我们types.go的定义 (我们之前可以说是先定义了crd yaml ,然后来写types.go 文件)\n# 会在当前目录的manifests 下 生成自定义资源的crd yaml文件\ncontroller-gen crd paths=./...  output:crd:dir=manifests",
    "crumbs": [
      "二次开发",
      "operator",
      "kubebuilder"
    ]
  },
  {
    "objectID": "docs/devops/k8s/develop/operator/kubebuilder.html#kubebuilder123",
    "href": "docs/devops/k8s/develop/operator/kubebuilder.html#kubebuilder123",
    "title": "斯巴拉稀",
    "section": "2 kubebuilder234",
    "text": "2 kubebuilder234\n\n\n\n\n\n\nTip\n\n\n\n\nkubebuilder 是专门用来开发operator 的脚手架工具\n前面稍微介绍了下 controller-tools,现在介绍的kubebuilder 实际内部会也使用到了controller-tools\n\n\n\n\n2.1 快速感受一下\ncurl -L -o kubebuilder \"https://go.kubebuilder.io/dl/latest/$(go env GOOS)/$(go env GOARCH)\"\nchmod +x kubebuilder && mv kubebuilder /usr/local/bin/\n# 直接运行命令, 会看到一些帮助\nkubebuilder\n\nmkdir crd-kubebuilder\ncd crd-kubebuilder\ngo mod init crd-kubebuilder\n\n# 1. 初始化,使用的v4 plugin, 会下载比较新版本的 库\nkubebuilder init --domain example.com\ntree -L 2\n.\n├── Dockerfile\n├── Makefile\n├── PROJECT\n├── README.md\n├── cmd\n│   └── main.go\n├── config # 一些yaml文件\n│   ├── default\n│   ├── manager\n│   ├── prometheus\n│   └── rbac\n├── go.mod\n├── go.sum\n└── hack\n    └── boilerplate.go.txt\n\n# 2. 创建api\nkubebuilder create api  --group stable  --version v1 --kind CronTab\n# y y\n# 3. 编写控制器逻辑等逻辑\n# 4. 生成 crd\nmake manifests\n\n\n2.2 架构介绍",
    "crumbs": [
      "二次开发",
      "operator",
      "kubebuilder"
    ]
  },
  {
    "objectID": "docs/devops/k8s/develop/operator/kubebuilder.html#footnotes",
    "href": "docs/devops/k8s/develop/operator/kubebuilder.html#footnotes",
    "title": "斯巴拉稀",
    "section": "Footnotes",
    "text": "Footnotes\n\n\ncontroller-tools↩︎\nkubebuilder github↩︎\nkubebuilder同上↩︎\nkubebuilder教程↩︎",
    "crumbs": [
      "二次开发",
      "operator",
      "kubebuilder"
    ]
  },
  {
    "objectID": "docs/devops/k8s/develop/operator/crd.html",
    "href": "docs/devops/k8s/develop/operator/crd.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "Tip\n\n\n\n\nk8s 在发展过程中, 肯定是不断的增加某种类型的资源, 比如 deployment, 我们会创建一个 类型是kind: Deployment的yaml文件\nk8s 系统里肯定有相关的代码来实现 这个类型的东西所具有的功能\n增加这样一个功能, 可能就需要很多的代码, k8s 代码更新的周期 可能就比较长, 新功能等待时间可能就比较长\n而自定义资源 的出现 ,就是让用户可以自己来简单的做这样一个扩展,增加了一个自己需要的功能.\n\n\n\n1.我们现在来创建一个yaml文件来表示我们的资源\n\n\ncrontab.yaml\n\napiVersion: \"stable.example.com/v1\"\nkind: CronTab\nmetadata:\n  name: my-new-cron-object\nspec:\n  cronSpec: \"* * * * */5\"\n  image: my-awesome-cron-image\n\n\n\n我们apply看看,肯定报错了\n\nk apply -f crontab.yaml\nerror: unable to recognize \"crontab.yaml\": no matches for kind \"CronTab\" in version \"stable.example.com/v1\"\n\n2.我们得让系统知道你yaml里的东西是啥玩意,我们定义一个CustomResourceDefinition让系统知道你yaml里的东西是啥意思\n\n\ncrontab-resource-definition.yaml\n\napiVersion: apiextensions.k8s.io/v1\nkind: CustomResourceDefinition\nmetadata:\n  # 名字必需与下面的 spec 字段匹配，并且格式为 '&lt;名称的复数形式&gt;.&lt;组名&gt;'\n  name: crontabs.stable.example.com\nspec:\n  # 组名称，用于 REST API: /apis/&lt;组&gt;/&lt;版本&gt;\n  group: stable.example.com\n  # 列举此 CustomResourceDefinition 所支持的版本\n  versions: # 可设置多个版本\n    - name: v1\n      # 每个版本都可以通过 served 标志来独立启用或禁止\n      served: true\n      # 其中一个且只有一个版本必需被标记为存储版本\n      storage: true\n      schema:\n1        openAPIV3Schema: #openAPIV3Schema 是验证自定义对象的模式\n          type: object\n          properties:\n            spec:\n              type: object\n              properties:\n                cronSpec:\n                  type: string\n                image:\n                  type: string\n                replicas:\n                  type: integer\n2      additionalPrinterColumns:\n      - name: Spec\n        type: string\n        description: The cron spec defining the interval a CronJob is run\n        jsonPath: .spec.cronSpec\n      - name: Replicas\n        type: integer\n        description: The number of jobs launched by the CronJob\n        jsonPath: .spec.replicas\n      - name: Age\n        type: date\n        jsonPath: .metadata.creationTimestamp\n  # 范围 可以是 Namespaced 或 Cluster\n  # 就像pod ,是有 ns 范围的\n  scope: Namespaced\n  names:\n    # 名称的复数形式，用于 URL：/apis/&lt;组&gt;/&lt;版本&gt;/&lt;名称的复数形式&gt;\n    plural: crontabs\n    # 名称的单数形式，作为命令行使用时和显示时的别名\n    singular: crontab\n    # kind 通常是单数形式的驼峰命名（CamelCased）形式。你的资源清单会使用这一形式。\n    kind: CronTab\n    # shortNames 允许你在命令行使用较短的字符串来匹配资源, 比如 k get po 中的po 是pod\n    shortNames:\n    - ct\n\n\n1\n\n合法性验证\n\n2\n\n额外的打印列\n\n\nk get ct #可以看到更多的列\nNAME                 SPEC        REPLICAS   AGE\nmy-new-cron-object   * * * * *   1          7s\n\nk apply -f crontab-resource-definition.yaml\n#查看创建了哪些 资源定义\nk get crd\n\n\n\n\n\n\n点击查看执行结果\n\n\n\n\n\nNAME                          CREATED AT\ncrontabs.stable.example.com   2023-08-07T02:35:01Z\n\n\n\n\n\nk api-resources # 这个时候能看到这个类型crontab的资源\n\n# 创建完成后,我们就可以有 通过http 来查询这类资源了\ncurl localhost:8001/apis/stable.example.com/v1/namespaces/default/crontabs/\n\n\n\n\n\n\n点击查看执行结果\n\n\n\n\n\n{\n  \"apiVersion\": \"stable.example.com/v1\",\n  \"items\": [],\n  \"kind\": \"CronTabList\",\n  \"metadata\": {\n    \"continue\": \"\",\n    \"resourceVersion\": \"2608555\"\n  }\n}\n\n\n\n\n# 这个时候我们再创建这个自定义类型的对象\nk apply -f crontab.yaml\n# 和我们使用 k get po  一样\n# 可以用上面crd里定义的ct这个shortName\nk get ct\n\ncurl localhost:8001/apis/stable.example.com/v1/namespaces/default/crontabs/my-new-cron-object\n3.现在创建的CronTab 类型的对象 和我们POD 类似, 只是pod对象创建完后,系统会给创建真正的pod,而CronTab系统可没做啥实质性的动作, 这需要我们写一些代码(自定义控制器,就是operator), 让系统看到这样的对象被写入后,做些什么事情,完全由用户来设计. 详见operator",
    "crumbs": [
      "二次开发",
      "operator",
      "自定义资源"
    ]
  },
  {
    "objectID": "docs/devops/k8s/develop/operator/crd.html#customresourcedefinition1",
    "href": "docs/devops/k8s/develop/operator/crd.html#customresourcedefinition1",
    "title": "斯巴拉稀",
    "section": "",
    "text": "Tip\n\n\n\n\nk8s 在发展过程中, 肯定是不断的增加某种类型的资源, 比如 deployment, 我们会创建一个 类型是kind: Deployment的yaml文件\nk8s 系统里肯定有相关的代码来实现 这个类型的东西所具有的功能\n增加这样一个功能, 可能就需要很多的代码, k8s 代码更新的周期 可能就比较长, 新功能等待时间可能就比较长\n而自定义资源 的出现 ,就是让用户可以自己来简单的做这样一个扩展,增加了一个自己需要的功能.\n\n\n\n1.我们现在来创建一个yaml文件来表示我们的资源\n\n\ncrontab.yaml\n\napiVersion: \"stable.example.com/v1\"\nkind: CronTab\nmetadata:\n  name: my-new-cron-object\nspec:\n  cronSpec: \"* * * * */5\"\n  image: my-awesome-cron-image\n\n\n\n我们apply看看,肯定报错了\n\nk apply -f crontab.yaml\nerror: unable to recognize \"crontab.yaml\": no matches for kind \"CronTab\" in version \"stable.example.com/v1\"\n\n2.我们得让系统知道你yaml里的东西是啥玩意,我们定义一个CustomResourceDefinition让系统知道你yaml里的东西是啥意思\n\n\ncrontab-resource-definition.yaml\n\napiVersion: apiextensions.k8s.io/v1\nkind: CustomResourceDefinition\nmetadata:\n  # 名字必需与下面的 spec 字段匹配，并且格式为 '&lt;名称的复数形式&gt;.&lt;组名&gt;'\n  name: crontabs.stable.example.com\nspec:\n  # 组名称，用于 REST API: /apis/&lt;组&gt;/&lt;版本&gt;\n  group: stable.example.com\n  # 列举此 CustomResourceDefinition 所支持的版本\n  versions: # 可设置多个版本\n    - name: v1\n      # 每个版本都可以通过 served 标志来独立启用或禁止\n      served: true\n      # 其中一个且只有一个版本必需被标记为存储版本\n      storage: true\n      schema:\n1        openAPIV3Schema: #openAPIV3Schema 是验证自定义对象的模式\n          type: object\n          properties:\n            spec:\n              type: object\n              properties:\n                cronSpec:\n                  type: string\n                image:\n                  type: string\n                replicas:\n                  type: integer\n2      additionalPrinterColumns:\n      - name: Spec\n        type: string\n        description: The cron spec defining the interval a CronJob is run\n        jsonPath: .spec.cronSpec\n      - name: Replicas\n        type: integer\n        description: The number of jobs launched by the CronJob\n        jsonPath: .spec.replicas\n      - name: Age\n        type: date\n        jsonPath: .metadata.creationTimestamp\n  # 范围 可以是 Namespaced 或 Cluster\n  # 就像pod ,是有 ns 范围的\n  scope: Namespaced\n  names:\n    # 名称的复数形式，用于 URL：/apis/&lt;组&gt;/&lt;版本&gt;/&lt;名称的复数形式&gt;\n    plural: crontabs\n    # 名称的单数形式，作为命令行使用时和显示时的别名\n    singular: crontab\n    # kind 通常是单数形式的驼峰命名（CamelCased）形式。你的资源清单会使用这一形式。\n    kind: CronTab\n    # shortNames 允许你在命令行使用较短的字符串来匹配资源, 比如 k get po 中的po 是pod\n    shortNames:\n    - ct\n\n\n1\n\n合法性验证\n\n2\n\n额外的打印列\n\n\nk get ct #可以看到更多的列\nNAME                 SPEC        REPLICAS   AGE\nmy-new-cron-object   * * * * *   1          7s\n\nk apply -f crontab-resource-definition.yaml\n#查看创建了哪些 资源定义\nk get crd\n\n\n\n\n\n\n点击查看执行结果\n\n\n\n\n\nNAME                          CREATED AT\ncrontabs.stable.example.com   2023-08-07T02:35:01Z\n\n\n\n\n\nk api-resources # 这个时候能看到这个类型crontab的资源\n\n# 创建完成后,我们就可以有 通过http 来查询这类资源了\ncurl localhost:8001/apis/stable.example.com/v1/namespaces/default/crontabs/\n\n\n\n\n\n\n点击查看执行结果\n\n\n\n\n\n{\n  \"apiVersion\": \"stable.example.com/v1\",\n  \"items\": [],\n  \"kind\": \"CronTabList\",\n  \"metadata\": {\n    \"continue\": \"\",\n    \"resourceVersion\": \"2608555\"\n  }\n}\n\n\n\n\n# 这个时候我们再创建这个自定义类型的对象\nk apply -f crontab.yaml\n# 和我们使用 k get po  一样\n# 可以用上面crd里定义的ct这个shortName\nk get ct\n\ncurl localhost:8001/apis/stable.example.com/v1/namespaces/default/crontabs/my-new-cron-object\n3.现在创建的CronTab 类型的对象 和我们POD 类似, 只是pod对象创建完后,系统会给创建真正的pod,而CronTab系统可没做啥实质性的动作, 这需要我们写一些代码(自定义控制器,就是operator), 让系统看到这样的对象被写入后,做些什么事情,完全由用户来设计. 详见operator",
    "crumbs": [
      "二次开发",
      "operator",
      "自定义资源"
    ]
  },
  {
    "objectID": "docs/devops/k8s/develop/operator/crd.html#finalizers34",
    "href": "docs/devops/k8s/develop/operator/crd.html#finalizers34",
    "title": "斯巴拉稀",
    "section": "2 Finalizers23",
    "text": "2 Finalizers23\n\n2.1 介绍\n如果给对象设置了metadata.finalizers字段, 那么删除k8s对象前会触发对应的钩子函数 可以使用 Finalizers 控制资源的垃圾收集, 或阻止删除未被管理的资源\n\n\n\n\n\n\n\nTip\n\n\n\n\n一个常见的 Finalizer 的例子是 kubernetes.io/pv-protection, 它用来防止意外删除 PersistentVolume 对象\n当一个 PersistentVolume 对象被 Pod 使用时, Kubernetes 会添加 pv-protection Finalizer. 如果你试图删除 PersistentVolume,它将进入 Terminating 状态, 但是控制器因为该 Finalizer 存在而无法删除该资源.当 Pod 停止使用 PersistentVolume 时, Kubernetes 清除 pv-protection Finalizer,控制器就会删除该卷\n\n\n\nk get pv pv-nfs-0001 -o yaml |grep finalizers -A 3 -B 10\n    apiVersion: v1\n    kind: PersistentVolume\n    metadata:\n    annotations:\n        pv.kubernetes.io/bound-by-controller: \"yes\"\n    creationTimestamp: \"2023-07-18T12:44:00Z\"\n    finalizers:\n    - kubernetes.io/pv-protection\n\n\n2.2 模拟一下\n\n\npod-finalizers.yaml\n\napiVersion: v1\nkind: Pod\nmetadata:\n  name: pod-nginx\n  labels:\n    app: pod-nginx\n  finalizers:\n  - abc/protect-xyz # 随便写一个\nspec:\n  containers:\n  - name: c-main\n    image: nginx:1.14.2\n\nk apply -f pod-finalizers.yaml\nk delete -f pod-finalizers.yaml # 会看到卡着, 等待..\n# 我们手动将 finalizers 字段删除\n\nk edit pod  pod-nginx # 删除finalizers\n# 可以看到 ok了",
    "crumbs": [
      "二次开发",
      "operator",
      "自定义资源"
    ]
  },
  {
    "objectID": "docs/devops/k8s/develop/operator/crd.html#footnotes",
    "href": "docs/devops/k8s/develop/operator/crd.html#footnotes",
    "title": "斯巴拉稀",
    "section": "Footnotes",
    "text": "Footnotes\n\n\ncustom-resources↩︎\nfinalizers↩︎\nfinalizers↩︎",
    "crumbs": [
      "二次开发",
      "operator",
      "自定义资源"
    ]
  },
  {
    "objectID": "docs/devops/k8s/core/config.html",
    "href": "docs/devops/k8s/core/config.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "Tip\n\n\n\n\n就是为了配置与代码分离\n不同的pod 里某些东西可能使用相同的配置, 这样只要写一次, pod里直接用就行\nsecret && configmap 可以理解为2中特殊类型的存储卷\nconfigmap存放的时候明文数据\n简称 cm\n\n\n\nconfigmap\nk explain cm\n\n\n\n\n\n\n环境准备\n\ncat &gt;game.properties &lt;&lt;EOF\nenemies=aliens\nlives=3\nenemies.cheat=true\nenemies.cheat.level=noGoodRotten\nsecret.code.passphrase=UUDDLRLRBABAS\nsecret.code.allowed=true\nsecret.code.lives=30\nEOF\ncat &gt;ui.properties&lt;&lt;EOF\ncolor.good=purple\ncolor.bad=yellow\nallow.textmode=true\nhow.nice.to.look=fairlyNice\nEOF\n\ntree\n.\n└── cfg\n    ├── game.properties\n    └── ui.properties\n\n\n\n创建\n\n# 基于目录,就是目录下的所有文件\nk create cm game-all-config --from-file=./cfg/\n# 基于文件 ,默认是default 命名空间, -n 指定\nk create cm ui-config --from-file=./cfg/ui.properties -n test\n# 默认是用文件名作为key, 可以指定\nk create cm ui-config-with-key --from-file=ui=./cfg/ui.properties\n# 基于多个文件\nk create cm game-all-config-with-multi \\\n    --from-file=./cfg/ui.properties \\\n    --from-file=./cfg/game.properties\n\n\n\n\n查看\n\nk get cm #(1)\n\n\n\n执行结果\n\nNAME                  DATA    AGE\ngame-all-config        2      113s\n\n\n\n\n查看某歌配置\n\nk describe cm game-all-config\n\n\nk get cm game-all-config  -o yaml # 查看(2)\n\n\n执行结果\n\napiVersion: v1\ndata:\n  game.properties: |\n    enemies=aliens\n    lives=3\n    enemies.cheat=true\n    enemies.cheat.level=noGoodRotten\n    secret.code.passphrase=UUDDLRLRBABAS\n    secret.code.allowed=true\n    secret.code.lives=30\n  ui.properties: |\n    color.good=purple\n    color.bad=yellow\n    allow.textmode=true\n    how.nice.to.look=fairlyNice\nkind: ConfigMap\nmetadata:\n  creationTimestamp: \"2023-07-17T08:16:36Z\"\n  name: game-config\n  namespace: default\n  resourceVersion: \"906578\"\n  uid: a8341d85-c916-40cd-bb5e-0ef334cc31f6\n\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\n\nEnv 文件包含环境变量列表\n\nEnv 文件中的每一行必须为 VAR=VAL 格式。\n以＃开头的行（即注释）将被忽略。\n空行将被忽略。\n引号不会被特殊处理（即它们将成为 ConfigMap 值的一部分）\n\n\n\n\n\n\n环境准备\n\ncat &gt;game-env-file.properties&lt;&lt;EOF\nenemies=aliens\nlives=3\nallowed=\"true\"\nEOF\n\n\n\n创建\n\n#从 k8s 1.23 版本开始，kubectl 支持多次指定 --from-env-file 参数来从多个数据源创建\nk create cm game-env-file \\\n    --from-env-file=./cfg/game-env-file.properties\n\n\n\n\n查看\n\nk get cm game-env-file -o yaml\n\n\n\n执行结果\n\napiVersion: v1\ndata:\n  allowed: '\"true\"'\n  enemies: aliens\n  lives: \"3\"\nkind: ConfigMap\nmetadata:\n  creationTimestamp: \"2023-07-17T08:43:55Z\"\n  name: game-env-file\n  namespace: default\n  resourceVersion: \"908873\"\n  uid: 5f8c87a6-9af0-4b7b-8ed3-9018667c338f\n\n注意 allowed: ‘“true”’ 的true 数字会用双引号\n\n\n\n\nk create cm mysql-config \\\n    --from-literal=mysql.user=root \\\n    --from-literal=mysql.port=3306\n\n\n\n\n\nmysql-cm.yaml\n\napiVersion: v1\nkind: ConfigMap\nimmutable: true\nmetadata:\n  name: mysql-config2\n  namespace: default\ndata: #同命令创建的 --from-literal=database=test --from-literal=port=3306\n  database: \"test\"\n  port: \"3306\"\n\n\nimmutable: true 设置成不可变\n\n这样你无法通过`k edit cm` 修改\n无法通过修改yaml文件,然后apply -f 或 k replace -f\n可以用`k replace --force -f`\n\n数字必须用引号括起来!!!\n\nk create -f mysql-cm.yaml\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nConfigMap 位于确定的命名空间中. 每个 ConfigMap 只能被同一命名空间中的 Pod 引用\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\n适用于使用几个环境变量, 直接注入,如果你后续修改了configmap, 是不会同步到pod里的\n\n\n\n\npod-cm-valuefrom.yaml\n\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: special-config\n  namespace: default\ndata:\n  hello: world\n  python: good\n---\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: cm-mysql\n  namespace: default\ndata:\n  mysql_port: \"3306\"\n---\napiVersion: v1\nkind: Pod\nmetadata:\n  name: pod-cm-valuefrom\nspec:\n  containers:\n    - name: test-container\n      image: busybox\n      imagePullPolicy: IfNotPresent\n      command: [ \"/bin/sh\", \"-c\", \"env\" ]\n      env:\n        - name: tom\n          value: cat # env环境变量,我们当然可以直接赋值\n        - name: WELCOME\n          valueFrom: # 使用来自cm的key\n            configMapKeyRef:\n              # 指定 包含你要赋给 WELCOME 值 的ConfigMap\n              name: special-config\n              # 指定与取值相关的键名\n              key: hello\n        - name: MYSQL_PORT\n          valueFrom:\n            configMapKeyRef:\n              name: cm-mysql\n              key: mysql-port\n              optional: false  #(1)\n  restartPolicy: Never\n\n\noptional: false 默认是false\n\nfalse:\n\n指定的configmap不存在,则pod无法启动\n指定的key不存在, pod 也无法启动\n\ntrue: 表示如果指定的configmap或key 不存在, 可以启动pod,只不过就是没有用到,key无效\n\n\nk create -f pod-cm-valuefrom.yaml\n# 打印 env 环境变量 ,可以看到 WELCOME = world, MYSQL_PORT等\nk logs pod-cm-valuefrom\n\n\n\n\n\n\n\n\n\nTip\n\n\n\n将configmap里所有的作为环境变量,也是注入的方式, 修改configmap,同样不会同步到pod里\n\n\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: special-config\n  namespace: default\ndata:\n  hello: world\n  python: good\n---\napiVersion: v1\nkind: Pod\nmetadata:\n  name: pod-cm-envfrom\nspec:\n  containers:\n    - name: test-container\n      image: busybox\n      imagePullPolicy: IfNotPresent\n      command: [ \"/bin/sh\", \"-c\", \"env\" ]\n      envFrom:\n1        - prefix: TEST_\n          configMapRef:\n            name: special-config\n2            optional: true\n  restartPolicy: Never\n\n1\n\n环境变量加上前缀\n\n2\n\n默认是false  false: 如果指定的configmap不存在,则pod无法启动true: 表示如果指定的cm 不存在, 可以启动pod,只不过就是没有用到cm\n\n\n\n\n\n\n\nmy.conf\n\nserver {\n    listen       8099;\n    listen       [::]:8099;\n    server_name  _;\n    root         /usr/share/nginx/html;\n    include /etc/nginx/default.d/*.conf;\n    error_page 404 /404.html;\n    location = /404.html {\n    }\n    error_page 500 502 503 504 /50x.html;\n    location = /50x.html {\n    }\n}\n\n# 混合 来创建一个cm\nk create cm cm-nginx-8099 --from-file=my.conf  --from-literal=mysql.port=3306\napiVersion: v1\nkind: Pod\nmetadata:\n  name: cm-vol-1\n  namespace: default\nspec:\n  containers:\n  - image: nginx:alpine\n    name: web-server\n    volumeMounts:\n    - name: vol-cm-nginx-8099 #使用的volume的名称\n      mountPath: /etc/nginx/conf.d/  #挂载到容器里的哪个目录, 挂载后这个目录下原来的所有文件将被删除\n      readOnly: true\n    - name: vol-cm-nginx-8099 #可以挂载到多个目录 ,没有的话,会自动创建目录\n      mountPath: /etc/nginx/abc/\n      readOnly: true\n  volumes:\n  - name: vol-cm-nginx-8099  #volume的名称\n    configMap: # 存储卷类型\n      name: cm-nginx-8099 #cm名字\n      items: #修改挂载到容器里的名称,默认是key名, 有多个key 就有多个文件 (看下面说道的 2个文件软连接 )\n        - key: my.conf #cm里的key名\n          path: my2.conf    # 挂载到容器里的名称 最终是在 上面设置的mountPath /etc/nginx/conf.d/my2.conf\n        - key: mysql.port\n          path: mysql_port\n          mode: 0666 # 单独设置权限\n      defaultMode: 0666  #8进制   挂载到容器里的文件的权限  记得去看软连接的原始文件的权限来验证\nk exec -it configmap-volume-demo -- ls -l /etc/nginx/conf.d\nlrwxrwxrwx    1 root     root  15 Jul 17 14:27 my2.conf -&gt; ..data/my2.conf  内容就是my.conf文件内容\nlrwxrwxrwx    1 root     root  17 Jul 17 14:27 mysql_port -&gt; ..data/mysql_port 内容是3306\n\n\n\n\n\n\nImportant\n\n\n\n\n这种文件挂载的方式, 如果你的configmap修改了,pod里看到的配置也会是修改后的\n不过 这还不行, 你的pod里的程序必须也能够 热加载才行, (就是能监控配置文件的变化,自动重启)",
    "crumbs": [
      "核心概念与实战",
      "配置管理"
    ]
  },
  {
    "objectID": "docs/devops/k8s/core/config.html#configmap",
    "href": "docs/devops/k8s/core/config.html#configmap",
    "title": "斯巴拉稀",
    "section": "",
    "text": "Tip\n\n\n\n\n就是为了配置与代码分离\n不同的pod 里某些东西可能使用相同的配置, 这样只要写一次, pod里直接用就行\nsecret && configmap 可以理解为2中特殊类型的存储卷\nconfigmap存放的时候明文数据\n简称 cm\n\n\n\nconfigmap\nk explain cm\n\n\n\n\n\n\n环境准备\n\ncat &gt;game.properties &lt;&lt;EOF\nenemies=aliens\nlives=3\nenemies.cheat=true\nenemies.cheat.level=noGoodRotten\nsecret.code.passphrase=UUDDLRLRBABAS\nsecret.code.allowed=true\nsecret.code.lives=30\nEOF\ncat &gt;ui.properties&lt;&lt;EOF\ncolor.good=purple\ncolor.bad=yellow\nallow.textmode=true\nhow.nice.to.look=fairlyNice\nEOF\n\ntree\n.\n└── cfg\n    ├── game.properties\n    └── ui.properties\n\n\n\n创建\n\n# 基于目录,就是目录下的所有文件\nk create cm game-all-config --from-file=./cfg/\n# 基于文件 ,默认是default 命名空间, -n 指定\nk create cm ui-config --from-file=./cfg/ui.properties -n test\n# 默认是用文件名作为key, 可以指定\nk create cm ui-config-with-key --from-file=ui=./cfg/ui.properties\n# 基于多个文件\nk create cm game-all-config-with-multi \\\n    --from-file=./cfg/ui.properties \\\n    --from-file=./cfg/game.properties\n\n\n\n\n查看\n\nk get cm #(1)\n\n\n\n执行结果\n\nNAME                  DATA    AGE\ngame-all-config        2      113s\n\n\n\n\n查看某歌配置\n\nk describe cm game-all-config\n\n\nk get cm game-all-config  -o yaml # 查看(2)\n\n\n执行结果\n\napiVersion: v1\ndata:\n  game.properties: |\n    enemies=aliens\n    lives=3\n    enemies.cheat=true\n    enemies.cheat.level=noGoodRotten\n    secret.code.passphrase=UUDDLRLRBABAS\n    secret.code.allowed=true\n    secret.code.lives=30\n  ui.properties: |\n    color.good=purple\n    color.bad=yellow\n    allow.textmode=true\n    how.nice.to.look=fairlyNice\nkind: ConfigMap\nmetadata:\n  creationTimestamp: \"2023-07-17T08:16:36Z\"\n  name: game-config\n  namespace: default\n  resourceVersion: \"906578\"\n  uid: a8341d85-c916-40cd-bb5e-0ef334cc31f6\n\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\n\nEnv 文件包含环境变量列表\n\nEnv 文件中的每一行必须为 VAR=VAL 格式。\n以＃开头的行（即注释）将被忽略。\n空行将被忽略。\n引号不会被特殊处理（即它们将成为 ConfigMap 值的一部分）\n\n\n\n\n\n\n环境准备\n\ncat &gt;game-env-file.properties&lt;&lt;EOF\nenemies=aliens\nlives=3\nallowed=\"true\"\nEOF\n\n\n\n创建\n\n#从 k8s 1.23 版本开始，kubectl 支持多次指定 --from-env-file 参数来从多个数据源创建\nk create cm game-env-file \\\n    --from-env-file=./cfg/game-env-file.properties\n\n\n\n\n查看\n\nk get cm game-env-file -o yaml\n\n\n\n执行结果\n\napiVersion: v1\ndata:\n  allowed: '\"true\"'\n  enemies: aliens\n  lives: \"3\"\nkind: ConfigMap\nmetadata:\n  creationTimestamp: \"2023-07-17T08:43:55Z\"\n  name: game-env-file\n  namespace: default\n  resourceVersion: \"908873\"\n  uid: 5f8c87a6-9af0-4b7b-8ed3-9018667c338f\n\n注意 allowed: ‘“true”’ 的true 数字会用双引号\n\n\n\n\nk create cm mysql-config \\\n    --from-literal=mysql.user=root \\\n    --from-literal=mysql.port=3306\n\n\n\n\n\nmysql-cm.yaml\n\napiVersion: v1\nkind: ConfigMap\nimmutable: true\nmetadata:\n  name: mysql-config2\n  namespace: default\ndata: #同命令创建的 --from-literal=database=test --from-literal=port=3306\n  database: \"test\"\n  port: \"3306\"\n\n\nimmutable: true 设置成不可变\n\n这样你无法通过`k edit cm` 修改\n无法通过修改yaml文件,然后apply -f 或 k replace -f\n可以用`k replace --force -f`\n\n数字必须用引号括起来!!!\n\nk create -f mysql-cm.yaml\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nConfigMap 位于确定的命名空间中. 每个 ConfigMap 只能被同一命名空间中的 Pod 引用\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\n适用于使用几个环境变量, 直接注入,如果你后续修改了configmap, 是不会同步到pod里的\n\n\n\n\npod-cm-valuefrom.yaml\n\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: special-config\n  namespace: default\ndata:\n  hello: world\n  python: good\n---\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: cm-mysql\n  namespace: default\ndata:\n  mysql_port: \"3306\"\n---\napiVersion: v1\nkind: Pod\nmetadata:\n  name: pod-cm-valuefrom\nspec:\n  containers:\n    - name: test-container\n      image: busybox\n      imagePullPolicy: IfNotPresent\n      command: [ \"/bin/sh\", \"-c\", \"env\" ]\n      env:\n        - name: tom\n          value: cat # env环境变量,我们当然可以直接赋值\n        - name: WELCOME\n          valueFrom: # 使用来自cm的key\n            configMapKeyRef:\n              # 指定 包含你要赋给 WELCOME 值 的ConfigMap\n              name: special-config\n              # 指定与取值相关的键名\n              key: hello\n        - name: MYSQL_PORT\n          valueFrom:\n            configMapKeyRef:\n              name: cm-mysql\n              key: mysql-port\n              optional: false  #(1)\n  restartPolicy: Never\n\n\noptional: false 默认是false\n\nfalse:\n\n指定的configmap不存在,则pod无法启动\n指定的key不存在, pod 也无法启动\n\ntrue: 表示如果指定的configmap或key 不存在, 可以启动pod,只不过就是没有用到,key无效\n\n\nk create -f pod-cm-valuefrom.yaml\n# 打印 env 环境变量 ,可以看到 WELCOME = world, MYSQL_PORT等\nk logs pod-cm-valuefrom\n\n\n\n\n\n\n\n\n\nTip\n\n\n\n将configmap里所有的作为环境变量,也是注入的方式, 修改configmap,同样不会同步到pod里\n\n\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: special-config\n  namespace: default\ndata:\n  hello: world\n  python: good\n---\napiVersion: v1\nkind: Pod\nmetadata:\n  name: pod-cm-envfrom\nspec:\n  containers:\n    - name: test-container\n      image: busybox\n      imagePullPolicy: IfNotPresent\n      command: [ \"/bin/sh\", \"-c\", \"env\" ]\n      envFrom:\n1        - prefix: TEST_\n          configMapRef:\n            name: special-config\n2            optional: true\n  restartPolicy: Never\n\n1\n\n环境变量加上前缀\n\n2\n\n默认是false  false: 如果指定的configmap不存在,则pod无法启动true: 表示如果指定的cm 不存在, 可以启动pod,只不过就是没有用到cm\n\n\n\n\n\n\n\nmy.conf\n\nserver {\n    listen       8099;\n    listen       [::]:8099;\n    server_name  _;\n    root         /usr/share/nginx/html;\n    include /etc/nginx/default.d/*.conf;\n    error_page 404 /404.html;\n    location = /404.html {\n    }\n    error_page 500 502 503 504 /50x.html;\n    location = /50x.html {\n    }\n}\n\n# 混合 来创建一个cm\nk create cm cm-nginx-8099 --from-file=my.conf  --from-literal=mysql.port=3306\napiVersion: v1\nkind: Pod\nmetadata:\n  name: cm-vol-1\n  namespace: default\nspec:\n  containers:\n  - image: nginx:alpine\n    name: web-server\n    volumeMounts:\n    - name: vol-cm-nginx-8099 #使用的volume的名称\n      mountPath: /etc/nginx/conf.d/  #挂载到容器里的哪个目录, 挂载后这个目录下原来的所有文件将被删除\n      readOnly: true\n    - name: vol-cm-nginx-8099 #可以挂载到多个目录 ,没有的话,会自动创建目录\n      mountPath: /etc/nginx/abc/\n      readOnly: true\n  volumes:\n  - name: vol-cm-nginx-8099  #volume的名称\n    configMap: # 存储卷类型\n      name: cm-nginx-8099 #cm名字\n      items: #修改挂载到容器里的名称,默认是key名, 有多个key 就有多个文件 (看下面说道的 2个文件软连接 )\n        - key: my.conf #cm里的key名\n          path: my2.conf    # 挂载到容器里的名称 最终是在 上面设置的mountPath /etc/nginx/conf.d/my2.conf\n        - key: mysql.port\n          path: mysql_port\n          mode: 0666 # 单独设置权限\n      defaultMode: 0666  #8进制   挂载到容器里的文件的权限  记得去看软连接的原始文件的权限来验证\nk exec -it configmap-volume-demo -- ls -l /etc/nginx/conf.d\nlrwxrwxrwx    1 root     root  15 Jul 17 14:27 my2.conf -&gt; ..data/my2.conf  内容就是my.conf文件内容\nlrwxrwxrwx    1 root     root  17 Jul 17 14:27 mysql_port -&gt; ..data/mysql_port 内容是3306\n\n\n\n\n\n\nImportant\n\n\n\n\n这种文件挂载的方式, 如果你的configmap修改了,pod里看到的配置也会是修改后的\n不过 这还不行, 你的pod里的程序必须也能够 热加载才行, (就是能监控配置文件的变化,自动重启)",
    "crumbs": [
      "核心概念与实战",
      "配置管理"
    ]
  },
  {
    "objectID": "docs/devops/k8s/core/config.html#secret",
    "href": "docs/devops/k8s/core/config.html#secret",
    "title": "斯巴拉稀",
    "section": "2 secret",
    "text": "2 secret\n官方文档\n\n\n\n\n\n\nTip\n\n\n\n\n由于configmap 是明文, 因此与configmap 有着同样功能的 secret 就相应的设计出来了\n使用方法与 configmap 类似,在yaml文件上把configmap 改成 secret,大部分就ok了\n\n\n\n\n\n\n\n\n\nsecret 的类型\n\n\n\n\n\n\n\n\n\n\n\n\n类型\n描述\n\n\n\n\nOpaque\n通用型Secret,用户自定义，默认类型\n\n\nkubernetes.io/service-account-token\n作用于ServiceAccount，包含一个令牌，用于标识API服务账户\n\n\nkubernetes.io/dockercfg\nserialized ~/.dockercfg file\n\n\nkubernetes.io/dockerconfigjson\n下载私有仓库镜像使用的Secret, 和宿主机的 ~/.docker/config.json一致 ,宿主机docker login后即可产生该文件\n\n\nkubernetes.io/basic-auth\n用于使用基本认证(账号密码)的Secret，可以使用Opaque取代\n\n\nkubernetes.io/ssh-auth\n用于存储ssh密钥的Secret\n\n\nkubernetes.io/tls\n用于存储HTTPS域名证书文件的Secret，可以被Ingress使用\n\n\nbootstrap.kubernetes.io/token\n一种简单的 bearer token,用于创建新集群或将新节点添加到现有集群,在集群安装时可用于自动颁发集群的证书\n\n\n\n\n\n\nkubectl create secret generic mysql-root-password \\\n    --from-literal=password=123456  \\\n    --from-literal=username=root\n\nk get secret\n\n\n我们可以看到这个 secret 的类型是 Opaque\n\nNAME                  TYPE    DATA   AGE\nmysql-root-password   Opaque  2      12s\n\n\n\nk describe secrets  mysql-root-password\n\n\nData 里只显示几个字节!\n\nName:         mysql-root-password\nNamespace:    default\nLabels:       &lt;none&gt;\nAnnotations:  &lt;none&gt;\n\nType:  Opaque\n\nData\n====\npassword:  6 bytes\nusername:  4 bytes\n\n\n\nk get secrets mysql-root-password  -o yaml\n\n\nData 显示的是加密的\n\napiVersion: v1\ndata:\n  password: MTIzNDU2\n  username: cm9vdA==\nkind: Secret\nmetadata:\n  creationTimestamp: \"2023-07-18T01:56:16Z\"\n  name: mysql-root-password\n  namespace: default\n  resourceVersion: \"941954\"\n  uid: 51b42a5f-02c8-4cc1-a482-2c6c0eceb3eb\ntype: Opaque\n\n# 然而那这个加密仅仅是base64 可以解密\n# 能够得到 密码 123456\necho MTIzNDU2 |base64 -d\n\n#文件形式创建\ncat user.txt\n    root\ncat pass.txt\n    123456\nkubectl create secret generic mysql-root-password2 --from-file=user.txt --from-file=pass.txt",
    "crumbs": [
      "核心概念与实战",
      "配置管理"
    ]
  },
  {
    "objectID": "docs/devops/k8s/core/config.html#注意",
    "href": "docs/devops/k8s/core/config.html#注意",
    "title": "斯巴拉稀",
    "section": "3 注意",
    "text": "3 注意\n\n我们一般是用配置文件来创建configmap\n前面提到过,真正的热更新,还需要程序检测自动重启的支持\n使用envFrom和valueFrom是无法更新环境变量的, 环境变量是启动容器就定了的.需要重启容器",
    "crumbs": [
      "核心概念与实战",
      "配置管理"
    ]
  },
  {
    "objectID": "docs/devops/k8s/core/api-resource.html",
    "href": "docs/devops/k8s/core/api-resource.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "Important\n\n\n\n本机(安装kubectl并配置可访问k8s的任何机器)代理到apiserver\nk proxy --accept-hosts=\".*\" --address=0.0.0.0\n# 这样可以直接访问\ncurl localhost:8001/api/v1/namespaces",
    "crumbs": [
      "核心概念与实战",
      "API资源"
    ]
  },
  {
    "objectID": "docs/devops/k8s/core/api-resource.html#api组织方式",
    "href": "docs/devops/k8s/core/api-resource.html#api组织方式",
    "title": "斯巴拉稀",
    "section": "1 API组织方式",
    "text": "1 API组织方式\n\n\n核心对象非核心对象\n\n\n\n\n\n\n\n\nTip\n\n\n\n支撑k8s最基本功能的对象,比如pod, group是空\n\n\napiVersion: v1\nkind: Pod\nmetadata:\n  name: nginx\n  namespace: test\n  labels:\n    app: nginx\nspec:\n  containers:\n  - name: nginx1\n    image: nginx:1.14.2\n    imagePullPolicy: IfNotPresent\n\n\n\n\n\n\n\n\nNote\n\n\n\n比如应用部署有关的对象,deployment,group是apps\n\n\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: deploy-nginx\n  labels:\n    app: nginx\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: pod-deploy-nginx\n  template:\n    metadata:\n      labels:\n        app: pod-deploy-nginx\n    spec:\n      containers:\n      - name: c-deploy-nginx\n        image: nginx:1.14.2\n        ports:\n        - containerPort: 80",
    "crumbs": [
      "核心概念与实战",
      "API资源"
    ]
  },
  {
    "objectID": "docs/devops/k8s/core/api-resource.html#属性",
    "href": "docs/devops/k8s/core/api-resource.html#属性",
    "title": "斯巴拉稀",
    "section": "2 属性",
    "text": "2 属性",
    "crumbs": [
      "核心概念与实战",
      "API资源"
    ]
  },
  {
    "objectID": "docs/devops/k8s/core/service/service.html#为什么有这个设计",
    "href": "docs/devops/k8s/core/service/service.html#为什么有这个设计",
    "title": "斯巴拉稀",
    "section": "1 为什么有这个设计",
    "text": "1 为什么有这个设计\n\n\n\n\n\n\nTip\n\n\n\n我们前面这个那个的pod 各种搞, 是时候让外面的用户来访问我们通过pod 提供的服务了\n\n\n\n\n\n\n\n\n为什么?\n\n\n\n\n像deploy 部署的一组pod 为我们提供服务, 如果其中一个pod 重建了,ip修改了, 如何访问到呢?\n就像我们去就餐, 我们不需要知道具体为你提供服务的人的名字, 只需要叫服务员,就会有人来提供服务.\n\n\n\n就是很多pod在前端的一个负载均衡调度器 service 先到的endpoint controller 然后通过找到对应的pod",
    "crumbs": [
      "核心概念与实战",
      "服务",
      "service"
    ]
  },
  {
    "objectID": "docs/devops/k8s/core/service/service.html#clusterip",
    "href": "docs/devops/k8s/core/service/service.html#clusterip",
    "title": "斯巴拉稀",
    "section": "2 clusterIP",
    "text": "2 clusterIP\n\n\n\n\n\n\nTip\n\n\n\nService的默认类型，服务被发布至仅集群内部可见的虚拟IP地址上\n\n\n\n\ndeploy-nginx2.yaml\n\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  labels:\n    app: deploy-nginx\n  name: deploy-nginx2\nspec:\n  replicas: 2\n  revisionHistoryLimit: 10\n  selector:\n    matchLabels:\n      app: pod-deploy-nginx2\n  strategy:\n    rollingUpdate:\n      maxSurge: 1\n      maxUnavailable: 1\n    type: RollingUpdate\n  template:\n    metadata:\n       labels:\n        app: pod-deploy-nginx2\n    spec:\n       restartPolicy: Always\n       containers:\n       - image: nginx:1.14.2-alpine\n         imagePullPolicy: IfNotPresent\n         name: c-deploy-nginx\n         ports:\n         - containerPort: 80\n           name: web\n           protocol: TCP\n\nk apply -f deploy-nginx2.yaml\n\n\nsvc-deploy-nginx.yaml\n\nkind: Service\napiVersion: v1\nmetadata:\n  name: svc-deploy-nginx\nspec:\n  selector: # 关联哪些 pod ,上面我们deploy 创建的pod 就有这个标签\n    app: pod-deploy-nginx2\n # clusterIP: 10.96.1.11 # 可以指定一个你要的ip,默认是随机分配的一个\n  type: ClusterIP\n  ports:\n  - protocol: TCP\n    port: 8800   # service 端口\n    targetPort: web  # 想要关联的pod 它们暴露的端口  可以写80 , 或者像这样 使用上面pod定义的端口名称\n\n# 创建 svc, 必须和pod 在同一个namespace\nk apply -f svc-deploy-nginx.yaml\nk get svc\n    NAME               TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)   AGE\n    svc-deploy-nginx   ClusterIP   10.99.229.242   &lt;none&gt;        80/TCP    6m38s\n# 服务选择pod的控制器不断扫描与标签选择匹配的 Pod，然后将所有更新发布到也称为 “svc-deploy-nginx” 同名的 Endpoint 对象\n# ep endpoint\nk get ep\n    NAME               ENDPOINTS                       AGE\n    svc-deploy-nginx   10.244.1.77:80,10.244.2.78:80   2m59s\n# 同名ep中关联的2个 ip地址 正是 2个pod的ip\nk get po -l app=pod-deploy-nginx2 -o wide\n    NAME                             READY   STATUS    RESTARTS   AGE   IP            NODE\n    deploy-nginx2-57cfcdb8c7-6nhzj   1/1     Running   0          11m   10.244.2.78   node2\n    deploy-nginx2-57cfcdb8c7-sqpr4   1/1     Running   0          11m   10.244.1.77   node1\n\n# 直接访问 svc的ip和端口 ,就能访问到后面实际pod里的nginx 服务了. 而且负载均衡\n# 访问svc, 会通过ep 找到对应的pod ip地址\ncurl 10.99.229.242:8800\n\n# 进入pod 容器\ncat /etc/resolv.conf\n    nameserver 10.96.0.10\n    search default.svc.cluster.local svc.cluster.local cluster.local\n    options ndots:5\nping svc-deploy-nginx\nwget svc-deploy-nginx:8800 #ok的\nwget svc-deploy-nginx.default.svc.cluster.local:8800\n# 删除pod 后, deploy 重建了pod ,然后ep 会重现关联新的pod ip\n\n# 删除svc 会将关联的ep也删除\n\n\nsvc-nginx-multi-port.yaml\n\nkind: Service\napiVersion: v1\nmetadata:\n  name: svc-nginx-multi-port\nspec:\n  selector:\n    app: pod-deploy-nginx\n  type: ClusterIP\n  ports:\n  - protocol: TCP\n    port: 80\n    targetPort: web\n  - protocol: TCP\n    port: 8080\n    targetPort: web2",
    "crumbs": [
      "核心概念与实战",
      "服务",
      "service"
    ]
  },
  {
    "objectID": "docs/devops/k8s/core/service/service.html#nodeport",
    "href": "docs/devops/k8s/core/service/service.html#nodeport",
    "title": "斯巴拉稀",
    "section": "3 nodePort",
    "text": "3 nodePort\nClusterIP 只能在集群内部访问 (默认)\n映射一个端口 给node, 外部可以直接访问node的端口\n\n\nsvc-nginx-node-port.yaml\n\nkind: Service\napiVersion: v1\nmetadata:\n  name: svc-nginx-node-port\nspec:\n  selector:\n    app: pod-deploy-nginx2\n # clusterIP: 10.96.1.11 # 可以指定一个你要的ip,默认是随机分配的一个\n  type: NodePort\n  ports:\n  - protocol: TCP\n    port: 80\n    targetPort: web\n    #nodePort: 30192 # 可以指定 也可以不写, 不写就会随机\n\n# 看到随机端口\nk get svc\n    NAME                  TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)        AGE\n    svc-nginx-node-port   NodePort    10.105.50.239   &lt;none&gt;        80:30046/TCP   1s\n\nk get no -o wide\n# 现在可以用任意一个node 的ip :30046 来访问pod服务\n\n\n\n\n\n\n控制随机使用的nodePort\n\n\n\n\n/etc/kubernetes/manifests/kube-apiserver.yaml\n在spec.containers.command 最后一行添加,比如- --service-node-port-range=40000-40100\n等待 kube-apiserver 重启完成,稍微等等, systemctl status kubelet",
    "crumbs": [
      "核心概念与实战",
      "服务",
      "service"
    ]
  },
  {
    "objectID": "docs/devops/k8s/core/service/service.html#代理-k8s-外部应用",
    "href": "docs/devops/k8s/core/service/service.html#代理-k8s-外部应用",
    "title": "斯巴拉稀",
    "section": "4 代理 k8s 外部应用",
    "text": "4 代理 k8s 外部应用\n\n\n\n\n\n\nTip\n\n\n\n\n比如我们一个golang web服务, 需要连接外部的mysql或redis ,这就需要维护它们的ip地址\n我们希望在生产环境中使用某个固定的名称而非IP地址来访问这些外部的中间件服务\n某个项目正在迁移至k8s集群，但是一部分服务仍然在集群外部，此时可以使用service代理至 k8s 集群外部的服务 - 假定一个场景. 我们要从原先传统的服务迁移到k8s, a服务和b服务, 里面a访问b 是直接用的ip地址比如192.168.1.100:8080 (比如在a的配置文件里有这个ip地址 ) - 我们先迁移了a, b服务暂时还在外部,未来某一个时间可能才会迁移到k8s, 我们大概就会修改a的配置里的b ip地址, 过段时间 b迁移到 k8s,我们又要修改 这个ip地址, 然后重启 a服务,,, 我们不想要这么麻烦,\n\n\n\n\n\nsvc-nginx-external.yaml\n\napiVersion: v1\nkind: Service\nmetadata:\n  labels:\n   app: svc-nginx-external\n  name: svc-nginx-external\nspec:\n  ports:\n  - name: abc # 注意如果用了name,那么你ep里的ports name必须和这个一样\n    port: 80\n    protocol: TCP\n    targetPort: 80 # 后端pod提供服务的端口, 后面ep配置里的ip地址提供的服务的端口\n  type: ClusterIP\n\nkubectl apply -f svc-nginx-external.yaml\n# 查看是否有关联的ep , 这里我们还没关联ep\nk describe svc svc-nginx-external |grep -i endpoint\n# kubectl get ep 是没有自动创建的. 因为我们创建的svc没有没有selector, 就没关联pod\n# 之所以我们以前能通过svc  访问到 pod 的ip ,是根据 ep的设置\n# 那么现在我们手动创建一个ep,让ep指向外部的ip ,不就行了.\n\n\n\nep-single.yaml\n\napiVersion: v1\nkind: Endpoints\nmetadata:\n  name: svc-nginx-external\n  namespace: default\nsubsets:\n- addresses:\n  - ip: 10.244.1.79 # 写上你外部服务的ip, 我这里直接用pod的ip来测试\n  - ip: 10.244.2.81\n  ports:\n  - port: 80 # 外部服务的端口\n    name: abc\n\nk apply -f ep-single.yaml\n# 有了 关联的ep了\nk get svc svc-nginx-external |grep -i endpoint\n\n\n\n\n\n\n之前弄完后一直连接不了\n\n\n\n原因是 svc ports 里设置了name, ep里没有设置, 必须设置,且name名字一样才可以.",
    "crumbs": [
      "核心概念与实战",
      "服务",
      "service"
    ]
  },
  {
    "objectID": "docs/devops/k8s/core/service/service.html#externalname",
    "href": "docs/devops/k8s/core/service/service.html#externalname",
    "title": "斯巴拉稀",
    "section": "5 ExternalName",
    "text": "5 ExternalName\n\n5.1 外部域名\n\n\n\n\n\n\nTip\n\n\n\n\n通过svc访问外部的域名(就是给外部服务域名起一个别名)\nports 字段设置是无效的,因为这里就是域名的映射\n\n\n\nkind: Service\napiVersion: v1\nmetadata:\n  name: svc-external-name-baidu\nspec:\n  type: ExternalName\n  externalName: www.baidu.com\nk get svc\n    NAME                 TYPE           CLUSTER-IP      EXTERNAL-IP     PORT(S)        AGE\n    svc-external-name-baidu   ExternalName   &lt;none&gt;          www.baidu.com   &lt;none&gt;       6s\n\n# 进入一个容器.\nkubectl exec -it dep-nginx-cc78676bc-ncrxb -- ping svc-external-name-baidu\n\n\n5.2 内部svc 起个别名\n\nkind: Service\napiVersion: v1\nmetadata:\n  name: svc-external-name-another-svc\n  namespace: test\nspec:\n  type: ExternalName\n  # 这里写我们已经创建的svc的name, 作为已经它的一个svc别名\n  #externalName: svc-deploy-nginx.default.svc.cluster.local 这里这样 就相当于给不同ns的svc 起个别名一样.\n  # 要全, svc.cluster.local 不能省略, 本身全的 ,你在哪个ns下的pod 都能访问 ,每个pod里的 /etc/resolv.conf\n  externalName: svc-deploy-nginx.default.svc.cluster.local\n# 首先 pod 里能通过 svc-deploy-nginx 访问\nk exec -it deploy-nginx2-667f55f99f-frtxh -- wget svc-deploy-nginx:8800\n# test 命名空间下的pod里访问default命名空间下的 svc name, 你需要 指定 命名空间, .default\nk exec -n test -it deploy-nginx-test-65cb6bf5f6-8mrxw -- wget svc-deploy-nginx.default:8800\n# 直接访问, 其它namespace的svc 的别名, 就不需要带上 namespace\nk exec -n test deploy-nginx-test-65cb6bf5f6-8mrxw  -- wget svc-external-name-another-svc:8800\n\n\n5.3 headless svc\n\n\nsvc-headless-nginx.yaml\n\napiVersion: v1\nkind: Service\nmetadata:\n  name: svc-headless-nginx\n  labels:\n    app: svc-headless-nginx\nspec:\n  ports:\n  - port: 80\n    name: web\n#它的 clusterIP 字段的值是:None，即:这个 Service，没有一个 VIP 作为“头”。 \n#这也就是 Headless 的含义。所以，这个 Service 被创建后并不会被分配一个 VIP，\n#而是会 以 DNS 记录的方式暴露出它所代理的 Pod。\n  clusterIP: None\n  selector:\n    app: pod-deploy-nginx2\n\nk get svc\n    NAME                      TYPE           CLUSTER-IP       EXTERNAL-IP     PORT(S)    AGE\n    svc-headless-nginx        ClusterIP      None             &lt;none&gt;          80/TCP     1s\n\nk get ep\n    NAME                  ENDPOINTS                       AGE\n    svc-headless-nginx    10.244.1.82:80,10.244.2.81:80   11s\n\n# 每次都会直接 ping 为 后端某一个pod的ip ,就是ep上设置的某一个ip\nk exec deploy-nginx2-667f55f99f-frtxh -- ping svc-headless-nginx",
    "crumbs": [
      "核心概念与实战",
      "服务",
      "service"
    ]
  },
  {
    "objectID": "docs/devops/k8s/core/service/service.html#几个注意的问题",
    "href": "docs/devops/k8s/core/service/service.html#几个注意的问题",
    "title": "斯巴拉稀",
    "section": "6 几个注意的问题",
    "text": "6 几个注意的问题\n\n6.1 pod 健康检查失败\n\n\n\n\n\n\nTip\n\n\n\n前面我们说过, pod 就绪探针失败, 会将pod 切断流量\n\n\n\n\nsvc-pod-readiness.yaml\n\napiVersion: v1\nkind: Pod\nmetadata:\n  labels:\n    test: pod-readiness-liveness\n  name: pod-readiness-liveness\nspec:\n  containers:\n  - name: c-readiness-liveness\n    image: busybox\n    imagePullPolicy: IfNotPresent\n    args:\n    - /bin/sh\n    - -c\n    - touch /tmp/healthy; sleep 30; rm -f /tmp/healthy; sleep 600\n    readinessProbe:\n      exec:\n        command:\n        - sh\n        - -c\n        - cat /tmp/healthy\n      initialDelaySeconds: 5\n      periodSeconds: 5\n      timeoutSeconds: 1\n      successThreshold: 1\n      failureThreshold: 3\n---\n\nkind: Service\napiVersion: v1\nmetadata:\n  name: svc-pod-readiness\nspec:\n  selector:\n    test: pod-readiness-liveness\n  type: ClusterIP\n  ports:\n  - protocol: TCP\n    port: 80\n    targetPort: 80\n\n#k apply  -f  svc-pod-readiness.yaml -l test=pod-readiness-liveness\n#k delete -f svc-pod-readiness.yaml  -l test=pod-readiness-liveness\nk apply -f svc-pod-readiness.yaml\nk get ep # 一开始是有的, 过了一段时间, pod 变成 不 ready了, ep里就删除了该pod ip\n\n\n6.2 svc指定的selector 没有pod\nkind: Service\napiVersion: v1\nmetadata:\n  name: svc-selector-no-pod\nspec:\n  selector:\n    app: pod-deploy-nginx3\n  type: ClusterIP\n  ports:\n  - protocol: TCP\n    port: 8800\n    targetPort: 80\n\n\n\n\n\n\nTip\n\n\n\n会创建同名的ep, 只是ep里的ENDPOINTS 没有ip,是空的.\n\n\nk get ep\n    NAME                  ENDPOINTS                       AGE\n    svc-selector-no-pod   &lt;none&gt;                          82s",
    "crumbs": [
      "核心概念与实战",
      "服务",
      "service"
    ]
  },
  {
    "objectID": "docs/devops/k8s/core/service/ingress.html",
    "href": "docs/devops/k8s/core/service/ingress.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "外部访问我们的pod提供的服务, 怎么办?\n直接使用svc 不行吗? 直接 nodePort类型?\n需要搞好多端口, 管理麻烦",
    "crumbs": [
      "核心概念与实战",
      "服务",
      "ingress"
    ]
  },
  {
    "objectID": "docs/devops/k8s/core/service/ingress.html#为什么需要",
    "href": "docs/devops/k8s/core/service/ingress.html#为什么需要",
    "title": "斯巴拉稀",
    "section": "",
    "text": "外部访问我们的pod提供的服务, 怎么办?\n直接使用svc 不行吗? 直接 nodePort类型?\n需要搞好多端口, 管理麻烦",
    "crumbs": [
      "核心概念与实战",
      "服务",
      "ingress"
    ]
  },
  {
    "objectID": "docs/devops/k8s/core/service/ingress.html#介绍",
    "href": "docs/devops/k8s/core/service/ingress.html#介绍",
    "title": "斯巴拉稀",
    "section": "2 介绍",
    "text": "2 介绍\ningress 用于实现 用域名的方式访问 k8s 内部应用\ningress 为k8s集群中的服务提供了入口, 可以提供负载均衡、SsL终止和基于域名的虚拟主机、应用的灰度发布等功能",
    "crumbs": [
      "核心概念与实战",
      "服务",
      "ingress"
    ]
  },
  {
    "objectID": "docs/devops/k8s/core/service/ingress.html#实战",
    "href": "docs/devops/k8s/core/service/ingress.html#实战",
    "title": "斯巴拉稀",
    "section": "3 实战",
    "text": "3 实战\n部署 手动安装k8s集群的系统部署方式\nwget https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.8.1/deploy/static/provider/baremetal/deploy.yaml\n\nkubectl apply -f  deploy.yaml",
    "crumbs": [
      "核心概念与实战",
      "服务",
      "ingress"
    ]
  },
  {
    "objectID": "docs/devops/k8s/core/pod.html",
    "href": "docs/devops/k8s/core/pod.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "它由一组、一个或多个容器组成， 每个容器都有自己的 pid mount user 每个Pod还包含了一个Pause容器，Pause容器是Pod的父容器，基础容器, 主要负责僵尸进程的回收管理 pod里的每个容器都继承该容器, 通过Pause容器可以使同一个Pod里面的多个容器共享存储、网络、PID、IPC等\npod里的容器 IPC,UTS,network 就是共享的. pid 是否需要共享需要设置\n\n\n\n\n\n\nTip\n\n\n\n把pod 看成一台计算机, 容器看成里面的进程",
    "crumbs": [
      "核心概念与实战",
      "pod"
    ]
  },
  {
    "objectID": "docs/devops/k8s/core/pod.html#什么是pod",
    "href": "docs/devops/k8s/core/pod.html#什么是pod",
    "title": "斯巴拉稀",
    "section": "",
    "text": "它由一组、一个或多个容器组成， 每个容器都有自己的 pid mount user 每个Pod还包含了一个Pause容器，Pause容器是Pod的父容器，基础容器, 主要负责僵尸进程的回收管理 pod里的每个容器都继承该容器, 通过Pause容器可以使同一个Pod里面的多个容器共享存储、网络、PID、IPC等\npod里的容器 IPC,UTS,network 就是共享的. pid 是否需要共享需要设置\n\n\n\n\n\n\nTip\n\n\n\n把pod 看成一台计算机, 容器看成里面的进程",
    "crumbs": [
      "核心概念与实战",
      "pod"
    ]
  },
  {
    "objectID": "docs/devops/k8s/core/pod.html#为什么引入pod",
    "href": "docs/devops/k8s/core/pod.html#为什么引入pod",
    "title": "斯巴拉稀",
    "section": "2 为什么引入pod",
    "text": "2 为什么引入pod\n强依赖的服务需要部署在一起 nginx 与php,多个服务需要相互协作,pod内容器之间用localhost:port来访问彼此,因为他们共用一个网络空间\n兼容其他cri标准",
    "crumbs": [
      "核心概念与实战",
      "pod"
    ]
  },
  {
    "objectID": "docs/devops/k8s/core/pod.html#pod的yaml定义",
    "href": "docs/devops/k8s/core/pod.html#pod的yaml定义",
    "title": "斯巴拉稀",
    "section": "3 pod的yaml定义",
    "text": "3 pod的yaml定义\n\n\n\n\n\n\nWarning\n\n\n\n\n下面这个pod, 会有一个容器启动失败的,因为80端口已经有被占用\nnginx1 执行完后退出\nnginx2 ok, 使用pod ip的端口80\nnginx3 发现80 端口被占用…\n\n\n\n1apiVersion: v1\n2kind: Pod\nmetadata:\n3  name: nginx\n4  namespace: test\n5  labels:\n    app: nginx\n6spec:\n  containers:\n  - name: nginx1\n    image: nginx:1.14.2\n7    imagePullPolicy: IfNotPresent\n8    securityContext:\n      privileged: true\n9    env:\n    - name: HELLO\n      value: world\n    ports:\n    - containerPort: 80\n      hostPort: 8901\n10    command: ['echo']\n11    args: [\"$(HELLO)\"]\n12    workingDir: /test\n13    resources:\n      requests:\n        memory: \"64Mi\"\n        cpu: \"250m\"\n      limits:\n        memory: \"128Mi\"\n        cpu: \"500m\"\n  - name: nginx2\n    image: nginx:1.14.2\n    imagePullPolicy: IfNotPresent\n    ports:\n    - containerPort: 80\n      hostPort: 8901\n  - name: nginx3\n    image: nginx:1.14.2\n    imagePullPolicy: IfNotPresent\n14    ports:\n    - containerPort: 80\n      hostPort: 8902\n15  hostAliases:\n  - ip: \"180.101.50.188\"\n    hostnames:\n    - \"abc\"\n    - \"baidu\"\n16  restartPolicy: Never\n  # hostNetwork: true\n17  dnsPolicy: Default\n  dnsConfig:\n    nameservers:\n      - 8.8.8.8\n\n1\n\n版本\n\n2\n\n资源类型\n\n3\n\npod的名字\n\n4\n\n命名空间,不指定的话,默认是default, 指定的话,这个命名空间必须存在\n\n5\n\n标签,可以多个, 将来用来过滤选择指定pod\n\n6\n\nspec : specification 表示规格,规范,明细单,指定pod里创建什么样的容器\n\n7\n\n镜像拉取策略\n\n8\n\n这个表示特权模式,相当于用root 执行security-context\n\n9\n\n设置环境变量, 通过env设置的环境变量将覆盖容器镜像中指定的所有环境变量\n\n10\n\n相当于dockerfile里的entrypoint, 可以修改容器的启动命令,如果未提供，则使用镜像的 ENTRYPOINT\n\n11\n\n相当于dockerfile里的CMD,传递参数,如果未提供，则使用镜像的 CMD,这里我们使用了上面配置的环境变量\n\n12\n\ndockerfile中的Dir ,如果未指定，将使用容器的默认值\n\n13\n\n对容器资源的要求和限制,调度的时候会看你的需求再选择合适的节点\n\n14\n\nports端口\n\n15\n\n前面是的pod里容器的配置,这里是pod的其他配置, 与containers 平级\n\n16\n\n容器重启策略\n\n17\n\npod的dns策略\n\n\nk get po -n test\n  NAME    READY   STATUS     RESTARTS   AGE\n  nginx   1/3     NotReady   0          9m43s\nk logs nginx nginx1 -n test\n  world\nk logs nginx nginx3 -n test\n  0.0.0.0:80 failed (98: Address already in use)",
    "crumbs": [
      "核心概念与实战",
      "pod"
    ]
  },
  {
    "objectID": "docs/devops/k8s/core/pod.html#探针",
    "href": "docs/devops/k8s/core/pod.html#探针",
    "title": "斯巴拉稀",
    "section": "4 探针",
    "text": "4 探针\n\n4.1 LivenessProbe 存活探针\n\n用于探测容器是否正常运行\n若没有配置该探针，默认就是success.\n配置后如果 探测失败,kubelet会杀死容器,并根据重启策略做相应的处理\n\n基于官方代码修改\n\n\nliveness.go\n\npackage main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"net/http\"\n    \"time\"\n\n)\n\nfunc main() {\n    started := time.Now()\n    http.HandleFunc(\"/started\", func(w http.ResponseWriter, r *http.Request) {\n        w.WriteHeader(200)\n        data := (time.Since(started)).String()\n        w.Write([]byte(data))\n    })\n    http.HandleFunc(\"/healthz\", func(w http.ResponseWriter, r *http.Request) {\n        duration := time.Since(started)\n        if duration.Seconds() &gt; 30 {\n            w.WriteHeader(500)\n            w.Write([]byte(fmt.Sprintf(\"error: %v\", duration.Seconds())))\n        } else {\n            w.WriteHeader(200)\n            w.Write([]byte(\"ok\"))\n        }\n    })\n    log.Fatal(http.ListenAndServe(\":8080\", nil))\n}\n\nFROM golang:alpine as base\nWORKDIR /test\nCOPY . .\nRUN go env -w GOPROXY=https://goproxy.cn,http://mirrors.aliyun.com/goproxy/,https://goproxy.io,direct \\\n    && go mod init go-liveness \\\n    && go mod tidy \\\n    && go build\nFROM alpine:3.16\nCOPY --from=base /test/go-liveness /go-liveness\nEXPOSE 8080\nCMD [\"/go-liveness\"]\napiVersion: v1\nkind: Pod\nmetadata:\n  labels:\n    test: liveness\n  name: liveness-exec\n  namespace: test\nspec:\n  imagePullSecrets:\n  - name: regcred3\n  containers:\n  - name: go-liveness\n    image: hb.6o6.com/6o6/go-liveness\n    imagePullPolicy: IfNotPresent\n    livenessProbe:\n      httpGet: \n        path: /healthz\n        port: 8080\n        httpHeaders:\n        - name: Custom-Header\n          value: Awesome\n      initialDelaySeconds: 5\n      periodSeconds: 5\n      timeoutSeconds: 1\n      successThreshold: 1\n      failureThreshold: 3\n\n\n容器启动后要等待多少秒后才启动存活和就绪探测器\n执行探测的时间间隔(单位是秒),默认是 10 秒.最小值是 1. 这里每隔5s就执行一次探测\n探测的超时后等待多少秒。默认值是 1 秒。最小值是 1\n探测器在失败后，被视为成功的最小连续成功数。默认值是 1。 存活和启动探测的这个值必须是 1。最小值是 1\n当探测失败时，Kubernetes 的重试次数。 对存活探测而言，放弃就意味着重新启动容器。 对就绪探测而言，放弃意味着 Pod 会被打上未就绪的标签。默认值是 3。最小值是 1\n\n\n\n\n\n\n\nNote\n\n\n\n存活探针会不断的去探测. 像服务心跳包, 像 icu的心电图一样. 如果探测失败,根据你的restartPolicy 做相应的操作\n\n\n\n\n4.2 ReadinessProbe 就绪探针\n\n\n\n\n\n\nWarning\n\n\n\n\n就绪探针也会不断的去探测, 如果探测失败, 不会重启容器,这是因为就绪探针的目的是看pod是否准备完毕,是否可以提供服务了,探测失败只是说它还没准备好\nk get po READY 显示0/1, 容器所在 Pod 上报还未就绪的信息，并且不接受通过 Kubernetes Service(svc,后续会说到) 的流量,就是不提供服务了. Endpoints Controller将从所有的Service的Endpoints 中删除此容器所在Pod的IP地址(这个后续说)\n就绪探针返回成功，这个容器已经完成启动，并且程序已经是可以接受流量的状态 ,就是可以处理请求了, 会通知Kubernetes该容器已经可以接收流量。这样可以确保在容器完全就绪之前，不会将流量路由到该容器，避免了流量过早进入不稳定的容器\n主要的作用就是 我什么时候认为这个pod 可以提供服务了,可以处理请求了. (比如nginx web服务器负载均衡, 你这个pod是否可以接收流量了.)\n\n\n\n\n\npod-no-probe-nginx-sleep.yaml\n\napiVersion: v1\nkind: Pod\nmetadata:\n  labels:\n    run: nginx-test\n  name: nginx-test\n  namespace: test\nspec:\n  containers:\n  - image: nginx:1.14.2\n    name: nginx-test\n    command:\n    - sh\n    - -c\n    - sleep 30;nginx -g \"daemon off;\"\n\nk apply -f pod-no-probe-nginx-sleep.yaml\n\nk get po -n test\n  NAME         READY   STATUS    RESTARTS   AGE\n  nginx-test   1/1     Running   0          13s\n\n\n\n\n\n\nWarning\n\n\n\n我们可以看到 这个时候pod 已经是running 且ready了, 但是我们知道不应该让这个pod接收流量,就是接收请求,因为实际nginx还没有真正启动. 所以如何来处理这个问题呢?\n\n\napiVersion: v1\nkind: Pod\nmetadata:\n  labels:\n    run: nginx-test\n  name: nginx-readiness\n  namespace: test\nspec:\n  containers:\n  - image: nginx:1.14.2\n    name: nginx-readiness-c\n    command:\n    - sh\n    - -c\n    - sleep 30;nginx -g \"daemon off;\"\n    readinessProbe:\n      httpGet:\n        path: /\n        port: 80\n      initialDelaySeconds: 5\n      periodSeconds: 5\n      timeoutSeconds: 1\n      successThreshold: 1\n      failureThreshold: 3\napiVersion: v1\nkind: Pod\nmetadata:\n  labels:\n    test: readiness-liveness\n  name: readiness-liveness\n  namespace: test\nspec:\n  containers:\n  - name: readiness-liveness-c\n    image: busybox\n    imagePullPolicy: IfNotPresent\n    args:\n    - /bin/sh\n    - -c\n    - touch /tmp/healthy; sleep 60; rm -f /tmp/healthy; sleep 600\n    readinessProbe:\n      exec: \n        command:\n        - sh\n        - -c\n        - echo readiness-$(date +\"%Y/%m/%d %H:%M:%S\")&gt;&gt;/probe.log;cat /tmp/healthy\n      initialDelaySeconds: 5\n      periodSeconds: 5\n      timeoutSeconds: 1\n      successThreshold: 1\n      failureThreshold: 3\n    livenessProbe:\n      exec:\n        command:\n        - sh\n        - -c\n        - echo liveness-$(date +\"%Y/%m/%d %H:%M:%S\")&gt;&gt;/probe.log;cat /tmp/healthy\n      initialDelaySeconds: 5\n      periodSeconds: 5\n      timeoutSeconds: 1\n      successThreshold: 1\n      failureThreshold: 3\nk exec -n test readiness-liveness -- tail -f /probe.log\n2个探针都会一直执行.\n\n\n\n\n\n\n就绪和存活能不能合成一个?\n\n\n\n不行! 如何合成一个, 那么如果探测3次都没有成功, 意味着没就绪,你是准备重启容器? 这样死循环? 就绪是看是否准备提供服务, 接收请求, 不是说容器有问题了, 只是没准备好 存活是看是否运行正常, 不正常要重启啥的.\n\n\n\n\n4.3 StartupProbe 启动探针\n\n\n\n\n\n\nTip\n\n\n\n\nk8s1.16版本后新加的探测方式,用于判断容器内应用程序是否已经启动\n如果配置了startupProbe,就会先禁止其他的探测,直到它成功为止,失败则会根据restartPolicy策略进行相应操作,成功则启动探针将不再探测,开始后续的就绪和存活探测\n\n\n\n\n\n\n\n\n\n为什么需要,直接用存活探针不行吗?\n\n\n\n\n有些应用在启动的时候需要比较长的时间,\n\n那么这个时候就绪探针我们无所谓, 它一直探,没成功没关系\n存活探针\n\n你说到底等待多久才开始探测, 这需要你先判断你的程序启动要多久,比如90s, 然后initialDelaySeconds设置为90s,好像可以解决问题\n假设有一次失败了,要重启或重建容器, 这次偏偏启动时间更长了,直接让你 存活探针失败, 然后重启… 死循环了.\n首先initialDelaySeconds不可能改来改去, 你可能会说, 增加探测次数和探测间隔怎么样, 假设你改成failureThreshold=5,periodSeconds=10, 那么如果容器异常, 可能需要50s的时间 才会判定容器异常, 才会重启或重建容器,白白等待这么久.\n\n设计了 启动探针\n\n假设你的程序启动大概要90s\n设置failureThreshold=10, periodSeconds=10,initialDelay=10\n\n这个如果在110s内成功了, 就ok\n可能10s就ok了, 不需要像存活探针那样固定的死等90s时间\n你可能会说,110s没成功,重启了, 也这个可能. 所以你当初设置时根据具体情况,可以将failureThreshold增加, 一般情况下不会出现这种情况\n\n\n\n\n\n\napiVersion: v1\nkind: Pod\nmetadata:\n  creationTimestamp: null\n  labels:\n    run: nginx-test\n  name: nginx-start-probe\nspec:\n  restartPolicy: Always\n  containers:\n  - image: nginx\n    name: nginx-start-probe-c\n    command:\n    - sh\n    - -c\n    - sleep 10;nginx -g \"daemon off;\"\n    startProbe:\n        failureThreshold: 3\n        successThreshold: 1\n        periodSeconds: 5\n        initialDelaySeconds: 2\n        timeoutSeconds: 2\n        tcpSocket:\n            port: 80",
    "crumbs": [
      "核心概念与实战",
      "pod"
    ]
  },
  {
    "objectID": "docs/devops/k8s/core/pod.html#poststart",
    "href": "docs/devops/k8s/core/pod.html#poststart",
    "title": "斯巴拉稀",
    "section": "5 postStart",
    "text": "5 postStart\n\n\n\n\n\n\nTip\n\n\n\n\n在容器启动后,立刻执行一个指定的操作\n虽然是在容器command执行之后，实际上和它是异步的, 就是说可能在postStart启动时,command有可能还没有执行结束\n在postStart执行完毕前, pod还不是running状态\n\n\n\napiVersion: v1\nkind: Pod\nmetadata:\n  name: lifecycle-post-start\nspec:\n  containers:\n  - name: lifecycle-post-start-c\n    image: nginx:1.14.2\n    imagePullPolicy: IfNotPresent\n    lifecycle:\n      postStart:\n        exec:\n          command: [\"/bin/sh\", \"-c\", \"sleep 20;echo postStart... &gt; /tmp.log\"]",
    "crumbs": [
      "核心概念与实战",
      "pod"
    ]
  },
  {
    "objectID": "docs/devops/k8s/core/pod.html#prestop",
    "href": "docs/devops/k8s/core/pod.html#prestop",
    "title": "斯巴拉稀",
    "section": "6 preStop",
    "text": "6 preStop\n\n\n\n\n\n\nTip\n\n\n\n\npreStop操作的执行是同步的. 所以它会阻塞当前的容器杀死流程，直到这个操作完成才允许容器被杀死\n我们可以在里面写优雅退出的东西\nterminationGracePeriodSeconds 中止宽限时间,preStop 执行前 就会开始计算\n\n\n\napiVersion: v1\nkind: Pod\nmetadata:\n  name: lifecycle-pre-stop\nspec:\n  terminationGracePeriodSeconds: 30  # 默认是30s\n  containers:\n  - name: lifecycle-pre-stop-c\n    image: nginx\n    imagePullPolicy: IfNotPresent\n    lifecycle:\n      preStop:\n        exec:\n          command: [\"/bin/sh\", \"-c\", \"sleep 45;echo Hello\"]\n          # 可以写优雅退出nginx\n          # command: [\"/bin/sh\",\"-c\",\"echo preStop...; nginx -s quit; while killall -0 nginx; do sleep 1; done\"]\nk delete lifecycle-pre-stop\n# 看效果\nk logs -f lifecycle-pre-stop",
    "crumbs": [
      "核心概念与实战",
      "pod"
    ]
  },
  {
    "objectID": "docs/devops/k8s/core/pod.html#init容器",
    "href": "docs/devops/k8s/core/pod.html#init容器",
    "title": "斯巴拉稀",
    "section": "7 init容器",
    "text": "7 init容器\ninit-container\n\n\n\n\n\n\nTip\n\n\n\n相比普通的container,Init Containers 的生命周期会先于所有的 Containers运行,并且严格按照定义的顺序执行.\n\n\n\nInit容器可以包含一些安装过程中应用容器中不存在的实用工具或个性化代码\nInit容器可以安全地运行这些工具，避免这些工具导致应用镜像的安全性降低\nInit容器可以以root身份运行，执行一些高权限命令\nInit容器 ==相关操作执行完成以后即退出，不会给业务容器带来安全隐患==\n\n在主应用启动之前，做一些初始化的操作，比如创建文件、修改内核参数、等待 依赖程序启动或其他需要在主程序启动之前需要做的工作\npostStart与init的对比\n\nPostStart:依赖主应用的环境，而且并不一定先于Command运行\nInitContainer:不依赖主应用的环境，可以有更高的权限和更多的工具，一定会在主应用启动之前完成\n\n初始化容器和普通容器的区别\n\nInit 容器与普通的容器非常像，除了如下几点:\n\n如果为一个 Pod 指定了多个 Init 容器，这些容器会按顺序逐个运行。 每个 Init 容器必须运行成功，下一个才能够运行。当所有的 Init 容器运行完成时， Kubernetes 才会为 Pod 初始化应用容器并像平常一样运行\n如果pod的Init 容器失败，Kubernetes 会不断地重启该 Pod，直到 Init 容器成功为止\n如果Pod 对应的 restartPolicy 值为 Never，init失败了.则Kubernetes 不会 重新启动 Pod。\nInit 容器不支持 lifecycle、livenessProbe、 readinessProbe 和 startupProbe\n\n\nInit 容器是一种特殊容器，在 Pod 内的应用容器启动之前运行。Init 容器可以包括一些应用镜像中不存在的实用工具和安装脚本\n# 通过这个可以找到对应的文档url\nkubectl explain pods.spec.initContainers\n\n\npod-with-2init.yaml\n\napiVersion: v1\nkind: Pod\nmetadata:\n  name: pod-with-2init\n  labels:\n    app: pod-with-2init\nspec:\n  containers:\n  - name: c-main\n    image: busybox:1.28\n    command: ['sh', '-c', 'echo The app is running! && sleep 3600']\n  initContainers:\n  - name: c-init-wait-service\n    image: busybox:1.28\n    command: ['sh', '-c', 'until nslookup wait-service; do echo waiting for wait-service; sleep 2; done;']\n  - name: c-init-wait-db\n    image: busybox:1.28\n    command: ['sh', '-c', 'until nslookup wait-db; do echo waiting for wait-db; sleep 2; done;']\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: wait-service\n  labels:\n    app: wait-service\nspec:\n  ports:\n  - protocol: TCP\n    port: 80\n    targetPort: 9376\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: wait-db\n  labels:\n    app: wait-service\nspec:\n  ports:\n  - protocol: TCP\n    port: 80\n    targetPort: 9377\n\n# 创建pod\nk apply -f pod-with-2init.yaml  -l app=pod-with-2init\nk get po\n  NAME                             READY   STATUS     RESTARTS   AGE\n  pod-with-2init                   0/1     Init:0/2   0          3m7s\n# 可以看到2个init 容器都在waiting\n# 因为我们的svc ,还没创建, nslookup wait-service\n# 显示的时候按照顺序显示, \nk describe po pod-with-2init |grep -E 'c-|state' -i\n  c-init-wait-service: # 启动了 在运行\n    State:          Running\n  c-init-wait-db: #  由于 c-init-wait-service 这个容器没有运行成功,所以等待\n    State:          Waiting\n  c-main:\n    State:          Waiting\nk logs pod-with-2init -c c-init-wait-service\nk logs pod-with-2init -c c-init-wait-db\n\n# 这个时候我们创建对应的svc, 先让c-init-wait-service 运行成功\nk apply -f pod-with-2init.yaml  -l app=wait-service\n# 再看pod 状态\nk describe po pod-with-2init |grep -E 'c-|state' -i\n  c-init-wait-service:\n    State:          Terminated\n  c-init-wait-db: # 前面的运行完毕了,这个才开始运行\n    State:          Running\n  c-main:\n    State:          Waiting\nk apply -f pod-with-2init.yaml  -l app=wait-db\n# 最后查看\nk describe po pod-with-2init |grep -E 'c-|state' -i\n  c-init-wait-service:\n    State:          Terminated\n  c-init-wait-db:\n    State:          Terminated\n  c-main:\n    State:          Running",
    "crumbs": [
      "核心概念与实战",
      "pod"
    ]
  },
  {
    "objectID": "docs/devops/k8s/core/pod.html#临时容器debug",
    "href": "docs/devops/k8s/core/pod.html#临时容器debug",
    "title": "斯巴拉稀",
    "section": "8 临时容器(debug)",
    "text": "8 临时容器(debug)\n容器的安全考虑,如果你的容器里安装了太多的东西, 比如ssh,可能让黑客越权访问你的节点, 所以一般用最小的镜像来减少攻击面并减少故障和漏洞的暴露\nDistroless 镜像 允许用户部署最小的容器镜像\n但是如果我们给容器安装最小的东西, 如果你的容器出了问题需要调试, 里面什么命令都没有… 就麻烦了\n可以在现有 Pod 中运行临时容器来检查其状态并运行任意命令\n官方文档\n与常规容器一样，将临时容器添加到 Pod 后，将不能更改或删除临时容器\n# 会报错,因为corednspod 里基本东西没有.\nks exec -it coredns-65c54cc984-4p2zj -- sh\n# 我们创建一个临时容器 名字叫debugger-x, 并进入交互\n# 由于coredns 默认没有开启进程命名空间共享. 所以这里需要 使用--target=pod里你想进行调试的容器名\nks debug coredns-65c54cc984-4p2zj -it -c debugger-x --image=busybox --target=coredns\n# 退出后,临时容器就没了\n# 不指定临时容器名,名字会自动创建一个名字\nks debug coredns-65c54cc984-4p2zj -it  --image=busybox --target=coredns\n# 进入临时容器后 执行命令看看\nps  # 你才会看到, coredns 容器运行的进程. --target 让他们共享一个命名空间了\n    USER     TIME  COMMAND\n    1 root      1:52 /coredns -conf /etc/coredns/Corefile\n   15 root      0:00 sh\n   21 root      0:00 ps\n\n# 会看到里面拉取镜像,创建并启动了一个容器,名字debugger-xxx\nks describe  po  coredns-65c54cc984-4p2zj\n\n# 退出临时交互后\nks describe  po  coredns-65c54cc984-4p2zj|grep -E 'Containers|debugger|State|coredns:$'\n  Containers:\n    coredns:\n      State:          Running\n  Ephemeral Containers:\n    debugger-x7ld5:\n      State:          Terminated\n    debugger-x:\n      State:          Terminated\napiVersion: v1\nkind: Pod\nmetadata:\n  name: pod-nginx\n  labels:\n    app: pod-nginx\nspec:\n  shareProcessNamespace: true\n  containers:\n  - name: c-main\n    image: nginx:1.14.2\n# 本身开启 pid命名空间共享的 pod, 不需要 --target\nk debug pod-nginx  -it --image=busybox\nps\n  PID   USER     TIME  COMMAND\n    1 65535     0:00 /pause\n    7 root      0:00 nginx: master process nginx -g daemon off;\n   13 101       0:00 nginx: worker process\n   14 root      0:00 sh\n   20 root      0:00 ps\n实际的原理 应该类似下面这样, 给pod 注入一个容器. pod 里的容器是共享 命名空间等的\nShare Process Namespace between Containers in a Pod | Kubernetes\napiVersion: v1\nkind: Pod\nmetadata:\n  name: nginx\nspec:\n  shareProcessNamespace: true    # 需要打开\n  containers:\n  - name: nginx\n    image: nginx\n  - name: shell\n    image: busybox:1.28\n    securityContext:\n      capabilities:\n        add:\n        - SYS_PTRACE\n    stdin: true\n    tty: true\n# 1. Create the pod `nginx` on your cluster:\n# 2. Attach to the `shell` container and run `ps`:\nkubectl attach -it nginx -c shell\nkubectl-debug",
    "crumbs": [
      "核心概念与实战",
      "pod"
    ]
  },
  {
    "objectID": "docs/devops/k8s/check.html",
    "href": "docs/devops/k8s/check.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "Back to top"
  },
  {
    "objectID": "docs/devops/k8s/component/kubectl.html",
    "href": "docs/devops/k8s/component/kubectl.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "Tip\n\n\n\n\nkubectl是一个k8s的命令行工具,它允许用户以命令行的方式与k8s交互,默认读取配置文件~/.kube/config\nkubectl会将接收到的用户请求转化为rest调用 以 rest 的形式与 apiserver 通讯\n\n\n\n# 加上 -v 8或9 可以看到 加载的哪个配置文件 和实际用的http请求url 以及请求的参数和返回结果\n# -v 6/7 都可以试试.\nk get ns -v 8\nk get ns -v 9\n# 在任意可以 通过kubectl 对k8s 进行操作的机器上\nk proxy --accept-hosts=\".*\" --address=0.0.0.0\n# 然后就能直接 curl localhost:8001/...\n\n\n\n Back to top",
    "crumbs": [
      "组件",
      "kubectl"
    ]
  },
  {
    "objectID": "docs/devops/k8s/component/controller-manager.html",
    "href": "docs/devops/k8s/component/controller-manager.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "Warning\n\n\n\n\n待整理…",
    "crumbs": [
      "组件",
      "controller-manager"
    ]
  },
  {
    "objectID": "docs/devops/k8s/component/controller-manager.html#默认控制器",
    "href": "docs/devops/k8s/component/controller-manager.html#默认控制器",
    "title": "斯巴拉稀",
    "section": "1 默认控制器",
    "text": "1 默认控制器\nController Manager 是多个控制器的组合, 另外像调度器其实是一种特殊的控制器.\nks exec kube-controller-manager-master1 \\\n    -- kube-controller-manager -h \\\n    |grep -iA 2 \"\\-\\-controllers\"",
    "crumbs": [
      "组件",
      "controller-manager"
    ]
  },
  {
    "objectID": "docs/devops/k8s/component/controller-manager.html#控制器架构原理",
    "href": "docs/devops/k8s/component/controller-manager.html#控制器架构原理",
    "title": "斯巴拉稀",
    "section": "2 控制器架构原理",
    "text": "2 控制器架构原理\n\n2.1 核心逻辑\n\n\n\n\n\n\nImportant\n\n\n\nk8s中每一个控制器 都对应负责k8s中的一种资源, 保证这种资源是其期待的状态 每个 Controller 事实上都是一个 control loop死循环,负责侦听其管控的对象,当对象发生变更时完成配置. Controller 配置失败通常会触发自动重试,整个集群会在控制器不断重试的机制下确保最终一致性\n\n\n\n\n控制器的核心逻辑\n\nfor {\n    当前状态:= 获取集群中对象X的当前状态(Current State)\n    期望状态:= 获取集群中对象X的期望状态(Desired State)\n    // 只有不一致的时候\n    if 当前状态 != 期望状态 {\n        //将当前状态调整为期望状态\n    }\n}\n\n\n\n2.2 设计思路\n\n我的简单思考k8s的实际设计\n\n\n\n\n\n\n\n\n\n\n\n2.3 ResourceVersion\n\n\n\n\n\n\nImportant\n\n\n\n在看源码之前我们先学习一下ResourceVersion 资源版本号这个知识点 请先去看下博文etcd的版本管理\n\n\n\n2.3.1 资源对象与etcd\n# 创建一个pod nginx, 然后\nk get po nginx -o yaml |grep -i resourceVersion\n    resourceVersion: \"2794306\"\n# 我们知道k8s 的数据持久化到etcd的,所以这里我们看下这个pod在etcd里的存储情况\ne get \"\" --prefix --keys-only |grep nginx\n    /registry/pods/default/nginx\n\n# 看下 存放在etcd时的版本情况,与  k get po 得到的版本是一样的.\ne get /registry/pods/default/nginx -w json\n\n\n执行结果\n\n{\n    \"header\": {\n        \"cluster_id\": 2356888313039106048,\n        \"member_id\": 14381832694777033788,\n        \"revision\": 2794357,\n        \"raft_term\": 10\n    },\n    \"kvs\": [\n        {\n            \"key\": \"L3JlZ2lzdHJ5L3BvZHMvZGVmYXVsdC9uZ2lueA==\",\n            \"create_revision\": 2738283,\n            // k8s 通过etcd中的这个 和 k get po 获取的resourceVersion进行对比\n            // 如果不相同说明 ,在你更新的时候,po 已经被更新了,则拒绝更新, 这就是乐观锁\n            \"mod_revision\": 2794306,\n            \"version\": 10,\n            \"value\": \"+=\"\n        }\n    ],\n    \"count\": 1\n}\n\n\n# 给pod 增加一个label 再看\nk get po nginx -o yaml |grep -i resourceVersion\n  resourceVersion: \"2794480\"\n\ne get /registry/pods/default/nginx -w json\n\n\n结果\n\n{\n    \"header\": {\n        \"cluster_id\": 2356888313039106048,\n        \"member_id\": 14381832694777033788,\n        \"revision\": 2794941,\n        \"raft_term\": 10\n    },\n    \"kvs\": [\n        {\n            \"key\": \"L3JlZ2lzdHJ5L3BvZHMvZGVmYXVsdC9uZ2lueA==\",\n            \"create_revision\": 2738283,\n            \"mod_revision\": 2794480,\n            \"version\": 11,\n            \"value\": \"+=\"\n        }\n    ],\n    \"count\": 1\n}\n\n\n# 可以看到这2个版本的数据\ne watch /registry/pods/default/nginx --rev=2794306\n\n\n2.3.2 查询时带上\n关于查询中带resourceVersion的具体表现,请看官方文档的说明\n\nlist使用resourceVersionget使用resourceVersionwatch使用resourceVersion\n\n\n\n\n\n\n\n\n\n\n\n\nresourceVersionMatch 参数\n分页参数\nresourceVersion 未设置\nresourceVersion=“0”\nresourceVersion=“&lt;非零值&gt;”\n\n\n\n\n未设置\nlimit 未设置\n最新版本\n任意版本\n不老于指定版本\n\n\n未设置\nlimit=n, continue 未设置\n最新版本\n任意版本\n精确匹配\n\n\n未设置\nlimit=n, continue=token\n从 token 开始、精确匹配\n非法请求视为从 token 开始、精确匹配\n非法请求返回 HTTP 400 Bad Request\n\n\nExact\nlimit 未设置\n非法请求\n非法请求\n精确匹配\n\n\nExact\nlimit=n, continue 未设置\n非法请求\n非法请求\n精确匹配\n\n\nNotOlderThan\nlimit 未设置\n非法请求\n任意版本\n不老于指定版本\n\n\nNotOlderThan\nlimit=n, continue 未设置\n非法请求\n任意版本\n不老于指定版本\n\n\n\n\n\n\n\n\n\nTip\n\n\n\n\nresourceVersionMatch 如果设置的话,值=Exact或NotOlderThan\nhttp://localhost:8001/api/v1/pods?resourceVersion=2196120&resourceVersionMatch=NotOlderThan&limit=1 结果里能看到metadata里 continue的值xxx, 然后 请求带上 &continue=xxx ,就是分页一样,第二页了.\n最新版本的意思: 从 etcd 读取\n任意版本的意思: 从缓存中读取,因为缓存中可能是旧的,也可能是和etcd中一致的数据, 所以这里称为任意版本\n\n\n\n\n\n\n\n\nresourceVersion 未设置\nresourceVersion=“0”\nresourceVersion=“&lt;非零值&gt;”\n\n\n\n\n最新版本\n任何版本\n不老于给定版本\n\n\n\n\n\n\n\n\nresourceVersion 未设置\nresourceVersion=“0”\nresourceVersion=“&lt;非零值&gt;”\n\n\n\n\n读取状态并从最新版本开始\n读取状态并从任意版本开始\n从指定版本开始\n\n\n\n\n\n\n\n\n\n\n\n\n源码说明什么时候从etcd获取,什么时候从etcd中获取\n\n\n\n待确认…\n\n\nstaging/src/k8s.io/apiserver/pkg/storage/cacher/cacher.go\n\nfunc (c *Cacher) List(ctx context.Context, key string, opts storage.ListOptions, listObj runtime.Object) error {\n    resourceVersion := opts.ResourceVersion\n    pred := opts.Predicate\n    if shouldDelegateList(opts) {\n        // 从etcd 获取\n        return c.storage.List(ctx, key, opts, listObj)\n    }\n    //...\n}\n\nfunc shouldDelegateList(opts storage.ListOptions) bool {\n    resourceVersion := opts.ResourceVersion\n    pred := opts.Predicate\n    pagingEnabled := utilfeature.DefaultFeatureGate.Enabled(features.APIListChunking)\n    hasContinuation := pagingEnabled && len(pred.Continue) &gt; 0\n    // resourceVersion 不等于0\n    hasLimit := pagingEnabled && pred.Limit &gt; 0 && resourceVersion != \"0\"\n\n    return resourceVersion == \"\" || hasContinuation || hasLimit || opts.ResourceVersionMatch == metav1.ResourceVersionMatchExact\n}\n\n\n\n\nresourceVersion 空hasLimithasContinuation从缓存中读取\n\n\n\n# list操作 返回的结果里最外层的resourceVersion 是 list 响应被构造时的reversion\n# 就是 拉取的数据是  etcd全局reversion = 最外层的resourceVersion这个值的时候的数据\n# 所以 下次拉取的时候, 使用watch ,然后设置不老于 这个resourceVersion, 这样就全量+增量获取数据了\n# 不带resourceVersion 的时候, 会从etcd 读取,所以 这个时候的 值= 拉取的时候etcd全局的reversion\ncurl localhost:8001/api/v1/namespaces/default/pods\n# 或直接在浏览器打开\nlocalhost:8001/api/v1/namespaces/default/pods #(1)\n\n\n结果\n\n{\n    \"kind\": \"PodList\",\n    \"apiVersion\": \"v1\",\n    \"metadata\": {\n        \"resourceVersion\": \"...\"\n    },\n    \"items\": [\n        {\n            \"metadata\": {\n                \"name\": \"...\",\n                \"namespace\": \"...\",\n                \"resourceVersion\": \"....\",\n            },\n            \"spec\": {},\n            \"status\": {}\n        },\n        {...},\n        {...},\n        {...}\n    ]\n}\n\n\n\n\n# 下面这个操作 会获取pod是nginx 版本为2794306的信息\n# 如果指定的版本被压缩过,会报错,因为这个是精确匹配,表示全局reversion=2794306时的数据,而这个版本不在了\n# 从etcd获取\nlocalhost:8001/api/v1/namespaces/default/pods?resourceVersion=2794306&limit=5\n\n\n\n# continue 分页, 从etcd 获取\nlocalhost:8001/api/v1/namespaces/default/pods?limit=1 \n\n\n结果显示\n\n{\n    \"kind\": \"PodList\",\n    \"apiVersion\": \"v1\",\n    \"metadata\": {\n        \"resourceVersion\":    \"2840267\",\n        \"continue\":           \"XXXXXXXXXXXXX\",\n        \"remainingItemCount\": 3 // 剩余还有几条数据\n    },\n    \"items\": []\n}\n\n\n# 使用 continue 继续获取下一页\nlocalhost:8001/api/v1/namespaces/default/pods?limit=1&continue=XXXXXXXXXXXXX\n\n\n# 不老于指定版本, 返回的结果里最外层的resourceVersion 是 list 响应被构造时的reversion\n# 由于是从缓存(apiserver的缓存)中获取,所以获取的时候,是缓存中最新版本的数据,但是因为是缓存\n# 显示的resourceVersion 可能在实际etcd里是已经被压缩过而不存在的值\n# 实际测试,可以测到, 这个resourceVersion 用下面的 可以访问, 去etcd 命令访问会提示too old\nlocalhost:8001/api/v1/namespaces/default/pods?resourceVersion=2794306\n# 同上\nlocalhost:8001/api/v1/namespaces/default/pods?resourceVersion=2794306&resourceVersionMatch=NotOlderThan\n\n\n\n\n\n\n2.4 代码流程\n\n\n\n\n\n\nTip\n\n\n\n我们以ReplicaSet资源的控制器为例\n\n\n\n2.4.1 流程简图\n\n\n\n2.4.2 入口\n\ncontrollermanager#run\n\n\n\n\ncmd/kube-controller-manager/app/controllermanager.go#run\n\nfunc Run(c *config.CompletedConfig, stopCh &lt;-chan struct{}) error {\n    run := func(ctx context.Context, startSATokenController InitFunc, initializersFunc ControllerInitializersFunc) {\n\n        controllerContext, err := CreateControllerContext(c, rootClientBuilder, clientBuilder, ctx.Done())\n        if err != nil {\n        }\n        // 3. 来至NewControllerInitializers里一个个 startXXXController\n        // 每个startXXXController 里都用工厂方法实例化 对应类型的informer\n        controllerInitializers := initializersFunc(controllerContext.LoopMode)\n        // 4. 执行每个 startXXXController()  (2)\n        // 都使用controllerContext.InformerFactory 来创建对应资源informer\n        // 都存于controllerContext.InformerFactory.informers中\n        if err := StartControllers(ctx, controllerContext, startSATokenController, controllerInitializers, unsecuredMux, healthzHandler); err != nil {\n        }\n        // 5. 然后这里启动所有的informer (1)\n        controllerContext.InformerFactory.Start(stopCh)\n        controllerContext.ObjectOrMetadataInformerFactory.Start(stopCh)\n        close(controllerContext.InformersStarted)\n\n        select {}\n    }\n\n    // Start the main lock\n    go leaderElectAndRun(c, id, electionChecker,\n        c.ComponentConfig.Generic.LeaderElection.ResourceLock,\n        c.ComponentConfig.Generic.LeaderElection.ResourceName,\n        leaderelection.LeaderCallbacks{\n            OnStartedLeading: func(ctx context.Context) {\n                // 1. NewControllerInitializers 各种不同资源控制器的定义 (3)\n                initializersFunc := NewControllerInitializers\n                if leaderMigrator != nil {\n                    initializersFunc = createInitializersFunc(leaderMigrator.FilterFunc, leadermigration.ControllerNonMigrated)\n                }\n                // 2. run 去看上方的run定义\n                run(ctx, startSATokenController, initializersFunc)\n            },\n            OnStoppedLeading: func() {\n            },\n        })\n\n}\n\n\nInformerFactory.StartStartControllersNewControllerInitializers\n\n\n// Start initializes all requested informers.\nfunc (f *sharedInformerFactory) Start(stopCh &lt;-chan struct{}) {\n    f.lock.Lock()\n    defer f.lock.Unlock()\n\n    for informerType, informer := range f.informers {\n        if !f.startedInformers[informerType] {\n            go informer.Run(stopCh)\n            f.startedInformers[informerType] = true\n        }\n    }\n}\n\n\nfunc StartControllers(ctx context.Context, controllerCtx ControllerContext, startSATokenController InitFunc, controllers map[string]InitFunc,...){\n    for controllerName, initFn := range controllers {\n        // ...\n        ctrl, started, err := initFn(ctx, controllerCtx)\n        // ...\n    }\n}\n\n\nfunc NewControllerInitializers(loopMode ControllerLoopMode) map[string]InitFunc {\n    controllers := map[string]InitFunc{}\n    controllers[\"endpoint\"] = startEndpointController\n    controllers[\"endpointslice\"] = startEndpointSliceController\n    controllers[\"endpointslicemirroring\"] = startEndpointSliceMirroringController\n    controllers[\"replicationcontroller\"] = startReplicationController\n    controllers[\"podgc\"] = startPodGCController\n    controllers[\"resourcequota\"] = startResourceQuotaController\n    controllers[\"namespace\"] = startNamespaceController\n    controllers[\"serviceaccount\"] = startServiceAccountController\n    controllers[\"garbagecollector\"] = startGarbageCollectorController\n    controllers[\"daemonset\"] = startDaemonSetController\n    controllers[\"job\"] = startJobController\n    controllers[\"deployment\"] = startDeploymentController\n    controllers[\"replicaset\"] = startReplicaSetController\n    //....\n    //....\n    return controllers\n}\n\n\n\n\n\n\n\n\n2.4.3 实例化控制器\n\nstartReplicaSetController.Informer()AddEventHandler\n\n\nfunc startReplicaSetController(ctx context.Context, controllerContext ControllerContext) (controller.Interface, bool, error) {\n    go replicaset.NewReplicaSetController(\n        controllerContext.InformerFactory.Apps().V1().ReplicaSets(), //定义rs的informer\n        controllerContext.InformerFactory.Core().V1().Pods(),  // rs 监控pod资源, 所以也需要pod的\n        controllerContext.ClientBuilder.ClientOrDie(\"replicaset-controller\"),\n        replicaset.BurstReplicas,\n    ).Run(ctx, int(controllerContext.ComponentConfig.ReplicaSetController.ConcurrentRSSyncs))\n    return nil, true, nil\n}\nfunc NewReplicaSetController(rsInformer appsinformers.ReplicaSetInformer, podInformer coreinformers.PodInformer, kubeClient clientset.Interface, burstReplicas int) *ReplicaSetController {\n    return NewBaseController(rsInformer, podInformer,...)\n}\nfunc NewBaseController(...) *ReplicaSetController {\n    // ...\n    rsc := &ReplicaSetController{\n        GroupVersionKind: gvk,\n        kubeClient:       kubeClient,\n        podControl:       podControl,\n        burstReplicas:    burstReplicas,\n        expectations:     controller.NewUIDTrackingControllerExpectations(controller.NewControllerExpectations()),\n        // 工作队列, 消费DeltaFifo 时, 会先将数据放到这个工作队列\n        queue:            workqueue.NewNamedRateLimitingQueue(workqueue.DefaultControllerRateLimiter(), queueName),\n    }\n    // .Informer() 将会在 controllerContext.InformerFactory.informers 设置 .informers[informerType]=...\n    // 消费DeltaFifo里rs资源时, 对应的事件处理方法\n    rsInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs{\n        AddFunc:    rsc.addRS,\n        UpdateFunc: rsc.updateRS,\n        DeleteFunc: rsc.deleteRS,\n    })\n    rsc.rsLister = rsInformer.Lister()\n    rsc.rsListerSynced = rsInformer.Informer().HasSynced\n    // 消费DeltaFifo里pod资源时, 对应的事件处理方法\n    podInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs{\n        AddFunc: rsc.addPod,\n        UpdateFunc: rsc.updatePod,\n        DeleteFunc: rsc.deletePod,\n    })\n    rsc.podLister = podInformer.Lister()\n    rsc.podListerSynced = podInformer.Informer().HasSynced\n\n    rsc.syncHandler = rsc.syncReplicaSet\n    return rsc\n}\n\n\nfunc (f *podInformer) Informer() cache.SharedIndexInformer {\n    return f.factory.InformerFor(&corev1.Pod{}, f.defaultInformer)\n}\n\nfunc (f *podInformer) defaultInformer(client kubernetes.Interface, resyncPeriod time.Duration) cache.SharedIndexInformer {\n    return NewFilteredPodInformer(client,f.namespace,resyncPeriod,cache.Indexers{cache.NamespaceIndex: cache.MetaNamespaceIndexFunc},f.tweakListOptions)\n}\nfunc NewFilteredIngressInformer(client kubernetes.Interface, namespace string, resyncPeriod time.Duration, indexers cache.Indexers, tweakListOptions internalinterfaces.TweakListOptionsFunc) cache.SharedIndexInformer {\n    return cache.NewSharedIndexInformer(\n        &cache.ListWatch{\n            ListFunc: func(options metav1.ListOptions) (runtime.Object, error) {\n                if tweakListOptions != nil {\n                    tweakListOptions(&options)\n                }\n                return client.NetworkingV1().Ingresses(namespace).List(context.TODO(), options)\n            },\n            WatchFunc: func(options metav1.ListOptions) (watch.Interface, error) {\n                if tweakListOptions != nil {\n                    tweakListOptions(&options)\n                }\n                return client.NetworkingV1().Ingresses(namespace).Watch(context.TODO(), options)\n            },\n        },\n        &networkingv1.Ingress{},\n        resyncPeriod,\n        indexers,\n    )\n}\nfunc NewSharedIndexInformer(lw ListerWatcher, exampleObject runtime.Object, defaultEventHandlerResyncPeriod time.Duration, indexers Indexers) SharedIndexInformer {\n    realClock := &clock.RealClock{}\n    sharedIndexInformer := &sharedIndexInformer{\n        processor:                       &sharedProcessor{clock: realClock},\n        indexer:                         NewIndexer(DeletionHandlingMetaNamespaceKeyFunc, indexers),\n        listerWatcher:                   lw,\n        objectType:                      exampleObject,\n        resyncCheckPeriod:               defaultEventHandlerResyncPeriod,\n        defaultEventHandlerResyncPeriod: defaultEventHandlerResyncPeriod,\n        cacheMutationDetector:           NewCacheMutationDetector(fmt.Sprintf(\"%T\", exampleObject)),\n        clock:                           realClock,\n    }\n    return sharedIndexInformer\n}\n\nfunc NewIndexer(keyFunc KeyFunc, indexers Indexers) Indexer {\n    return &cache{\n        cacheStorage: NewThreadSafeStore(indexers, Indices{}),\n        keyFunc:      keyFunc,\n    }\n}\n\nfunc NewThreadSafeStore(indexers Indexers, indices Indices) ThreadSafeStore {\n    return &threadSafeMap{\n        items:    map[string]interface{}{},\n        indexers: indexers,\n        indices:  indices,\n    }\n}\n\n\n我们在.Informer() 中初始化了 processor 在AddEventHandler 添加了 Listener\nfunc (s *sharedIndexInformer) AddEventHandler(handler ResourceEventHandler) {\n    s.AddEventHandlerWithResyncPeriod(handler, s.defaultEventHandlerResyncPeriod)\n}\nfunc (s *sharedIndexInformer) AddEventHandlerWithResyncPeriod(handler ResourceEventHandler, resyncPeriod time.Duration) {\n\n    s.startedLock.Lock()\n    defer s.startedLock.Unlock()\n\n    if s.stopped {\n        klog.V(2).Infof(\"Handler %v was not added to shared informer because it has stopped already\", handler)\n        return\n    }\n\n    if resyncPeriod &gt; 0 {\n        if resyncPeriod &lt; minimumResyncPeriod {\n            klog.Warningf(\"resyncPeriod %v is too small. Changing it to the minimum allowed value of %v\", resyncPeriod, minimumResyncPeriod)\n            resyncPeriod = minimumResyncPeriod\n        }\n\n        if resyncPeriod &lt; s.resyncCheckPeriod {\n            if s.started {\n                klog.Warningf(\"resyncPeriod %v is smaller than resyncCheckPeriod %v and the informer has already started. Changing it to %v\", resyncPeriod, s.resyncCheckPeriod, s.resyncCheckPeriod)\n                resyncPeriod = s.resyncCheckPeriod\n            } else {\n                // if the event handler's resyncPeriod is smaller than the current resyncCheckPeriod, update\n                // resyncCheckPeriod to match resyncPeriod and adjust the resync periods of all the listeners\n                // accordingly\n                s.resyncCheckPeriod = resyncPeriod\n                s.processor.resyncCheckPeriodChanged(resyncPeriod)\n            }\n        }\n    }\n\n    listener := newProcessListener(handler, resyncPeriod, determineResyncPeriod(resyncPeriod, s.resyncCheckPeriod), s.clock.Now(), initialBufferSize)\n\n    if !s.started {\n        s.processor.addListener(listener)\n        return\n    }\n\n    s.blockDeltas.Lock()\n    defer s.blockDeltas.Unlock()\n\n    s.processor.addListener(listener)\n    for _, item := range s.indexer.List() {\n        listener.add(addNotification{newObj: item})\n    }\n}\n\n\n\n\n\n2.4.4 控制器.Run()\n\nRun()worker()processNextWorkItem()\n\n\nfunc (rsc *ReplicaSetController) Run(ctx context.Context, workers int) {\n    // ...\n    if !cache.WaitForNamedCacheSync(rsc.Kind, ctx.Done(), rsc.podListerSynced, rsc.rsListerSynced) {\n        return\n    }\n\n    for i := 0; i &lt; workers; i++ {\n        // worker\n        go wait.UntilWithContext(ctx, rsc.worker, time.Second)\n    }\n\n    &lt;-ctx.Done()\n}\n\n\n// worker runs a worker thread that just dequeues items, processes them, and marks them done.\n// It enforces that the syncHandler is never invoked concurrently with the same key.\nfunc (rsc *ReplicaSetController) worker(ctx context.Context) {\n    for rsc.processNextWorkItem(ctx) {\n    }\n}\n\n\nfunc (rsc *ReplicaSetController) processNextWorkItem(ctx context.Context) bool {\n    key, quit := rsc.queue.Get()\n    if quit {\n        return false\n    }\n    defer rsc.queue.Done(key)\n\n    err := rsc.syncHandler(ctx, key.(string))\n    if err == nil {\n        rsc.queue.Forget(key)\n        return true\n    }\n\n    utilruntime.HandleError(fmt.Errorf(\"sync %q failed with %v\", key, err))\n    rsc.queue.AddRateLimited(key)\n\n    return true\n}\n\n\n\n\n\n2.4.5 informer.run()\n\n\n\ninformer.Run\n\nfunc (s *sharedIndexInformer) Run(stopCh &lt;-chan struct{}) {\n    // ...\n    if s.HasStarted() {\n        // 可以 想到, 这就和前面的 设计是一致的\n        // 同类型资源的informer 如果已经启动了, 就不用启动了.\n        return\n    }\n    // 初始化 DeltaFIFO\n    fifo := NewDeltaFIFOWithOptions(DeltaFIFOOptions{\n        KnownObjects:          s.indexer,\n        EmitDeltaTypeReplaced: true,\n    })\n\n    cfg := &Config{\n        Queue:            fifo,\n        ListerWatcher:    s.listerWatcher,\n        ObjectType:       s.objectType,\n        FullResyncPeriod: s.resyncCheckPeriod,\n        RetryOnError:     false,\n        ShouldResync:     s.processor.shouldResync,\n        Process:           s.HandleDeltas,\n        WatchErrorHandler: s.watchErrorHandler,\n    }\n\n    func() {\n        s.startedLock.Lock()\n        defer s.startedLock.Unlock()\n\n        s.controller = New(cfg)\n        s.controller.(*controller).clock = s.clock\n        s.started = true // HasStarted()\n    }()\n\n    // Separate stop channel because Processor should be stopped strictly after controller\n    processorStopCh := make(chan struct{})\n    var wg wait.Group\n    defer wg.Wait()              // Wait for Processor to stop\n    defer close(processorStopCh) // Tell Processor to stop\n    wg.StartWithChannel(processorStopCh, s.cacheMutationDetector.Run)\n    wg.StartWithChannel(processorStopCh, s.processor.run) //\n\n    defer func() {\n        s.startedLock.Lock()\n        defer s.startedLock.Unlock()\n        s.stopped = true // Don't want any new listeners\n    }()\n    s.controller.Run(stopCh)\n}\n\n\n\ncontroller.Runs.processor.run\n\n\nfunc (c *controller) Run(stopCh &lt;-chan struct{}) {\n    // ...\n    r := NewReflector(\n        c.config.ListerWatcher,\n        c.config.ObjectType,\n        c.config.Queue,  // 这是r.store 是 前面定义的DeltaFIFO\n        c.config.FullResyncPeriod,\n    )\n    r.ShouldResync = c.config.ShouldResync\n    r.WatchListPageSize = c.config.WatchListPageSize\n    r.clock = c.clock\n    if c.config.WatchErrorHandler != nil {\n        r.watchErrorHandler = c.config.WatchErrorHandler\n    }\n\n    c.reflectorMutex.Lock()\n    c.reflector = r\n    c.reflectorMutex.Unlock()\n\n    var wg wait.Group\n\n    wg.StartWithChannel(stopCh, r.Run)\n    // processLoop 消费DeltaFifo的方法\n    wait.Until(c.processLoop, time.Second, stopCh)\n    wg.Wait()\n}\n\nr.Runcontroller.processLoop\n\n\nfunc (g *Group) StartWithChannel(stopCh &lt;-chan struct{}, f func(stopCh &lt;-chan struct{})) {\n    g.Start(func() {\n        f(stopCh)\n    })\n}\nfunc (r *Reflector) Run(stopCh &lt;-chan struct{}) {\n    wait.BackoffUntil(func() {\n        if err := r.ListAndWatch(stopCh); err != nil {\n            r.watchErrorHandler(r, err)\n        }\n    }, r.backoffManager, true, stopCh)\n}\n\nr.ListAndWatchr.listerWatcher.List/Watchpager.List()r.watchHandler\n\n\nfunc (r *Reflector) ListAndWatch(stopCh &lt;-chan struct{}) error {\n    var resourceVersion string\n\n    options := metav1.ListOptions{ResourceVersion: r.relistResourceVersion()}\n\n    if err := func() error {\n        defer initTrace.LogIfLong(10 * time.Second)\n        var list runtime.Object\n        var paginatedResult bool\n        var err error\n        listCh := make(chan struct{}, 1)\n        panicCh := make(chan interface{}, 1)\n        go func() {\n            defer func() {\n                if r := recover(); r != nil {\n                    panicCh &lt;- r\n                }\n            }()\n            pager := pager.New(pager.SimplePageFunc(func(opts metav1.ListOptions) (runtime.Object, error) {\n                // r.listerWatcher 来至c.config.ListerWatcher\n                // c.config.ListerWatcher 来至 sharedIndexInformer.listerWatcher\n                // 全量拉取数据, 配合后面的Watch 获取增量更新\n                return r.listerWatcher.List(opts)\n            }))\n            switch {\n            case r.WatchListPageSize != 0:\n                pager.PageSize = r.WatchListPageSize\n            case r.paginatedResult:\n            case options.ResourceVersion != \"\" && options.ResourceVersion != \"0\":\n                pager.PageSize = 0\n            }\n\n            list, paginatedResult, err = pager.List(context.Background(), options)\n            if isExpiredError(err) || isTooLargeResourceVersionError(err) {\n                // 设置 true时, 下面的 r.relistResourceVersion() 将得到ResourceVersion=\"\"\n                r.setIsLastSyncResourceVersionUnavailable(true)\n                list, paginatedResult, err = pager.List(context.Background(), metav1.ListOptions{ResourceVersion: r.relistResourceVersion()})\n            }\n            close(listCh)\n        }()\n        select {\n        case &lt;-stopCh:\n            return nil\n        case r := &lt;-panicCh:\n            panic(r)\n        case &lt;-listCh:\n        }\n        if err != nil {\n            return \n        }\n        if options.ResourceVersion == \"0\" && paginatedResult {\n            r.paginatedResult = true\n        }\n        r.setIsLastSyncResourceVersionUnavailable(false) // list was successful\n        listMetaInterface, err := meta.ListAccessor(list)\n        if err != nil {\n            return\n        }\n        resourceVersion = listMetaInterface.GetResourceVersion()\n        items, err := meta.ExtractList(list)\n        if err != nil {\n            return\n        }\n        // 将资源对象列表中的资源对象和资源版本号存储至DeltaFIFO中,会替换已存在的对象\n        if err := r.syncWith(items, resourceVersion); err != nil {\n            return\n        }\n        // 设置最后同步的资源版本号\n        r.setLastSyncResourceVersion(resourceVersion)\n        return nil\n    }(); err != nil {\n        return err\n    }\n\n    resyncerrc := make(chan error, 1)\n    cancelCh := make(chan struct{})\n    defer close(cancelCh)\n    go func() {\n        resyncCh, cleanup := r.resyncChan()\n        defer func() {\n            cleanup() // Call the last one written into cleanup\n        }()\n        for {\n            select {\n            case &lt;-resyncCh:\n            case &lt;-stopCh:\n                return\n            case &lt;-cancelCh:\n                return\n            }\n            if r.ShouldResync == nil || r.ShouldResync() {\n                if err := r.store.Resync(); err != nil {\n                    resyncerrc &lt;- err\n                    return\n                }\n            }\n            cleanup()\n            resyncCh, cleanup = r.resyncChan()\n        }\n    }()\n\n    for {\n        select {\n        case &lt;-stopCh:\n            return nil\n        default:\n        }\n\n        timeoutSeconds := int64(minWatchTimeout.Seconds() * (rand.Float64() + 1.0))\n        options = metav1.ListOptions{\n            ResourceVersion: resourceVersion,\n            TimeoutSeconds: &timeoutSeconds,\n            AllowWatchBookmarks: true,\n        }\n\n        // watch, 用上面全量获取后的 资源版本号, 表示监听这之后的\n        // 增量更新\n        w, err := r.listerWatcher.Watch(options)\n        if err != nil {\n            if utilnet.IsConnectionRefused(err) || apierrors.IsTooManyRequests(err) {\n                &lt;-r.initConnBackoffManager.Backoff().C()\n                continue\n            }\n            return err\n        }\n\n        // 对监听到的事件进行处理\n        if err := r.watchHandler(start, w, &resourceVersion, resyncerrc, stopCh); err != nil {\n            if err != errorStopRequested {\n                switch {\n                case isExpiredError(err):\n                case apierrors.IsTooManyRequests(err):\n                    &lt;-r.initConnBackoffManager.Backoff().C()\n                    continue\n                default:\n                }\n            }\n            return nil\n        }\n    }\n}\n\n\n在实例化Informer的时候, 设置了对应的list和watch方法 关于 pod的list和watch 操作 参考 博文\ninformer := sharedInformers.Core().V1().Pods().Informer()\nfunc (f *podInformer) Informer() cache.SharedIndexInformer {\n    return f.factory.InformerFor(&corev1.Pod{}, f.defaultInformer)\n}\n// f.defaultInformer\nfunc (f *podInformer) defaultInformer(client kubernetes.Interface, resyncPeriod time.Duration) cache.SharedIndexInformer {\n    return NewFilteredPodInformer(client, f.namespace, resyncPeriod, cache.Indexers{cache.NamespaceIndex: cache.MetaNamespaceIndexFunc}, f.tweakListOptions)\n}\n// NewFilteredPodInformer\nfunc NewFilteredPodInformer(client kubernetes.Interface, namespace string, resyncPeriod time.Duration, indexers cache.Indexers, tweakListOptions internalinterfaces.TweakListOptionsFunc) cache.SharedIndexInformer {\n    return cache.NewSharedIndexInformer(\n        &cache.ListWatch{\n            ListFunc: func(options metav1.ListOptions) (runtime.Object, error) {\n                if tweakListOptions != nil {\n                    tweakListOptions(&options)\n                }\n                // 这个就是获取所有pod的操作\n                return client.CoreV1().Pods(namespace).List(context.TODO(), options)\n            },\n            WatchFunc: func(options metav1.ListOptions) (watch.Interface, error) {\n                if tweakListOptions != nil {\n                    tweakListOptions(&options)\n                }\n                // watch操作\n                return client.CoreV1().Pods(namespace).Watch(context.TODO(), options)\n            },\n        },\n        &corev1.Pod{},\n        resyncPeriod,\n        indexers,\n    )\n}\n\n\nfunc (p *ListPager) List(ctx context.Context, options metav1.ListOptions) (runtime.Object, bool, error) {\n    if options.Limit == 0 {\n        options.Limit = p.PageSize\n    }\n    requestedResourceVersion := options.ResourceVersion\n    requestedResourceVersionMatch := options.ResourceVersionMatch\n    var list *metainternalversion.List\n    paginatedResult := false\n\n    for {\n        select {\n        case &lt;-ctx.Done():\n            return nil, paginatedResult, ctx.Err()\n        default:\n        }\n\n        obj, err := p.PageFn(ctx, options)\n        if err != nil {\n            // Expired #(1)\n            if !errors.IsResourceExpired(err) || !p.FullListIfExpired || options.Continue == \"\" {\n                return nil, paginatedResult, err\n            }\n            // 我们重新发起请求\n            options.Limit = 0\n            options.Continue = \"\"\n            options.ResourceVersion = requestedResourceVersion\n            options.ResourceVersionMatch = requestedResourceVersionMatch\n            result, err := p.PageFn(ctx, options)\n            return result, paginatedResult, err\n        }\n        m, err := meta.ListAccessor(obj)\n        if err != nil {\n            return nil, paginatedResult, fmt.Errorf(\"returned object must be a list: %v\", err)\n        }\n\n        if len(m.GetContinue()) == 0 && list == nil {\n            return obj, paginatedResult, nil\n        }\n\n        if list == nil {\n            list = &metainternalversion.List{Items: make([]runtime.Object, 0, options.Limit+1)}\n            list.ResourceVersion = m.GetResourceVersion()\n            list.SelfLink = m.GetSelfLink()\n        }\n        // 这里大体上是这样的 #(2)\n        if err := meta.EachListItem(obj, func(obj runtime.Object) error {\n            list.Items = append(list.Items, obj)\n            return nil\n        }); err != nil {\n            return nil, paginatedResult, err\n        }\n\n        if len(m.GetContinue()) == 0 {\n            return list, paginatedResult, nil\n        }\n\n        options.Continue = m.GetContinue()\n        options.ResourceVersion = \"\"\n        options.ResourceVersionMatch = \"\"\n        paginatedResult = true\n    }\n}\n\nIsResourceExpired 比如自己测试,你分页请求 使用continue 第二页的时候,等待一些时间, 再发起请求\n\n{\n    \"kind\": \"Status\",\n    \"apiVersion\": \"v1\",\n    \"metadata\": {\n        \"continue\": \"XXXXXXXXXXXXX\"\n    },\n    \"status\": \"Failure\",\n    \"message\": \"The provided continue parameter is too old to display a consistent list result.\n    You can start a new list without the continue parameter, or use the continue token \n    in this response to retrieve the remainder of the results. \n    Continuing with the provided token results in an inconsistent list - objects that were created,\n    modified, or deleted between the time the first chunk was returned and now may show up in the list.\",\n    \"reason\": \"Expired\",\n    \"code\": 410\n}\n\nmeta.EachListItem() list()获取的列表,将items里每个添加到list中\n\n{\n    \"kind\": \"PodList\",\n    \"apiVersion\": \"v1\",\n    \"metadata\": {\n        \"resourceVersion\": \"2871322\"\n    },\n    \"items\": [\n        {},\n        {},\n        {},\n        {}\n    ]\n}\n\n\n// watchHandler watches w and keeps *resourceVersion up to date.\nfunc (r *Reflector) watchHandler(start time.Time, w watch.Interface, resourceVersion *string, errc chan error, stopCh &lt;-chan struct{}) error {\n    eventCount := 0\n\n    // Stopping the watcher should be idempotent and if we return from this function there's no way\n    // we're coming back in with the same watch interface.\n    defer w.Stop()\n\nloop:\n    for {\n        select {\n        case &lt;-stopCh:\n            return errorStopRequested\n        case err := &lt;-errc:\n            return err\n        case event, ok := &lt;-w.ResultChan():\n            if !ok {\n                break loop\n            }\n            if event.Type == watch.Error {\n                return \n            }\n            if r.expectedType != nil {\n                if e, a := r.expectedType, reflect.TypeOf(event.Object); e != a {\n                    continue\n                }\n            }\n            if r.expectedGVK != nil {\n                if e, a := *r.expectedGVK, event.Object.GetObjectKind().GroupVersionKind(); e != a {\n                    continue\n                }\n            }\n            meta, err := meta.Accessor(event.Object)\n            if err != nil {\n                continue\n            }\n            newResourceVersion := meta.GetResourceVersion()\n            switch event.Type {\n                // 添加到DeltaFIFO 中\n            case watch.Added:\n                err := r.store.Add(event.Object)\n                if err != nil {\n                }\n            case watch.Modified:\n                err := r.store.Update(event.Object)\n                if err != nil {\n                }\n            case watch.Deleted:\n                err := r.store.Delete(event.Object)\n                if err != nil {\n                }\n            case watch.Bookmark:\n                // A `Bookmark` means watch has synced here, just update the resourceVersion\n            default:\n            }\n            *resourceVersion = newResourceVersion\n            r.setLastSyncResourceVersion(newResourceVersion)\n            if rvu, ok := r.store.(ResourceVersionUpdater); ok {\n                rvu.UpdateResourceVersion(newResourceVersion)\n            }\n            eventCount++\n        }\n    }\n\n    watchDuration := r.clock.Since(start)\n    if watchDuration &lt; 1*time.Second && eventCount == 0 {\n        return\n    }\n    return nil\n}\n\n\n\n\n\nfunc (c *controller) processLoop() {\n    for {\n        obj, err := c.config.Queue.Pop(PopProcessFunc(c.config.Process))\n        if err != nil {\n            if err == ErrFIFOClosed {\n                return\n            }\n            if c.config.RetryOnError {\n                c.config.Queue.AddIfNotPresent(obj)\n            }\n        }\n    }\n}\n\nPop()c.config.processs.processor.distribute\n\n\nfunc (f *DeltaFIFO) Pop(process PopProcessFunc) (interface{}, error) {\n    f.lock.Lock()\n    defer f.lock.Unlock()\n    for {\n        for len(f.queue) == 0 {\n            if f.closed {\n                return nil, ErrFIFOClosed\n            }\n            f.cond.Wait()\n        }\n        id := f.queue[0] // 弹出一个\n        f.queue = f.queue[1:] // 队列=剩余的\n        depth := len(f.queue)\n        if f.initialPopulationCount &gt; 0 {\n            f.initialPopulationCount--\n        }\n        item, ok := f.items[id]\n        if !ok {\n            continue\n        }\n        delete(f.items, id)\n        err := process(item)\n        if e, ok := err.(ErrRequeue); ok {\n            f.addIfNotPresent(id, item)\n            err = e.Err\n        }\n        return item, err\n    }\n}\n\n\n\n\nprocess() 处理方法\n\nfunc (s *sharedIndexInformer) Run(stopCh &lt;-chan struct{}) {\n    // ...\n    cfg := &Config{\n        Queue:            fifo,\n        //...\n        Process:           s.HandleDeltas,\n        WatchErrorHandler: s.watchErrorHandler,\n    }\n}\nfunc (s *sharedIndexInformer) HandleDeltas(obj interface{}) error {\n    s.blockDeltas.Lock()\n    defer s.blockDeltas.Unlock()\n\n    // from oldest to newest\n    for _, d := range obj.(Deltas) {\n        switch d.Type {\n        case Sync, Replaced, Added, Updated:\n            s.cacheMutationDetector.AddObject(d.Object)\n            if old, exists, err := s.indexer.Get(d.Object); err == nil && exists {\n                // 更新缓存\n                if err := s.indexer.Update(d.Object); err != nil {\n                    return err\n                }\n\n                isSync := false\n                switch {\n                case d.Type == Sync:\n                    // Sync events are only propagated to listeners that requested resync\n                    isSync = true\n                case d.Type == Replaced:\n                    if accessor, err := meta.Accessor(d.Object); err == nil {\n                        if oldAccessor, err := meta.Accessor(old); err == nil {\n                            // Replaced events that didn't change resourceVersion are treated as resync events\n                            // and only propagated to listeners that requested resync\n                            isSync = accessor.GetResourceVersion() == oldAccessor.GetResourceVersion()\n                        }\n                    }\n                }\n                s.processor.distribute(updateNotification{oldObj: old, newObj: d.Object}, isSync)\n            } else {\n                if err := s.indexer.Add(d.Object); err != nil {\n                    return err\n                }\n                s.processor.distribute(addNotification{newObj: d.Object}, false)\n            }\n        case Deleted:\n            if err := s.indexer.Delete(d.Object); err != nil {\n                return err\n            }\n            s.processor.distribute(deleteNotification{oldObj: d.Object}, false)\n        }\n    }\n    return nil\n}\n\n\n\nfunc (p *sharedProcessor) distribute(obj interface{}, sync bool) {\n    p.listenersLock.RLock()\n    defer p.listenersLock.RUnlock()\n\n    if sync {\n        for _, listener := range p.syncingListeners {\n            // \n            listener.add(obj)\n        }\n    } else {\n        for _, listener := range p.listeners {\n            listener.add(obj)\n        }\n    }\n}\n\n\n\n\n\n\n\n\n前面informer.run中 wg.StartWithChannel(processorStopCh, s.processor.run)\nfunc (p *sharedProcessor) run(stopCh &lt;-chan struct{}) {\n    func() {\n        p.listenersLock.RLock()\n        defer p.listenersLock.RUnlock()\n        for _, listener := range p.listeners {\n            p.wg.Start(listener.run)  //(1)\n            p.wg.Start(listener.pop)\n        }\n        p.listenersStarted = true\n    }()\n    &lt;-stopCh\n    p.listenersLock.RLock()\n    defer p.listenersLock.RUnlock()\n    for _, listener := range p.listeners {\n        close(listener.addCh) // Tell .pop() to stop. .pop() will tell .run() to stop\n    }\n    p.wg.Wait() // Wait for all .pop() and .run() to stop\n}\n\nlistener.run\n\nfunc (p *processorListener) run() {\n    // this call blocks until the channel is closed.  When a panic happens during the notification\n    // we will catch it, **the offending item will be skipped!**, and after a short delay (one second)\n    // the next notification will be attempted.  This is usually better than the alternative of never\n    // delivering again.\n    stopCh := make(chan struct{})\n    wait.Until(func() {\n        for next := range p.nextCh {\n            switch notification := next.(type) {\n            case updateNotification:\n                // OnUpdate这些就是我们前面.Informer().AddEventHandler(..)\n                p.handler.OnUpdate(notification.oldObj, notification.newObj)\n            case addNotification:\n                p.handler.OnAdd(notification.newObj)\n            case deleteNotification:\n                p.handler.OnDelete(notification.oldObj)\n            default:\n                utilruntime.HandleError(fmt.Errorf(\"unrecognized notification: %T\", next))\n            }\n        }\n        // the only way to get here is if the p.nextCh is empty and closed\n        close(stopCh)\n    }, 1*time.Second, stopCh)\n}\n\n\n\nstaging/src/k8s.io/client-go/informers/ 有各种资源的informer\n\n\n\n2.5 informer\n\n\n\n\n\n\nTip\n\n\n\n\ninform: 通知 的意思\n每一个k8s资源上都实现了Informer机制\n通过informer与apiserver进行通信,保证通信的实时性、可靠性、顺序性等\ninformer到底是如何工作的呢?\n\n\n\n\n2.5.1 先看看一个简单例子\npackage main\n\nimport (\n    \"flag\"\n    \"fmt\"\n    \"path/filepath\"\n    \"time\"\n\n    // corev1 \"k8s.io/api/core/v1\"\n\n    metav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n    \"k8s.io/client-go/informers\"\n    \"k8s.io/client-go/kubernetes\"\n    \"k8s.io/client-go/tools/cache\"\n    \"k8s.io/client-go/tools/clientcmd\"\n    \"k8s.io/client-go/util/homedir\"\n)\n\nfunc main() {\n    // fmt.Println(reflect.TypeOf(&corev1.Pod{}))\n    // return\n    var kubeconfig *string\n    if home := homedir.HomeDir(); home != \"\" {\n        // ~/.kube/config 确保你家目录下有k8s的配置文件\n        // 你本地可以用kubectl get po 进行查询.\n        kubeconfig = flag.String(\"kubeconfig\", filepath.Join(home, \".kube\", \"config\"), \"(optional) absolute path to the kubeconfig file\")\n    } else {\n        kubeconfig = flag.String(\"kubeconfig\", \"\", \"absolute path to the kubeconfig file\")\n    }\n    flag.Parse()\n\n    // 使用指定的kubeconfig文件创建一个Config对象\n    config, err := clientcmd.BuildConfigFromFlags(\"\", *kubeconfig)\n    if err != nil {\n        panic(err.Error())\n    }\n\n    // 创建一个新的Kubernetes客户端\n    clientset, err := kubernetes.NewForConfig(config)\n    if err != nil {\n        panic(err.Error())\n    }\n\n    stopCh := make(chan struct{})\n    defer close(stopCh)\n    sharedInformerFactory := informers.NewSharedInformerFactory(\n        // 需要这个 与apiserver 交互\n        clientset,\n        time.Minute,\n    )\n    // 获取pod资源的informer 对象,监听谁\n    informer := sharedInformerFactory.Core().V1().Pods().Informer()\n    // informer2 := sharedInformers.Core().V1().Pods().Informer()\n\n    informer.AddEventHandler(cache.ResourceEventHandlerFuncs{\n        // 创建pod 资源时触发的事件回调方法\n        AddFunc: func(obj interface{}) {\n            // k8s实际这里是将 事件推送到 workQueue\n            // 我们例子直接打印看看\n            metav1Obj := obj.(metav1.Object)\n            fmt.Println(\"新的pod被添加到缓存中\", metav1Obj.GetName())\n        },\n        DeleteFunc: func(obj interface{}) {\n            metav1Obj := obj.(metav1.Object)\n            fmt.Println(\"pod从缓存中删除\", metav1Obj.GetName())\n        },\n        UpdateFunc: func(oldObj, newObj interface{}) {\n            oObj := oldObj.(metav1.Object)\n            nObj := newObj.(metav1.Object)\n            fmt.Printf(\"%s pod updated to %s\\n\", oObj.GetName(), nObj.GetName())\n        },\n    })\n    informer.Run(stopCh)\n    // sharedInformerFactory.Start(stopCh)\n\n}\n\n\nSharedInformer\n\n\nfunc (f *podInformer) Informer() cache.SharedIndexInformer {\n    return f.factory.InformerFor(&corev1.Pod{}, f.defaultInformer)\n}\n\nfunc (f *sharedInformerFactory) InformerFor(obj runtime.Object, newFunc internalinterfaces.NewInformerFunc) cache.SharedIndexInformer {\n\n    informerType := reflect.TypeOf(obj)\n    informer, exists := f.informers[informerType]\n    // 对于同一个类型的资源 ,不需要重复创建\n    // 存在就直接返回\n    if exists {\n        return informer\n    }\n\n    resyncPeriod, exists := f.customResync[informerType]\n    if !exists {\n        resyncPeriod = f.defaultResync\n    }\n\n    informer = newFunc(f.client, resyncPeriod)\n    // 第一次 设置\n    f.informers[informerType] = informer\n\n    return informer\n}\n\n\n\n2.5.2 Reflector\n\n2.5.2.1 Bookmark event\nwatch bookmark\npod list 后, watch 里比如一直没有pod资源的事件, 其他资源的事件很多导致 resourceVersion 变大了很多, 然后由于k8s etcd 5分钟就会compact, 然后某个时候 pod 的informer 出了问题,后重新连接, 我们需要重新开始同步 ,使用list, 会用之前存的比较老的resourceVersion,但是这个可能已经被compact过的, 这样会导致错误,然后重新 从etcd 全量拉取\n\n\n\n\n\n\n重要说明\n\n\n\n官方文档里写了, 就算你指定了allowWatchBookmarks=true 查询参数来请求 BOOKMARK 事件, 你也不能认为bookmark事件会在某一个特定的时间间隔触发 http://localhost:8001/api/v1/namespaces/default/pods?watch=1&allowWatchBookmarks=true\n\n\npackage main\n\nimport (\n    \"context\"\n    \"flag\"\n    \"fmt\"\n    \"log\"\n    \"path/filepath\"\n    \"time\"\n\n    corev1 \"k8s.io/api/core/v1\"\n    metav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n    \"k8s.io/apimachinery/pkg/watch\"\n    \"k8s.io/client-go/kubernetes\"\n    \"k8s.io/client-go/tools/clientcmd\"\n    \"k8s.io/client-go/util/homedir\"\n)\n\nfunc main() {\n    var kubeconfig *string\n    if home := homedir.HomeDir(); home != \"\" {\n        kubeconfig = flag.String(\"kubeconfig\", filepath.Join(home, \".kube\", \"config\"), \"(optional) absolute path to the kubeconfig file\")\n    } else {\n        kubeconfig = flag.String(\"kubeconfig\", \"\", \"absolute path to the kubeconfig file\")\n    }\n    flag.Parse()\n\n    config, err := clientcmd.BuildConfigFromFlags(\"\", *kubeconfig)\n    if err != nil {\n        panic(err.Error())\n    }\n\n    clientset, err := kubernetes.NewForConfig(config)\n    if err != nil {\n        panic(err.Error())\n    }\n    watcher, err := clientset.CoreV1().Pods(\"\").Watch(context.TODO(), metav1.ListOptions{\n        // LabelSelector: \"app=pod-vol,run=test\",\n        AllowWatchBookmarks: true,\n        ResourceVersion:     \"2937860\", // ResourceVersion 如果已经被压缩过, 不会报错\n    })\n    if err != nil {\n        log.Fatal(err)\n    }\n\nLoop:\n    for {\n        select {\n        case event := &lt;-watcher.ResultChan():\n            // meta, err := meta.Accessor(event.Object)\n            // newResourceVersion := meta.GetResourceVersion()\n            // meta, _ := meta.Accessor(event.Object)\n\n            pod, ok := event.Object.(*corev1.Pod)\n            newResourceVersion := pod.GetResourceVersion()\n\n            if !ok {\n                fmt.Println(\"xxxx::\", pod)\n            }\n            switch event.Type {\n            case watch.Added:\n                fmt.Printf(\"Pod %s added: %s,%s\\n\", pod.Name, pod.GetResourceVersion(), pod.ResourceVersion)\n            case watch.Modified:\n                fmt.Printf(\"Pod %s modified: %s,%s\\n\", pod.Name, pod.GetResourceVersion(), pod.ResourceVersion)\n            case watch.Deleted:\n                fmt.Printf(\"Pod deleted: %s\\n\", pod.Name)\n            case watch.Bookmark:\n                fmt.Println(\"book:\", pod.Name, time.Now().Format(\"15:04:05\"), newResourceVersion)\n            }\n        case &lt;-time.After(6660 * time.Second):\n            fmt.Println(9999)\n            break Loop\n        }\n    }\n\n\n}\n\n\n\n\n执行的结果...\n\nbook:  16:15:22 2939960\n\nbook:  16:16:22 2939960\n\nbook:  16:17:22 2939960\n\nbook:  16:18:22 2939960\n\nbook:  16:19:22 2939960\n\n\n\n\n\n\n\n代码还没有细看,回答暂时都是我的猜测\n\n\n\n\n问:\n\n根据代码测试, 发现大概1分钟(根据上面的重要说明,这个不用纠结它)能接收到bookmark 事件, 但是收到的resourceVersion 一直都是旧的, 很久后的bookmark事件收到的resourceVersion 才是稍微新一点的, 这和我们上面说的bookmark的目的有点相违背了?\n\n答:\n\n我们访问的是实际是APIServer(数据它给的), APIServer 也有 listAndWatch, 从etcd那里获取数据缓存到它的本地, 而如果没有对应的事件, apiserver缓存就不会更新resourceVersion, etcd是没有bookmark 事件的, bookmark是apiserver设计提供给其他客户端的一种事件.\n我们访问 http://localhost:8001/api/v1/namespaces/default/pods?resourceVersion=2939961 会发现提示Too large resource version,所以首先上面的结果一直没变是对的,因为apiserver本身就没有更新resourceVersion, 然而实际上 etcd已经compact了, 这个版本在etcd里已经不存在了.\n不同资源更新后设置自己更新时的resourceVersion,在上面的环境中,k create sa sa-test ,再获取它的resourceVersion rv,http://localhost:8001/api/v1/namespaces/default/serviceaccounts?resourceVersion=rv ok, 去 pods?resourceVersion=rv 报错Too large resource version\n\n需要再确认\n\n问:\n\n如果一直没有对应事件, apiserver不可能一直不更新resourceVersion, 那么大概多久?\n\n答:\n\n10分钟? cmd/kube-apiserver/app/server.go\nversionedInformers = clientgoinformers.NewSharedInformerFactory(clientgoExternalClient, 10*time.Minute)\n我给出的答案可能是不对的, 我先标记一下,后续等看apiserver 源码再修改\n\n\n\n\n\n\n\n关于间隔1分钟\n\n// staging/src/k8s.io/apiserver/pkg/storage/cacher/cacher.go\nfunc (t *watcherBookmarkTimeBuckets) addWatcher(w *cacheWatcher) bool {\n    nextTime, ok := w.nextBookmarkTime(t.clock.Now(), t.bookmarkFrequency)\n    //...\n}\nfunc newTimeBucketWatchers(clock clock.Clock, bookmarkFrequency time.Duration) *watcherBookmarkTimeBuckets {\n    return &watcherBookmarkTimeBuckets{\n        watchersBuckets:   make(map[int64][]*cacheWatcher),\n        createTime:        clock.Now(),\n        startBucketID:     0,\n        clock:             clock,\n        bookmarkFrequency: bookmarkFrequency,\n    }\n}\n\nfunc NewCacherFromConfig(config Config) (*Cacher, error) {\n    //...\n    cacher := &Cacher{\n        // ...\n        bookmarkWatchers: newTimeBucketWatchers(config.Clock, defaultBookmarkFrequency),\n    }\n}\nvar (\n    defaultBookmarkFrequency = time.Minute\n)\n\n\n\n\n2.5.3 DeltaFIFO\n\n\n\n\n\n\nTip\n\n\n\n\n前面我们看到, Reflector 通过 ListAndWatch 将数据先都添加到 DeltaFIFO 这个队列中去了\n接下来看看这个的具体情况\ndelta: 在数学中表示变化量\n\n\n\n\n\nDeltaFIFO\n\n\n\nitems存放的\n\ntype Deltas []Delta\n\n// 存放的资源对象的变化\ntype Delta struct {\n    Type   DeltaType // 变化的类型\n    Object interface{}\n}\n\ntype DeltaType string\n\nconst (\n    Added   DeltaType = \"Added\"\n    Updated DeltaType = \"Updated\"\n    Deleted DeltaType = \"Deleted\"\n    Replaced DeltaType = \"Replaced\"\n    Sync DeltaType = \"Sync\"\n)\n\nkeyFunc\n\nfunc NewDeltaFIFOWithOptions(opts DeltaFIFOOptions) *DeltaFIFO {\n    if opts.KeyFunction == nil {\n        // 获取key的方法\n        opts.KeyFunction = MetaNamespaceKeyFunc\n    }\n\n    f := &DeltaFIFO{\n        items:        map[string]Deltas{},\n        queue:        []string{},\n        keyFunc:      opts.KeyFunction,\n        knownObjects: opts.KnownObjects,\n\n        emitDeltaTypeReplaced: opts.EmitDeltaTypeReplaced,\n    }\n    f.cond.L = &f.lock\n    return f\n}\nfunc MetaNamespaceKeyFunc(obj interface{}) (string, error) {\n    if key, ok := obj.(ExplicitKey); ok {\n        return string(key), nil\n    }\n    meta, err := meta.Accessor(obj)\n    if err != nil {\n        return \"\", fmt.Errorf(\"object has no meta: %v\", err)\n    }\n    if len(meta.GetNamespace()) &gt; 0 {\n        // 如果有命名空间 则key = 命名空间/资源定义里的name\n        return meta.GetNamespace() + \"/\" + meta.GetName(), nil\n    }\n    // 有些资源是没有命名空间的\n    return meta.GetName(), nil\n}\n\n\n\n\n\n\n2.5.4 Workqueue\n\n\n\n2.5.5 indexer",
    "crumbs": [
      "组件",
      "controller-manager"
    ]
  },
  {
    "objectID": "docs/devops/k8s/component/controller-manager.html#自定义控制器",
    "href": "docs/devops/k8s/component/controller-manager.html#自定义控制器",
    "title": "斯巴拉稀",
    "section": "3 自定义控制器",
    "text": "3 自定义控制器\n参考 pkg/controller/replicaset/replica_set.go\n\n\n\n\n\n\nTip\n\n\n\n下面的例子是当你创建一个service ,没有关联的pod 时,自动创建pod, 简单的demo,较粗糙\n\n\n\n3.1 代码\n├── go.mod\n├── main.go\n└── pkg\n    └── controller.go\n\n\nmain.go\n\npackage main\n\nimport (\n    \"ctrl01/pkg\"\n    \"flag\"\n    \"path/filepath\"\n    \"time\"\n\n    // corev1 \"k8s.io/api/core/v1\"\n\n    \"k8s.io/client-go/informers\"\n    \"k8s.io/client-go/kubernetes\"\n    \"k8s.io/client-go/rest\"\n    \"k8s.io/client-go/tools/clientcmd\"\n    \"k8s.io/client-go/util/homedir\"\n)\n\nfunc main() {\n    var kubeconfig *string\n    if home := homedir.HomeDir(); home != \"\" {\n        // ~/.kube/config 确保你家目录下有k8s的配置文件\n        // 你本地可以用kubectl get po 进行查询.\n        kubeconfig = flag.String(\"kubeconfig\", filepath.Join(home, \".kube\", \"config\"), \"(optional) absolute path to the kubeconfig file\")\n    } else {\n        kubeconfig = flag.String(\"kubeconfig\", \"\", \"absolute path to the kubeconfig file\")\n    }\n    flag.Parse()\n    // 使用指定的kubeconfig文件创建一个Config对象\n    config, err := clientcmd.BuildConfigFromFlags(\"\", *kubeconfig)\n    if err != nil {\n        // 我们当这种情况是在集群内部, 使用集群内部的配置\n        // 就是pod 的形式 运行我们这个controller 会用到的配置路径\n        config, err = rest.InClusterConfig()\n        if err != nil {\n            panic(err.Error())\n        }\n\n    }\n\n    // 创建一个新的Kubernetes客户端\n    clientset, err := kubernetes.NewForConfig(config)\n    if err != nil {\n        panic(err.Error())\n    }\n\n    stopCh := make(chan struct{})\n    defer close(stopCh)\n    sharedInformerFactory := informers.NewSharedInformerFactory(\n        // 需要这个 与apiserver 交互\n        clientset,\n        time.Minute,\n    )\n    // 获取pod资源的informer 对象,监听谁\n    serviceInformer := sharedInformerFactory.Core().V1().Services()\n    podInformer := sharedInformerFactory.Core().V1().Pods()\n\n    c := pkg.NewController(clientset, serviceInformer, podInformer)\n    sharedInformerFactory.Start(stopCh)\n    // 等待数据同步到DeltaFifo 完成后\n    sharedInformerFactory.WaitForCacheSync(stopCh)\n    // 我们才执行这个\n    c.Run(stopCh)\n}\n\n\n\ncontroller.go\n\npackage pkg\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"reflect\"\n    \"time\"\n\n    corev1 \"k8s.io/api/core/v1\"\n    metav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n    \"k8s.io/apimachinery/pkg/labels\"\n    \"k8s.io/apimachinery/pkg/selection\"\n    utilruntime \"k8s.io/apimachinery/pkg/util/runtime\"\n    \"k8s.io/apimachinery/pkg/util/sets\"\n    \"k8s.io/apimachinery/pkg/util/wait\"\n    coreInformerV1 \"k8s.io/client-go/informers/core/v1\"\n\n    \"k8s.io/client-go/kubernetes\"\n    coreListerV1 \"k8s.io/client-go/listers/core/v1\"\n\n    \"k8s.io/client-go/tools/cache\"\n    \"k8s.io/client-go/util/workqueue\"\n)\n\ntype controller struct {\n    client        kubernetes.Interface\n    podLister     coreListerV1.PodLister\n    serviceLister coreListerV1.ServiceLister\n    queue         workqueue.RateLimitingInterface\n}\n\n/*\n我们主要就是编写控制器\n定义相关的informer 表示用来获取什么类型的资源\n然后关心这些资源变化, 将监听到的对应事件处理函数写上\n*/\nfunc NewController(client kubernetes.Interface, serviceInformer coreInformerV1.ServiceInformer, podInformer coreInformerV1.PodInformer) controller {\n    c := controller{\n        client,\n        podInformer.Lister(),\n        serviceInformer.Lister(),\n        // 前面 controller-manager 架构里 说过\n        // DeltaFifo 消费时 数据没有直接处理,而是先放到工作队列中\n        workqueue.NewNamedRateLimitingQueue(workqueue.DefaultControllerRateLimiter(), \"serviceWorkqueue\"),\n    }\n\n    serviceInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs{\n        AddFunc:    c.addService,\n        UpdateFunc: c.updateService,\n    })\n    // podInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs{\n    //  DeleteFunc: c.deletePod,\n    // })\n    return c\n}\n\nfunc (c *controller) addService(obj interface{}) {\n    metav1Obj := obj.(metav1.Object)\n    fmt.Println(\"新的service被添加到缓存中\", metav1Obj.GetName())\n\n    c.enqueue(obj)\n}\n\nfunc (c *controller) updateService(oldObj, newObj interface{}) {\n    metav1Obj := oldObj.(metav1.Object)\n    metav1NewObj := newObj.(metav1.Object)\n    fmt.Println(\"service update\", metav1Obj.GetName(), metav1NewObj.GetName())\n    // 如果更新来的数据和旧的一样, 就不做操作\n    if reflect.DeepEqual(oldObj, newObj) {\n        return\n    }\n    fmt.Println(\"更新有变化, 添加到工作队列: \", metav1NewObj.GetName())\n    c.enqueue(newObj)\n}\n\nfunc (c *controller) deletePod(obj interface{}) {\n    // todo\n}\n\nvar workers = 5\n\n// 处理工作队列\nfunc (c *controller) Run(stopCh chan struct{}) {\n    for i := 0; i &lt; workers; i++ {\n        go wait.Until(c.worker, time.Minute, stopCh)\n    }\n    &lt;-stopCh\n}\nfunc (c *controller) worker() {\n    for c.processNextItem() {\n\n    }\n}\n\nfunc (c *controller) processNextItem() bool {\n    // 从队列中\n    item, shutdown := c.queue.Get()\n    if shutdown {\n        return false\n    }\n\n    defer c.queue.Done(item)\n    key := item.(string)\n    err := c.syncService(key)\n    if err == nil {\n        c.queue.Forget(key)\n        return true\n    }\n\n    utilruntime.HandleError(fmt.Errorf(\"sync %q failed with %v\", key, err))\n    c.queue.AddRateLimited(key)\n\n    return true\n\n}\n\n// syncService 这里就是简单测试, 写的很随意\n// 这里主要功能是 根据创建的service 的label selector,如果没有对应的pod, 则创建一个关联的pod.\n//  请参考k8s源码 比如 ReplicaSetController.syncReplicaSet()\nfunc (c *controller) syncService(key string) error {\n    // 从key 中获取 namespace 和 name\n    namespace, name, err := cache.SplitMetaNamespaceKey(key)\n    if err != nil {\n        return err\n    }\n    // 获取service 对象\n    service, err := c.serviceLister.Services(namespace).Get(name)\n\n    selectorLabelValue, ok := service.Spec.Selector[\"nginx-pod\"]\n    if !ok {\n        return nil\n    }\n    //\n    servicePodsRequire, err := labels.NewRequirement(\"nginx-pod\",\n        selection.Equals,\n        sets.NewString(selectorLabelValue).List())\n    if err != nil {\n        return err\n    }\n    servicePodsRequires := []labels.Requirement{\n        *servicePodsRequire,\n    }\n\n    // 从缓存 中获取pod\n    pods, err := c.podLister.\n        Pods(namespace).\n        List(labels.NewSelector().Add(servicePodsRequires...))\n    if err != nil {\n        return err\n    }\n    fmt.Println(\"len\", len(pods))\n    if len(pods) &gt; 0 {\n        fmt.Println(\"exists\", pods[0].GetName())\n        return nil\n    }\n    pod := &corev1.Pod{\n        ObjectMeta: metav1.ObjectMeta{\n            Name:      name + \"-pod\",\n            Namespace: namespace,\n            Labels: map[string]string{\n                \"nginx-pod\": selectorLabelValue,\n            },\n        },\n        Spec: corev1.PodSpec{\n            Containers: []corev1.Container{\n                {\n                    Name:            \"my-container\",\n                    Image:           \"nginx:1.14.2\",\n                    ImagePullPolicy: corev1.PullIfNotPresent,\n                },\n            },\n        },\n    }\n    p, err := c.client.CoreV1().\n        Pods(namespace).\n        Create(context.TODO(), pod, metav1.CreateOptions{})\n    if err != nil {\n        return err\n    }\n    fmt.Printf(\"创建了 service %s 关联的 pod: %s\\n\", name, p.Name)\n    return nil\n}\n\n// 添加到工作队列\nfunc (c *controller) enqueue(obj interface{}) {\n    // o := obj.(*corev1.Service)\n    // 获取key, 这个默认方法是  namespace/name 作为key\n    key, err := cache.MetaNamespaceKeyFunc(obj)\n    if err != nil {\n        utilruntime.HandleError(err)\n        return\n    }\n    fmt.Println(\"enqueue:\", key)\n    c.queue.Add(key)\n}\n\n\n\nsvc-controller.yaml\n\nkind: Service\napiVersion: v1\nmetadata:\n  name: svc-controller\nspec:\n  selector:\n    nginx-pod: abc\n  type: ClusterIP\n  ports:\n  - protocol: TCP\n    port: 80\n    targetPort: 80\n\ngo run main.go\nk apply -f svc-controller.yaml\nk get po # 查看是否创建了pod\n\n\n3.2 部署到k8s\nFROM golang:1.18.10-alpine as base\nWORKDIR /test\nCOPY . .\nRUN go env -w GOPROXY=https://goproxy.cn,http://mirrors.aliyun.com/goproxy/,https://goproxy.io,direct \\\n    && go mod tidy \\\n    && GOOS=linux GOARCH=amd64 go build -o my-controller  main.go\nFROM alpine:3.16\nCOPY --from=base /test/my-controller /my-controller\nCMD [\"/my-controller\"]\ndocker build -t hb.6o6.com/xyz/mycontroller:1.0 .\n# push 到你的harbor\n# 如果是 dockerhub , 记得 tag 变下\n\n\n\n\n\n\nWarning\n\n\n\n\n因为默认使用的default sa ,只有命名空间下的view 权限, 其他命名空间就没有了, 而我们代码是list watch所有命名空间,以及还有创建pod的操作\n使用 k logs 可以看到报错信息 这里我直接给 pod默认使用的sa 用户 clusterrolebinding 绑定一个clusterrole cluster-admin, 当然也可以自己创建clusterrole\n\n\n\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRoleBinding\nmetadata:\n  creationTimestamp: null\n  name: crb-default-clusterrole-view\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: ClusterRole\n  name: cluster-admin\nsubjects:\n- kind: ServiceAccount\n  name: default\n  namespace: default\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: deploy-my-controller\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: pod-my-controller\n  template:\n    metadata:\n      labels:\n        app: pod-my-controller\n    spec:\n      containers:\n      - name: c-deploy-controller\n        image: hb.6o6.com/xyz/mycontroller:1.0\n        imagePullPolicy: IfNotPresent\n        imagePullSecrets:\n          - name: regcred\nk apply -f svc-controller.yaml",
    "crumbs": [
      "组件",
      "controller-manager"
    ]
  },
  {
    "objectID": "docs/devops/k8s/command.html",
    "href": "docs/devops/k8s/command.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "!!! warning 未完待续, 需要重新整理"
  },
  {
    "objectID": "docs/devops/k8s/command.html#查",
    "href": "docs/devops/k8s/command.html#查",
    "title": "斯巴拉稀",
    "section": "1 查",
    "text": "1 查\n# 根据~/.kube/config  里面的配置找到要看的是哪个集群\n- context:\n    cluster: kubernetes  集群\n    user: kubernetes-admin  用户\n\n#命令空间级别的资源\nkubectl get ns \n    default           Active   115m\n    kube-node-lease   Active   115m\n    kube-public       Active   115m\n    kube-system       Active   115m\n# 查看节点\nkubectl get nodes\n# 等价\nkubectl get no\n\n\nkubectl get po / pod /pods\nkubectl get pods # 默认是看的default命名空间下的资源, 有多个pod\n#kube-system 命名空间下的 pod资源, 默认就有的\nget pods -n kube-system -o wide\nget po -nkube-system -owide # 可以连在一起写\n# 查看所有命名空间的pods\nkubectl get pods -A  # 等价于 --all-namespaces\n# 指定ns 多个pod\nkubectl get po/calico-node-6tfnq po/calico-node-mq6p6 -n kube-system\nkubectl get po -w  # watch 的, 一直在显示 \n#labels\nkubectl get po -w -l app=nginx\n# 可以这样 查看pod的image 是什么\nkubectl get po -l app=nginx  -oyaml |grep image:\n\n# 查看 node 的使用情况\nkubectl top node\n# 查看pod 的使用情况\nkubectl top pod"
  },
  {
    "objectID": "docs/devops/k8s/command.html#增",
    "href": "docs/devops/k8s/command.html#增",
    "title": "斯巴拉稀",
    "section": "2 增",
    "text": "2 增\n# 创建命令空间\nkubectl create ns dev \n# 同上一模一样的效果\nkubectl create namespace dev\n# 删除一个资源\n#namespaces 表示一种资源类型\nkubectl delete namespaces dev\nkubectl delete ns/dev #同上, 可以指定多个 \nkubectl delete ns/dev ns/test\n\n# 这个是陈述式的 语句\n# 如果已经创建过,则会报错\nkubectl create -f dev-ns.yaml\nkubectl create -f dashboard.yaml\n# 这个是申明式的语句,\n#这个不会报错,重新应用一遍\nkubectl apply -f dashboard.yaml #(推荐) \n# 查看状态\nkubectl get -f myapp.yaml\n#可以指定一个目录,一次创建多个\nkubectl apply -f ./\n\n# 注意这个 会先删除pod 再重建, 会导致Pod的IP地址和标识符uid发生变化\nkubectl replace --force -f dashboard.yaml\nk get po -o yaml # 看到的uid不一样了,/var/lib/kubelet/pods/\n\n\n# 使用已有的pod 到处一个pod 的yaml文件,然后修改修改\n# --export 这个参数,会让导出 少一些东西\nkubectl get pods/ngx-dep-75944fcf5f-jzlkm -o yaml --export &gt; aa.yaml\n\n# 创建一个deploy\nkubectl create deploy ngx-dep  --image=nginx:1.14-alpine"
  },
  {
    "objectID": "docs/devops/k8s/command.html#删",
    "href": "docs/devops/k8s/command.html#删",
    "title": "斯巴拉稀",
    "section": "3 删",
    "text": "3 删\n# 删除命名空间下的所有pod\nkubectl delete po --all\n\n# 同样根据文件来删除 里面指定的pod\nkubectl delete -f dev-ns.yaml\n\n# -l labels 来过滤 ,删除掉这些labels 的pod\nKubectl delete po -l app=nginx\n# 默认情况下 ,所有的删除操作都会附有 30 秒钟的宽限期限\n# kubectl delete 命令支持 --grace-period=&lt;seconds&gt; 选项，允许你重载默认值， 设定自己希望的期限值\n# 强制删除, 比如node 节点你停止了. 想要删除上面的 pod\nk delete po redis-cache-7954659dc4  --grace-period=0  --force\n\n# 删除pod里的容器\nk  delete pod &lt;pod_name&gt; -c &lt;container_name&gt;"
  },
  {
    "objectID": "docs/devops/k8s/command.html#改",
    "href": "docs/devops/k8s/command.html#改",
    "title": "斯巴拉稀",
    "section": "4 改",
    "text": "4 改\n# 进入pod 中的某个容器, 如果该pod有多个容器 容器名前面需要加 -c\n# 先查看pod\nkubectl get pods\n# 获取pod 更多信息,找到 里面的容器名\n    containers:\n    - image: nginx:1.14-alpine\n        imagePullPolicy: IfNotPresent\n        name: nginx # 这个就是容器名\n        resources: {}\n        terminationMessagePath: /dev/termination-log\n        terminationMessagePolicy: File\n        volumeMounts:\n        - mountPath: /var/run/secrets/kubernetes.io/serviceaccount\n        name: default-token-9qwmq\n        readOnly: true\n\nkubectl get pods/ngx-dep-75944fcf5f-jzlkm -o yaml\n# kubectl exec pod名 -c 容器名  -n 命名空间\nkubectl exec ngx-dep-75944fcf5f-jzlkm -c nginx  -it -- /bin/sh\n## -- 后面直接运行你要运行的命令, 比如 rm删什么东西\nkubectl exec ngx-dep-75944fcf5f-jzlkm -c nginx  -- rm /test.txt\n# 如果只有一个容器,则可以 省略 -c 容器名\n# 进去之后可以查看ip 地址,\n\n4.1 patch\nyaml title=\"nginx-test.yaml\" apiVersion: v1 kind: Pod metadata:   labels:     run: nginx-test   name: nginx-test   namespace: test spec:   containers:   - image: nginx:1.14.2     name: nginx1\nyaml title=\"patch.yaml\" metadata:   labels:     app: nginx-oo\n\nk apply -f nginx-test.yaml\n# 没有的就增加, 有的就更新\n# 也只有一些属性可以这样操作\nk patch pod -n test nginx-test  --patch \"$(cat patch.yaml)\"\nk get po -n test nginx-test -o yaml"
  },
  {
    "objectID": "docs/devops/k8s/command.html#其他",
    "href": "docs/devops/k8s/command.html#其他",
    "title": "斯巴拉稀",
    "section": "5 其他",
    "text": "5 其他\nkubernetes port-forward podname nodeport:podport"
  },
  {
    "objectID": "docs/devops/k8s/command.html#pod的操作",
    "href": "docs/devops/k8s/command.html#pod的操作",
    "title": "斯巴拉稀",
    "section": "6 pod的操作",
    "text": "6 pod的操作\n# c = container\n# 没看到容器 相关\nctr c ls\n# 我们需要加上namespace 才能看到\nctr -n k8s.io c ls\n    0ccb703e70ea5b20c7aa12459cd71a6c5bc5ff2cc8ba05c9ed5523f2689d663b    registry.cn-hangzhou.aliyuncs.com/google_containers/pause:3.6          io.containerd.runc.v2\n    \n#修改pod里容器的资源开销\nkubectl set resources deployment nginx-app -c=nginx -- limits=cpu=500m,memory=128Mi\n\n6.1 直接创建\n#直接命令创建 ,不推荐\nkubectl run nginx-test --image=nginx\n#运行一个临时的 pod \nkubectl run -it --image busybox dns-test --restart=Never --rm /bin/sh\n\nkubectl get po -owide\n    nginx-test   1/1     Running   0              4m54s   172.20.204.66    m3 \n# 测试\ncurl 172.20.204.66:80\nkubectl delete po nginx-test\n\n\n6.2 使用yaml文件创建\nkubectl run nginx-test --image=nginx  --dry-run -oyaml  &gt;nginx.yaml\n\n    #--dry-run is deprecated and can be replaced with --dry-run=client.\n    apiVersion: v1\n    kind: Pod #资源类型\n    metadata: #元数据\n      creationTimestamp: null\n      labels: # 标签\n        run: nginx-test # key value\n      name: nginx-test #pod 名称 \n    spec: #pod 真正的配置\n      containers: #配置容器的地方,可以定义多个\n      - image: nginx\n        name: nginx-test\n        ports:\n        - containerPort: 80\n        args: [\"abc\"] #相当于docker里的CMD\n        command: [ \"sleep\" ,\"10\" ] # 相当于docker里的entrypoint, 可以修改容器的启动命令\n        \n     #  - image: redis\n     #   name: redis\n        resources: {}\n      dnsPolicy: ClusterFirst\n      restartPolicy: Always\n    status: {}\n\n# 如果yaml文件里有多个配置(---隔开的). 可以选择创建哪一个.\nk create -f sidecar.yaml  -l run=nginx-test\n\n6.2.1 查看官方文档\n!!! tip 命令中有url 地址 ,官方的帮助文档\n#apiVersion: v1\n# 使用下面这个命令来查看 到底是使用什么版本\nkubectl api-resources |grep pod\n# 查看pod的申明式定义\nkubectl explain pod\nkubectl explain pod.spec.containers\nkubectl explain namespaces\nkubectl explain service\nkubectl explain service.kind # 多级解释\n\n\nkubectl create -f nginx.yaml\n# 如果你需要修改nginx.yaml 里的spec , 那么需要先删除原来的pod\nkubectl delete -f nginx.yaml\n\n\n\n6.3 events\nk get events\nk get ev # 简化..\n\n\n6.4 查看pod的状态,调查pod失败原因\nkubectl describe pod nginx-test\n\n# 直接执行一下 容器里的命令\nkubectl exec dep-nginx-cc78676bc-xlg48 -- ping 192.168.66.110\n\n# 进入容器 \nkubectl exec  -it dep-nginx-cc78676bc-xlg48 -- sh\n\n\n6.5 查看pod的日志\n# 容器里日志打在前台的可以这样直接看\nk logs nginx-test\n# 最近10m中内的日志 , --since=1h 一个小时\nk logs  nginx --since=10m\n# 实时查看\nk logs -f nginx-test\n# 查看最新的100行\nk logs --tail=100 nginx-test\n# Pod之前发生过崩溃,访问上一个Pod的日志\nk logs --previous nginx-test\n# k logs pod名 容器名\nk logs pod-nginx c-nginx1 -n test\n# 如果容器里日志写在它里面的某个文件, 那就 exec 进去容器 查看\nk exec nginx-test -- tail -f /var/logs/xxxxx"
  },
  {
    "objectID": "docs/devops/k8s/command.html#labels",
    "href": "docs/devops/k8s/command.html#labels",
    "title": "斯巴拉稀",
    "section": "7 labels",
    "text": "7 labels\n# 显示标签\nkubectl get po  --show-labels\n    NAME                         READY   STATUS    RESTARTS       AGE   LABELS\n    busybox                      1/1     Running   41 (20m ago)   8d    &lt;none&gt;\n    nginx-hpa-7b486cb77c-q6jd4   1/1     Running   0              55m   app=nginx-hpa,pod-template-hash=7b486cb77c\n# 使用标签过滤\nkubectl get po -l app=nginx\n\n# 打标器.,一次命令可以打多个标签,给多个对象打\nkubectl label node n1 n2 gpu=true disk=ssd\n# 更新 标签\nkubectl label node n1  gpu=false  --overwrite\n\n# 批量更新, 有gpu(可以是其他选择方式) 标签的 更新 gpu=xx\nkubectl label node -l gpu gpu=xx  --overwrite\n\n# 删除标签  key-\nkubectl label no n1 gpu-"
  },
  {
    "objectID": "docs/devops/k8s/command.html#注解",
    "href": "docs/devops/k8s/command.html#注解",
    "title": "斯巴拉稀",
    "section": "8 注解",
    "text": "8 注解\n# 添加\nk annotate sc nfs-client  storageclass.kubernetes.io/is-default-class=true\n# 删除\nk annotate sc nfs-client  storageclass.kubernetes.io/is-default-class-"
  },
  {
    "objectID": "docs/devops/cicd/git-server.html",
    "href": "docs/devops/cicd/git-server.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "Caution\n\n\n\ntodo…",
    "crumbs": [
      "git服务"
    ]
  },
  {
    "objectID": "docs/devops/cicd/git-server.html#git-服务",
    "href": "docs/devops/cicd/git-server.html#git-服务",
    "title": "斯巴拉稀",
    "section": "1 git 服务",
    "text": "1 git 服务\ngitea\n\n1.1 gogs\ngogs github docker方式安装\n\n\ndocker-compose\n\nversion: \"3\"\nvolumes:\n   gogs-data:\nservices:\n  gogs:\n    image: gogs/gogs\n   #  image: gogs/gogs:0.12.10\n    container_name: gogs\n    volumes:\n    - gogs-data:/data\n    restart: always\n    ports:\n      - \"10022:22\"\n      - \"10880:3000\"\n\n浏览器访问10880端口\nSSH 端口号 改成上面设置的10022\n数据库类型 自己测试可以暂时使用sqlite\n域名 改成 ip地址. 192.168.1.105\n应用 URL 改成 http://192.168.1.105:10880/\n\n管理员帐号设置  我设的 root root\n\nssh设置添加密钥\n右上角点击+号, 创建新的仓库\n然后你的代码那里 git remote add origin ... \ngit push -u origin master \n\n\n1.2 gitea\n\n\ndocker-compose.yaml\n\nversion: \"3\"\nnetworks:\n  gitea:\n    external: false\nvolumes:\n   gitea-data:\nservices:\n  server:\n    image: gitea/gitea:latest\n    container_name: gitea\n    environment:\n      - USER_UID=1000\n      - USER_GID=1000\n    restart: always\n    networks:\n      - gitea\n    volumes:\n      - gitea-data:/data\n      - /etc/timezone:/etc/timezone:ro\n      - /etc/localtime:/etc/localtime:ro\n    ports:\n      - \"10022:22\"\n      - \"10880:3000\"\n\n浏览器访问10880端口\n管理后台–&gt;应用–&gt; 创建oauth(url 填写drone的登录url : http://192.168.1.105:8084/login) 记住 客户端ID和客户端密钥 在drone中 填写..",
    "crumbs": [
      "git服务"
    ]
  },
  {
    "objectID": "docs/devops/linux/bash/var.html",
    "href": "docs/devops/linux/bash/var.html",
    "title": "bash 变量",
    "section": "",
    "text": "env # 打印所有环境变量\nprintenv # 同上\necho $HOME # 打印某个变量的值\nprintenv HOME # 同上\n\n# 一些常用的环境变量\necho $PWD\necho $HOST # 当前主机名\necho $IFS # 词与词的分隔符, 默认为空格\necho $RANDOM #返回一个0到32767之间的随机数\necho $SHELL  # 当前使用的Shell  比如 /bin/bash 或/bin/zsh",
    "crumbs": [
      "bash",
      "变量"
    ]
  },
  {
    "objectID": "docs/devops/linux/bash/var.html#环境变量",
    "href": "docs/devops/linux/bash/var.html#环境变量",
    "title": "bash 变量",
    "section": "",
    "text": "env # 打印所有环境变量\nprintenv # 同上\necho $HOME # 打印某个变量的值\nprintenv HOME # 同上\n\n# 一些常用的环境变量\necho $PWD\necho $HOST # 当前主机名\necho $IFS # 词与词的分隔符, 默认为空格\necho $RANDOM #返回一个0到32767之间的随机数\necho $SHELL  # 当前使用的Shell  比如 /bin/bash 或/bin/zsh",
    "crumbs": [
      "bash",
      "变量"
    ]
  },
  {
    "objectID": "docs/devops/linux/bash/var.html#自定义变量",
    "href": "docs/devops/linux/bash/var.html#自定义变量",
    "title": "bash 变量",
    "section": "2 自定义变量",
    "text": "2 自定义变量\n\n增读删export设置默认值\n\n\necho $ff # 没有定义的变量名 ,默认是空\na=1 # 两边不能用空格\n# 这个相当于 \"a=\" 然后 执行1 这个命令\n# 提示 没有1 这个命令\na= 1\na =1 # 同样 ,会将a 作为命令 执行,提示没有该命令\n\nstr=\"hello world\" # 用空格 用\"\" 包起来\necho $str  # hello world, 默认会将多个空格合并成一个\nstr=\"hello     world\"\necho $str  # hello world\necho \"$str\"  # hello     world\n\n\npython_version=3.10\npython=snake\n# $ 会将后面的字符串视为变量名\necho $python_version # 3.10\n# 使用{} 将变量名包起来\necho ${python}_version # snake_version\n\n\n变量的值当成变量名\n\na=b\nc=a\necho $c # a\necho ${!c} # b\n\n\n\na=1\nunset a\n# 设置为空, 就是删除, 前面说到,不定义,默认就是空\na=''\na=\n\n\na=1 # 只能在当前shell可用,\nexport a # 这样 在当前shell创建的子shell都可以使用该变量\nexport b=2 # 直接赋值export\n\n\n# b 不为空,则返回b的值, 否则返回 123\na=${b:-123}\necho $a # 123 ,b还是空的\n# b 不为空,则返回b的值, 否则设置b为123,并且返回123\na=${b:=123}\necho $a,$b # 123,123\n# c 不为空,则返回1, 否则返回空\n# 可以用来判断c 是否为空,返回1 就是不为空了\necho ${c:+1} #\nc=2\necho ${c:+1} # 1\n\n# 如果d变量未定义,则报错退出 ,错误信息是你写的 undefined\n# 用来防止变量未定义\n${d:?undefined} # -bash: d: undefined\n\n\n脚本中应用\n\n# 使用 1 到 9 表示参数\n#!/bin/bash\n${1:?\"请带上参数\"}",
    "crumbs": [
      "bash",
      "变量"
    ]
  },
  {
    "objectID": "docs/devops/linux/bash/var.html#局部变量和全局变量",
    "href": "docs/devops/linux/bash/var.html#局部变量和全局变量",
    "title": "bash 变量",
    "section": "3 局部变量和全局变量",
    "text": "3 局部变量和全局变量\n#!/bin/bash\na=1\nfoo(){\n    b=2 # 执行foo函数后, b是全局变量\n    local c=3 # 局部变量\n    local a=4 # 与外部的a 是不一样的变量\n}\nfoo\necho $a # 1\necho $b # 读取的到\necho $c # 读取不到\nbar(){\n    echo $b\n}\nbar # 会打印 b的值",
    "crumbs": [
      "bash",
      "变量"
    ]
  },
  {
    "objectID": "docs/devops/linux/bash/var.html#开头的特殊变量",
    "href": "docs/devops/linux/bash/var.html#开头的特殊变量",
    "title": "bash 变量",
    "section": "4 $开头的特殊变量",
    "text": "4 $开头的特殊变量\n# 上一个命令的退出码,我们用来判断命令执行是否成功\nlss\necho $?  # &gt; 0 表示执行失败, 0 表示成功\n\n# $$为当前Shell的进程ID\necho $$\n\n#$_ 上一个命令的最后一个参数\nls tmp_install\necho $_ # tmp_install\n\n\n脚本a.sh\n\n#!/bin/bash\n\necho $0\necho $1\necho $2\necho $*\necho $@\necho $#\n# 看看$@ $* 之间的区别\nfor var in \"$*\"\ndo\n    echo \"$var\"\ndone\n\nfor var in \"$@\"\ndo\n    echo \"$var\"\ndone\n\n\n\n执行 ./a.sh a b c 的结果\n\n./a.sh  # $0 脚本本身\na       # $1 第一个参数\nb       # $2 第二个参数\na b c   # $* 所有参数\na b c   # $@ 所有参数\n3       # $# 参数个数\na b c   # \"$*\" 参数作为一个整体\na       # \"$@\" 还是会\nb\nc",
    "crumbs": [
      "bash",
      "变量"
    ]
  },
  {
    "objectID": "docs/devops/linux/bash/var.html#declare-typeset",
    "href": "docs/devops/linux/bash/var.html#declare-typeset",
    "title": "bash 变量",
    "section": "5 declare / typeset",
    "text": "5 declare / typeset\n\n\n\n\n\n\nTip\n\n\n\ndeclare和typeset 等价\n\n\n\n5.1 打印当前环境所有变量\n# 不带参数\ndeclare\ntypeset\n\n\n5.2 申明为只读\n# 只读, 修改会报错\ndeclare -r a=1\na=2  # -bash: a: readonly variable\nunset a  # -bash: unset: a: cannot unset: readonly variable\n\n\n5.3 申明为整型\na1=1\na2=2\nc=b1+b2\necho $c  # 结果是  b1+b2\n# 我们计算是要这样的\na4=$((a1 + a2))  # 或a3=$(($a1 + $a2))\n# 申明为整型\ndeclare -i a1=1 a2=2\ndeclare -i res\nres=a1+a2\necho $res # 3\nres=a1+a2 # 3 这样其实就ok的, 只要 结果的变量设置为整型,a1和a2 不需要设置.\nres=a1+10 # 11\n\nd=1+2\necho d # 1+2\ndeclare -i d\nd=1+2\necho d # 3\n\n\n5.4 声明变量为大/小写字母\n# 申明为小写\ndeclare -l a\na=AbC\necho $a # abc\n# 申明为大写\ndeclare -u b\nb=abc\necho $b # ABC\n# 取消变量b 的大写申明\ndeclare +u b # - 变+ 都有类似效果\nb=abc\necho $b # abc 不再会变成ABC了\n\n\n5.5 申明为环境变量\na=1\ndeclare -x a # 同export a\n\n\n5.6 显示当前环境的所有函数\n# 打印当前环境的所有函数名 以及 定义\ndeclare -f\n# 只打印函数名\ndeclare -F",
    "crumbs": [
      "bash",
      "变量"
    ]
  },
  {
    "objectID": "docs/devops/linux/bash/var.html#字符串",
    "href": "docs/devops/linux/bash/var.html#字符串",
    "title": "bash 变量",
    "section": "6 字符串",
    "text": "6 字符串\n\n6.1 拼接\nstr1=\"hello\"\nstr2=\"world\"\nresult=\"$str1 $str2\"\n\n\n6.2 长度\nstr=\"hello world\"\necho ${#str} # 输出 \"11\"\n\necho $(expr length \"$str\")\necho `expr length \"$str\"`\n\n\n6.3 截取\n\n截取获取字符在字符串中的索引获取子串的长度\n\n\nstr=\"hello world\"\n#  从第6个索引开始,包含索引位置的字符, 截取5个字符.\necho ${str:6:5} # 输出 \"world\"\n\necho ${str:2} # llo world\n# 同上\necho ${str:(2)}  # llo world\n\n# : 后面必须有空格. -2 表示从尾部开始找\necho ${str: -2} #ld\n# 同上\necho ${str:(-2)} #ld\necho ${str: -5:2} # wo\necho ${str:(-5):2} # wo\n\n\n\n\n\n\n\n\nCaution\n\n\n\n\nexpr index 命令只能查找单个字符或字符串中的第一个字符，不能查找多个字符组成的子串\n如果是子串,那会将子串里的每个字符全部找一遍, 然后显示最短的那个\n==这里的索引是从1 开始的, 而${str:1} 是从0开始的==\n\n\n\nstr=\"hello world\"\n# 不是7 而是3?  这是因为它会将你的字串里的每个字符全部找一遍, 然后显示最短的那个\n# w 是在 第7个位置, o在 5,  而l 是在3 最短\nexpr index \"$str\" \"world\" # 3\nexpr index \"$str\" \"worle\" # 2\n\n# 我们应该这样使用这个\nexpr index \"$str\" \"w\"  # 7\n\n\n\n\n\n\nTip\n\n\n\n所以这个的用法 就不该整子串, 而是用来找单个字符的操作\n\n\n\n\n\n\n\n\n\n\nWarning\n\n\n\n必须是从头开始找的\n\n\nstr=\"hello world\"\nexpr match \"$str\" world # 0\nexpr match \"$str\" hell # 4\nexpr match \"$str\" hellq # 0\n\n\n\n\n\n6.4 替换\n\n替换第一个匹配的替换全部匹配的\n\n\nstr=\"hello hello world\"\necho ${str/hello/goodbye} # 输出 \"goodbye hello world\"\n\n\nstr=\"hello hello world\"\necho ${str//hello/goodbye} # 输出 \"goodbye goodbye world\"\n\n\n\n\n\n6.5 删除(替换为空)\n\n从头删除从尾删除\n\n\n\n\n最短匹配\n\nstr=\"hello world hello python\"\necho ${str#*llo} # world hello python\n\n\n\n最长匹配\n\nstr=\"hello world hello python\"\necho ${str##*llo} # python\n\n\n\n\n\n最短匹配\n\nstr=\"hello world hello python\"\necho ${str%llo*} # hello world he\n\n\n\n最长匹配\n\nstr=\"hello world hello python\"\necho ${str%%llo*} # he\n\n\n\n\n\n\n6.6 大小写转换\n\n大写转小写小写转大写\n\n\nstr=\"Hello World\"\necho ${str,,} # 输出 \"hello world\"\n\n\nstr=\"hello world\"\necho ${str^^} # 输出 \"HELLO WORLD\"",
    "crumbs": [
      "bash",
      "变量"
    ]
  },
  {
    "objectID": "docs/devops/linux/bash/var.html#数组",
    "href": "docs/devops/linux/bash/var.html#数组",
    "title": "bash 变量",
    "section": "7 数组",
    "text": "7 数组\n\n\n\n\n\n\nTip\n\n\n\n\n整型数组无需用declare -a arr 进行申明\n关联数组必须要declare -A arr 进行申明\n\n\n\n\n7.1 增\n\n方式一方式二方式三read -a追加元素\n\n\narr[0]=a\narr[1]=b\narr[2]=c\n\n\narr=(a b c) # 索引按顺序\narr=([0]=c [1]=a [2]=b) # 指定索引\n\n\ntouch a.txt b.txt c.txt\narr=(x *.txt)\necho ${arr[0]} # x\necho ${arr[1]} # a.txt\n\narr2=(x $(ls *.txt))\n\n\nread -a arr # 输入 a b c\necho ${arr[0]} # a\n\n\narr=(a b c)\narr+=(1 2 3)\necho ${arr[@]} # a b c 1 2 3 \n\n\n\n\n\n7.2 查\n\n单个元素所有元素元素个数元素的长度索引遍历截取\n\n\narr=(a b c)\necho ${arr[0]} # a\necho $arr  # 输出 首个元素的值\necho $arr[0] # 输出 a[0]  ,{} 是必须的.\n\n\narr=(a b c)\necho ${arr[@]} # a b c\necho ${arr[*]}\n\n\narr=([5]=1 [2]=4 [10]=1)\necho ${#arr[*]} #3\necho ${#arr[@]} #3\n\n\n\n\n索引0的元素的长度\n\narr=(abc e fg)\necho ${#arr[0]} #3\n\n\n\narr=([5]=1 [2]=4 [10]=1)\necho ${!arr[@]} # 打印索引 2 5 10\necho ${!arr[*]} # 同上\n\n\narr=(a b c)\nfor i in ${!arr[@]}\ndo\n    echo ${arr[i]}\ndone\n\n\n\n\n\n\n\n\nTip\n\n\n\n与字符串截取类似\n\n\narr=(a b c e f g)\n# ${arr[@]:position:length}\necho ${arr[@]:1:2} # b c\n# 省略 length\necho ${arr[@]:2} # c e f g\necho ${arr[@]: -2} # f g\necho ${arr[@]: -3:1} # e\n\n\n\n\n\n7.3 删\narr=(a b c)\necho ${!arr[@]} # 0 1 2\nunset arr[0]\necho ${arr[@]} # b c\necho ${!arr[@]} # 1 2, 索引0 没有了.\nunset arr # 全部删除\n\n\n7.4 关联数组\n\n\n\n\n\n\nCaution\n\n\n\n需要bash 4.0 以上版本\n\n\ndeclare -A it\nit[\"go\"]=\"1.19.0\"\nit[\"python\"]=\"3.10.0\"\nit[\"rust\"]=\"1.58.1\"",
    "crumbs": [
      "bash",
      "变量"
    ]
  },
  {
    "objectID": "docs/devops/linux/bash/grep.html",
    "href": "docs/devops/linux/bash/grep.html",
    "title": "bash grep",
    "section": "",
    "text": "-E/egrep\n\n\n\n\n不带-E的时候 那么{} () | + ? 没有特别含义,就是它本身,如果想要变成特殊含义则前面加上\n\n带上-E与之相反\n等价与egrep",
    "crumbs": [
      "bash",
      "grep"
    ]
  },
  {
    "objectID": "docs/devops/linux/bash/grep.html#v-显示不匹配的行",
    "href": "docs/devops/linux/bash/grep.html#v-显示不匹配的行",
    "title": "bash grep",
    "section": "1 -v 显示不匹配的行",
    "text": "1 -v 显示不匹配的行\n\n1.txt不带 -v带-v\n\n\nhello world\npython hell\nabc hello efg\n\n\ngrep hello 1.txt\n# 结果\nhello world\nabc hello efg\n\n\ngrep hello -v 1.txt\n# 结果\npython hell",
    "crumbs": [
      "bash",
      "grep"
    ]
  },
  {
    "objectID": "docs/devops/linux/bash/grep.html#忽略大小写",
    "href": "docs/devops/linux/bash/grep.html#忽略大小写",
    "title": "bash grep",
    "section": "2 忽略大小写",
    "text": "2 忽略大小写\ngrep -i hello &lt;&lt;EOF\nhello world\npython hell\nabc HeLlo efg\nEOF\n# 结果\nhello world\nabc HeLlo efg",
    "crumbs": [
      "bash",
      "grep"
    ]
  },
  {
    "objectID": "docs/devops/linux/bash/grep.html#显示行号",
    "href": "docs/devops/linux/bash/grep.html#显示行号",
    "title": "bash grep",
    "section": "3 显示行号",
    "text": "3 显示行号\ngrep -n hello &lt;&lt;EOF\nhello world\npython hell\nabc hello efg\nEOF\n\n1:hello world\n3:abc hello efg",
    "crumbs": [
      "bash",
      "grep"
    ]
  },
  {
    "objectID": "docs/devops/linux/bash/grep.html#递归搜索",
    "href": "docs/devops/linux/bash/grep.html#递归搜索",
    "title": "bash grep",
    "section": "4 递归搜索",
    "text": "4 递归搜索\ntree\n.\n├── 1.txt \n└── a\n    ├── 1.txt\n    └── b\n        └── 1.txt\n# 会搜索当前目录下的所有文件\ngrep -r hello # 不能指定文件\n    a/b/1.txt:go hello\n    a/1.txt:python hello\n    1.txt:hello\n    1.txt:hello world\n\n# -l 只显示 匹配的文件名\ngrep -rl hello\n    a/b/1.txt\n    a/1.txt\n    1.txt",
    "crumbs": [
      "bash",
      "grep"
    ]
  },
  {
    "objectID": "docs/devops/linux/bash/grep.html#f-按字面意思找",
    "href": "docs/devops/linux/bash/grep.html#f-按字面意思找",
    "title": "bash grep",
    "section": "5 -F 按字面意思找",
    "text": "5 -F 按字面意思找\ngrep \"he.*\" 1.txt\n    hello\n    hello world\n    hell\n    he.*\ngrep \"he\\.\\*\" 1.txt\n    he.*\ngrep -F \"he.*\" 1.txt\n    he.*",
    "crumbs": [
      "bash",
      "grep"
    ]
  },
  {
    "objectID": "docs/devops/linux/bash/grep.html#查看匹配行的前后几行",
    "href": "docs/devops/linux/bash/grep.html#查看匹配行的前后几行",
    "title": "bash grep",
    "section": "6 查看匹配行的前后几行",
    "text": "6 查看匹配行的前后几行\n# -A  --after-context\n# -B  --before-context\ncat example.txt|grep \"hello\" -A 10 -B 2",
    "crumbs": [
      "bash",
      "grep"
    ]
  },
  {
    "objectID": "docs/devops/linux/bash/grep.html#c-只显示匹配了几行",
    "href": "docs/devops/linux/bash/grep.html#c-只显示匹配了几行",
    "title": "bash grep",
    "section": "7 -c 只显示匹配了几行",
    "text": "7 -c 只显示匹配了几行\ngrep -c hello 1.txt",
    "crumbs": [
      "bash",
      "grep"
    ]
  },
  {
    "objectID": "docs/devops/linux/bash/grep.html#w-匹配整词",
    "href": "docs/devops/linux/bash/grep.html#w-匹配整词",
    "title": "bash grep",
    "section": "8 -w 匹配整词",
    "text": "8 -w 匹配整词\ngrep -w hello &lt;&lt;EOF\nhelloworld\nhello world\nabchello xzy\nEOF",
    "crumbs": [
      "bash",
      "grep"
    ]
  },
  {
    "objectID": "docs/devops/linux/bash/grep.html#x-匹配到整行",
    "href": "docs/devops/linux/bash/grep.html#x-匹配到整行",
    "title": "bash grep",
    "section": "9 -x 匹配到整行",
    "text": "9 -x 匹配到整行\ngrep -x \"hello world\" &lt;&lt;EOF\nhello world \nhello world\nhello world ok\nEOF\n# 只会匹配到第二行, 第一行 后面有空格 也不行.",
    "crumbs": [
      "bash",
      "grep"
    ]
  },
  {
    "objectID": "docs/devops/linux/bash/script.html",
    "href": "docs/devops/linux/bash/script.html",
    "title": "bash 脚本",
    "section": "",
    "text": "# 直接执行脚本, 会在一个子shell中执行脚本\n# 脚本执行完毕后, 子shell退出, 在子shell中设置的变量和函数不会影响到父shell环境\n./script.sh\n\n设置的变量或者函数都会在当前的shell环境中生效\n\n\nx\n\n# 设置的变量或者函数都会在当前的shell环境中生效\nsource ./script.sh\n# 完全等价于 source\n. ./script.sh\n\n\n# 设置的变量或者函数都会在当前的shell环境中生效\nsource ./script.sh\n# 完全等价于 source\n. ./script.sh",
    "crumbs": [
      "bash",
      "脚本"
    ]
  },
  {
    "objectID": "docs/devops/linux/bash/script.html#source-和-.",
    "href": "docs/devops/linux/bash/script.html#source-和-.",
    "title": "bash 脚本",
    "section": "",
    "text": "# 直接执行脚本, 会在一个子shell中执行脚本\n# 脚本执行完毕后, 子shell退出, 在子shell中设置的变量和函数不会影响到父shell环境\n./script.sh\n\n设置的变量或者函数都会在当前的shell环境中生效\n\n\nx\n\n# 设置的变量或者函数都会在当前的shell环境中生效\nsource ./script.sh\n# 完全等价于 source\n. ./script.sh\n\n\n# 设置的变量或者函数都会在当前的shell环境中生效\nsource ./script.sh\n# 完全等价于 source\n. ./script.sh",
    "crumbs": [
      "bash",
      "脚本"
    ]
  },
  {
    "objectID": "docs/devops/linux/bash/script.html#循环",
    "href": "docs/devops/linux/bash/script.html#循环",
    "title": "bash 脚本",
    "section": "2 循环",
    "text": "2 循环\n\n2.1 while\nwhile true\ndo\n    echo 1\n    sleep 3\ndone\n# killall -0 docker-proxy 执行的结果 $? =0 的情况, 才会进入循环\nwhile killall -0 docker-proxy\ndo\n    echo 1\n    sleep 3\ndone\n\n\n2.2 for\ni=0\nwhile [ $i -lt 20 ]\ndo\n    for j in '-' '\\' '|' '/'\n    do\n        printf \"intel testing : %s\\r\" $j\n        sleep 0.1\n        ((i++))\n    done\ndone\na=(\"a b\" \"c d\" \"e\")\nfor ((i=0;i&lt;${#a[*]};i++))\ndo\n    echo $i\n    echo ${a[$i]}\ndone",
    "crumbs": [
      "bash",
      "脚本"
    ]
  },
  {
    "objectID": "docs/devops/linux/bash/script.html#函数",
    "href": "docs/devops/linux/bash/script.html#函数",
    "title": "bash 脚本",
    "section": "3 函数",
    "text": "3 函数\n\n3.1 获取函数名称\n\n\n\n\n\n\nWarning\n\n\n\n不要用 sh fun.sh 来执行, 否则 没有 $FUNCNAME\n\n\n\n\nfun.sh\n\n#!/bin/bash\nshow(){\n    # FUNCNAME 实际是一个数组,包含了当前调用栈上所有函数的名称,先进后出\n    echo $FUNCNAME # 首个元素是当前函数名\n    # 可以发现实际有个main 函数, 先main,再调用了show2, 最后show\n    echo ${FUNCNAME[@]} # show show2 main.\n}\nshow2(){\n    show\n}\nshow2\n\nbash fun.sh\n# 或者\nchmod +x fun.sh\n./fun.sh",
    "crumbs": [
      "bash",
      "脚本"
    ]
  },
  {
    "objectID": "docs/devops/linux/bash/script.html#section",
    "href": "docs/devops/linux/bash/script.html#section",
    "title": "bash 脚本",
    "section": "4 ()",
    "text": "4 ()\n\n\n\n\n\n\nCaution\n\n\n\n\n实现执行脚本时,没有参数直接提示错误, 然后退出脚本\n() 里实际是在子shell里执行命令,它的exit退出,变量修改等操作都不影响当前shell,所以不对\n{} 里面的是在当前shell的, 一组命令作为一个整体执行.\n\n\n\n\n\n错的版本\n\n#!/bin/bash\ntest -z $1 && ( echo \"need arg\";exit; )\necho ok\n\n\n\n对的版本\n\n#!/bin/bash\ntest -z $1 && { echo \"need arg\";exit; }\necho ok\n\n\n\n\n\n\n\nWarning\n\n\n\n注意 需要{ } 两边空格, 最后 }前面的; 也是需要的",
    "crumbs": [
      "bash",
      "脚本"
    ]
  },
  {
    "objectID": "docs/devops/linux/bash/script.html#和",
    "href": "docs/devops/linux/bash/script.html#和",
    "title": "bash 脚本",
    "section": "5 `` 和 $()",
    "text": "5 `` 和 $()\n\n\n\n\n\n\nNote\n\n\n\n将命令执行的结果赋值给变量\n\n\nt=$(date +%Y) # t=`date +%Y`\necho $t # 2023",
    "crumbs": [
      "bash",
      "脚本"
    ]
  },
  {
    "objectID": "docs/devops/linux/bash/script.html#shift",
    "href": "docs/devops/linux/bash/script.html#shift",
    "title": "bash 脚本",
    "section": "6 shift",
    "text": "6 shift\n\n\nshift.sh\n\n#!/bin/bash\necho $*   # sh shift.sh a b c d e f\nshift  # 参数左移一位\necho $1 # 这个时候 第一个参数就是 b\nshift 1 # 同 shift\necho $1 #  c\nshift 3 # 参数左移3 位\necho $1 # 这个时候 $1 是f\n\nsh shift.sh a b c d e f",
    "crumbs": [
      "bash",
      "脚本"
    ]
  },
  {
    "objectID": "docs/devops/linux/bash/script.html#getops",
    "href": "docs/devops/linux/bash/script.html#getops",
    "title": "bash 脚本",
    "section": "7 getops",
    "text": "7 getops\ngetopts 是一个内置命令,用于解析脚本的命令行参数\n#!/bin/bash\nwhile getopts \":a:b:\" opt; do\n  case $opt in\n    a)\n      echo \"选项 -a 被设置为: $OPTARG\"\n      ;;\n    b)\n      echo \"选项 -b 被设置为: $OPTARG\"\n      ;;\n1    \\?)\n      echo \"无效选项: -$OPTARG\" &gt;&2\n      exit 1\n      ;;\n2    :)\n      echo \"选项 -$OPTARG 需要一个参数。\" &gt;&2\n      exit 1\n      ;;\n  esac\ndone\n\n1\n\n无效的命令行参数的情况\n\n2\n\n命令行参数值没有指定的情况\n\n\n\n\n\n执行无效的参数测试一下\n\nsh a.sh -a aa -b bb -c\n\n\n\n执行结果\n\n选项 -a 被设置为: aa\n选项 -b 被设置为: bb\n无效选项: -c\n\n\n\n\n\n参数没有指定值测试一下\n\nsh a.sh -a aa -b\n\n\n\n执行结果\n\n选项 -a 被设置为: aa\n选项 -b 需要一个参数。",
    "crumbs": [
      "bash",
      "脚本"
    ]
  },
  {
    "objectID": "docs/devops/linux/bash/script.html#expect",
    "href": "docs/devops/linux/bash/script.html#expect",
    "title": "bash 脚本",
    "section": "8 expect",
    "text": "8 expect",
    "crumbs": [
      "bash",
      "脚本"
    ]
  },
  {
    "objectID": "docs/devops/linux/service/supervisor.html",
    "href": "docs/devops/linux/service/supervisor.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "Caution\n\n\n\ntodo…\n\n\n[program:test]\ncommand=/test -conf /conf/app.yaml #要执行的命令\nstdout_logfile=/logs/test.log\nautostart=true\nautorestart=true\nstartsecs=5\npriority=1\nstopasgroup=true\nsupervisorctl update # 即可\nsupervisorctl reload #  这个也是\nsupervisorctl start test  #test 对应ini里的program 名字\nsupervisorctl restart test\nsupervisorctl # 查看运行状态\n\n\n\n Back to top"
  },
  {
    "objectID": "docs/programming/go/basic/start-go.html",
    "href": "docs/programming/go/basic/start-go.html",
    "title": "go 启动过程",
    "section": "",
    "text": "Tip\n\n\n\nTODO中…. 勿看",
    "crumbs": [
      "基础篇",
      "go程序的启动过程"
    ]
  },
  {
    "objectID": "docs/programming/go/basic/start-go.html#找到程序入口函数",
    "href": "docs/programming/go/basic/start-go.html#找到程序入口函数",
    "title": "go 启动过程",
    "section": "1 找到程序入口函数",
    "text": "1 找到程序入口函数\ngo build -o main main.go\nreadelf -h main\n\n\n查看 Entry point address\n\nELF Header:\n  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00\n  Class:                             ELF64\n  Data:                              2's complement, little endian\n  Version:                           1 (current)\n  OS/ABI:                            UNIX - System V\n  ABI Version:                       0\n  Type:                              EXEC (Executable file)\n  Machine:                           Advanced Micro Devices X86-64\n  Version:                           0x1\n  Entry point address:               0x456ca0\n  Start of program headers:          64 (bytes into file)\n  Start of section headers:          456 (bytes into file)\n  Flags:                             0x0\n  Size of this header:               64 (bytes)\n  Size of program headers:           56 (bytes)\n  Number of program headers:         7\n  Size of section headers:           64 (bytes)\n  Number of section headers:         23\n  Section header string table index: 3\n\n# 查看go 程序执行的入口\nreadelf -s main|grep 456ca0\n    1034: 0000000000456ca0     5 FUNC    GLOBAL DEFAULT    1 _rt0_amd64_linux\n\n\n\nitem\ndescription\n\n\n\n\nrt0\nruntime0\n\n\n\n\n\ngo/src/runtime/rt0_linux_amd64.s\n\n// Copyright 2009 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n#include \"textflag.h\"\n\nTEXT _rt0_amd64_linux(SB),NOSPLIT,$-8\n    JMP _rt0_amd64(SB)\n\nTEXT _rt0_amd64_linux_lib(SB),NOSPLIT,$0\n    JMP _rt0_amd64_lib(SB)\n\n\n\n我们可以用dlv调试看到入口\n\ndlv exec main\n(dlv) l\n&gt; _rt0_amd64_linux() /usr/local/go/src/runtime/rt0_linux_amd64.s:8 (PC: 0x4567c0)\nWarning: debugging optimized function\n     3: // license that can be found in the LICENSE file.\n     4:\n     5: #include \"textflag.h\"\n     6:\n     7: TEXT _rt0_amd64_linux(SB),NOSPLIT,$-8\n=&gt;   8:     JMP _rt0_amd64(SB)\n     9:\n    10: TEXT _rt0_amd64_linux_lib(SB),NOSPLIT,$0\n    11:     JMP _rt0_amd64_lib(SB)\n\n\n\ngo/src/runtime/asm_amd64.s\n\n// _rt0_amd64 is common startup code for most amd64 systems when using\n// internal linking. This is the entry point for the program from the\n// kernel for an ordinary -buildmode=exe program. The stack holds the\n// number of arguments and the C-style argv.\nTEXT _rt0_amd64(SB),NOSPLIT,$-8\n    MOVQ    0(SP), DI   // argc  参数个数\n    LEAQ    8(SP), SI   // argv  调用命令时的参数\n    JMP runtime·rt0_go(SB)\n\nTEXT runtime·rt0_go(SB),NOSPLIT|TOPFRAME,$0\n    // 将参数复制到栈上\n    MOVQ    DI, AX      // argc\n    MOVQ    SI, BX      // argv\n    SUBQ    $(5*8), SP      // 3args 2auto\n    ANDQ    $~15, SP\n    MOVQ    AX, 24(SP)\n    MOVQ    BX, 32(SP)\n\n    // 创建go程序的第一个协程 g0,用来调度其他协程\n    MOVQ    $runtime·g0(SB), DI\n    LEAQ    (-64*1024+104)(SP), BX\n    MOVQ    BX, g_stackguard0(DI)\n    MOVQ    BX, g_stackguard1(DI)\n    MOVQ    BX, (g_stack+stack_lo)(DI)\n    MOVQ    SP, (g_stack+stack_hi)(DI)\n    // ...\n    // ...\n    // ...\n    // 运行时 检查\n    CALL    runtime·check(SB)\n\n    MOVL    24(SP), AX      // copy argc\n    MOVL    AX, 0(SP)\n    MOVQ    32(SP), AX      // copy argv\n    MOVQ    AX, 8(SP)\n    CALL    runtime·args(SB) // 设置参数\n    CALL    runtime·osinit(SB) // cpu 核心等\n    CALL    runtime·schedinit(SB) // 初始化调度器\n\n    MOVQ    $runtime·mainPC(SB), AX     // runtime.main 函数地址\n    PUSHQ   AX\n    CALL    runtime·newproc(SB) // 启动一个协程\n    POPQ    AX\n\n    // start this M\n    CALL    runtime·mstart(SB)  // GMP中的M\n\n    CALL    runtime·abort(SB)   // mstart should never return\n    RET\n\n// mainPC is a function value for runtime.main, to be passed to newproc.\n// The reference to runtime.main is made via ABIInternal, since the\n// actual function (not the ABI0 wrapper) is needed by newproc.\nDATA    runtime·mainPC+0(SB)/8,$runtime·main&lt;ABIInternal&gt;(SB)",
    "crumbs": [
      "基础篇",
      "go程序的启动过程"
    ]
  },
  {
    "objectID": "docs/programming/go/basic/start-go.html#验证一下参数",
    "href": "docs/programming/go/basic/start-go.html#验证一下参数",
    "title": "go 启动过程",
    "section": "2 验证一下参数",
    "text": "2 验证一下参数\ndlv exec main a b\n# 打断点到JMP   runtime·rt0_go(SB), 路径看自己的改改\nb /usr/local/go/src/runtime/asm_amd64.s:18 # 在18行, 看自己的代码实际情况\n# 用si 可以一个指令一个指令的执行\nc # 运行\nregs # 查看寄存器\n    Rsi = 0x00007ffcde282508 # 是参数 ( 存的是字符数组的地址)\n    Rdi = 0x0000000000000003 # 参数个数, ok的\np unsafe.Pointer(*(*uintptr)(0x00007ffcde282508))\n    unsafe.Pointer(0x7ffcde2827dc)\np *(*uint8)(0x00007FFCDE2827DC)\np *(*uint8)(0x00007FFCDE2827DD)\n# 这里我一个字节一个字节的打 ,结果是\n47 114 111 111 116 47 116 109 112 47 116 101 115 116 50 47 116 116 51 47 109 97 105 110 0 97 0 98\n# ===&gt; 路径有点哈哈.. 徒增自己的麻烦...\n# ascii 0 表示空字符,在c 语言中 作为字符串的结尾\n/root/tmp/test2/tt3/main[NUL]a[NUL]b[NUL]",
    "crumbs": [
      "基础篇",
      "go程序的启动过程"
    ]
  },
  {
    "objectID": "docs/programming/go/basic/start-go.html#runtime.check",
    "href": "docs/programming/go/basic/start-go.html#runtime.check",
    "title": "go 启动过程",
    "section": "3 runtime.check",
    "text": "3 runtime.check\n\n\nsrc/runtime1.go#runtime.check()\n\nfunc check() {\n    var (\n        a     int8\n        b     uint8\n        c     int16\n        d     uint16\n        e     int32\n        f     uint32\n        g     int64\n        h     uint64\n        i, i1 float32\n        j, j1 float64\n        k     unsafe.Pointer\n        l     *uint16\n        m     [4]byte\n    )\n    type x1t struct {\n        x uint8\n    }\n    type y1t struct {\n        x1 x1t\n        y  uint8\n    }\n    var x1 x1t\n    var y1 y1t\n    // 各种类型长度检查\n    if unsafe.Sizeof(a) != 1 {\n        throw(\"bad a\")\n    }\n    if unsafe.Sizeof(b) != 1 {\n        throw(\"bad b\")\n    }\n    if unsafe.Sizeof(c) != 2 {\n        throw(\"bad c\")\n    }\n    if unsafe.Sizeof(d) != 2 {\n        throw(\"bad d\")\n    }\n    if unsafe.Sizeof(e) != 4 {\n        throw(\"bad e\")\n    }\n    if unsafe.Sizeof(f) != 4 {\n        throw(\"bad f\")\n    }\n    if unsafe.Sizeof(g) != 8 {\n        throw(\"bad g\")\n    }\n    if unsafe.Sizeof(h) != 8 {\n        throw(\"bad h\")\n    }\n    if unsafe.Sizeof(i) != 4 {\n        throw(\"bad i\")\n    }\n    if unsafe.Sizeof(j) != 8 {\n        throw(\"bad j\")\n    }\n    if unsafe.Sizeof(k) != goarch.PtrSize {\n        throw(\"bad k\")\n    }\n    if unsafe.Sizeof(l) != goarch.PtrSize {\n        throw(\"bad l\")\n    }\n    if unsafe.Sizeof(x1) != 1 {\n        throw(\"bad unsafe.Sizeof x1\")\n    }\n    // 结构体偏移量和长度检查\n    if unsafe.Offsetof(y1.y) != 1 {\n        throw(\"bad offsetof y1.y\")\n    }\n    if unsafe.Sizeof(y1) != 2 {\n        throw(\"bad unsafe.Sizeof y1\")\n    }\n\n    if timediv(12345*1000000000+54321, 1000000000, &e) != 12345 || e != 54321 {\n        throw(\"bad timediv\")\n    }\n\n    // cas ,atomic操作 检查\n    var z uint32\n    z = 1\n    if !atomic.Cas(&z, 1, 2) {\n        throw(\"cas1\")\n    }\n    if z != 2 {\n        throw(\"cas2\")\n    }\n\n    z = 4\n    if atomic.Cas(&z, 5, 6) {\n        throw(\"cas3\")\n    }\n    if z != 4 {\n        throw(\"cas4\")\n    }\n\n    z = 0xffffffff\n    if !atomic.Cas(&z, 0xffffffff, 0xfffffffe) {\n        throw(\"cas5\")\n    }\n    if z != 0xfffffffe {\n        throw(\"cas6\")\n    }\n\n    m = [4]byte{1, 1, 1, 1}\n    atomic.Or8(&m[1], 0xf0)\n    if m[0] != 1 || m[1] != 0xf1 || m[2] != 1 || m[3] != 1 {\n        throw(\"atomicor8\")\n    }\n\n    m = [4]byte{0xff, 0xff, 0xff, 0xff}\n    atomic.And8(&m[1], 0x1)\n    if m[0] != 0xff || m[1] != 0x1 || m[2] != 0xff || m[3] != 0xff {\n        throw(\"atomicand8\")\n    }\n\n    //指针操作检查\n    *(*uint64)(unsafe.Pointer(&j)) = ^uint64(0)\n    if j == j {\n        throw(\"float64nan\")\n    }\n    if !(j != j) {\n        throw(\"float64nan1\")\n    }\n\n    *(*uint64)(unsafe.Pointer(&j1)) = ^uint64(1)\n    if j == j1 {\n        throw(\"float64nan2\")\n    }\n    if !(j != j1) {\n        throw(\"float64nan3\")\n    }\n\n    *(*uint32)(unsafe.Pointer(&i)) = ^uint32(0)\n    if i == i {\n        throw(\"float32nan\")\n    }\n    if i == i {\n        throw(\"float32nan1\")\n    }\n\n    *(*uint32)(unsafe.Pointer(&i1)) = ^uint32(1)\n    if i == i1 {\n        throw(\"float32nan2\")\n    }\n    if i == i1 {\n        throw(\"float32nan3\")\n    }\n\n    testAtomic64()\n    // 栈大小是否是2的幂次方\n    if _FixedStack != round2(_FixedStack) {\n        throw(\"FixedStack is not power-of-2\")\n    }\n\n    if !checkASM() {\n        throw(\"assembly checks failed\")\n    }\n}",
    "crumbs": [
      "基础篇",
      "go程序的启动过程"
    ]
  },
  {
    "objectID": "docs/programming/go/basic/start-go.html#runtime.args",
    "href": "docs/programming/go/basic/start-go.html#runtime.args",
    "title": "go 启动过程",
    "section": "4 runtime.args()",
    "text": "4 runtime.args()\n\n\n设置参数\n\nfunc args(c int32, v **byte) {\n    argc = c\n    argv = v\n    sysargs(c, v)\n}",
    "crumbs": [
      "基础篇",
      "go程序的启动过程"
    ]
  },
  {
    "objectID": "docs/programming/go/basic/start-go.html#runtime.osinit",
    "href": "docs/programming/go/basic/start-go.html#runtime.osinit",
    "title": "go 启动过程",
    "section": "5 runtime.osinit()",
    "text": "5 runtime.osinit()\n\n\n获取cpu核心数\n\nfunc osinit() {\n    ncpu = getncpu()\n    physPageSize = getPageSize()\n    osinit_hack()\n}",
    "crumbs": [
      "基础篇",
      "go程序的启动过程"
    ]
  },
  {
    "objectID": "docs/programming/go/basic/start-go.html#runtimeschedinit",
    "href": "docs/programming/go/basic/start-go.html#runtimeschedinit",
    "title": "go 启动过程",
    "section": "6 runtime·schedinit",
    "text": "6 runtime·schedinit\nfunc schedinit() {\n    lockInit(&sched.lock, lockRankSched)\n    lockInit(&sched.sysmonlock, lockRankSysmon)\n    lockInit(&sched.deferlock, lockRankDefer)\n    lockInit(&sched.sudoglock, lockRankSudog)\n    lockInit(&deadlock, lockRankDeadlock)\n    lockInit(&paniclk, lockRankPanic)\n    lockInit(&allglock, lockRankAllg)\n    lockInit(&allpLock, lockRankAllp)\n    lockInit(&reflectOffs.lock, lockRankReflectOffs)\n    lockInit(&finlock, lockRankFin)\n    lockInit(&trace.bufLock, lockRankTraceBuf)\n    lockInit(&trace.stringsLock, lockRankTraceStrings)\n    lockInit(&trace.lock, lockRankTrace)\n    lockInit(&cpuprof.lock, lockRankCpuprof)\n    lockInit(&trace.stackTab.lock, lockRankTraceStackTab)\n    // Enforce that this lock is always a leaf lock.\n    // All of this lock's critical sections should be\n    // extremely short.\n    lockInit(&memstats.heapStats.noPLock, lockRankLeafRank)\n\n    // raceinit must be the first call to race detector.\n    // In particular, it must be done before mallocinit below calls racemapshadow.\n    gp := getg()\n    if raceenabled {\n        gp.racectx, raceprocctx0 = raceinit()\n    }\n    // 系统M线程的最大数量\n    sched.maxmcount = 10000\n\n    // The world starts stopped.\n    worldStopped()\n\n    moduledataverify()\n    stackinit()  //栈初始化\n    mallocinit()  // 内存分配器初始化\n    godebug := getGodebugEarly()\n    initPageTrace(godebug) // must run after mallocinit but before anything allocates\n    cpuinit(godebug)       // must run before alginit\n    // 算法初始化\n    alginit()              // maps, hash, fastrand must not be used before this call\n    fastrandinit()         // must run before mcommoninit\n    mcommoninit(gp.m, -1)\n    modulesinit()   // provides activeModules\n    typelinksinit() // uses maps, activeModules\n    itabsinit()     // uses activeModules\n    stkobjinit()    // must run before GC starts\n\n    sigsave(&gp.m.sigmask)\n    initSigmask = gp.m.sigmask\n\n    goargs() // 加载参数\n    goenvs() // 加载环境变量\n    secure()\n    parsedebugvars()\n    gcinit()\n\n    // if disableMemoryProfiling is set, update MemProfileRate to 0 to turn off memprofile.\n    // Note: parsedebugvars may update MemProfileRate, but when disableMemoryProfiling is\n    // set to true by the linker, it means that nothing is consuming the profile, it is\n    // safe to set MemProfileRate to 0.\n    if disableMemoryProfiling {\n        MemProfileRate = 0\n    }\n\n    lock(&sched.lock)\n    sched.lastpoll.Store(nanotime())\n    procs := ncpu\n    if n, ok := atoi32(gogetenv(\"GOMAXPROCS\")); ok && n &gt; 0 {\n        procs = n\n    }\n    if procresize(procs) != nil {\n        throw(\"unknown runnable goroutine during bootstrap\")\n    }\n    unlock(&sched.lock)\n\n    // World is effectively started now, as P's can run.\n    worldStarted()\n\n    // For cgocheck &gt; 1, we turn on the write barrier at all times\n    // and check all pointer writes. We can't do this until after\n    // procresize because the write barrier needs a P.\n    if debug.cgocheck &gt; 1 {\n        writeBarrier.cgo = true\n        writeBarrier.enabled = true\n        for _, pp := range allp {\n            pp.wbBuf.reset()\n        }\n    }\n\n    if buildVersion == \"\" {\n        // Condition should never trigger. This code just serves\n        // to ensure runtime·buildVersion is kept in the resulting binary.\n        buildVersion = \"unknown\"\n    }\n    if len(modinfo) == 1 {\n        // Condition should never trigger. This code just serves\n        // to ensure runtime·modinfo is kept in the resulting binary.\n        modinfo = \"\"\n    }\n}",
    "crumbs": [
      "基础篇",
      "go程序的启动过程"
    ]
  },
  {
    "objectID": "docs/programming/go/basic/start-go.html#newproc",
    "href": "docs/programming/go/basic/start-go.html#newproc",
    "title": "go 启动过程",
    "section": "7 newproc",
    "text": "7 newproc\n// Create a new g running fn.\n// Put it on the queue of g's waiting to run.\n// The compiler turns a go statement into a call to this.\nfunc newproc(fn *funcval) {\n    gp := getg()\n    pc := getcallerpc()\n    systemstack(func() {\n        newg := newproc1(fn, gp, pc)\n\n        pp := getg().m.p.ptr()\n        runqput(pp, newg, true)\n\n        if mainStarted {\n            wakep()\n        }\n    })\n}\n// Create a new g in state _Grunnable, starting at fn. callerpc is the\n// address of the go statement that created this. The caller is responsible\n// for adding the new g to the scheduler.\nfunc newproc1(fn *funcval, callergp *g, callerpc uintptr) *g {\n    if fn == nil {\n        fatal(\"go of nil func value\")\n    }\n\n    mp := acquirem() // disable preemption because we hold M and P in local vars.\n    pp := mp.p.ptr()\n    newg := gfget(pp)\n    if newg == nil {\n        newg = malg(_StackMin)\n        casgstatus(newg, _Gidle, _Gdead)\n        allgadd(newg) // publishes with a g-&gt;status of Gdead so GC scanner doesn't look at uninitialized stack.\n    }\n    if newg.stack.hi == 0 {\n        throw(\"newproc1: newg missing stack\")\n    }\n\n    if readgstatus(newg) != _Gdead {\n        throw(\"newproc1: new g is not Gdead\")\n    }\n\n    totalSize := uintptr(4*goarch.PtrSize + sys.MinFrameSize) // extra space in case of reads slightly beyond frame\n    totalSize = alignUp(totalSize, sys.StackAlign)\n    sp := newg.stack.hi - totalSize\n    spArg := sp\n    if usesLR {\n        // caller's LR\n        *(*uintptr)(unsafe.Pointer(sp)) = 0\n        prepGoExitFrame(sp)\n        spArg += sys.MinFrameSize\n    }\n\n    memclrNoHeapPointers(unsafe.Pointer(&newg.sched), unsafe.Sizeof(newg.sched))\n    newg.sched.sp = sp\n    newg.stktopsp = sp\n    newg.sched.pc = abi.FuncPCABI0(goexit) + sys.PCQuantum // +PCQuantum so that previous instruction is in same function\n    newg.sched.g = guintptr(unsafe.Pointer(newg))\n    gostartcallfn(&newg.sched, fn)\n    newg.gopc = callerpc\n    newg.ancestors = saveAncestors(callergp)\n    newg.startpc = fn.fn\n    if isSystemGoroutine(newg, false) {\n        sched.ngsys.Add(1)\n    } else {\n        // Only user goroutines inherit pprof labels.\n        if mp.curg != nil {\n            newg.labels = mp.curg.labels\n        }\n        if goroutineProfile.active {\n            // A concurrent goroutine profile is running. It should include\n            // exactly the set of goroutines that were alive when the goroutine\n            // profiler first stopped the world. That does not include newg, so\n            // mark it as not needing a profile before transitioning it from\n            // _Gdead.\n            newg.goroutineProfiled.Store(goroutineProfileSatisfied)\n        }\n    }\n    // Track initial transition?\n    newg.trackingSeq = uint8(fastrand())\n    if newg.trackingSeq%gTrackingPeriod == 0 {\n        newg.tracking = true\n    }\n    casgstatus(newg, _Gdead, _Grunnable)\n    gcController.addScannableStack(pp, int64(newg.stack.hi-newg.stack.lo))\n\n    if pp.goidcache == pp.goidcacheend {\n        // Sched.goidgen is the last allocated id,\n        // this batch must be [sched.goidgen+1, sched.goidgen+GoidCacheBatch].\n        // At startup sched.goidgen=0, so main goroutine receives goid=1.\n        pp.goidcache = sched.goidgen.Add(_GoidCacheBatch)\n        pp.goidcache -= _GoidCacheBatch - 1\n        pp.goidcacheend = pp.goidcache + _GoidCacheBatch\n    }\n    newg.goid = pp.goidcache\n    pp.goidcache++\n    if raceenabled {\n        newg.racectx = racegostart(callerpc)\n        newg.raceignore = 0\n        if newg.labels != nil {\n            // See note in proflabel.go on labelSync's role in synchronizing\n            // with the reads in the signal handler.\n            racereleasemergeg(newg, unsafe.Pointer(&labelSync))\n        }\n    }\n    if trace.enabled {\n        traceGoCreate(newg, newg.startpc)\n    }\n    releasem(mp)\n\n    return newg\n}",
    "crumbs": [
      "基础篇",
      "go程序的启动过程"
    ]
  },
  {
    "objectID": "docs/programming/go/basic/start-go.html#runtime.main",
    "href": "docs/programming/go/basic/start-go.html#runtime.main",
    "title": "go 启动过程",
    "section": "8 runtime.main",
    "text": "8 runtime.main\n\n\nsrc/runtime/proc.go\n\n// The main goroutine.\nfunc main() {\n    mp := getg().m\n\n    // Racectx of m0-&gt;g0 is used only as the parent of the main goroutine.\n    // It must not be used for anything else.\n    mp.g0.racectx = 0\n\n    // Max stack size is 1 GB on 64-bit, 250 MB on 32-bit.\n    if goarch.PtrSize == 8 {\n        maxstacksize = 1000000000\n    } else {\n        maxstacksize = 250000000\n    }\n\n    // An upper limit for max stack size. Used to avoid random crashes\n    // after calling SetMaxStack and trying to allocate a stack that is too big,\n    // since stackalloc works with 32-bit sizes.\n    maxstackceiling = 2 * maxstacksize\n\n    // Allow newproc to start new Ms.\n    mainStarted = true\n\n    if GOARCH != \"wasm\" { // no threads on wasm yet, so no sysmon\n        systemstack(func() {\n            newm(sysmon, nil, -1)\n        })\n    }\n\n    // Lock the main goroutine onto this, the main OS thread,\n    // during initialization. Most programs won't care, but a few\n    // do require certain calls to be made by the main thread.\n    // Those can arrange for main.main to run in the main thread\n    // by calling runtime.LockOSThread during initialization\n    // to preserve the lock.\n    lockOSThread()\n\n    if mp != &m0 {\n        throw(\"runtime.main not on m0\")\n    }\n\n    // Record when the world started.\n    // Must be before doInit for tracing init.\n    runtimeInitTime = nanotime()\n    if runtimeInitTime == 0 {\n        throw(\"nanotime returning zero\")\n    }\n\n    if debug.inittrace != 0 {\n        inittrace.id = getg().goid\n        inittrace.active = true\n    }\n\n    doInit(&runtime_inittask) // Must be before defer.\n\n    // Defer unlock so that runtime.Goexit during init does the unlock too.\n    needUnlock := true\n    defer func() {\n        if needUnlock {\n            unlockOSThread()\n        }\n    }()\n\n    gcenable()\n\n    main_init_done = make(chan bool)\n    if iscgo {\n        if _cgo_thread_start == nil {\n            throw(\"_cgo_thread_start missing\")\n        }\n        if GOOS != \"windows\" {\n            if _cgo_setenv == nil {\n                throw(\"_cgo_setenv missing\")\n            }\n            if _cgo_unsetenv == nil {\n                throw(\"_cgo_unsetenv missing\")\n            }\n        }\n        if _cgo_notify_runtime_init_done == nil {\n            throw(\"_cgo_notify_runtime_init_done missing\")\n        }\n        // Start the template thread in case we enter Go from\n        // a C-created thread and need to create a new thread.\n        startTemplateThread()\n        cgocall(_cgo_notify_runtime_init_done, nil)\n    }\n\n    doInit(&main_inittask)\n\n    // Disable init tracing after main init done to avoid overhead\n    // of collecting statistics in malloc and newproc\n    inittrace.active = false\n\n    close(main_init_done)\n\n    needUnlock = false\n    unlockOSThread()\n\n    if isarchive || islibrary {\n        // A program compiled with -buildmode=c-archive or c-shared\n        // has a main, but it is not executed.\n        return\n    }\n    fn := main_main\n    fn()  // 调用我们代码写的main函数了.\n    if raceenabled {\n        runExitHooks(0) // run hooks now, since racefini does not return\n        racefini()\n    }\n\n    // Make racy client program work: if panicking on\n    // another goroutine at the same time as main returns,\n    // let the other goroutine finish printing the panic trace.\n    // Once it does, it will exit. See issues 3934 and 20018.\n    if runningPanicDefers.Load() != 0 {\n        // Running deferred functions should not take long.\n        for c := 0; c &lt; 1000; c++ {\n            if runningPanicDefers.Load() == 0 {\n                break\n            }\n            Gosched()\n        }\n    }\n    if panicking.Load() != 0 {\n        gopark(nil, nil, waitReasonPanicWait, traceEvGoStop, 1)\n    }\n    runExitHooks(0)\n\n    exit(0)\n    for {\n        var x *int32\n        *x = 0\n    }\n}\n\n\n\nfn := main_main 编译指示中说过\n\n// main.main main包的main函数\n//\n//go:linkname main_main main.main\nfunc main_main()",
    "crumbs": [
      "基础篇",
      "go程序的启动过程"
    ]
  },
  {
    "objectID": "docs/programming/go/basic/start-go.html#mstart",
    "href": "docs/programming/go/basic/start-go.html#mstart",
    "title": "go 启动过程",
    "section": "9 mstart",
    "text": "9 mstart\n// mstart is the entry-point for new Ms.\n// It is written in assembly, uses ABI0, is marked TOPFRAME, and calls mstart0.\nfunc mstart()\n\n// mstart0 is the Go entry-point for new Ms.\n// This must not split the stack because we may not even have stack\n// bounds set up yet.\n//\n// May run during STW (because it doesn't have a P yet), so write\n// barriers are not allowed.\n//\n//go:nosplit\n//go:nowritebarrierrec\nfunc mstart0() {\n    gp := getg()\n\n    osStack := gp.stack.lo == 0\n    if osStack {\n        // Initialize stack bounds from system stack.\n        // Cgo may have left stack size in stack.hi.\n        // minit may update the stack bounds.\n        //\n        // Note: these bounds may not be very accurate.\n        // We set hi to &size, but there are things above\n        // it. The 1024 is supposed to compensate this,\n        // but is somewhat arbitrary.\n        size := gp.stack.hi\n        if size == 0 {\n            size = 8192 * sys.StackGuardMultiplier\n        }\n        gp.stack.hi = uintptr(noescape(unsafe.Pointer(&size)))\n        gp.stack.lo = gp.stack.hi - size + 1024\n    }\n    // Initialize stack guard so that we can start calling regular\n    // Go code.\n    gp.stackguard0 = gp.stack.lo + _StackGuard\n    // This is the g0, so we can also call go:systemstack\n    // functions, which check stackguard1.\n    gp.stackguard1 = gp.stackguard0\n    mstart1()\n\n    // Exit this thread.\n    if mStackIsSystemAllocated() {\n        // Windows, Solaris, illumos, Darwin, AIX and Plan 9 always system-allocate\n        // the stack, but put it in gp.stack before mstart,\n        // so the logic above hasn't set osStack yet.\n        osStack = true\n    }\n    mexit(osStack)\n}\n// The go:noinline is to guarantee the getcallerpc/getcallersp below are safe,\n// so that we can set up g0.sched to return to the call of mstart1 above.\n//\n//go:noinline\nfunc mstart1() {\n    gp := getg()\n\n    if gp != gp.m.g0 {\n        throw(\"bad runtime·mstart\")\n    }\n\n    // Set up m.g0.sched as a label returning to just\n    // after the mstart1 call in mstart0 above, for use by goexit0 and mcall.\n    // We're never coming back to mstart1 after we call schedule,\n    // so other calls can reuse the current frame.\n    // And goexit0 does a gogo that needs to return from mstart1\n    // and let mstart0 exit the thread.\n    gp.sched.g = guintptr(unsafe.Pointer(gp))\n    gp.sched.pc = getcallerpc()\n    gp.sched.sp = getcallersp()\n\n    asminit()\n    minit()\n\n    // Install signal handlers; after minit so that minit can\n    // prepare the thread to be able to handle the signals.\n    if gp.m == &m0 {\n        mstartm0()\n    }\n\n    if fn := gp.m.mstartfn; fn != nil {\n        fn()\n    }\n\n    if gp.m != &m0 {\n        acquirep(gp.m.nextp.ptr())\n        gp.m.nextp = 0\n    }\n    schedule()\n}",
    "crumbs": [
      "基础篇",
      "go程序的启动过程"
    ]
  },
  {
    "objectID": "docs/programming/go/basic/start-go.html#schedule",
    "href": "docs/programming/go/basic/start-go.html#schedule",
    "title": "go 启动过程",
    "section": "10 schedule()",
    "text": "10 schedule()\n// One round of scheduler: 找到一个可运行的goroutine并运行它\n// Never returns.\nfunc schedule() {\n    mp := getg().m\n\n    if mp.locks != 0 {\n        throw(\"schedule: holding locks\")\n    }\n\n    if mp.lockedg != 0 {\n        stoplockedm()\n        execute(mp.lockedg.ptr(), false) // Never returns.\n    }\n\n    // We should not schedule away from a g that is executing a cgo call,\n    // since the cgo call is using the m's g0 stack.\n    if mp.incgo {\n        throw(\"schedule: in cgo\")\n    }\n\ntop:\n    pp := mp.p.ptr()\n    pp.preempt = false\n\n    // Safety check: if we are spinning, the run queue should be empty.\n    // Check this before calling checkTimers, as that might call\n    // goready to put a ready goroutine on the local run queue.\n    if mp.spinning && (pp.runnext != 0 || pp.runqhead != pp.runqtail) {\n        throw(\"schedule: spinning with local work\")\n    }\n    // 找到一个可运行的goroutine\n    gp, inheritTime, tryWakeP := findRunnable() // blocks until work is available\n\n    // This thread is going to run a goroutine and is not spinning anymore,\n    // so if it was marked as spinning we need to reset it now and potentially\n    // start a new spinning M.\n    if mp.spinning {\n        resetspinning()\n    }\n\n    if sched.disable.user && !schedEnabled(gp) {\n        // Scheduling of this goroutine is disabled. Put it on\n        // the list of pending runnable goroutines for when we\n        // re-enable user scheduling and look again.\n        lock(&sched.lock)\n        if schedEnabled(gp) {\n            // Something re-enabled scheduling while we\n            // were acquiring the lock.\n            unlock(&sched.lock)\n        } else {\n            sched.disable.runnable.pushBack(gp)\n            sched.disable.n++\n            unlock(&sched.lock)\n            goto top\n        }\n    }\n\n    // If about to schedule a not-normal goroutine (a GCworker or tracereader),\n    // wake a P if there is one.\n    if tryWakeP {\n        wakep()\n    }\n    if gp.lockedm != 0 {\n        // Hands off own p to the locked m,\n        // then blocks waiting for a new p.\n        startlockedm(gp)\n        goto top\n    }\n    // 执行\n    execute(gp, inheritTime)\n}",
    "crumbs": [
      "基础篇",
      "go程序的启动过程"
    ]
  },
  {
    "objectID": "docs/programming/go/basic/start-go.html#execute",
    "href": "docs/programming/go/basic/start-go.html#execute",
    "title": "go 启动过程",
    "section": "11 execute",
    "text": "11 execute\n// Schedules gp to run on the current M.\n// If inheritTime is true, gp inherits the remaining time in the\n// current time slice. Otherwise, it starts a new time slice.\n// Never returns.\n//\n// Write barriers are allowed because this is called immediately after\n// acquiring a P in several places.\n//\n//go:yeswritebarrierrec\nfunc execute(gp *g, inheritTime bool) {\n    mp := getg().m\n\n    if goroutineProfile.active {\n        // Make sure that gp has had its stack written out to the goroutine\n        // profile, exactly as it was when the goroutine profiler first stopped\n        // the world.\n        tryRecordGoroutineProfile(gp, osyield)\n    }\n\n    // Assign gp.m before entering _Grunning so running Gs have an\n    // M.\n    mp.curg = gp\n    gp.m = mp\n    casgstatus(gp, _Grunnable, _Grunning)\n    gp.waitsince = 0\n    gp.preempt = false\n    gp.stackguard0 = gp.stack.lo + _StackGuard\n    if !inheritTime {\n        mp.p.ptr().schedtick++\n    }\n\n    // Check whether the profiler needs to be turned on or off.\n    hz := sched.profilehz\n    if mp.profilehz != hz {\n        setThreadCPUProfiler(hz)\n    }\n\n    if trace.enabled {\n        // GoSysExit has to happen when we have a P, but before GoStart.\n        // So we emit it here.\n        if gp.syscallsp != 0 && gp.sysblocktraced {\n            traceGoSysExit(gp.sysexitticks)\n        }\n        traceGoStart()\n    }\n\n    gogo(&gp.sched)\n}",
    "crumbs": [
      "基础篇",
      "go程序的启动过程"
    ]
  },
  {
    "objectID": "docs/programming/go/basic/start-go.html#gogo",
    "href": "docs/programming/go/basic/start-go.html#gogo",
    "title": "go 启动过程",
    "section": "12 gogo",
    "text": "12 gogo\n\n\nsrc/runtime/asm_amd64.s\n\n/*\n *  go-routine\n */\n\n// func gogo(buf *gobuf)\n// restore state from Gobuf; longjmp\nTEXT runtime·gogo(SB), NOSPLIT, $0-8\n    MOVQ    buf+0(FP), BX       // gobuf\n    MOVQ    gobuf_g(BX), DX\n    MOVQ    0(DX), CX       // make sure g != nil\n    JMP gogo&lt;&gt;(SB)\n\nTEXT gogo&lt;&gt;(SB), NOSPLIT, $0\n    get_tls(CX)\n    MOVQ    DX, g(CX)\n    MOVQ    DX, R14     // set the g register\n    MOVQ    gobuf_sp(BX), SP    // 将goroutine 结构中存的 自己的栈指针 设置到sp\n    MOVQ    gobuf_ret(BX), AX\n    MOVQ    gobuf_ctxt(BX), DX\n    MOVQ    gobuf_bp(BX), BP\n    MOVQ    $0, gobuf_sp(BX)    // clear to help garbage collector\n    MOVQ    $0, gobuf_ret(BX)\n    MOVQ    $0, gobuf_ctxt(BX)\n    MOVQ    $0, gobuf_bp(BX)\n    // 这个pc, 就是如果你cpu执行一段时间这个goroutine的代码后,切出, 后来又拿到cpu执行,可以知道执行到哪里了\n    MOVQ    gobuf_pc(BX), BX // goroutine中 下一个指令的地址\n    JMP BX  // 执行这个指令",
    "crumbs": [
      "基础篇",
      "go程序的启动过程"
    ]
  },
  {
    "objectID": "docs/programming/go/basic/start-go.html#goexit",
    "href": "docs/programming/go/basic/start-go.html#goexit",
    "title": "go 启动过程",
    "section": "13 goexit",
    "text": "13 goexit\n\n\nsrc/runtime/asm_amd64.s\n\n// The top-most function running on a goroutine\n// returns to goexit+PCQuantum.\nTEXT runtime·goexit(SB),NOSPLIT|TOPFRAME,$0-0\n    BYTE    $0x90   // NOP\n    CALL    runtime·goexit1(SB) // does not return\n    // traceback from goexit1 must hit code range of goexit\n    BYTE    $0x90   // NOP\n\n\n\nruntime/proc.go\n\n\nfunc goexit1() {\n    if raceenabled {\n        racegoend()\n    }\n    if trace.enabled {\n        traceGoEnd()\n    }\n    // 从当前的g 切换到g0的 栈, 然后执行该 goexit0 方法\n    mcall(goexit0)\n}\n\n// goexit continuation on g0.\n// 传递的是goroutine, goroutine运行完毕做哪些补充清理工作,修改状态等\nfunc goexit0(gp *g) {\n    mp := getg().m\n    pp := mp.p.ptr()\n\n    casgstatus(gp, _Grunning, _Gdead)\n    gcController.addScannableStack(pp, -int64(gp.stack.hi-gp.stack.lo))\n    if isSystemGoroutine(gp, false) {\n        sched.ngsys.Add(-1)\n    }\n    gp.m = nil\n    locked := gp.lockedm != 0\n    gp.lockedm = 0\n    mp.lockedg = 0\n    gp.preemptStop = false\n    gp.paniconfault = false\n    gp._defer = nil // should be true already but just in case.\n    gp._panic = nil // non-nil for Goexit during panic. points at stack-allocated data.\n    gp.writebuf = nil\n    gp.waitreason = waitReasonZero\n    gp.param = nil\n    gp.labels = nil\n    gp.timer = nil\n\n    if gcBlackenEnabled != 0 && gp.gcAssistBytes &gt; 0 {\n        // Flush assist credit to the global pool. This gives\n        // better information to pacing if the application is\n        // rapidly creating an exiting goroutines.\n        assistWorkPerByte := gcController.assistWorkPerByte.Load()\n        scanCredit := int64(assistWorkPerByte * float64(gp.gcAssistBytes))\n        gcController.bgScanCredit.Add(scanCredit)\n        gp.gcAssistBytes = 0\n    }\n\n    dropg()\n\n    if GOARCH == \"wasm\" { // no threads yet on wasm\n        gfput(pp, gp)\n        schedule() // never returns\n    }\n\n    if mp.lockedInt != 0 {\n        print(\"invalid m-&gt;lockedInt = \", mp.lockedInt, \"\\n\")\n        throw(\"internal lockOSThread error\")\n    }\n    gfput(pp, gp)\n    if locked {\n        // The goroutine may have locked this thread because\n        // it put it in an unusual kernel state. Kill it\n        // rather than returning it to the thread pool.\n\n        // Return to mstart, which will release the P and exit\n        // the thread.\n        if GOOS != \"plan9\" { // See golang.org/issue/22227.\n            gogo(&mp.g0.sched)\n        } else {\n            // Clear lockedExt on plan9 since we may end up re-using\n            // this thread.\n            mp.lockedExt = 0\n        }\n    }\n    // 最后重新开始调度, 选一个goroutine 来执行\n    schedule()\n}",
    "crumbs": [
      "基础篇",
      "go程序的启动过程"
    ]
  },
  {
    "objectID": "docs/programming/go/basic/map.html",
    "href": "docs/programming/go/basic/map.html",
    "title": "go map",
    "section": "",
    "text": "Caution\n\n\n\n源码方面看的是不支持泛型的版本. 未完待续…",
    "crumbs": [
      "基础篇",
      "Map"
    ]
  },
  {
    "objectID": "docs/programming/go/basic/map.html#图书馆与map",
    "href": "docs/programming/go/basic/map.html#图书馆与map",
    "title": "go map",
    "section": "1 图书馆与map",
    "text": "1 图书馆与map\n\n\n\n\n\n\n\n\nmap\n图书馆对应\n\n\n\n\n桶\n一个个分类不同的书架\n\n\n哈希算法\n你根据书名进行判断的判断方法,知道是哪个分类, 放到哪个书架上\n\n\n哈希冲突\n多本书,根据书名进行判断,都在同一个分类书架上,就依次放到书架上的空余位置即可  如果该书架满了,则需要新的同分类名的书架,将书放到这个新的书架上.\n\n\n读取数据\n你根据书名进行判断,知道是哪个分类书架,然后到该书架上 从左到右比对过去,比对书名(ISBN),找到并拿走\n\n\n写入数据\n你根据书名进行判断,知道是哪个分类书架,然后到该书架上 从左到右比对过去,比对书名(ISBN),如果有,则更换书,没有就放入最右边空余位置\n\n\n装载因子(元素个数/桶数量&lt;=6.5)\n很显然书架上的书越多,你找书就越慢, 如果每个书架上都只有一个本书, 那么你一定非常快就找到了.",
    "crumbs": [
      "基础篇",
      "Map"
    ]
  },
  {
    "objectID": "docs/programming/go/basic/map.html#源码分析",
    "href": "docs/programming/go/basic/map.html#源码分析",
    "title": "go map",
    "section": "2 源码分析",
    "text": "2 源码分析\n\n2.1 数据结构\nfunc main() {\n    a := make(map[int]string, 10)\n    fmt.Println(a)\n}\n\n\n\n\n\n\nTip\n\n\n\ngo tool compile -S main.go 查看汇编代码可以看到 runtime.makemap  容量小的话,可以看到runtime.makemap_small\n\n\nfunc makemap(t *maptype, hint int, h *hmap) *hmap {\n    mem, overflow := math.MulUintptr(uintptr(hint), t.bucket.size)\n    if overflow || mem &gt; maxAlloc {\n        hint = 0\n    }\n    if h == nil {\n        h = new(hmap)\n    }\n    h.hash0 = fastrand()\n    B := uint8(0)\n    for overLoadFactor(hint, B) {\n        B++\n    }\n    h.B = B\n\n    if h.B != 0 {\n        var nextOverflow *bmap\n        h.buckets, nextOverflow = makeBucketArray(t, h.B, nil)\n        if nextOverflow != nil {\n            h.extra = new(mapextra)\n            h.extra.nextOverflow = nextOverflow\n        }\n    }\n    return h\n}\n\nmap结构桶结构\n\n\n\n\nsrc/runtime/map.go\n\ntype hmap struct {\n    // map 中的元素个数，必须放在 struct 的第一个位置，\n    // 因为内置的 len 函数会通过unsafe.Pointer会从这里读取\n    count     int\n    flags     uint8\n    // bucket的数量是2^B, 最多可以放 loadFactor * 2^B 个元素，再多就要 hashGrow 了\n    // 装载因子 loadFactor= 元素个数/桶数量&lt;=6.5\n    B         uint8\n    //overflow 的 bucket 近似数\n    noverflow uint16\n    hash0     uint32 // hash seed\n    //2^B 大小的数组指针，如果 count == 0 的话，可能是 nil\n    buckets    unsafe.Pointer\n    // 扩容的时候，buckets 长度会是 oldbuckets 的两倍,只有在 growing 时候为空。\n    oldbuckets unsafe.Pointer\n    // 指示扩容进度，小于此地址的 buckets 迁移完成\n    nevacuate  uintptr // progress counter for evacuation (buckets less than this have been evacuated)\n    // 当 key 和 value 都可以 inline 的时候，就会用这个字段\n    extra *mapextra // optional fields\n}\n\n\n\n\n\nsrc/runtime/map.go\n\ntype bmap struct {\n    // 存储了键的哈希的高 8 位\n    tophash [bucketCnt]uint8\n}\n\n上面这个数据结构并不是 golang runtime 时的结构，在编译时候编译器会给它动态创建一个新的结构 因为哈希表中可能存储不同类型的键值对，而且 Go 语言也不支持泛型，所以键值对占据的内存空间大小只能在编译时进行推导\n// 每个 bucket 里面最多存储 8 个 key\ntype bmap struct {\n    topbits  [8]uint8 //key 计算出来的 hash 值的高 8 位\n    keys     [8]keytype\n    values   [8]valuetype\n    pad      uintptr\n    overflow uintptr\n}\n\n\n\n\n\n为什么 桶内的key和value 要这样设计? 我们以 map[int64]int8 为例来说明\n\n如果按照 key/value/key/value/… 这样的模式存储，由于内存对齐,在每一个 key/value 之后都要额外需要7个字节\nint64 8个字节 int8一个字节, 剩下的7个字节就浪费了. 因为接下来的key 8个字节你放不下\n而将所有的 key，value 分别绑定到一起，这种形式 key/key/…/value/value/…，则只需要在最后添加 pad\n\n每个 bucket 设计成最多只能放 8 个 key-value 对，如果有第 9 个 key-value 落入当前的 bucket，那就需要再构建一个 bucket ，通过 overflow 指针连接起来\n\n\n\n2.2 B值的计算\n\n2.2.1 源码解析\n\n\n这里我们创建10个容量的map\n\nfunc main() {\n    a := make(map[int]string, 10)\n    fmt.Println(a)\n}\n\n\nmakemap()中B值相关overLoadFactor()bucketShift()\n\n\nB := uint8(0)\n// hint 就是 10\n// 如果当前元素/桶数 超过了装载因子6.5 则说明桶数不够,需要增加,B++\nfor overLoadFactor(hint, B) {\n    B++\n}\n\n\n// 判断是否超过了装载因子\nfunc overLoadFactor(count int, B uint8) bool {\n    // bucketCntBits = 3\n    // bucketCnt     = 1 &lt;&lt; bucketCntBits  //1 左移3位 = 8\n    // 得出 bucketCnt = 8\n    // loadFactorNum = 13\n    // loadFactorDen = 2\n    // count&gt;bucketCnt 如果容量&gt; 一个桶能放的元素数\n    // 且 第一次循环, B=0, 10&gt;13*(1/2) 一个桶最多6.5 ,我们装载因为是6.5,超过了,说明需要扩容桶\n    // 则第二循环, B=1, bucketShift(B)= 1&lt;&lt;1=2 , 10&gt;13*(2/2) 不城里,退出循环了, 结果是B=1\n    return count &gt; bucketCnt && uintptr(count) &gt; loadFactorNum*(bucketShift(B)/loadFactorDen)\n}\n\n\nfunc bucketShift(b uint8) uintptr {\n    // Masking the shift amount allows overflow checks to be elided.\n    return uintptr(1) &lt;&lt; (b & (8*8 - 1))\n}\n\n\n\n\n\n2.2.2 代码验证\npackage main\nimport (\n    \"fmt\"\n    \"unsafe\"\n)\ntype MapStruct struct {\n    count int\n    flags uint8\n    B     uint8\n    noverflow  uint16\n    hash0      uint32\n    buckets    uintptr //unsafe.Pointer\n    oldbuckets unsafe.Pointer\n    nevacuate  uintptr\n    extra      uintptr\n}\nfunc main() {\n    m := make(map[int32]int32, 10)\n    // m 实际是个指针, 指向了真正的hmap\n    m[1] = 22\n    m[2] = 33\n    fmt.Println(len(m)) //2\n    hmapReal := *(**MapStruct)(unsafe.Pointer(&m))\n    fmt.Println(hmapReal.count, hmapReal.B) // 2 1\n    bks := hmapReal.buckets\n    for i := 0; i &lt; (1 &lt;&lt; hmapReal.B); i++ {\n        // bmap的size=88\n        kbase := bks + uintptr(i*88)\n        for j := 0; j &lt; 8; j++ {\n            fmt.Println(\"key=\", *(*int32)((unsafe.Pointer)(kbase + uintptr(8+j*4))))\n            fmt.Println(\"val=\", *(*int32)((unsafe.Pointer)(kbase + uintptr(8+8*4+j*4))))\n        }\n\n    }\n}\n\n\n\n2.3 访问\n\n2.3.1 for range 为啥是随机的\npackage main\n\nimport (\n    \"fmt\"\n)\nfunc main() {\n    m := make(map[int32]int32, 10)\n    m[1] = 22\n    m[2] = 33\n    m[3] = 44\n    m[4] = 55\n    m[5] = 66\n    for k, v := range m {\n        fmt.Println(k, v)\n    }\n}\n查看汇编 可以看到 写入map 的相关函数runtime.mapassign_fast32 range 的相关函数 runtime.mapiterinit\n\n\nmapiterinit()\n\nfunc mapiterinit(t *maptype, h *hmap, it *hiter) {\n    ...\n    ...\n    // decide where to start\n    r := uintptr(fastrand())\n    if h.B &gt; 31-bucketCntBits {\n        r += uintptr(fastrand()) &lt;&lt; 31\n    }\n    it.startBucket = r & bucketMask(h.B)\n    it.offset = uint8(r &gt;&gt; h.B & (bucketCnt - 1))\n\n    // iterator state\n    it.bucket = it.startBucket\n}\n\n\n\n\n2.4 扩容\n\n2.4.1 为什么需要扩容\n桶里key 多起来了,8个满了, 再overflow 整个几个. 你查询起来就慢了. 需要遍历桶里的元素, 这就是有装载因子的判断\n\n\n2.4.2 渐进式扩容",
    "crumbs": [
      "基础篇",
      "Map"
    ]
  },
  {
    "objectID": "docs/programming/go/basic/quick-start.html",
    "href": "docs/programming/go/basic/quick-start.html",
    "title": "go 快速入门",
    "section": "",
    "text": "Tip\n\n\n\n将github上的一个仓库作为你go项目的一个包来使用\n\n\n\n\n初始化go.mod\n\n# go1.16之前需要\ngo env -w GO111MODULE=on\n# 执行这个命令, 会在当前目录下生成一个 go.mod 文件\ngo mod init test\n\n\n\n查看go.mod\n\nmodule test\n\ngo 1.20\n\n\n\n添加一个包\n\ngo get github.com/pkg/errors\n\n在 go get 的时候如果不手动指定版本信息,会自动拉取最新的版本的包\n如果想要拉取指定版本可以通过 go get github.com/pkg/errors@v0.9.0 的方式\n\n@版本号 例如 @v0.9.0\n@分支名 例如 @master\n@commit tag 例如 @6cff360233dc4457f1536e4f3df4e4e740fd3410\n\n\n\n再看go.mod文件\n\nmodule test\n\ngo 1.20\n\nrequire (\n    github.com/pkg/errors v0.9.1 // indirect\n)\n\n// indirect 表示 这个包我们没有在代码中直接import 使用它, 大概是间接依赖的包, 比如 import A, 然后A里有import B, B就是我们间接依赖的包\npackage main\n\nimport \"github.com/pkg/errors\"\n\nfunc main() {\n    err := errors.New(\"abc\")\n    println(err)\n}\n当你在main.go 里使用了我们前面go get的包errors, 再去看下 go.mod 会看到提示说 should be  direct\n# 会下载依赖的包,并清理哪些不再需要的依赖,整理go.mod,\n# 这里会将 // indirect 取消掉了,意思就是直接\ngo mod tidy # 你应该每次下载包,用这个命令来\n# 将包缓存到本地 (你项目目录下会生成一个vendor 目录)\ngo mod vendor\n# 使用本地的包来编译, 这样不会去远程拉取\ngo build -mod vendor\n# 仓库作者修改了地址, 你可以修改\n# 这样你代码中 import \"github.com/Sirupsen/logrus\" 实际会使用替换后的\ngo mod edit -replace  github.com/Sirupsen/logrus@v1.4.1=github.com/sirupsen/logrus@v1.4.1",
    "crumbs": [
      "基础篇",
      "快速入门"
    ]
  },
  {
    "objectID": "docs/programming/go/basic/quick-start.html#go-mod包管理工具",
    "href": "docs/programming/go/basic/quick-start.html#go-mod包管理工具",
    "title": "go 快速入门",
    "section": "",
    "text": "Tip\n\n\n\n将github上的一个仓库作为你go项目的一个包来使用\n\n\n\n\n初始化go.mod\n\n# go1.16之前需要\ngo env -w GO111MODULE=on\n# 执行这个命令, 会在当前目录下生成一个 go.mod 文件\ngo mod init test\n\n\n\n查看go.mod\n\nmodule test\n\ngo 1.20\n\n\n\n添加一个包\n\ngo get github.com/pkg/errors\n\n在 go get 的时候如果不手动指定版本信息,会自动拉取最新的版本的包\n如果想要拉取指定版本可以通过 go get github.com/pkg/errors@v0.9.0 的方式\n\n@版本号 例如 @v0.9.0\n@分支名 例如 @master\n@commit tag 例如 @6cff360233dc4457f1536e4f3df4e4e740fd3410\n\n\n\n再看go.mod文件\n\nmodule test\n\ngo 1.20\n\nrequire (\n    github.com/pkg/errors v0.9.1 // indirect\n)\n\n// indirect 表示 这个包我们没有在代码中直接import 使用它, 大概是间接依赖的包, 比如 import A, 然后A里有import B, B就是我们间接依赖的包\npackage main\n\nimport \"github.com/pkg/errors\"\n\nfunc main() {\n    err := errors.New(\"abc\")\n    println(err)\n}\n当你在main.go 里使用了我们前面go get的包errors, 再去看下 go.mod 会看到提示说 should be  direct\n# 会下载依赖的包,并清理哪些不再需要的依赖,整理go.mod,\n# 这里会将 // indirect 取消掉了,意思就是直接\ngo mod tidy # 你应该每次下载包,用这个命令来\n# 将包缓存到本地 (你项目目录下会生成一个vendor 目录)\ngo mod vendor\n# 使用本地的包来编译, 这样不会去远程拉取\ngo build -mod vendor\n# 仓库作者修改了地址, 你可以修改\n# 这样你代码中 import \"github.com/Sirupsen/logrus\" 实际会使用替换后的\ngo mod edit -replace  github.com/Sirupsen/logrus@v1.4.1=github.com/sirupsen/logrus@v1.4.1",
    "crumbs": [
      "基础篇",
      "快速入门"
    ]
  },
  {
    "objectID": "docs/programming/go/basic/quick-start.html#编译运行",
    "href": "docs/programming/go/basic/quick-start.html#编译运行",
    "title": "go 快速入门",
    "section": "2 编译运行",
    "text": "2 编译运行\n\n\nmain.go\n\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    fmt.Println(\"hello\")\n}\n\n\n\n简单运行\n\ngo run main.go\n\n\n\n查看编译过程\n\ngo mod init test\ngo build -n\n\n    # import config\n    packagefile fmt=...\n    # 一个go程序会将runtime 编译进去.\n    packagefile runtime=...\n    # 编译\n    /usr/local/go/pkg/tool/linux_amd64/compile -o\n    # 要link 的文件清单\n    cat &gt;$WORK/b001/importcfg.link ...\n    # link 操作\n    /usr/local/go/pkg/tool/linux_amd64/link -o $WORK/b001/exe/a.out\n    /usr/local/go/pkg/tool/linux_amd64/buildid -w $WORK/b001/exe/a.out\n    # 重命名\n    mv $WORK/b001/exe/a.out test",
    "crumbs": [
      "基础篇",
      "快速入门"
    ]
  },
  {
    "objectID": "docs/programming/go/basic/quick-start.html#基本数据类型",
    "href": "docs/programming/go/basic/quick-start.html#基本数据类型",
    "title": "go 快速入门",
    "section": "3 基本数据类型",
    "text": "3 基本数据类型\n\n常量生成器iota\n\n\n// 每当遇到const, 就会重置为0\nconst c1 = iota // 0\nconst (\n    // const() 中每增加一行声明就会将iota计数 +1\n    a  = \"hello\" // hello\n    b            // hello\n    c  = 9\n    d         // 9  使用与它最近的表达式 这里是上面的 9\n    e         // 9\n    a1 = iota // 5  前面a 那里是0\n    a2        //6\n    _         //7\n    a4        //8\n    b1 = iota //9\n    b2        // 10\n)\n\nconst (\n    d1 = iota * 2 // 0\n    d2            //2\n    d3 = iota * 3 // 6\n    d4            //9  使用最近的 表达式 iota*3\n)\n\nconst (\n    e1 = 1 &lt;&lt; iota //1\n    e2             //2  左移 iota=1 位\n    e3             //4  左移 iota=2 位\n)\nconst pi=3.14\nfunc main() {\n    // # 常量是无法做 取址操作的,会报错\n    println(&pi)\n}\n\n\n\n\n\n\nTip\n\n\n\nconst申明的常量,是在编译期间就已经确定的固定值,你无法修改,所以你取址操作无意义",
    "crumbs": [
      "基础篇",
      "快速入门"
    ]
  },
  {
    "objectID": "docs/programming/go/basic/quick-start.html#空结构体struct",
    "href": "docs/programming/go/basic/quick-start.html#空结构体struct",
    "title": "go 快速入门",
    "section": "4 空结构体struct",
    "text": "4 空结构体struct\n\n\n\n\n\n\nImportant\n\n\n\n不占用内存, 经常用, 用来节约内存\n\n\n\npackage main\n\nimport (\n    \"fmt\"\n    \"unsafe\"\n)\n\nfunc main() {\n    a := struct{}{}\n    b := struct{}{}\n    fmt.Println(unsafe.Sizeof(a), unsafe.Sizeof(b)) //0\n    // 相同\n    fmt.Printf(\"%p,%p\\n\", &a, &b)\n    d := uintptr(unsafe.Pointer(&a))\n    fmt.Println(d)\n\n    cat := Cat{\n        Name:   \"abc\",\n        Ag:     struct{}{},\n        Age:    11,\n        Weight: 110,\n    }\n    // 我们发现 结果是32 , 在结构体里成员类型是空 struct{} ,也是不占用空间的\n    fmt.Println(unsafe.Sizeof(cat))\n    // 但是 和上面的 a, b 的 空结构体地址不一样.\n    // &cat.Ag, &cat.Age 地址一样\n    fmt.Printf(\"%p,%p,%p,%p\\n\", &cat.Name, &cat.Ag, &cat.Age, &cat.Weight)\n    dog := Dog{\n        Ag:     struct{}{},\n        Name:   \"abc\",\n        Age:    11,\n        Weight: 110,\n    }\n    fmt.Println(unsafe.Sizeof(dog)) // 32 不占用空间\n    // &dog.Ag, &dog.Name 地址一样\n    fmt.Printf(\"%p,%p,%p,%p\\n\", &dog.Ag, &dog.Name, &dog.Age, &dog.Weight)\n    // 放在结构体最后\n    h1 := struct {\n        b byte\n        s struct{}\n    }{}\n    fmt.Printf(\"%p,%p\\n\", &h1.b, &h1.s)\n    // 2 个字节, 也就是说填充了一个字节\n    // 试着 将 b 弄成 int16 int32 int64 看看\n    fmt.Println(unsafe.Sizeof(h1))\n}\ntype Cat struct {\n    Name   string //16 byte\n    Ag     struct{}\n    Age    int64 // 8\n    Weight int64 // 8\n}\ntype Dog struct {\n    Ag     struct{}\n    Name   string //16 byte\n    Age    int64  // 8\n    Weight int64  // 8\n}\n\n\n\n底层原理\n\nfunc mallocgc(size uintptr, typ *_type, needzero bool) unsafe.Pointer {\n    // ....\n    if size == 0 {\n        // 统一返回全局变量 zerobase 的地址\n        return unsafe.Pointer(&zerobase)\n    }\n}\n// base address for all 0-byte allocations\nvar zerobase uintptr\n\n\n\ndlv调试看看\n\nb main.main\nc\nb 16\nc\np d\np uintptr(&runtime.zerobase) # 与上面值一样",
    "crumbs": [
      "基础篇",
      "快速入门"
    ]
  },
  {
    "objectID": "docs/programming/go/basic/quick-start.html#nil",
    "href": "docs/programming/go/basic/quick-start.html#nil",
    "title": "go 快速入门",
    "section": "5 nil",
    "text": "5 nil\n\n\n\n\n\n\nTip\n\n\n\nnil 是一个变量\n\n\n\n\n\n源码中,请看看注释\n\n// nil is zero value for a pointer, channel, func, interface, map, or slice type.\n// Type must be a pointer, channel, func, interface, map, or slice type\nvar nil Type\n\n    var a *int\n    println(a == nil) //true\n    var b chan int\n    println(b == nil) //true\n    var c func() int\n    println(c == nil) //true\n    var d interface{}\n    println(d == nil) //true\n    d = b             // 看看接口的数据结构就知道了\n    println(d == nil) //false\n    var e map[string]int\n    println(e == nil) //true\n    var f []int\n    println(f == nil) //true",
    "crumbs": [
      "基础篇",
      "快速入门"
    ]
  },
  {
    "objectID": "docs/programming/go/basic/quick-start.html#make-new",
    "href": "docs/programming/go/basic/quick-start.html#make-new",
    "title": "go 快速入门",
    "section": "6 make && new",
    "text": "6 make && new\n// 只用来创建slice，map和channel\nfunc make(t Type, size ...IntegerType) Type\n\n// 返回的是指针, 指针指向的地址可能在栈上也可能在堆上\nfunc new(Type) *Type",
    "crumbs": [
      "基础篇",
      "快速入门"
    ]
  },
  {
    "objectID": "docs/programming/go/basic/panic-recover.html",
    "href": "docs/programming/go/basic/panic-recover.html",
    "title": "go panic recover",
    "section": "",
    "text": "Tip\n\n\n\npanic后会执行当前协程(main也是协程)的defer",
    "crumbs": [
      "基础篇",
      "panic-recover"
    ]
  },
  {
    "objectID": "docs/programming/go/basic/panic-recover.html#底层原理",
    "href": "docs/programming/go/basic/panic-recover.html#底层原理",
    "title": "go panic recover",
    "section": "1 底层原理",
    "text": "1 底层原理\nfunc gopanic(e any) {\n    gp := getg()  // 获取当前协程\n    // ...\n    for {\n        d := gp._defer\n        if d == nil {\n            break\n        }\n        // ...\n        if p.recovered {\n            // ...\n        }\n    }",
    "crumbs": [
      "基础篇",
      "panic-recover"
    ]
  },
  {
    "objectID": "docs/programming/go/basic/mem.html",
    "href": "docs/programming/go/basic/mem.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "package main\n\nvar global_init_xyz int64 = 3\nvar global_noinit_xyz int64\nvar global_init_strxyz string = \"hello\"\nvar global_noinit_strxyz string\n\nconst global_xyz int64 = 314  // 常量\nfunc main() {\n    var local_xyz int64 = 2\n    println(&local_xyz)\n    println(&global_init_xyz)\n    println(&global_noinit_xyz)\n    println(&global_init_strxyz)\n    println(&global_noinit_strxyz)\n    println(global_xyz)\n}\n\nobjdump查看各个段go tool compile\n\n\ngo build -o main -gcflags \"-N -l\" main.go\n# size 可执行文件\n# 查看程序内存的代码段 数据段等\n# 最好使用c程序来 看各个变量在哪个段\nsize main\n# dec = text+data+bss\n# hex 是dec的16进制数\n    text       data     bss     dec     hex filename\n    774543    13424  202000  989967   f1b0f main\nobjdump -t main|grep xyz\n    00000000004c0170 g     O .noptrdata 0000000000000008 main.global_init_xyz\n    00000000004f10a0 g     O .noptrbss  0000000000000008 main.global_noinit_xyz\n    00000000004c12e0 g     O .data  0000000000000010 main.global_init_strxyz\n    00000000004c35b0 g     O .bss   0000000000000010 main.global_noinit_strxyz\nobjdump -t main|grep string\n    0000000000466220 l     O .rodata    0000000000000000 go:string.*\n\n\n\n\ngo tool compile -S -N -l main.go 查看\n\ngo:string.\"hello\" SRODATA dupok size=5\n0x0000 68 65 6c 6c 6f                                   hello\n\nmain.global_init_xyz SNOPTRDATA size=8\nmain.global_noinit_xyz SNOPTRBSS size=8\nmain.global_init_strxyz SDATA size=16\nmain.global_noinit_strxyz SBSS size=16\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\n字符串 字面量 hello这种是在只读的内存区的. 定义的常量 global_xyz ,在汇编中可能是以 MOVL    $314, AX 这种形式来操作的,并不存在只读区,具体情况具体分析 可以关注到go里有 noptrdata noptrbss这种 无指针的 这种区\n\n\n\n\n\n Back to top",
    "crumbs": [
      "基础篇",
      "程序的内存分布"
    ]
  },
  {
    "objectID": "docs/programming/go/basic/reflect.html",
    "href": "docs/programming/go/basic/reflect.html",
    "title": "go 反射",
    "section": "",
    "text": "Tip\n\n\n\n建议先看下接口章节",
    "crumbs": [
      "基础篇",
      "反射"
    ]
  },
  {
    "objectID": "docs/programming/go/basic/reflect.html#元数据",
    "href": "docs/programming/go/basic/reflect.html#元数据",
    "title": "go 反射",
    "section": "1 元数据",
    "text": "1 元数据\n\n\n\n\n\n\n什么是元数据?\n\n\n\n是描述数据的数据 比如一个结构体对象是个数据, 它是什么类型,这个类型就是用来描述这个它自己的一种数据 这个结构体对象的值,比如 Dog{Name:“tom”} tom 这种就是它的值, 它显然也是描述该结构体的一种数据 我们只要有了一个数据的类型和值, 那么我们就知道了该数据的全部信息",
    "crumbs": [
      "基础篇",
      "反射"
    ]
  },
  {
    "objectID": "docs/programming/go/basic/reflect.html#三定律",
    "href": "docs/programming/go/basic/reflect.html#三定律",
    "title": "go 反射",
    "section": "2 三定律",
    "text": "2 三定律\n\n2.1 接口类型变量转换为反射对象\n\n2.1.1 类型 reflect.Type\n\n\n\n\n\n\nTip\n\n\n\n\n是接口,用于获取元数据 : “类型”信息\nreflect.TypeOf() 对象转换为Type接口的方法\n\n\n\n\n\nTypeOf()结构体和结构体指针的反射\n\n\n\n\n\n\n\n\n重要\n\n\n\n\n从源码看, 刚好和我们之前讲到的接口与元数据将变量转为接口类型,就可以获取它的元数据的推断一致\n后面比如.Field(0) 这类操作的底层与 接口章节的代码验证结构 原理一致\n\n\n\nfunc TypeOf(i any) Type {\n    eface := *(*emptyInterface)(unsafe.Pointer(&i))\n    return toType(eface.typ)\n}\n\n\npackage test\n\nimport (\n    \"fmt\"\n    \"reflect\"\n    \"testing\"\n)\ntype Dog struct {\n    Age  int\n    name string\n}\n\nfunc (d Dog) shout() {\n    println(\"wang ...\")\n}\nfunc (d Dog) Show() {\n    println(\"show ...\")\n}\nfunc (d *Dog) SetName(name string) {\n    d.name = name\n}\n\n结构体 反射结构体指针 反射\n\n\nfunc TestA(t *testing.T) {\n    d := Dog{11, \"tom\"}\n    typ := reflect.TypeOf(d)\n    fmt.Println(typ.Name(), typ.Kind())\n    if typ.Kind() == reflect.Struct {\n        // 字段\n        numField := typ.NumField()\n        for i := 0; i &lt; numField; i++ {\n            // 可以获取 private 字段 信息\n            fmt.Println(typ.Field(i).Name, \"是否公开:\", typ.Field(i).IsExported())\n        }\n        // 方法\n        numMethod := typ.NumMethod()\n        fmt.Println(\"方法个数:\", numMethod) //1\n        for i := 0; i &lt; numMethod; i++ {\n            // 只能获取public 方法 ,Show\n            fmt.Println(typ.Method(i).Name)\n        }\n    }\n}\n\n\nfunc TestA(t *testing.T) {\n    ptrD := &Dog{11, \"tom\"}\n    ptrTyp := reflect.TypeOf(ptrD)\n    // kind 是ptr指针\n    fmt.Println(ptrTyp.Name(), ptrTyp.Kind())\n    // 方法\n    numMethod := ptrTyp.NumMethod()\n    fmt.Println(\"方法个数:\", numMethod) // 2\n    for i := 0; i &lt; numMethod; i++ {\n        // SetName  Show (前面说过编译器会默认生成一个对应的 *Dog 为接受者的方法)\n        fmt.Println(ptrTyp.Method(i).Name)\n    }\n    fmt.Println(ptrTyp.Elem().Kind()) // struct\n}\n\n\n\n\n\n\n\n\n2.1.2 值 reflect.Value\n\n\n\n\n\n\nTip\n\n\n\n\n是结构体,用于获取元数据: “值”信息\nreflect.ValueOf() 对象转换为Value结构体的方法\n\n\n\n\n\n结构体与结构体指针 值的反射\n\n\npackage test\n\nimport (\n    \"fmt\"\n    \"reflect\"\n    \"testing\"\n)\ntype Dog struct {\n    Age  int\n    name string\n}\n\nfunc (d Dog) shout() {\n    println(\"wang ...\")\n}\nfunc (d Dog) Show() {\n    println(\"show ...\")\n}\nfunc (d *Dog) SetName(name string) {\n    d.name = name\n}\n\n结构体反射结构体指针\n\n\nfunc TestA(t *testing.T) {\n    d := Dog{11, \"tom\"}\n    val := reflect.ValueOf(d)\n    typFromVal := val.Type()\n    numField := val.NumField()\n    for i := 0; i &lt; numField; i++ {\n        field := val.Field(i)\n        typField := typFromVal.Field(i)\n        if typField.IsExported() {\n            // 私有的字段无法 获取它的值的\n            // 值无法修改 ,因为 方法是值转递,无意义,指针的话就可以了\n            fmt.Println(field.Interface(), field.CanSet())\n\n        } else {\n            fmt.Println(typField.Name)\n        }\n    }\n}\n\n\nfunc TestA(t *testing.T) {\n    ptrD := &Dog{11, \"tom\"}\n    ptrVal := reflect.ValueOf(ptrD)\n    val = ptrVal.Elem()\n    typFromVal = val.Type()\n    numField = val.NumField()\n    for i := 0; i &lt; numField; i++ {\n        field := val.Field(i)\n        typField := typFromVal.Field(i)\n        if typField.IsExported() {\n            fmt.Println(field.Interface(), field.CanSet())\n            field.SetInt(3)\n            fmt.Println(ptrD.Age)\n            // 或\n            field.Set(reflect.ValueOf(5))\n            fmt.Println(ptrD.Age)\n        } else {\n            fmt.Println(typField.Name)\n        }\n    }\n    fmt.Println(ptrD.Age)\n}\n\n\n\n\n\n\n\n\n\n2.2 反射对象转换为接口类型变量\n\n\n\n\n\n\nreflect.Interface()\n\n\n\n转为接口类型的变量, 然后可通过类型断言等转为原来的类型\n\n\n\n\n2.3 可变性",
    "crumbs": [
      "基础篇",
      "反射"
    ]
  },
  {
    "objectID": "docs/programming/go/basic/reflect.html#基础操作",
    "href": "docs/programming/go/basic/reflect.html#基础操作",
    "title": "go 反射",
    "section": "3 基础操作",
    "text": "3 基础操作\ntype Dog struct {\n    Age  int\n    Name string\n}\nfunc (d Dog) SetName(name string) {\n    d.Name = name\n}\nfunc TestReflect(t *testing.T) {\n    d := &Dog{Age: 2, Name: \"ff\"}\n    dT := reflect.TypeOf(d)\n    for i := 0; i &lt; dT.NumMethod(); i++ {\n        // 打印方法\n        fmt.Println(dT.Method(i).Name, \"==\", dT.Method(i).Type, \"==\", dT.Method(i).Type.Kind())\n    }\n\n    vv := reflect.ValueOf(d)\n    args := []reflect.Value{reflect.ValueOf(\"tom\")}\n    // 调用方法\n    vv.MethodByName(dT.Method(0).Name).Call(args)\n    fmt.Println(d.Name)\n}",
    "crumbs": [
      "基础篇",
      "反射"
    ]
  },
  {
    "objectID": "docs/programming/go/basic/defer.html",
    "href": "docs/programming/go/basic/defer.html",
    "title": "go defer",
    "section": "",
    "text": "Tip\n\n\n\n常用于关闭资源,先进后执行",
    "crumbs": [
      "基础篇",
      "defer"
    ]
  },
  {
    "objectID": "docs/programming/go/basic/defer.html#例子分析",
    "href": "docs/programming/go/basic/defer.html#例子分析",
    "title": "go defer",
    "section": "1 例子分析",
    "text": "1 例子分析\n\n1.1 例子1\nfunc TestDefer(t *testing.T) {\n    fmt.Println(111)\n    // 先进后执行\n    defer func() {\n        fmt.Println(333)\n    }()\n    {\n        // 代码块中的defer 也是在函数返回前执行\n        defer func() {\n            fmt.Println(\"代码块中的defer\")\n        }()\n        fmt.Println(\"代码块执行完毕\")\n    }\n\n    defer func() {\n        fmt.Println(444)\n    }()\n    fmt.Println(222)\n}\n\n\n执行结果\n\n111\n代码块执行完毕\n222\n444\n代码块中的defer\n333\n\n\n\n1.2 例子2\n\n\n\nOS\ngo version\n\n\n\n\nUbuntu 20.04.3 LTS\ngo1.20.4\n\n\n\n\n匿名返回值有名返回值\n\n\npackage main\n\nfunc defer1() int {\n    i := 2\n    defer func() {\n        i = 3\n    }()\n    return i\n}\nfunc main() {\n    ret := defer1()\n    // 结果是2\n    println(ret)\n}\n\n\npackage main\n\nfunc defer1() (i int) {\n    i = 2\n    defer func() {\n        i = 3\n    }()\n    return i\n}\nfunc main() {\n    ret := defer1()\n    // 结果是3\n    println(ret)\n}\n\n\n\ngo tool compile -S -N -l main.go\n\n汇编代码使用的是go 1.15.4生成的, 省略部分.\n\n匿名返回值有名返回值\n\n\n\n\"\".defer1 STEXT size=155 args=0x8 locals=0x68\n    0x0000 00000 (main.go:3)    TEXT    \"\".defer1(SB), ABIInternal, $104-8\n    0x0013 00019 (main.go:3)    SUBQ    $104, SP\n    0x0017 00023 (main.go:3)    MOVQ    BP, 96(SP)\n    0x001c 00028 (main.go:3)    LEAQ    96(SP), BP\n    # 返回值 r0\n    0x0021 00033 (main.go:3)    MOVQ    $0, \"\".~r0+112(SP)\n    # i\n    0x002a 00042 (main.go:4)    MOVQ    $2, \"\".i+8(SP)\n    0x0033 00051 (main.go:5)    MOVL    $8, \"\"..autotmp_3+16(SP)\n    0x003b 00059 (main.go:5)    LEAQ    \"\".defer1.func1·f(SB), AX\n    0x0042 00066 (main.go:5)    MOVQ    AX, \"\"..autotmp_3+40(SP)\n    0x0047 00071 (main.go:5)    LEAQ    \"\".i+8(SP), AX\n    0x004c 00076 (main.go:5)    MOVQ    AX, \"\"..autotmp_3+88(SP)\n    0x0051 00081 (main.go:5)    LEAQ    \"\"..autotmp_3+16(SP), AX\n    0x0056 00086 (main.go:5)    MOVQ    AX, (SP)\n    0x005a 00090 (main.go:5)    CALL    runtime.deferprocStack(SB)\n    0x005f 00095 (main.go:5)    NOP\n    0x0060 00096 (main.go:5)    TESTL   AX, AX\n    0x0062 00098 (main.go:5)    JNE 129\n    0x0064 00100 (main.go:5)    JMP 102\n    0x0066 00102 (main.go:9)    MOVQ    \"\".i+8(SP), AX\n    # i 附给 返回值\n    0x006b 00107 (main.go:9)    MOVQ    AX, \"\".~r0+112(SP)\n    0x0070 00112 (main.go:9)    XCHGL   AX, AX\n    0x0071 00113 (main.go:9)    CALL    runtime.deferreturn(SB)\n\"\".defer1.func1 STEXT nosplit size=13 args=0x8 locals=0x0\n    0x0000 00000 (main.go:5)    TEXT    \"\".defer1.func1(SB), NOSPLIT|ABIInternal, $0-8\n    # i的地址 给AX\n    0x0000 00000 (main.go:6)    MOVQ    \"\".&i+8(SP), AX\n    # 赋值3 给 i\n    0x0005 00005 (main.go:6)    MOVQ    $3, (AX)\n\"\".main STEXT size=98 args=0x0 locals=0x18\n    0x0000 00000 (main.go:11)   TEXT    \"\".main(SB), ABIInternal, $24-0\n    0x000f 00015 (main.go:11)   SUBQ    $24, SP\n    0x0013 00019 (main.go:11)   MOVQ    BP, 16(SP)\n    0x0018 00024 (main.go:11)   LEAQ    16(SP), BP\n    0x0020 00032 (main.go:12)   CALL    \"\".defer1(SB)\n    # (SP) 就是 r0\n    0x0025 00037 (main.go:12)   MOVQ    (SP), AX\n    # 赋值给 ret\n    0x0029 00041 (main.go:12)   MOVQ    AX, \"\".ret+8(SP)\n    0x002e 00046 (main.go:13)   CALL    runtime.printlock(SB)\n    0x0033 00051 (main.go:13)   MOVQ    \"\".ret+8(SP), AX\n    0x0038 00056 (main.go:13)   MOVQ    AX, (SP)\n\n\n\n\"\".defer1 STEXT size=140 args=0x8 locals=0x60\n    0x0000 00000 (main.go:3)    TEXT    \"\".defer1(SB), ABIInternal, $96-8\n    0x000f 00015 (main.go:3)    SUBQ    $96, SP\n    0x0013 00019 (main.go:3)    MOVQ    BP, 88(SP)\n    0x0018 00024 (main.go:3)    LEAQ    88(SP), BP\n    # i 赋值\n    0x001d 00029 (main.go:3)    MOVQ    $0, \"\".i+104(SP)\n    0x0026 00038 (main.go:4)    MOVQ    $2, \"\".i+104(SP)\n    0x002f 00047 (main.go:5)    MOVL    $8, \"\"..autotmp_2+8(SP)\n    0x0037 00055 (main.go:5)    LEAQ    \"\".defer1.func1·f(SB), AX\n    0x003e 00062 (main.go:5)    MOVQ    AX, \"\"..autotmp_2+32(SP)\n    0x0043 00067 (main.go:5)    LEAQ    \"\".i+104(SP), AX\n    0x0048 00072 (main.go:5)    MOVQ    AX, \"\"..autotmp_2+80(SP)\n    0x004d 00077 (main.go:5)    LEAQ    \"\"..autotmp_2+8(SP), AX\n    0x0052 00082 (main.go:5)    MOVQ    AX, (SP)\n    0x0056 00086 (main.go:5)    PCDATA  $1, $0\n    0x0056 00086 (main.go:5)    CALL    runtime.deferprocStack(SB)\n    0x005b 00091 (main.go:5)    TESTL   AX, AX\n    0x005d 00093 (main.go:5)    JNE 114\n    0x005f 00095 (main.go:5)    NOP\n    0x0060 00096 (main.go:5)    JMP 98\n    0x0062 00098 (main.go:9)    XCHGL   AX, AX\n    0x0063 00099 (main.go:9)    CALL    runtime.deferreturn(SB)\n\"\".defer1.func1 STEXT nosplit size=13 args=0x8 locals=0x0\n    0x0000 00000 (main.go:5)    TEXT    \"\".defer1.func1(SB), NOSPLIT|ABIInternal, $0-8\n    # i的地址 给AX\n    0x0000 00000 (main.go:6)    MOVQ    \"\".&i+8(SP), AX\n    # 赋值3 给 i\n    0x0005 00005 (main.go:6)    MOVQ    $3, (AX)\n\"\".main STEXT size=98 args=0x0 locals=0x18\n    0x0000 00000 (main.go:11)   TEXT    \"\".main(SB), ABIInternal, $24-0\n    0x000f 00015 (main.go:11)   SUBQ    $24, SP\n    0x0013 00019 (main.go:11)   MOVQ    BP, 16(SP)\n    0x0018 00024 (main.go:11)   LEAQ    16(SP), BP\n    0x0020 00032 (main.go:12)   CALL    \"\".defer1(SB)\n    # (SP) 就是 返回值也是 i\n    0x0025 00037 (main.go:12)   MOVQ    (SP), AX\n    # 赋值给 ret\n    0x0029 00041 (main.go:12)   MOVQ    AX, \"\".ret+8(SP)\n    0x002e 00046 (main.go:13)   CALL    runtime.printlock(SB)\n    0x0033 00051 (main.go:13)   MOVQ    \"\".ret+8(SP), AX\n    0x0038 00056 (main.go:13)   MOVQ    AX, (SP)\n\n\n\n先设置返回值,然后执行defer ,最后将返回值复制给ret\n有名返回值的情况是 返回值与i变量是同一个内存位置, defer会修改这个i,就是修改了返回值,最后复制给ret,这样结果就是3了\n匿名返回值的情况是 会有一个临时变量(一块在main栈帧中的内存作为返回值),先设置返回值=2,接着执行defer,修改的是defer1函数栈帧中的 i变量,对返回值无影响\n\n\n1.3 例子3\npackage main\n\nfunc defer1() (i int) {\n    i = 2\n    defer func() {\n        // 之前例子的汇编可以看到,defer 里会用到 &i\n        // 实际上变成一个闭包了.\n        // 是1\n        println(\"defer1\", i)\n        i = 3\n    }()\n    // 设置返回值, i就是, 所以i=1\n    return 1\n}\nfunc main() {\n    // 3\n    println(defer1())\n}\n\n\n1.4 例子4\npackage main\n\nfunc add(i *int) int {\n    println(*i)\n    *i = *i + 1\n    return *i\n}\n\nfunc main() {\n    var i int = 1\n    // 会执行它的参数 i变成2\n    defer println(\"defer:\", add(&i))\n    defer func() {\n        // 闭包了\n        // 使用了外部变量 打印5\n        println(i)\n    }()\n    // 2\n    println(\"before return: \", i)\n    i = 5\n    println(\"return\")\n}",
    "crumbs": [
      "基础篇",
      "defer"
    ]
  },
  {
    "objectID": "docs/programming/go/basic/defer.html#底层原理",
    "href": "docs/programming/go/basic/defer.html#底层原理",
    "title": "go defer",
    "section": "2 底层原理",
    "text": "2 底层原理",
    "crumbs": [
      "基础篇",
      "defer"
    ]
  },
  {
    "objectID": "docs/programming/go/basic/pragma-directives.html",
    "href": "docs/programming/go/basic/pragma-directives.html",
    "title": "go 编译指示",
    "section": "",
    "text": "Tip\n\n\n\n\n编译指示一种语言结构,它指示编译器应该如何处理其输入\ngo中这样的注释 //go:(注释//与go没有空格) 就是 Go 语言编译指示的实现方式",
    "crumbs": [
      "基础篇",
      "编译指示"
    ]
  },
  {
    "objectID": "docs/programming/go/basic/pragma-directives.html#gonoinline",
    "href": "docs/programming/go/basic/pragma-directives.html#gonoinline",
    "title": "go 编译指示",
    "section": "1 //go:noinline",
    "text": "1 //go:noinline\n\n\n\n\n\n\n什么是inline内联优化?\n\n\n\n\n函数调用需要将相关寄存器中的数据入栈来保存现场,函数调用完毕又需要弹栈来恢复现场,频繁的这样消耗时间,影响执行效率\n内联就是将调用的函数直接复制到调用处.这样就不用频繁入栈出栈,减少了开销,执行速度快了.\n内联的问题\n\n增加了代码的重复\n如果函数被很多很多其他地方调用,都内联优化了,如果本来一个地方被缓存,读取指令快,现在可能缓存没有命中,得重新读取再缓存,慢了\n\n\n\n\n\n\n内联优化对比\n\nfunc show(){\n    fmt.Println(\"hello\")\n}\nfunc test(){\n    show()\n}\n// ==&gt; 内联优化后\nfunc show(){\n    fmt.Println(\"hello\")\n}\nfunc test(){\n    // 直接复制到调用处\n    fmt.Println(\"hello\")\n}\n\n\n\n\n\n\n\nTip\n\n\n\n\n//go:noinline 顾名思义就是禁止内联优化,通常我们需要调式的时候用\n后面必须跟着 func 的申明\n\n\n\npackage main\n\n// 哪个func 不想被内联优化, 就在哪个上面写\n//go:noinline\nfunc p() {\n    println(2)\n}\n\nfunc main() {\n    a := 1\n    println(a)\n    p()\n}\n# 代码中 写了 禁止内联, 查看汇编就可以不需要 -l\ngo tool compile -S  main.go |grep \"main.go:11\"",
    "crumbs": [
      "基础篇",
      "编译指示"
    ]
  },
  {
    "objectID": "docs/programming/go/basic/pragma-directives.html#golinkname",
    "href": "docs/programming/go/basic/pragma-directives.html#golinkname",
    "title": "go 编译指示",
    "section": "2 //go:linkname",
    "text": "2 //go:linkname\n\n\n\n\n\n\nTip\n\n\n\n\n当你想要使用别的包(自己写的包或者go源码的包都行)没有导出(私有)的变量和方法时\n//go:linkname localname [importpath.name]\n调试代码时可能会用到这类技术\n\n\n\n\n使用go源码中的包\n\nruntime.inheap 这个方法正常情况下我们是没法调用的\npackage main\n\nimport (\n    //  如果没有使用  也需要import \n    // _ \"unsafe\"\n    \"unsafe\"\n)\n\n// 表示 inheap 的真正实现是 runtime.inheap\n//\n//go:linkname inheap runtime.inheap\nfunc inheap(arg uintptr) bool  // 方法申明,去看 runtime.inheap 复制过来\nfunc main() {\n    var a int = 1\n    // false 表示在栈上\n    println(inheap(uintptr(unsafe.Pointer(&a))))\n}\n\n自己的包中的私有方法\n\n\n代码目录show.gomain.go\n\n\n.\n├── go.mod  # mod name  是test\n├── main.go\n├── pkg\n│   └── show.go\n\n\npackage pkg\n\nimport \"fmt\"\n\nfunc s() {\n    fmt.Println(11)\n}\n\n\npackage main\n\nimport (\n    _ \"test/pkg\"\n    _ \"unsafe\"\n)\n\nfunc main() {\n    show()\n}\n// 真正实现是test/pkg.s 函数\n//\n//go:linkname show test/pkg.s\nfunc show()",
    "crumbs": [
      "基础篇",
      "编译指示"
    ]
  },
  {
    "objectID": "docs/programming/go/basic/escape.html",
    "href": "docs/programming/go/basic/escape.html",
    "title": "go 逃逸分析",
    "section": "",
    "text": "Tip\n\n\n\n看过汇编后, 我们知道,在栈上的局部变量在函数返回后,会被释放,如果变量还会被引用到,那么就不能在栈上分配,编译器会将它设置为在堆上分配内存",
    "crumbs": [
      "基础篇",
      "逃逸分析"
    ]
  },
  {
    "objectID": "docs/programming/go/basic/escape.html#分析方法",
    "href": "docs/programming/go/basic/escape.html#分析方法",
    "title": "go 逃逸分析",
    "section": "1 分析方法",
    "text": "1 分析方法\n\n\n\n\n\n\n\nitem\ndescription\n\n\n\n\n-m\n打印逃逸分析信息\n\n\nxxx escapes to heap\n当前变量的一个副本拷贝在堆上进行分配\n\n\nmoved to heap: xxx\n表示变量自身在堆上进行分配\n\n\nleaking param content: xxx\n表示如果这个变量为指针的话，则是其指向的内容在堆上分配\n\n\n\npackage main\n\nimport (\n    \"unsafe\"\n)\n// 是否在堆中\n//\n//go:linkname inheap runtime.inheap\nfunc inheap(arg uintptr) bool\n\n// 是否在栈或堆中\n//\n//go:linkname inHeapOrStack runtime.inHeapOrStack\nfunc inHeapOrStack(b uintptr) bool\nfunc main() {\n    var a int = 1\n    // false 表示在栈上\n    println(inheap(uintptr(unsafe.Pointer(&a))))\n}\ngo run -gcflags \"-m -l\" main.go",
    "crumbs": [
      "基础篇",
      "逃逸分析"
    ]
  },
  {
    "objectID": "docs/programming/go/basic/escape.html#例子",
    "href": "docs/programming/go/basic/escape.html#例子",
    "title": "go 逃逸分析",
    "section": "2 例子",
    "text": "2 例子\n\n2.1 返回指针\npackage main\n\nfunc test() *int {\n    a := 66 // 逃逸到堆上\n    return &a\n}\n\nfunc main() {\n    println(test())\n}\ngo run -gcflags \"-m -l\" main.go\n    ./main.go:4:2: moved to heap: a\n    0xc00001c1a8",
    "crumbs": [
      "基础篇",
      "逃逸分析"
    ]
  },
  {
    "objectID": "docs/programming/go/basic/string.html",
    "href": "docs/programming/go/basic/string.html",
    "title": "go string",
    "section": "",
    "text": "首先我们知道在编译型语言中一个变量所占的内存必须是确定的\n\n\n编程语言中字符串都可以有类似这样的操作\n\nstr:=\"abc\"\nstr=\"hello\"\n\n从上面的代码我们做一些思考\n\n字符串变量指向的实际字符的内存内容是可变的\n如何知道字符串的长度\n\n实际存放字符的地方, 遇 “\\0” 截止?\n或设计上直接写明字符的字节长度\n\n实际字符串所在内存是否可以直接修改内容\n\n这个基于实际字符串放在内存的什么区域?\n\n字符串增长时(比如拼接)是怎么处理的\n\nstr:=\"abc\" 实际字符串所在位置是就分配3个字节\n增长时, 就需要重新分配内存,需要copy原先的字符串到新位置的操作\n如果你有很多次拼接,那么需要考虑性能, 用一些好的方式来拼接",
    "crumbs": [
      "基础篇",
      "字符串"
    ]
  },
  {
    "objectID": "docs/programming/go/basic/string.html#如何设计字符串",
    "href": "docs/programming/go/basic/string.html#如何设计字符串",
    "title": "go string",
    "section": "",
    "text": "首先我们知道在编译型语言中一个变量所占的内存必须是确定的\n\n\n编程语言中字符串都可以有类似这样的操作\n\nstr:=\"abc\"\nstr=\"hello\"\n\n从上面的代码我们做一些思考\n\n字符串变量指向的实际字符的内存内容是可变的\n如何知道字符串的长度\n\n实际存放字符的地方, 遇 “\\0” 截止?\n或设计上直接写明字符的字节长度\n\n实际字符串所在内存是否可以直接修改内容\n\n这个基于实际字符串放在内存的什么区域?\n\n字符串增长时(比如拼接)是怎么处理的\n\nstr:=\"abc\" 实际字符串所在位置是就分配3个字节\n增长时, 就需要重新分配内存,需要copy原先的字符串到新位置的操作\n如果你有很多次拼接,那么需要考虑性能, 用一些好的方式来拼接",
    "crumbs": [
      "基础篇",
      "字符串"
    ]
  },
  {
    "objectID": "docs/programming/go/basic/string.html#数据结构",
    "href": "docs/programming/go/basic/string.html#数据结构",
    "title": "go string",
    "section": "2 数据结构",
    "text": "2 数据结构\n\n\ngo的字符串的设计\n\ntype StringHeader struct {\n    // 指向实际字符串的地址 8字节\n    // 这个地址上是连续的内容空间来存放字符: 字节数组\n    Data uintptr\n    // 字符串的字节长度 8字节\n    Len  int\n}",
    "crumbs": [
      "基础篇",
      "字符串"
    ]
  },
  {
    "objectID": "docs/programming/go/basic/string.html#字符串的定义",
    "href": "docs/programming/go/basic/string.html#字符串的定义",
    "title": "go string",
    "section": "3 字符串的定义",
    "text": "3 字符串的定义\n可以先看看程序内存分布情况\n\n\n\n\n\n\nTip\n\n\n\n\n\n\n\nX=栈,Y=常量x=全局,y=常量X=栈,Y=堆X=堆,Y=常量x=栈,y=栈\n\n\nfunc TestString(t *testing.T) {\n    cd := 1\n    println(&cd)\n    a := \"abc我们\"\n    b := (*reflect.StringHeader)(unsafe.Pointer(&a))\n    // 字节大小16,  字符长度是9, 1个汉字占3个字节\n    println(unsafe.Sizeof(a), b.Len, b.Data)\n    println(&a, &b.Len, &b.Data)\n    fmt.Printf(\"0x%x\\n\", b.Data)\n    c := (*[3]int8)(unsafe.Pointer(b.Data))\n    // 97 98 99\n    println(c[0], c[1], c[2])\n    // c[0] = 'd' // 无法修改的,实际字符在内存的只读区\n\n    a2 := \"abc我们\"\n    b2 := (*reflect.StringHeader)(unsafe.Pointer(&a2))\n    // 我们发现, 实际字符串 和上面的变量a 的字符串 存放的位置是一样的\n    // 字符串字面量在常量区会重复使用, 因为是只读的,所以可以这样\n    println(b2.Data) // = b.Data\n}\n\n\nvar global_init_strxyz string = \"hello\"\n\nfunc TestString2(t *testing.T) {\n    b := (*reflect.StringHeader)(unsafe.Pointer(&global_init_strxyz))\n    // 0x1209c70 0x1209c78 0x1209c70\n    println(&global_init_strxyz, &b.Len, &b.Data)\n    fmt.Printf(\"0x%x\\n\", b.Data) //0x11293bd\n    c := (*[3]int8)(unsafe.Pointer(b.Data))\n    // 104 101 108\n    println(c[0], c[1], c[2])\n    // c[0] = 'd' // 无法修改的,实际字符在内存的只读区\n}\n\n\n//go:linkname inheap runtime.inheap\nfunc inheap(arg uintptr) bool\n\nfunc TestString4(t *testing.T) {\n    arr := [5]byte{'h', 'e', 'l', 'l', 'o'}\n    slc := arr[:]\n    fmt.Println(slc) // arr 逃逸到 堆中了\n    println(inheap(uintptr(unsafe.Pointer(&arr))))\n    // 直接将切片转为 字符串\n    b := *(*string)(unsafe.Pointer(&slc))\n    fmt.Println(b) // hello\n    slc[0] = 'w'\n    fmt.Println(b) // wello\n}\n\n\n//go:linkname inheap runtime.inheap\nfunc inheap(arg uintptr) bool\n\nfunc getString() *string {\n    r := \"hello\"\n    b := (*reflect.StringHeader)(unsafe.Pointer(&r))\n    println(b.Data)          // 0x1129A7D  常量区\n    println(&b.Len, &b.Data) //0xc00005e6a0  堆区\n    return &r\n}\nfunc TestString5(t *testing.T) {\n    s := getString()\n    println(s)\n    println(inheap(uintptr(unsafe.Pointer(s))))\n}\n\n\npackage main\n\nimport (\n    \"reflect\"\n    \"unsafe\"\n)\n\nfunc A(ptrArr *[5]byte) {\n    s := \"world\"\n    sStruct := (*reflect.StringHeader)(unsafe.Pointer(&s))\n    b := uintptr(unsafe.Pointer(ptrArr))\n    sStruct.Data = b\n    println(s)\n    ptrArr[0] = 'f'\n    println(s)\n}\n\nfunc main() {\n    arr := [5]byte{'h', 'e', 'l', 'l', 'o'}\n    x := 2\n    println(&arr, &x)\n    A(&arr)\n}\n汇编代码, 只列出一点,其他自行查看\n\n\nmain\n\nTEXT main.main(SB)\nfunc main() {\n0x105c906             4883ec30                SUBQ $0x30, SP\n0x105c90a             48896c2428              MOVQ BP, 0x28(SP)\n0x105c90f             488d6c2428              LEAQ 0x28(SP), BP\n        arr := [5]byte{'h', 'e', 'l', 'l', 'o'}\n0x105c914             c744240b68656c6c        MOVL $0x6c6c6568, 0xb(SP)\n0x105c91c             c644240f6f              MOVB $0x6f, 0xf(SP)\n        x := 2\n0x105c921             48c744241002000000      MOVQ $0x2, 0x10(SP)",
    "crumbs": [
      "基础篇",
      "字符串"
    ]
  },
  {
    "objectID": "docs/programming/go/basic/string.html#字符串与字符切片的转换",
    "href": "docs/programming/go/basic/string.html#字符串与字符切片的转换",
    "title": "go string",
    "section": "4 字符串与字符切片的转换",
    "text": "4 字符串与字符切片的转换\n前面代码验证字符串数据结构,知道 a := \"abc我们\" 这样定义的字符串是无法修改指向的内存的内容\n\n\n字符切片转字符串-方式一\n\nfunc main() {\n    a := []byte{'a', 'b', 'c'}\n    b := string(a)\n    println(b)\n}\n\n查看汇编可以看到使用的是runtime.slicebytetostring()\nfunc slicebytetostring(buf *tmpBuf, ptr *byte, n int) string {\n     // ...\n\n    var p unsafe.Pointer\n    if buf != nil && n &lt;= len(buf) {\n        p = unsafe.Pointer(buf)\n    } else {\n        p = mallocgc(uintptr(n), nil, false)\n    }\n    // 会复制切片的内容\n    memmove(p, unsafe.Pointer(ptr), uintptr(n))\n    return unsafe.String((*byte)(p), n)\n}\n\n\n字符切片转字符串-方式二\n\nfunc TestA(t *testing.T) {\n    a := []byte{'a', 'b', 'c'}\n    b := *(*string)(unsafe.Pointer(&a))\n    fmt.Println(b) // abc\n    a[0] = 'd'\n    fmt.Println(b) // dbc\n}\n\n\n切片的内存结构\n\n\n\n字符串的内存结构\n\n\n我们知道类型转换就是换一种方式来读写内存,根据切片和字符串的内存结构,发现他们刚好可以很方便的进行转换,切片data指向的字符数组成了字符串data的指向,这个转换是高效率的.\n\n\n稍微看下汇编\n\n0x006b 00107 (main.go:15) MOVQ    AX, main.a+48(SP) # 字符数组地址\n0x0070 00112 (main.go:15) MOVQ    $3, main.a+56(SP) # 切片长度 设置=3\n0x0079 00121 (main.go:15) MOVQ    $3, main.a+64(SP) # 切片cap 设置=3\n0x0082 00130 (main.go:16) LEAQ    main.a+48(SP), AX\n0x0087 00135 (main.go:16) TESTB   AL, (AX)\n0x0089 00137 (main.go:16) MOVQ    main.a+48(SP), AX\n0x008e 00142 (main.go:16) MOVQ    AX, main.b+32(SP) # 字符数组地址\n0x0093 00147 (main.go:16) MOVQ    $3, main.b+40(SP)  # 字符串的len 设置=3",
    "crumbs": [
      "基础篇",
      "字符串"
    ]
  },
  {
    "objectID": "docs/programming/go/basic/string.html#字符串拼接",
    "href": "docs/programming/go/basic/string.html#字符串拼接",
    "title": "go string",
    "section": "5 字符串拼接",
    "text": "5 字符串拼接\n\n\n\n\n\n\n思考\n\n\n\n前面在如何设计字符串中提到的如果多次拼接考虑性能,在字符串与字符切片的转换中提到的转换方法,我们不难想到一个高效拼接字符串的思路\n\n\n\n5.1 strings.Builder(推荐)\n\n\n\n\n\n\nTip\n\n\n\n推荐 事先看具体情况 Grow 一下\n\n\nfunc TestString6(t *testing.T) {\n    var builder strings.Builder\n    builder.WriteString(\"hello\")\n    res := builder.String()\n    fmt.Println(res)\n}\n\n\nstrings.Builder源码相关\n\ntype Builder struct {\n    addr *Builder\n    // 存放字符的切片, var builder strings.Builder 这个时候 切片的 cap ,len ,data 都是0\n    // WriteString 时,才会分配, 容量由 切片自己看情况扩容\n    // 基于这一点, 应该有 事先?就进行 字符切片容量分配的操作   ==&gt; Grow\n    buf  []byte\n}\nfunc (b *Builder) WriteString(s string) (int, error) {\n    b.copyCheck()\n    b.buf = append(b.buf, s...)\n    return len(s), nil\n}\nfunc (b *Builder) Grow(n int) {\n    b.copyCheck()\n    if n &lt; 0 {\n        panic(\"strings.Builder.Grow: negative count\")\n    }\n    if cap(b.buf)-len(b.buf) &lt; n {\n        b.grow(n)\n    }\n}\nfunc (b *Builder) grow(n int) {\n    buf := make([]byte, len(b.buf), 2*cap(b.buf)+n)\n    copy(buf, b.buf)\n    b.buf = buf\n}\n\nfunc (b *Builder) String() string {\n    return unsafe.String(unsafe.SliceData(b.buf), len(b.buf))\n}\n\n\n\n5.2 strings.Join\n\n\n\n\n\n\nTip\n\n\n\n底层原理是用的strings.builder\n\n\nfunc TestStringJoin(t *testing.T) {\n    baseSlice := []string{\"hello\", \"world\"}\n    s := strings.Join(baseSlice, \" \")\n    println(s)\n}",
    "crumbs": [
      "基础篇",
      "字符串"
    ]
  },
  {
    "objectID": "docs/programming/go/basic/string.html#其他操作",
    "href": "docs/programming/go/basic/string.html#其他操作",
    "title": "go string",
    "section": "6 其他操作",
    "text": "6 其他操作\n\n遍历字节长度转成utf-8字符数组截取\n\n\na := \"abc我们\"\nfor _, c := range a {\n    // 打印每个字符\n    fmt.Printf(\"%c\\n\", c)\n}\n\n\na := \"abc我们\"\nfmt.Println(len(a)) // 9 字节数\n\n\na := \"abc我们\"\ns := []rune(a) // 转成 utf-8字符 数组\nfmt.Println(s[0], s[1], s[2], string(s[3]), string(s[4]))\n\n\na := \"abc我们\"\n// 转成utf-8数组,切片后转成字符串\ns := string([]rune(a)[3:])\nfmt.Println(s) //我们",
    "crumbs": [
      "基础篇",
      "字符串"
    ]
  },
  {
    "objectID": "docs/programming/go/basic/string.html#字符集",
    "href": "docs/programming/go/basic/string.html#字符集",
    "title": "go string",
    "section": "7 字符集",
    "text": "7 字符集\n\n\n\n\n\n\nCaution\n\n\n\n有时间再详细写写\n\n\n\n\n\n\n\n\nCaution\n\n\n\n中英文混合的情况, 计算机是如何知道用一个字节或三个字节来区分是什么字符的呢? 是如何断字的?\n\n\n\n\n\n\n\n\nUTF-8的编码规则 go语言默认的编码方式\n\n\n\n\n1个字节的字符: 0xxxxxxx, 0开头表示一个字节的\n2个字节的字符: 110xxxxx 10xxxxxx\n\n110 开头表示2个字节的\n10开头表示一个字符的中间字节\n\n3个字节的字符: 1110xxxx 10xxxxxx 10xxxxxx\n4个字节的字符: 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n\n\n\nfunc TestString(t *testing.T) {\n    a := \"我\"\n    // 0xE6 1110  0110\n    // 0x88 10 001000\n    // 0x91 10 010001\n    fmt.Println(a[0], a[1], a[2])\n}\n\n\n\n\n\n\n结果\n\n\n\n我们将上面 “我” 汉字的每个字节的 “前缀” 去掉得到 0110 001000 010001 ==&gt; 01100010 00010001 =&gt; 0x6211 我的unicode 码就是 0x6211",
    "crumbs": [
      "基础篇",
      "字符串"
    ]
  },
  {
    "objectID": "docs/programming/go/concurrency/lock.html",
    "href": "docs/programming/go/concurrency/lock.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "Back to top"
  },
  {
    "objectID": "docs/programming/go/concurrency/context.html#background-todo",
    "href": "docs/programming/go/concurrency/context.html#background-todo",
    "title": "go context",
    "section": "1 Background & TODO",
    "text": "1 Background & TODO\nvar (\n    background = new(emptyCtx)\n    todo       = new(emptyCtx)\n)\n\n// Background returns a non-nil, empty Context. It is never canceled, has no\n// values, and has no deadline. It is typically used by the main function,\n// initialization, and tests, and as the top-level Context for incoming\n// requests.\n// 作为初始的ctx,是起点时使用这个来实例化,然后传递给后续的\nfunc Background() Context {\n    return background\n}\n\n// TODO returns a non-nil, empty Context. Code should use context.TODO when\n// it's unclear which Context to use or it is not yet available (because the\n// surrounding function has not yet been extended to accept a Context\n// parameter).\n// 不是起点时,然后你暂时不知道使用哪个context,代码里就暂时写上,\n// 把TODO作为方法 可以说其实就表明了之后逻辑弄完后,你应该再来看看具体是使用什么\nfunc TODO() Context {\n    return todo\n}",
    "crumbs": [
      "并发",
      "context"
    ]
  },
  {
    "objectID": "docs/programming/go/concurrency/context.html#withvalue",
    "href": "docs/programming/go/concurrency/context.html#withvalue",
    "title": "go context",
    "section": "2 WithValue",
    "text": "2 WithValue\npackage test\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"testing\"\n    \"time\"\n)\n\nfunc TestWithValue(t *testing.T) {\n    ctx := context.Background()\n    parent := context.WithValue(ctx, \"name\", \"tom\")\n    son := context.WithValue(parent, \"age\", \"11\")\n    fmt.Println(parent.Value(\"name\"))\n    fmt.Println(parent.Value(\"age\")) // nil 无法获取子ctx 设置的key\n    fmt.Println(son.Value(\"name\"))\n}\n// 我们一般是不会这么做的\nfunc TestWithValueMap(t *testing.T) {\n    ctx := context.Background()\n    parent := context.WithValue(ctx, \"m\", map[string]string{\"name\": \"tom\"})\n    m := parent.Value(\"m\").(map[string]string)\n    m[\"age\"] = \"11\"\n    son := context.WithValue(parent, \"m\", m)\n    fmt.Println(parent.Value(\"m\").(map[string]string)[\"name\"])\n    // 父 ctx 获取 子 ctx 设置的key\n    fmt.Println(parent.Value(\"m\").(map[string]string)[\"age\"])\n    fmt.Println(son.Value(\"m\").(map[string]string)[\"name\"])\n}",
    "crumbs": [
      "并发",
      "context"
    ]
  },
  {
    "objectID": "docs/programming/go/concurrency/context.html#withcancel",
    "href": "docs/programming/go/concurrency/context.html#withcancel",
    "title": "go context",
    "section": "3 WithCancel",
    "text": "3 WithCancel\n\n\n\n\n\n\nTip\n\n\n\n父ctx cancel或超时, 所有子孙ctx都会cancel或超时\n\n\npackage test\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"testing\"\n    \"time\"\n)\n\n// 前面timeout 可以说是到期会自动cancel\n// 这里是需要我们主动 cancel ,用来控制链路流程,比如控制子goroutine 退出\nfunc TestWithCancel(t *testing.T) {\n    ctx, cancel := context.WithCancel(context.Background())\n    go func(context.Context) {\n        go func(context.Context) {\n            c, cancelSon := context.WithCancel(ctx)\n            defer cancelSon()\n        Loop:\n            for {\n                select {\n                case &lt;-c.Done(): // 父ctx cancel 会导致子ctx 也cancel\n                    fmt.Println(\"gorouting2 is done\")\n                    // context canceled ,很明星, cancelSon() 是没执行的. 但是err 信息是\n                    fmt.Println(c.Err())\n                    break Loop\n                default:\n                }\n                fmt.Println(\"gorouting2 is running\")\n                time.Sleep(time.Second)\n            }\n        }(ctx)\n    Loop:\n        for {\n            select {\n            case &lt;-ctx.Done():\n                fmt.Println(\"gorouting1 is done\")\n                break Loop\n            default:\n            }\n            fmt.Println(\"gorouting1 is running\")\n            time.Sleep(time.Second)\n        }\n    }(ctx)\n\n    time.Sleep(3 * time.Second)\n    // 主动取消\n    cancel()\n    fmt.Println(\"cancel...\")\n    time.Sleep(3 * time.Second)\n}\n// A cancelCtx can be canceled. When canceled, it also cancels any children\n// that implement canceler.\ntype cancelCtx struct {\n    Context\n\n    mu       sync.Mutex            // protects following fields\n    done     atomic.Value          // of chan struct{}, created lazily, closed by first cancel call\n    children map[canceler]struct{} // set to nil by the first cancel call\n    err      error                 // set to non-nil by the first cancel call\n    cause    error                 // set to non-nil by the first cancel call\n}\n\nfunc withCancel(parent Context) *cancelCtx {\n    if parent == nil {\n        panic(\"cannot create context from nil parent\")\n    }\n    c := newCancelCtx(parent)\n    propagateCancel(parent, c)\n    return c\n}\n\nfunc newCancelCtx(parent Context) *cancelCtx {\n    return &cancelCtx{Context: parent}\n}\n\n// 父 cancel后, 将cancel 传递给子孙 (子孙也cancel)\nfunc propagateCancel(parent Context, child canceler) {\n    done := parent.Done()\n    if done == nil {\n        // WithValue 的done() 是nil\n        return\n    }\n\n    select {\n    case &lt;-done:\n        // 如果这个时候父 ctx cancel 了\n        // 则调用子孙的cancel, 将 父ctx的Err,以及谁引发的传递\n        child.cancel(false, parent.Err(), Cause(parent))\n        return\n    default: // 因为有default 所以如果 &lt;-done 没有数据,就会立马结束,走后面的代码\n    }\n\n    if p, ok := parentCancelCtx(parent); ok {\n        // 如果找到最近一个是cancelCtx 的祖先context\n        p.mu.Lock()\n        if p.err != nil {\n            // 再次判断\n            // 如果父ctx 这个时候cancel后, 那么直接cancel 子ctx\n            child.cancel(false, p.err, p.cause)\n        } else {\n            if p.children == nil {\n                p.children = make(map[canceler]struct{})\n            }\n            // 设置children ,子 ctx, 内容是 空结构体省内存\n            // 后面我们只需要key ctx 就行\n            // 后续 父cancel时,需要cancel 所有children 用到\n            p.children[child] = struct{}{}\n        }\n        p.mu.Unlock()\n    } else {\n        // \n        goroutines.Add(1)\n        go func() {\n            select {\n            case &lt;-parent.Done(): // \n                child.cancel(false, parent.Err(), Cause(parent))\n            case &lt;-child.Done(): // 关心自己\n            }\n        }()\n    }\n}\nfor child := range c.children {\n    child.cancel(false, err, cause)\n}\n// 如果parent是cancelCtx,则返回parent ctx的指针\n// 如果不是cancelCtx (比如WithValue 返回的ctx),则继续往前找,找到最近的祖先cancelCtx\nfunc parentCancelCtx(parent Context) (*cancelCtx, bool) {\n    done := parent.Done()\n    if done == closedchan || done == nil {\n        return nil, false\n    }\n    p, ok := parent.Value(&cancelCtxKey).(*cancelCtx)\n    if !ok {\n        return nil, false\n    }\n    pdone, _ := p.done.Load().(chan struct{})\n    if pdone != done {\n        return nil, false\n    }\n    return p, true\n}\nfunc (c *valueCtx) Value(key any) any {\n    if c.key == key {\n        return c.val\n    }\n    return value(c.Context, key)\n}\nfunc (c *cancelCtx) Value(key any) any {\n    if key == &cancelCtxKey {\n        return c\n    }\n    return value(c.Context, key)\n}",
    "crumbs": [
      "并发",
      "context"
    ]
  },
  {
    "objectID": "docs/programming/go/concurrency/context.html#withdeadlinetimeout",
    "href": "docs/programming/go/concurrency/context.html#withdeadlinetimeout",
    "title": "go context",
    "section": "4 WithDeadline/Timeout",
    "text": "4 WithDeadline/Timeout\n// A timerCtx carries a timer and a deadline. It embeds a cancelCtx to\n// implement Done and Err. It implements cancel by stopping its timer then\n// delegating to cancelCtx.cancel.\ntype timerCtx struct {\n    *cancelCtx\n    timer *time.Timer // Under cancelCtx.mu.\n\n    deadline time.Time\n}\n\n// WithTimeout 里面直接调用了 WithDeadline , 和它没啥区别\nfunc WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc) {\n    return WithDeadline(parent, time.Now().Add(timeout))\n}\n\nfunc WithDeadline(parent Context, d time.Time) (Context, CancelFunc) {\n    if parent == nil {\n        panic(\"cannot create context from nil parent\")\n    }\n    if cur, ok := parent.Deadline(); ok && cur.Before(d) {\n        // The current deadline is already sooner than the new one.\n        return WithCancel(parent)\n    }\n    c := &timerCtx{\n        cancelCtx: newCancelCtx(parent),\n        deadline:  d,\n    }\n    propagateCancel(parent, c)\n    dur := time.Until(d)\n    if dur &lt;= 0 {\n        c.cancel(true, DeadlineExceeded, nil) // deadline has already passed\n        return c, func() { c.cancel(false, Canceled, nil) }\n    }\n    c.mu.Lock()\n    defer c.mu.Unlock()\n    if c.err == nil {\n        c.timer = time.AfterFunc(dur, func() {\n            c.cancel(true, DeadlineExceeded, nil)\n        })\n    }\n    return c, func() { c.cancel(true, Canceled, nil) }\n}\npackage test\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"testing\"\n    \"time\"\n)\nfunc TestWithTimeout(t *testing.T) {\n    ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)\n    defer cancel()\n    dl, isSetDl := ctx.Deadline()\n    fmt.Printf(\"预计的过期时间: %s \\n是否设置了过期时间:%t\\n\", dl, isSetDl) // 预计的过期时间\n    _, isSetDl2 := context.Background().Deadline()\n    fmt.Println(isSetDl2) // false\n    now := time.Now()\n    go func() {\n        // 到期后, Done() 管道会有数据\n        &lt;-ctx.Done()\n        // 到期的情况时 错误信息\n        fmt.Println(\"err\", ctx.Err()) // err context deadline exceeded\n        fmt.Println(\"经过\", time.Since(now), time.Now())\n\n    }()\n\n    time.Sleep(4 * time.Second)\n}\n\nfunc TestWithTimeout2(t *testing.T) {\n    ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)\n    defer cancel()\n    // 超时 设置无效的,父ctx超时了, 子孙也超时了.\n    s, c := context.WithTimeout(ctx, 5*time.Second)\n    defer c()\n    go func() {\n        &lt;-s.Done()\n        fmt.Println(\"s:\", s.Err())\n    }()\n    go func() {\n        // 到期后, Done() 管道会有数据\n        &lt;-ctx.Done()\n        // 到期的情况时 错误信息\n        fmt.Println(\"err\", ctx.Err()) // err context deadline exceeded\n\n    }()\n\n    time.Sleep(7 * time.Second)\n}\nfunc TestWithTimeoutCancel(t *testing.T) {\n    ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)\n    now := time.Now()\n    go func() {\n        // 主动执行cancel()后, Done() 管道会有数据\n        &lt;-ctx.Done()\n        err := ctx.Err()\n        fmt.Println(\"err\", err) // err context canceled\n        switch err {\n        // 判断错误类型\n        case context.Canceled:\n        case context.DeadlineExceeded:\n        }\n        fmt.Println(\"经过\", time.Since(now))\n    }()\n\n    time.Sleep(1 * time.Second)\n    cancel()\n    time.Sleep(3 * time.Second)\n}\nfunc TestWithDeadline(t *testing.T) {\n    ctx, cancel := context.WithDeadline(context.Background(), time.Now().Add(3*time.Second))\n    defer cancel()\n    fmt.Println(ctx)\n}",
    "crumbs": [
      "并发",
      "context"
    ]
  },
  {
    "objectID": "docs/programming/go/infrastructure/clean-code.html",
    "href": "docs/programming/go/infrastructure/clean-code.html",
    "title": "golang 编码规范",
    "section": "",
    "text": "待整理…",
    "crumbs": [
      "工程设计",
      "编码规范"
    ]
  },
  {
    "objectID": "docs/programming/go/infrastructure/clean-code.html#注释",
    "href": "docs/programming/go/infrastructure/clean-code.html#注释",
    "title": "golang 编码规范",
    "section": "1 注释",
    "text": "1 注释\n对象声明的注释应该是完整的句子,即使这看起来有点多余. 当提取到doc文档中时,这种方式可以使它们格式化良好. 注释应以所描述事物的名称开头,并以句点结尾\n// Request represents a request to run a command.\ntype Request struct { ...\n\n// Encode writes the JSON encoding of req to w.\nfunc Encode(w io.Writer, req *Request) { ...",
    "crumbs": [
      "工程设计",
      "编码规范"
    ]
  },
  {
    "objectID": "docs/programming/go/infrastructure/clean-code.html#context",
    "href": "docs/programming/go/infrastructure/clean-code.html#context",
    "title": "golang 编码规范",
    "section": "2 Context",
    "text": "2 Context\n\n\n\n\n\n\nWarning\n\n\n\n大多数使用Context的函数都应将其作为第一个参数 不要将Context成员添加到结构类型, 应该将ctx参数添加到该类型需要传递的每个方法上\n\n\nfunc F(ctx context.Context, /* other arguments */) {}",
    "crumbs": [
      "工程设计",
      "编码规范"
    ]
  },
  {
    "objectID": "docs/programming/go/infrastructure/clean-code.html#crypto-rand",
    "href": "docs/programming/go/infrastructure/clean-code.html#crypto-rand",
    "title": "golang 编码规范",
    "section": "3 Crypto Rand",
    "text": "3 Crypto Rand\n不要使用软件包 math/rand 生成密钥，即使是一次性密钥也是如此。 在没有种子情况下，生成器是完全可预测的。 将time.Nanoseconds()的作为随机生成器的种子，只有几熵（应该是消耗很少的意思）。 相反，请使用 crypto/rand’s Reader，如果需要文本，请打印为十六进制或base64\nimport (\n    \"crypto/rand\"\n    // \"encoding/base64\"\n    // \"encoding/hex\"\n    \"fmt\"\n)\n\nfunc Key() string {\n    buf := make([]byte, 16)\n    _, err := rand.Read(buf)\n    if err != nil {\n        panic(err)  // out of randomness, should never happen\n    }\n    return fmt.Sprintf(\"%x\", buf)\n    // or hex.EncodeToString(buf)\n    // or base64.StdEncoding.EncodeToString(buf)\n}",
    "crumbs": [
      "工程设计",
      "编码规范"
    ]
  },
  {
    "objectID": "docs/programming/go/infrastructure/clean-code.html#声明空切片",
    "href": "docs/programming/go/infrastructure/clean-code.html#声明空切片",
    "title": "golang 编码规范",
    "section": "4 声明空切片",
    "text": "4 声明空切片\n声明空切片时，首选\nvar t []string \n其次\nt := []string{}\n前者声明nil slice值，而后者声明非nil但长度为零。 它们在功能上等同，他们 len和 cap均为零，而零切片是首选的风格。",
    "crumbs": [
      "工程设计",
      "编码规范"
    ]
  },
  {
    "objectID": "docs/programming/go/infrastructure/clean-code.html#错误字符串",
    "href": "docs/programming/go/infrastructure/clean-code.html#错误字符串",
    "title": "golang 编码规范",
    "section": "5 错误字符串",
    "text": "5 错误字符串\n错误字符串不应大写（除非以专有名词或缩写开头）或标点符号结束，因为它们通常是在其他上下文之后打印的。 也就是说，请使用 fmt.Errorf(“something bad”)，不要使用 fmt.Errorf(“Something bad”)，这样 log.Printf(“Reading %s: %v”, filename, err)格式就不会出现虚假的大写字母中间消息。 这不适用于日志记录，后者是隐式面向行的，并且未在其他消息中合并。",
    "crumbs": [
      "工程设计",
      "编码规范"
    ]
  },
  {
    "objectID": "docs/programming/go/infrastructure/clean-code.html#goroutine生命周期",
    "href": "docs/programming/go/infrastructure/clean-code.html#goroutine生命周期",
    "title": "golang 编码规范",
    "section": "6 Goroutine生命周期",
    "text": "6 Goroutine生命周期\n当您生成goroutine时，请清楚何时或是否退出。 Goroutine可以通过阻塞通道的发送或接收来泄漏：即使goroutine的阻塞通道不可访问，垃圾收集器也不会终止goroutine。 即使goroutine不会泄漏，在不再需要它们时仍在飞行中也会导致其他细微且难以诊断的问题。 在关闭的通道上发送紧急消息。 “在不需要结果之后”修改仍在使用的输入仍然会导致数据争用。 将goroutine进行任意长时间的飞行可能会导致不可预测的内存使用情况。 尝试使并发代码足够简单，以使goroutine生存期显而易见。 如果那不可行，请记录goroutine何时以及为何退出。 ## Imports 除避免名称冲突外，避免重命名导入； 好的软件包名称不需要重命名。 发生名称冲突时，最好重命名本地的或特定于项目的导入。 导入包是按组组织排序的，组之间有空白行。标准库软件包始终在第一组中\ngo imports 将为您做到这一点\n\n6.1 Import Blank\n仅出于辅助作用而导入的软件包（使用语法import _“pkg”）应仅在程序的主软件包或需要它们的测试中导入。 ### Import . 由于循环依赖关系，导入 . 形式不能用于要测试的程序包，因此在测试中很有用\npackage foo_test\n\nimport (\n    \"bar/testutil\" // also imports \"foo\"\n    . \"foo\"\n)",
    "crumbs": [
      "工程设计",
      "编码规范"
    ]
  },
  {
    "objectID": "docs/programming/go/infrastructure/clean-code.html#in-band-errors",
    "href": "docs/programming/go/infrastructure/clean-code.html#in-band-errors",
    "title": "golang 编码规范",
    "section": "7 In-Band Errors",
    "text": "7 In-Band Errors\n在C和类似语言中，函数通常返回-1这样的值或null来表示错误或没有结果\n// Lookup returns the value for key or \"\" if there is no mapping for key.\nfunc Lookup(key string) string\n\n// Failing to check a for an in-band error value can lead to bugs:\nParse(Lookup(key))  // returns \"parse failure for value\" instead of \"no value for key\"\nGo对多个返回值的支持提供了更好的解决方案。 函数应该返回一个附加值以指示其其他返回值是否有效，而不是要求客户端检查带内错误值。 该返回值可以是错误，也可以是布尔值（不需要说明时）。 它应该是最终的返回值\n// Lookup returns the value for key or ok=false if there is no mapping for key.\nfunc Lookup(key string) (value string, ok bool)\n鼓励使用更健壮和易读的代码：\nvalue, ok := Lookup(key)\nif !ok {\n    return fmt.Errorf(\"no value for %q\", key)\n}\nreturn Parse(value)",
    "crumbs": [
      "工程设计",
      "编码规范"
    ]
  },
  {
    "objectID": "docs/programming/go/infrastructure/clean-code.html#缩进错误流",
    "href": "docs/programming/go/infrastructure/clean-code.html#缩进错误流",
    "title": "golang 编码规范",
    "section": "8 缩进错误流",
    "text": "8 缩进错误流\n尝试使普通代码路径保持最小缩进，并缩进错误处理，并首先对其进行处理。 通过允许在视觉上快速扫描正常路径，可以提高代码的可读性。 例如，不要写\nif err != nil {\n    // error handling\n} else {\n    // normal code\n}\n应该写：\nif err != nil {\n    // error handling\n    return // or continue, etc.\n}\n// normal code\n如果该 if语句具有初始化语句，例如：\nif x, err := f(); err != nil {\n    // error handling\n    return\n} else {\n    // use x\n}\n那么这可能需要将short变量声明移至其自己的行： ==这样的目的是让业务代码能够直接清晰的看到==\nx, err := f()\nif err != nil {\n    // error handling\n    return\n}\n// use x",
    "crumbs": [
      "工程设计",
      "编码规范"
    ]
  },
  {
    "objectID": "docs/programming/go/infrastructure/clean-code.html#首字母缩写",
    "href": "docs/programming/go/infrastructure/clean-code.html#首字母缩写",
    "title": "golang 编码规范",
    "section": "9 首字母缩写",
    "text": "9 首字母缩写\n名称中的缩写词或首字母缩写词（例如“ URL”或“ NATO”）具有一致的大小写。 例如，“ URL”应显示为“ URL”或“ url”（如在“ urlPony”或“ URLPony”中一样），而从不显示为“ Url”。 例如：ServeHTTP而不是ServeHttp。 对于具有多个已初始化“单词”的标识符，请使用“ xmlHTTPRequest”或“ XMLHTTPRequest”。 当“ ID”是“ identifier”的缩写时，该规则也适用于“ ID”（这在几乎所有情况下都不是“ ego”，“ superego”中的“ id”），因此请写上“ appID”而不是“ appId”。 协议缓冲区编译器生成的代码不受此规则约束。 人工编写的代码要比机器编写的代码具有更高的标准。",
    "crumbs": [
      "工程设计",
      "编码规范"
    ]
  },
  {
    "objectID": "docs/programming/go/infrastructure/clean-code.html#接口interfaces",
    "href": "docs/programming/go/infrastructure/clean-code.html#接口interfaces",
    "title": "golang 编码规范",
    "section": "10 接口（Interfaces）",
    "text": "10 接口（Interfaces）\nGo接口通常属于使用接口类型的值的包中，而不是实现这些值的包中。 实现包应返回具体的（通常是指针或结构）类型：这样，可以将新方法添加到实现中，而无需进行大量重构。 不要在“用于模拟”的API的实现方定义接口； 而是设计API，以便可以使用实际实现的公共API对其进行测试。 在使用接口之前，不要先定义它们：如果没有实际的用法示例，很难知道接口是否是必需的，更不用说它应该包含什么方法了。 ### 接口命名 根据命名规则，一种方法的接口，需要在名称后面加上 -er 的后缀，或者通过代理名词的方式来进行修饰：Reader, Writer,Formatter,CloseNotifier 等\n这里最麻烦的是，你的一个接口有多个方法的时候，按照这个方式命名，就不总是很清晰明了。那是否要把结构拆分，变成一个接口对应一个方法呢？我觉得这个取决具体的使用场景了。 接口我的理解: 按理解来说应该名字倾向于一种功能的名字, 当然也可以是一种东西的名字. 一种类型一样的感觉\n\n命名规则基本和上面的结构体类型\n单个函数的结构名以 “er” 作为后缀，例如 Reader , Writer\n\ntype Reader interface {\n        Read(p []byte) (n int, err error)\n}\n\n两个函数的接口名综合两个函数名\n\ntype WriteFlusher interface {\n    Write([]byte) (int, error)\n    Flush() error\n}\n\n三个以上函数的接口名，类似于结构体名\n\ntype Car interface {\n    Start([]byte) \n    Stop() error\n    Recover()\n}",
    "crumbs": [
      "工程设计",
      "编码规范"
    ]
  },
  {
    "objectID": "docs/programming/go/infrastructure/clean-code.html#bool-类型变量命名",
    "href": "docs/programming/go/infrastructure/clean-code.html#bool-类型变量命名",
    "title": "golang 编码规范",
    "section": "11 bool 类型变量命名",
    "text": "11 bool 类型变量命名\n名称应以 Has, Is, Can 或 Allow 开头\nvar isExist bool\nvar hasConflict bool\nvar canManage bool\nvar allowGitHook bool",
    "crumbs": [
      "工程设计",
      "编码规范"
    ]
  },
  {
    "objectID": "docs/programming/go/infrastructure/clean-code.html#常量命名",
    "href": "docs/programming/go/infrastructure/clean-code.html#常量命名",
    "title": "golang 编码规范",
    "section": "12 常量命名",
    "text": "12 常量命名\n常量均需使用全部大写字母组成，并使用下划线分词\nconst APP_VER = \"1.0\"",
    "crumbs": [
      "工程设计",
      "编码规范"
    ]
  },
  {
    "objectID": "docs/programming/go/infrastructure/clean-code.html#行长度",
    "href": "docs/programming/go/infrastructure/clean-code.html#行长度",
    "title": "golang 编码规范",
    "section": "13 行长度",
    "text": "13 行长度\nGo代码中没有严格的行长度限制，但要避免行太长。 同样，请勿添加换行符以使行在可读性更强的情况下保持较短（例如，如果它们是重复的）。 在大多数情况下，人们“不自然地”换行（在函数调用或函数声明的中间，或多或少，例如，尽管周围有一些例外情况），如果参数和简短的变量名数量合理，则不需要换行。长行似乎包含长名，而摆脱长名会很有帮助。 换句话说，换行是因为您所写内容的语义（作为一般规则），而不是因为行长。 如果发现行太长，则更改名称或语义，可能会得到不错的结果。 实际上，这和关于功能应该写多长的建议是完全相同的。 没有强制的规则“一个函数的长度不能超过N行”，但是肯定存在这样一个问题，即函数太长或者小函数过于频繁，解决方案是重新划分函数的功能，而不是开始数行数。 ## Named Result Parameters (命名返回值参数)\n考虑一下godoc中的表现。命名结果参数如下：\nfunc (n *Node) Parent1() (node *Node) {}\nfunc (n *Node) Parent2() (node *Node, err error) {}\n会在godoc中显得繁杂；更好的表现如下：\nfunc (n *Node) Parent1() *Node {}\nfunc (n *Node) Parent2() (*Node, error) {}\n\n例外 另一方面，在某些情况下,如果函数返回两个或三个相同类型的参数， 或者如果从上下文中不清楚结果的含义，则添加名称可能很有用。不要仅仅为了避免在内部声明var而命名结果参数; 这就以不必要的API冗长为代价，牺牲了实现的简短性。\n\nfunc (f *Foo) Location() (float64, float64, error)\n\n// 不如用下面的好点\n// Location returns f's latitude and longitude.\n// Negative values mean south and west, respectively.\nfunc (f *Foo) Location() (lat, long float64, err error)\n如果函数只有几行，则可以使用裸返回。 一旦成为通用的函数，请明确说明您的返回值。 结论：为了使您可以使用裸返回而命名结果参数是不值得的。文档的清晰性始终比在函数中保存一两行更为重要",
    "crumbs": [
      "工程设计",
      "编码规范"
    ]
  },
  {
    "objectID": "docs/programming/go/infrastructure/clean-code.html#包注释",
    "href": "docs/programming/go/infrastructure/clean-code.html#包注释",
    "title": "golang 编码规范",
    "section": "14 包注释",
    "text": "14 包注释\n像godoc提出的所有注释一样，包注释必须出现在package子句的旁边，且不能有空行\n// Package math provides basic constants and mathematical functions.\npackage math\n\n/*\nPackage template implements data-driven templates for generating textual\noutput such as HTML.\n....\n*/\npackage template\n对于“ package main”注释，在二进制名称之后可以使用其他样式的注释（如果使用二进制格式，则可以大写），例如，对于在seedgen包中的package main包，您可以编写\n// Binary seedgen ...\npackage main\n\n// Command seedgen ...\npackage main\n\n// Program seedgen ...\npackage main\n\n// The seedgen program ...\npackage main\n\n\n// 都是可以的\n这些示例，以及这些的明智的变体是可以接受的。 请注意，包注释以小写单词开头的句子是不可可接受的，因为它们是公开可见的 应该用适当的英语写成，包括首字母大写的句子。当二进制名称是第一个单词时，将其大写即使它与拼写不完全匹配命令行调用也是必需的 ## 包名 您对包中所有名称的引用都将使用包名完成，因此您可以从标识符中省略该名称。例如，如果您在庞大的包中，您不需要输入ChubbyFile，客户端将其输入为 chubby.ChubbyFile。 而是命名类型 File，客户端将其写为 chubby.File。 避免使用无意义的程序包名称，例如util，common，misc，api，types 和interfaces。 请参阅 http://golang.org/doc/effective_go.html#package-names 和 http://blog.golang.org/package-names 以获得更多信息。\n保持package的名字和目录保持一致，尽量采取有意义的包名，简短，有意义，尽量和标准库不要冲突。包名应该为小写单词，不要使用下划线或者混合大小写 ## 文件命名 尽量采取有意义的文件名，简短，有意义，应该为小写单词，使用下划线分隔各个单词 ## 结构体命名\n\n采用驼峰命名法，首字母根据访问控制大写或者小写 ## 传递值 不要为了节省一些字节，将指针作为函数参数传递。 如果函数整个过程中都将 x 仅作为 x 使用，则自变量不应是指针。常见的实例包括传递指向字符串（ string的指针 ）或指向接口值的指针（ *io.Reader）。在这两种情况下，值本身都是固定大小，可以直接传递。这个建议不适用于大型结构，甚至不适用于可能增长的小型结构。",
    "crumbs": [
      "工程设计",
      "编码规范"
    ]
  },
  {
    "objectID": "docs/programming/go/infrastructure/clean-code.html#方法接收者命名",
    "href": "docs/programming/go/infrastructure/clean-code.html#方法接收者命名",
    "title": "golang 编码规范",
    "section": "15 方法接收者命名",
    "text": "15 方法接收者命名\n方法的接收者的名称应反映其身份。 通常，其类型的一个或两个字母缩写就足够了（例如，“客户”是“ c”或“ cl”）。 不要使用通用名称，例如“ me”，“ this”或“ self”，这是面向对象语言的典型标识符，这些标识符赋予该方法特殊的含义。 在Go中，方法的接收者只是另一个参数，因此应相应地命名。 该名称不必像方法参数那样具有描述性，因为它的作用是显而易见的，没有任何文档目的。 它可能很短，因为它将出现在该类型的每种方法的几乎每一行上；熟悉承认简洁。也要保持一致：如果在一种方法中将接收器称为“ c”，则在另一种方法中请勿将其称为“ cl”。\n\n使用一个字母或2个字母即可\n\ntype T struct{} \n    \nfunc (t *T)Get(){}",
    "crumbs": [
      "工程设计",
      "编码规范"
    ]
  },
  {
    "objectID": "docs/programming/go/infrastructure/clean-code.html#方法接收者类型",
    "href": "docs/programming/go/infrastructure/clean-code.html#方法接收者类型",
    "title": "golang 编码规范",
    "section": "16 方法接收者类型",
    "text": "16 方法接收者类型\n对于go初学者，接受者的类型如果不清楚，统一采用指针型\nfunc (t *T)Get(){}\n选择在方法上使用值接收器还是指针接收器可能很困难，特别是对于新的Go程序员而言。 如果有疑问，请使用指针，但是有时出于效率的原因（例如，小的不变结构或基本类型的值），值接收器才有意义。 一些有用的准则：\n\n如果接收方是map，func或channel，请不要使用指向它们的指针。 如果接收方是切片，并且该方法未重新切片或重新分配切片，请不要使用指向该切片的指针。\n\npackage main\n\nimport (\n    \"fmt\"\n)\n\ntype mp map[string]string\n\nfunc (m mp) Set(k, v string) {\n    m[k] = v\n}\n\nfunc main() {\n    m := make(mp)\n    m.Set(\"k\", \"v\")\n    fmt.Println(m)\n}\n//Channel\npackage main\n\nimport (\n    \"fmt\"\n)\n\ntype ch chan interface{}\n\nfunc (c ch) Push(i interface{}) {\n    c &lt;- i\n}\n\nfunc (c ch) Pop() interface{} {\n    return &lt;-c\n}\n\nfunc main() {\n    c := make(ch, 1)\n    c.Push(\"i\")\n    fmt.Println(c.Pop())\n}\n\n如果需要对slice进行修改，通过返回值的方式重新赋值\n\n//Slice\npackage main\n\nimport (\n    \"fmt\"\n)\n\ntype slice []byte\n\nfunc main() {\n    s := make(slice, 0)\n    s = s.addOne(42)\n    fmt.Println(s)\n}\n\nfunc (s slice) addOne(b byte) []byte {\n    return append(s, b)\n}\n\n如果该方法需要更改接收者，则接收者必须是指针。\n如果接收者是包含sync.Mutex或类似同步字段的结构，则接收者必须是一个指针以避免复制。\n\npackage main\n\nimport (\n    \"sync\"\n)\n\ntype T struct {\n    m sync.Mutex\n}\n\nfunc (t *T) lock() {\n    t.m.Lock()\n}\n\n如果接收者是大型结构或数组，则指针接收者效率更高。多大是大型？假设这等效于将其所有元素作为参数传递给方法。如果感觉太大，则对于接收者来说也太大。\n\n如果接收者是大的结构体或者数组，使用指针传递会更有效率\n\npackage main\n\nimport (\n    \"fmt\"\n)\n\ntype T struct {\n    data [1024]byte\n}\n\nfunc (t *T) Get() byte {\n    return t.data[0]\n}\n\nfunc main() {\n    t := new(T)\n    fmt.Println(t.Get())\n}\n\n函数或方法（同时执行或从该方法调用时）是否会使接收者发生变化？ 值类型在调用方法时创建接收者的副本，因此外部更新将不会应用于该接收者。 如果更改必须在原始接收者中可见，则接收者必须是指针。\n如果接收者是结构体，数组或切片，并且其任何元素都是指向可能正在修改的对象的指针，则最好使用指针接收者，因为它会使读者更加清楚意图。\n如果接收者是一个很小的数组或结构，自然是一个值类型（例如，诸如time.Time类型），没有可变字段且没有指针，或者仅仅是一个简单的基本类型（如int或string），值接收者是合理的。 值接收者可以减少可以生成的垃圾数量； 如果将值传递给值方法，则可以使用堆栈上的副本而不是在堆上分配。 （编译器会尽量避免这种分配，但是它不可能总是成功。）由于这个原因，请勿在没有进行概要分析的情况下选择值类型接收者。\n最后，如有疑问，请使用指针接收者。 ## 变量名 Go中的变量名应该简短而不是冗长。 对于范围有限的局部变量尤其如此。 比起 lineCount 更倾向于 c。比起 sliceIndex 更倾向于 i。",
    "crumbs": [
      "工程设计",
      "编码规范"
    ]
  },
  {
    "objectID": "docs/programming/go/infrastructure/clean-code.html#代码分析",
    "href": "docs/programming/go/infrastructure/clean-code.html#代码分析",
    "title": "golang 编码规范",
    "section": "17 代码分析",
    "text": "17 代码分析\n\n静态分析我们的源码存在的各种问题，例如多余的代码，提前return的逻辑，struct的tag是否符合标准等。\n\ngo vet .",
    "crumbs": [
      "工程设计",
      "编码规范"
    ]
  },
  {
    "objectID": "docs/programming/go/infrastructure/semver.html",
    "href": "docs/programming/go/infrastructure/semver.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "语义化版本号管理"
  },
  {
    "objectID": "docs/programming/go/infrastructure/semver.html#version",
    "href": "docs/programming/go/infrastructure/semver.html#version",
    "title": "斯巴拉稀",
    "section": "",
    "text": "语义化版本号管理"
  },
  {
    "objectID": "docs/programming/go/infrastructure/semver.html#commit-message",
    "href": "docs/programming/go/infrastructure/semver.html#commit-message",
    "title": "斯巴拉稀",
    "section": "2 commit message",
    "text": "2 commit message\nangular commit"
  },
  {
    "objectID": "docs/programming/go/infrastructure/test.html",
    "href": "docs/programming/go/infrastructure/test.html",
    "title": "go test",
    "section": "",
    "text": "\"go.testFlags\": [\n   \"-v\",\n   \"-gcflags=-l\",\n],",
    "crumbs": [
      "工程设计",
      "测试"
    ]
  },
  {
    "objectID": "docs/programming/go/infrastructure/test.html#vscode-golang-相关配置",
    "href": "docs/programming/go/infrastructure/test.html#vscode-golang-相关配置",
    "title": "go test",
    "section": "",
    "text": "\"go.testFlags\": [\n   \"-v\",\n   \"-gcflags=-l\",\n],",
    "crumbs": [
      "工程设计",
      "测试"
    ]
  },
  {
    "objectID": "docs/programming/go/infrastructure/test.html#代码",
    "href": "docs/programming/go/infrastructure/test.html#代码",
    "title": "go test",
    "section": "2 代码",
    "text": "2 代码\n\n\none_test.go 文件名必须以 _test 结尾\n\npackage test\n\nimport (\n    \"fmt\"\n    \"testing\"\n)\n// 函数名必须Test 开头\nfunc TestOne(t *testing.T) {\n    fmt.Println(1 == 1)\n}\n\n点击vscode 上看到的 run test 或 打断点后点击debug test 或者使用命令\n# -v 显示打印信息\ngo test -v # 执行当前目录下所有的 _test测试文件\ngo test -v target_dir/* # 指定目录\ngo test -v one_test.go # 指定文件\n# 执行指定测试方法\ngo test -v -run TestOne one_test.go",
    "crumbs": [
      "工程设计",
      "测试"
    ]
  },
  {
    "objectID": "docs/programming/go/pkg/gorm.html",
    "href": "docs/programming/go/pkg/gorm.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "待整理"
  },
  {
    "objectID": "docs/programming/go/pkg/gorm.html#关联关系",
    "href": "docs/programming/go/pkg/gorm.html#关联关系",
    "title": "斯巴拉稀",
    "section": "1 关联关系",
    "text": "1 关联关系\n\n1.1 属于\n\nuser 属于某个profile, profile表没有user的任何信息 可以说 一个profile 可以让多个user 使用, 所以使用这种方式来设计表 后面可以看看 包含关系的理解\n\n\nForeignKey AssociationForeignKey如何填 如下为例 我们要得到Profile ,肯定是根据某个字段 关联到Profile表才行 这个关联的字段就是 ForeignKey,外键,这个值不是随便插入的,是另外一个表的数据 不管是包含还是属于,思考一下,我要得到这个 profile 是根据哪个字段 就写哪个 这个字段可能在 User表 也可能在Profile表(不同的关系,在不同的表) 而AssociationForeignKey 填的 就是你写的外键是与哪个字段 进行关联的,一般可能是主键\n\ntype MyUser struct {\n    gorm.Model\n    // 在属于关系中,ForeignKey 表示 当前User表中 ProfileID 属于外键\n    // 就是说该值不是随便插入到user表的, 他的值 来自于 Profile表的 某个字段,这样2个表就将建立了关系了\n    //AssociationForeignKey 这个就是来指定 是来自于哪个字段的,\n    Profile   Profile `gorm:\"ForeignKey:ProfileID;AssociationForeignKey:ID\"`\n    ProfileID int\n}\n\ntype MyProfile struct {\n    gorm.Model\n    Name string\n}\nctx = context.Background()\ndb, err:= gorm.Open(\"mysql\", \"root:@tcp(127.0.0.1:3306)/hx?charset=utf8&parseTime=True&loc=Local\")\nfmt.Println(err)\ndb.LogMode(true)\ndefer db.Close()\ndb.Set(\"gorm:table_options\", \"ENGINE=InnoDB\").AutoMigrate(&User{},&Profile{})\n\n\np:=MyProfile{}\nu:=MyUser{}\ndb.First(&u)\n// 下面这个会报错的, 查看Related的源码, 能发现问题\n// 如果我们的模型名字和外键名字不这样起的话,就不会有问题\ndb.Model(&u).Related(&p)\n// 正确的方式需要 指定外键 或者 是  MyProfile (MyUser模型的属性) \ndb.Model(&u).Related(&p,\"ProfileID\")\n// 也可以这样\ndb.Model(&u).Related(&u.MyProfile,\"ProfileID\")\n\n// 一步走到位\n// u.MyProfile 也有了\n// 先查询my_users 表, 得到profile_id,然后去查询my_profiles 表\ndb.Model(&u).Preload(\"MyProfile\").First(&u)\n\n\n1.2 包含一个\n// User 包含一个 CreditCard, UserID 为外键\ntype User struct {\n    gorm.Model\n    CreditCard   CreditCard\n}\n\ntype CreditCard struct {\n    gorm.Model\n    UserID   uint\n    Number   string\n}\n\nvar card CreditCard\ndb.Model(&user).Related(&card, \"CreditCard\")\n//// SELECT * FROM credit_cards WHERE user_id = 123; // 123 is user's primary key\n// CreditCard是user的字段名称，这意味着获得user的CreditCard关系并将其填充到变量\n// 如果字段名与变量的类型名相同，如上例所示，可以省略，如：\ndb.Model(&user).Related(&card)\n\n指定外键和关联外键\n\n// 这个例子中 ,与之前的属于,做个对比\n// 我们可以看出从  数据库设计上, 一个User是可以有多个Profile的\n// 只不过这里User模型 的Profile 属性 类型是单一对象, 表示 只有一个profile,\n// 如果是包含多个, 就用 []Profile 就行了\ntype Profile struct {\n  gorm.Model\n  Name   string\n  UserID uint\n}\n\ntype User struct {\n  gorm.Model\n  Refer   string\n  // User得到Profile 是根据 Profile表的UserID外键, \n  // 该外键是 与 User表的 Refer 字段关联的,就是说外键的值来自于 Refer,默认不写的话是ID\n  Profile Profile `gorm:\"ForeignKey:UserID;AssociationForeignKey:Refer\"`\n}\n\n// 另外一个例子\ntype MyUser struct {\n    gorm.Model\n    Ids int64\n    MyProfile   MyProfile   `gorm:\"ForeignKey:ProfileID;AssociationForeignKey:ID\"` \n    ProfileID int\n    Name string\n    // 同理\n    Email Email `gorm:\"ForeignKey:UserID;AssociationForeignKey:IDs\"`\n}\ntype Email struct{\n    UserID int64\n    gorm.Model\n    Em string\n}\ntype MyProfile struct {\n    gorm.Model\n    Height int64\n    Name string\n    T int64\n}\n\n\n1.3 包含多个\n// User 包含多个 emails, UserID 为外键\ntype User struct {\n    gorm.Model\n    Emails   []Email\n}\n\ntype Email struct {\n    gorm.Model\n    Email   string\n    UserID  uint\n}\n\ndb.Model(&user).Related(&emails)\n\n\n1.4 通过主键(或者其他字段)判断如果有记录则更新,否则创建新的记录\n\n不会使用你传递的主键的\n\nr := Reviewer{}\n    // b := Reviewer{Name: \"yy\"}\n    // id是主键, 在 assign里不要添加 id ,否则会修改的\n    // 这里的意思即使 找id=1的记录,如果有则更新,否则创建\n    // 如果assign 参数使用的 是 对象 ,则里面如果有的值是0 或者false,是不执行的\n    // 而使用map则可以. 因为0,false 可能是默认值,处理上 不去执行了\n    err = db.Model(&r).Where(\"id=1\").Assign(map[string]interface{}{\n        \"name\": \"ioioxx\",\n    }).FirstOrCreate(&r).Error\n\n注意实际上上面的用法 一般用在一定要先判断是否存在的那种需求,而且查询的条件不是id 像上面的 用 判断id是否==0 =0则创建,!=0 则修改  会更好, 不用每次都查询 如果是判断表里是否有title为xx的记录,没有则写入,有则修改这样的需求 则用上面的\n\n\n\n1.5 hooks\n\n1.5.1 针对单个模型的钩子\nfunc (m *Course) AfterCreate(scope *gorm.Scope) error {\n    // scope.SetColumn(\"ID\", uuid.New())\n    fmt.Println(scope.FieldByName(\"title\"))\n    // fmt.Println(len(*scope.Fields))\n    // 可以获取到模型设置的值, 模型中可以设置数据库不需要的值\n    // Bbb         string      `gorm:\"-\"`  需要有 `gorm:\"-\"`\n    for _, v := range scope.Fields() {\n        fmt.Println(*v)\n    }\n    fmt.Println(scope.IndirectValue)\n    return nil\n}\nfunc (cp *CourseProgress) AfterDelete() error {\n    // 一条语句删除多条记录,只会触发一次这个\n    // cp的属性值,并不会从数据库里读取什么, 还是原来调用时的样子\n    fmt.Println(\"x\", cp)\n    return nil\n}\nfunc (m *Course) AfterUpdate(scope *gorm.Scope) error {\n    // 更新多条语句只会触发一次这个操作\n    // m的值 是之前 调用update 时的模型,以及 update() 中设置要更新的属性的值都会赋值给模型m, 还有更新时间会有\n    // fmt.Println(scope.FieldByName(\"ID\"))\n    fmt.Println(scope.CombinedConditionSql())\n    fmt.Println(scope.SQLVars)\n    fmt.Println(scope.SQL)\n    // fmt.Println(scope.Search)\n    fmt.Println(scope.SelectAttrs())\n    for _, vv := range scope.Fields() {\n        fmt.Println(vv.Name, vv.Field)\n    }\n    // fmt.Println(scope.IndirectValue)\n    return nil\n}\n\n\n1.5.2 callback中的事务问题\n// 从gorm 源码中 callback_create.go  callMethod去看\n// 根据不同的回调方法(其实就是参数不同的情况下)不同的执行方式\n// 使用scope *gorm.DB\n// scope.Create(&a) 正确执行,然后后面返回err, 这种情况, 都回滚了\nfunc (m *ModuleQuiz) AfterCreate(scope *gorm.DB) error {\n a := Lesson{CourseID: 1234, Payload: \"{}\", Covers: \"{}\"}\n scope.Create(&a)\n\n return errors.New(\"abc\")\n}\n\n// scope *gorm.Scope\nfunc (m *ModuleQuiz) AfterCreate(scope *gorm.Scope) error {\n a := Lesson{CourseID: 1234, Payload: \"{}\", Covers: \"{}\"}\n scope.DB().Create(&a) //  这个会执行的, 即使后面返回了error\n\n return errors.New(\"abc\")\n}\n\n\n\n1.6 preload\n\npreload 的意义是啥,脑子里想一想, preload里的东西一定是根据你外部的表的一个 字段来关联,然后查询数据 我们可以通过查看sql 得出 ,实际上就只有2条sql语句,一条是得到course的记录 一条是获取课程的课节的信息,  这条的sql是 这样的 course_id in(…) , 然后实际上 应该是做了一个循环,根据lesson的course_id来拼接到数组里,所以我们的prelaod的查询语句如果是自己做了些定义,必须带上 course_id ,否则 你无法获取,这就是为什么 下面的语句,看起来只要获取count就可以,为什么还要获取course_id这个字段的原因 记得还要group_by , 想想 2条sql语句就知道了\n\nerr := resource.GetDB().Model(&Course{}).\n        Count(&cnt).\n        Scopes(PageAndSize(page, size)).\n        Preload(\"Lesson\", func(db *gorm.DB) *gorm.DB {\n            // 获取 必须要带上 一个course_id, 这里的As count 可以 as id ,这样你的Lesson模型不用添加额外的属性\n            return db.Select(\"course_id,count(id) AS count\").Group(\"course_id\")\n        }).\n        Find(&cl).Error\n// 每个lesson都有一个对应的progress\n// 我们需要所有的Lesson的progress时 ,用 Lessons.Progress\n// 如果使用Lesson.Progress 只会获取一个\nerr = resource.GetDB().Model(c).Where(courseIDs).\n  Preload(\"Lessons\", func(db *gorm.DB) *gorm.DB {\n   return db.Order(\"id\")\n  }).\n  Preload(\"Lessons.Progress\", func(db *gorm.DB) *gorm.DB {\n\n\n1.7 update create save\n\n1.7.1 update\n\nupdate 凡是默认值得,都不会更新, 有就是说如果你需要将status修改为0, 你肯定传递过来0, 而实际上 不会修改, 因为0是默认值\n\n\n所以建议表里的字段的值设置不要有0\n\n\n\n1.7.2 save\n\n都会更新 是不是默认值不管, 使用模型的默认值 进行写入数据库了\n\n\n\n1.7.3 create\n\n使用模型的默认值, 所以你不传递的字段,会使用模型的默认值来进行初始化,写入数据库中 这种 也不好, 因为数据库表设计有可能有默认值 比如1, 那这种情况就会导致写入0了\n\n\n\n1.7.4 默认值问题\ntype Animal struct {\n    ID   int64\n    Name string `gorm:\"default:'galeone'\"`\n    Age  int64\n}\n\n然后测试 写入和获取 以及更新时 是该默认值 会不会更新\n\n\n好像根本不会写入默认值到数据库\n\n\n使用下面2种方式\n\n\n这样没有传递的时候,是不会用所谓的默认值写入到数据库的 create\n\n\n// Use pointer value\ntype User struct {\n  gorm.Model\n  Name string\n  Age  *int   //\n}\n\n// Use scanner/valuer\ntype User struct {\n  gorm.Model\n  Name string\n  Age  sql.NullInt64  //\n}\n\n个人觉得可能还是这样处理\n\n如果数据库里需要NUll 这样的,则用* 或者nullint64这种\n如果数据库默认值为&gt;0的,然后create时,没有传递,想要使用数据库中的默认值,则代码中直接写上,if =0 {} else {} 设置模型的值为数据库默认值 ? 好?\nupdate 时模型是默认值 是不更新的,所以尽量不要使用0\n添加时想要使用数据库的默认值 是否可以  gorm:\"-\" 来处理该字段 (获取的时候应该 是可以的?)\n\n\n\n\n\n1.8 使用omit来排除不要insert的和update的 解决上面的问题\n\n\n1.9 使用[]byte来处理json类型的字段\n// 将proto message 里的字段定义为bytes ,==&gt; go ==&gt; []byte\n// gorm model 字段也设置为[]byte ,可以从数据库里读取到数据, 写入也是ok的,\n//  如果我们想要将json格式的数据 返回到浏览器那边 是json的格式的话, 将[]byte 格式 写成 json.RawMessage 即可\n// 正常情况下我们会这样处理\na:=`{\"name\":\"x\",\"school\":{\"name\":\"qh\",\"class\":11}}`\ntype Person struct{\n    Age int64\n    Sch string\n}\np:=Person{\n    Age:11,\n    Sch:a\n}\njson.Marshal(p)  ==&gt; 得到的sch 还是个字符串\ntype Person struct{\n    Age int64\n    Sch json.RawMessage  ==&gt; 实际就是[]byte, 可以看看源码\n}\n\np:=Person{\n    Age:11,\n    Sch:(json.RawMessage)(a)\n}\njson.Marshal(p)  ==&gt; 可以都变成\n\n\n1.10 有关使用分表的注意事项\n// 根据uid 来判断写入哪个表\nfunc (t *Test) TableName() string {\n    return fmt.Sprintf(\"test_%d\", t.UID%10)\n}\n\n在使用 查询,更新 ,创建的时候,需要注意是否用到 分表\n\n// 使用 &Test{} 使用到了 分表\n//  &注意这个  没有& 的  就不适用了\n// 都是有deleted_at is null的\nModel(&Test{UID: 8}).Update(...)\n.Model(&User).Create(&Test{UID:8})  // 创建的是test ,与model指定的无关\n.Create(&Test{UID:8})  //走分表的\n.Create(Test{UID:8})  //没& 不走分表的\n\n// 因为使用Find 其实 不会去管Model里设置的是哪个表\n\n// 经过测试, 就是\na:=Test{}\nModel(&User{}).Find(&a) // 找的是test表,与 Model里的User表无关\n.Model(&Test{UID:8}).Find(&..)  // 不管model有没有& 都不走分表\n// 需要指定 .Table((&Test{UID:8}).TableName())\n.Model(&Test{UID:8}).Scan(&..)  //走分表   Model(没&)  不走分表\n\n// Scan 与 Find 的区别是,他必须指定table或者model\n// 所以上面我们的Scan 指定了model 是走分表的\n\n// 凡是用.Table 来指定表名的, 查询不会有 deleted_at is null\n// 更新也不会更新 updated_at\n\nFirst() 换成 Model(&).order limit .Scan(&obj)\n\n// model 不会管cp属性的值 来作为过滤条件,(除非是主键id有值,则会作为where条件)\n// 只会关心where里的 ,如果where里的用的是模型,那么 用& 才会指定tablename\n// 否则 出问题\n.Model(&cp).Where(&cp).Scan()\n\n\n// 注意如果这里Where(&cp), 然后后面update, 会先将\n// is_finished 属性true值 设置到模型cp中,然后作为where条件\n// 这样就导致问题了,\n// update is_finished=true where is_finished =true   XX\n// where 还是不用模型比较好\ncp := models.CourseProgress{UID: 1457341, LessonID: 97}\n    resource.GetDB().\n        //Where(\"uid = ?\", cp.UID).\n        //Where(\"lesson_id = ?\", cp.LessonID).\n        Where(&cp). \n        Model(&cp).\n        Update(\"is_finished\", true)\n// 这里不是指针\n    cp := CourseProgress{\n                Platform: 2,\n                UID:      121,\n                CourseID: 100,\n            }\n            //但是传递进去的是指针,所以里面会使用到 分表\n             cp.DeleteCourseProgress()\nfunc (cp *CourseProgress) DeleteCourseProgress() error {\n    fmt.Println(cp.LessonID)\n    cp.LessonID = 10\n    // Delete(cp) 是指针 才会使用模型中的TableName()\n    return resource.GetDB().Where(cp).Delete(cp).Error\n}\nfunc (c *User) Test() {\n    fmt.Println(c.ID)\n    c.ID = 123\n}\n\nfunc main() {\n    u := User{Name: \"xx\"}\n    u.Test()\n    fmt.Println(u) // 修改了id\n}"
  },
  {
    "objectID": "docs/programming/go/pkg/gorm.html#其他技巧",
    "href": "docs/programming/go/pkg/gorm.html#其他技巧",
    "title": "斯巴拉稀",
    "section": "2 其他技巧",
    "text": "2 其他技巧\n这样默认的表名不是+s 的, 可以不用 TableName()来具体指定了\ndb.SingularTable(true)\n\n修改默认表名\n您可以通过定义DefaultTableNameHandler对默认表名应用任何规则\ngorm.DefaultTableNameHandler = func (db *gorm.DB, defaultTableName string) string  {\n  return \"prefix_\" + defaultTableName;\n}\n\n*gorm.expr子查询\ndb.Where(\"amount &gt; ?\", DB.Table(\"orders\").Select(\"AVG(amount)\").Where(\"state = ?\", \"paid\").QueryExpr()).Find(&orders)\n\n\n// Cancel limit condition with -1\ndb.Limit(10).Find(&users1).Limit(-1).Find(&users2)\n\n// Cancel offset condition with -1\ndb.Offset(10).Find(&users1).Offset(-1).Find(&users2)\n\n2.1 Set 的使用\n\n我们在afterUpdate这种操作中,如果想要知道该update之前的某个字段的值的时候怎么办呢?\n\n// gorm 中的每次.Where啊什么的操作都是 db.clone() 一次的, 之后的clone都会带上你设置的值(set设置的)\ne = db.Where(&wher).Where(\"id = 111\").\n        Set(\"old\", 1). // 这个就是设置了一个临时的值,在afterupdate 可以使用\n        Update(map[string]interface{}{\"is_finished\": true, \"stars\": 11})\n\n// 所以你在afterUpdate 中可以\na, ok := scope.Get(\"old\")\nif ok {\n    fmt.Println(\"ss\", a)\n}\nfmt.Println(scope.DB().RowsAffected)\n\n\n// 这样我们就算是达到了,获取更新之前的old 值的要求了\n\n\n2.2 .Table()\n// 看下源码就知道了\n// 没有 deleted_at is null  需要手动添加\nresource.GetDB().Table((&Course{}).TableName()).Count() \n\n// 如果使用的是 Find 则\n//不需要 deleted_at is null 默认就有\n\nTable((&CourseProgress{UID: 2}).TableName()).\n  Find(&a)    // table 有效, Model 无效\n\n\n2.3 first & find\n\n意义上来说, 我们查询列表, 没有数据是完全正常的, 而当我们 查询某一条记录是否存在时,正常情况下,我们是需要这条记录的, 所以才查询. 所以系统设计上给你报err了\n\n//gorm  // callback_query.go / init()\n //查看实际调用的 查询方法.\n\nelse if scope.db.RowsAffected == 0 && !isSlice {\n    scope.Err(ErrRecordNotFound)\n   }\n\n//我们发现,Find(& xx   ) xx 使用切片的时候, \n//不会报ErrRecordNotFound, FIrst 使用的是单个 所以报ErrRecordNotFound"
  },
  {
    "objectID": "docs/programming/go/pkg/gorm.html#子查询",
    "href": "docs/programming/go/pkg/gorm.html#子查询",
    "title": "斯巴拉稀",
    "section": "3 子查询",
    "text": "3 子查询\n\nsubQuery 是会用() 包起来的\n\nresource.GetDB().Exec(\n    fmt.Sprintf(`insert into %s (a,b,c,d,created_at,updated_at,actived_at,e) select * from (?) tmp where not exists(?)`, cp.TableName()),\n    resource.GetDB().\n     Model(models.AB{}).\n     Select(\"?,b,c,d ,now(),now() ,now() ,'{}'\", cp.UID).\n     Where(\"id = ?\", c.ID).Order(\"id\").Limit(2).\n     SubQuery(),\n    resource.GetDB().Model(cp).Where(\"id=?\", ID).Where(\"id = tmp.id\").QueryExpr(),\n   )"
  },
  {
    "objectID": "docs/programming/go/pkg/lancet.html",
    "href": "docs/programming/go/pkg/lancet.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "Back to top"
  },
  {
    "objectID": "docs/programming/go/pkg/gdb.html",
    "href": "docs/programming/go/pkg/gdb.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "pt ptype\n\n\n\n Back to top"
  },
  {
    "objectID": "docs/programming/go/pkg/dlv.html",
    "href": "docs/programming/go/pkg/dlv.html",
    "title": "go dlv",
    "section": "",
    "text": "go install github.com/go-delve/delve/cmd/dlv@latest\n# 安装的路径在, 需要export\ngo env GOPATH",
    "crumbs": [
      "工具与实用库",
      "dlv调试"
    ]
  },
  {
    "objectID": "docs/programming/go/pkg/dlv.html#安装",
    "href": "docs/programming/go/pkg/dlv.html#安装",
    "title": "go dlv",
    "section": "",
    "text": "go install github.com/go-delve/delve/cmd/dlv@latest\n# 安装的路径在, 需要export\ngo env GOPATH",
    "crumbs": [
      "工具与实用库",
      "dlv调试"
    ]
  },
  {
    "objectID": "docs/programming/go/pkg/dlv.html#常用命令",
    "href": "docs/programming/go/pkg/dlv.html#常用命令",
    "title": "go dlv",
    "section": "2 常用命令",
    "text": "2 常用命令\ndlv attach pid #对正在运行的进程直接进行调试\ndlv debug main.go\ndlv exec 可执行文件\nhelp # 查看帮助\n# b  打断点 包名.方法名\nb main.main\nc\n# 在上面的c 执行后,才可以这样b 到行号\nb 11 # 直接行号 打断点\n# 或者 一开始这样直接打 行号的断点\nb main.go:12\nbp # 打印所有断点\np a # 打印变量a\n# 打印 某个内存地址的内容,比如想看 sp寄存器指向的内存\np *(*uint64)(0x000000c000050758)\ns # 逐行执行代码 遇到函数会进入内部\nsi # step-instruction  逐个 cpu指令的 执行\nso # stepout 跳出函数\nn # 逐行执行代码 不进入函数内\nargs #查看被调用函数所传入的参数值\nlocals #查看所有局部变量\nlocals 变量名 # 查看具体变量\nclear 编号 # 删除指定断点 ,bp 打印可以看到编号\nclearall #  删除所有断点\nregs # 打印寄存器信息\ngrs # goroutines  显示所有协程,有编号 , *表示当前执行的协程\ngr # goroutine 编号  切换协程\nl # 打印代码\n\nr # restart 重启当前进程\n# 查看汇编代码\ndisassemble -l main.main",
    "crumbs": [
      "工具与实用库",
      "dlv调试"
    ]
  },
  {
    "objectID": "docs/programming/go/pkg/dlv.html#调试-_test.go-文件",
    "href": "docs/programming/go/pkg/dlv.html#调试-_test.go-文件",
    "title": "go dlv",
    "section": "3 调试 _test.go 文件",
    "text": "3 调试 _test.go 文件\nfunc TestBasic(t *testing.T) {\n    a := struct{}{}\n    b := struct{}{}\n    fmt.Println(unsafe.Sizeof(a)) //0\n    // 相同\n    fmt.Printf(\"%p,%p\\n\", &a, &b)\n    fmt.Println(11)\n}\n# Double-dashes `--` can be used to pass arguments to the test program\n# dlv test [package] -- -test.run TestSomething -test.v -other-argument\ndlv test -- -test.run TestBasic -test.v\n# b 打断点 后面的是 Test 的方法名\n(dlv) b TestBasic\n(dlv) c  # 执行到断点位置\n(dlv) n # 下一行\n(dlv) n # 下一行\n(dlv) p &a",
    "crumbs": [
      "工具与实用库",
      "dlv调试"
    ]
  },
  {
    "objectID": "docs/programming/go/pkg/ast.html",
    "href": "docs/programming/go/pkg/ast.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "Back to top"
  },
  {
    "objectID": "docs/programming/underlying/data_structure.html",
    "href": "docs/programming/underlying/data_structure.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "静态类型, 动态类型, 强类型, 弱类型\n\npython3\n\n\npython 是动态强类型\nx = 10          # x 是整数\nx = \"Hello\"     # x 现在是字符串\nx = \"10\"\ny = 5\n# 下面的操作会抛出 TypeError\nresult = x + y\npython3 整型是可变长度\nimport sys\ni=1\nprint(sys.getsizeof(i))\ni=2**30\nprint(sys.getsizeof(i))",
    "crumbs": [
      "数据结构",
      "数据结构"
    ]
  },
  {
    "objectID": "docs/programming/underlying/data_structure.html#分类",
    "href": "docs/programming/underlying/data_structure.html#分类",
    "title": "斯巴拉稀",
    "section": "",
    "text": "静态类型, 动态类型, 强类型, 弱类型\n\npython3\n\n\npython 是动态强类型\nx = 10          # x 是整数\nx = \"Hello\"     # x 现在是字符串\nx = \"10\"\ny = 5\n# 下面的操作会抛出 TypeError\nresult = x + y\npython3 整型是可变长度\nimport sys\ni=1\nprint(sys.getsizeof(i))\ni=2**30\nprint(sys.getsizeof(i))",
    "crumbs": [
      "数据结构",
      "数据结构"
    ]
  },
  {
    "objectID": "docs/programming/python/basic/quick-start.html",
    "href": "docs/programming/python/basic/quick-start.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "!!! warning 早期 笔记 暂存 待修改.\npy title=\"输入密码, 就是让你看不到的那个效果\" import  getpass name=input('name:') password=getpass.getpass('password:')\n```py title=“for range” for i in range(10): print(i) # 0 - 9\nfor i in range(0,10,2): print(i) # 0 2 4 6 8"
  },
  {
    "objectID": "docs/programming/python/basic/quick-start.html#set-集合",
    "href": "docs/programming/python/basic/quick-start.html#set-集合",
    "title": "斯巴拉稀",
    "section": "1 set 集合",
    "text": "1 set 集合\n#set 也叫集合,主要用来去重,和关系测试,无序的\nlist1=[1,5,2,3,2,8,9]\nset1=set(list1)\nset2=set([1,4,3,7])\nprint(set1)\n#交集  set1 & set2\nprint(set1.intersection(set2))\n#并集 set1 | set2\nprint(set1.union(set2))\n#差集,我有的,你没有, set1 - set2\nprint(set1.difference(set2))\n#判断是否是子集  set1 &lt;= set2\nprint(set1.issubset(set2))\n#获取去掉交集的 数据  set1 ^ set2\nprint(set1.symmetric_difference(set2)) # {2, 4, 5, 7, 8, 9}\n\n#添加 一个\nset1.add('y')\n# 添加多个\nset1.update([0,10])\n# 删除, 如果没有这个 元素,则报错\nset1.remove(10)\n# 删除, 如果没有这个 元素,不会报错\nset1.discard(10)\nprint(0 in set1)"
  },
  {
    "objectID": "docs/programming/python/basic/quick-start.html#file",
    "href": "docs/programming/python/basic/quick-start.html#file",
    "title": "斯巴拉稀",
    "section": "2 file",
    "text": "2 file\n# 如果以w模式打开 文件的话, 首先你不能读取内容\n# 其次如果已经有个文件是a.txt 那么里面的内容会被清空\nf=open('a.txt','w')\n#\nf.write('aaa')\nf.close()\n\n# r 读\nf=open('a.txt','r')\nx=f.read()\nf.close()\n# 这个是追加内容,不会覆盖掉原来的\n# 还是不能读\nf2=open('a.txt','a')\nf2.close()\nf=open('a.txt','r')\n# 如果文件非常大,这样会一行一行的把内容存放到内存中\n# 这个不太好\nfor line in f.readlines():\n    print(line)\nfor index,line in enumerate(f.readlines()):\n    print(index,line)\nf.close() # ?\nf=open('a.txt','r')\n#这个也是一行一行的读,但是内存里只保存一行的数据,这个就比较好的方法\nfor line in f:\n    print(line)\nf.close()\n# a.txt\n# hello world\nf=open('a.txt','r',encoding='utf-8')\nx=f.read(2)\nprint(x) # he\n# tell 获取了几个字节\ncnt=f.tell()\nprint(cnt) #2\nf.seek(6)\nx=f.read(2)\nprint(x) # wo\nprint(f.encoding) #utf-8\nf.close()\nimport sys,time\nf=open('a.txt','a')\nf.write('b')\nf.flush() #立刻刷新到磁盘\nf.write('c')\ntime.sleep(5) # 这个期间你就能看到文件里有了b, 但是看不到c\nf.close()\n\n\nimport sys,time\nfor i in range(20):\n    sys.stdout.write('#')\n    # 这里就是立刻刷新,要不然会等结束后一起出来的\n    sys.stdout.flush()\n    time.sleep(0.1)\n#w+ 写读\n# 还是会先 重写该文件的,所以一般写读模式没什么用,我们一般用r+模式\n#r+ 是读写, 追加模式\nf=open('a.txt','r+')\nf.readline()\nprint(f.tell())\nf.write('------')\nf.close()\n# f=open('a.txt','rb') #b 表示以二进制模式打开\n#以二进制打开后,不能读取多少字节\n#一般在socket网络编程里会用到\nf=open('b.txt','wb')\n#需要将字符串转换成二进制写入,你看到的b.txt文件里还是hello\nf.write('hello'.encode())\nf.close()\n#修改文件,通过把该文件保存到另外一个文件\nf=open(\"09\",\"r\",encoding=\"utf-8\")\nfn=open('09.new','w',encoding=\"utf-8\")\nfor line in f:\n    if 'a' in line:\n        line=line.replace(\"a\",\"xxx\")\n    fn.write(line)\n\n\n#为了避免打开文件后忘记关闭\nwith open('a.txt',\"a\") as f:\n   pass\n#支持打开多个\nwith open(\"a.txt\",'a') as f1,open(\"b.txt\",\"a\") as f2:\n    pass"
  },
  {
    "objectID": "docs/programming/python/basic/quick-start.html#chardet",
    "href": "docs/programming/python/basic/quick-start.html#chardet",
    "title": "斯巴拉稀",
    "section": "3 chardet",
    "text": "3 chardet\nimport  sys\n\nimport  chardet\nprint(sys.getdefaultencoding()) # utf-8"
  },
  {
    "objectID": "docs/programming/python/basic/quick-start.html#函数",
    "href": "docs/programming/python/basic/quick-start.html#函数",
    "title": "斯巴拉稀",
    "section": "4 函数",
    "text": "4 函数\ndef t1():\n    return 1\n# 没有写return ,那么默认返回 None\ndef t2():\n    print(1)\n\nx=t2()\nprint(x) # None"
  },
  {
    "objectID": "docs/programming/python/pandas/quick-start.html",
    "href": "docs/programming/python/pandas/quick-start.html",
    "title": "python pandas",
    "section": "",
    "text": "import pandas as pd\nfile = \"output.xlsx\"\n\n# 简单创建一个xlsx文件\ndf = pd.DataFrame()\n# 保存到目录下,内容是空的\ndf.to_excel(\"output.xlsx\")\n\n\n\n\n会在最左边一列显示0 1 2,是dataFrame的索引\n\n\nimport pandas as pd\ndf = pd.DataFrame({\"id\": [11, 22, 33], \"name\": [\"xiaobai\", \"xiaohong\", \"xiaohei\"]})\ndf.to_excel(\"output.xlsx\")\n\n\n\n\n\n\n点击查看生成的excel\n\n\n\n\n\n\n\n\n\nid\nname\n\n\n\n\n0\n11\nxiaohei\n\n\n1\n22\nxiaohong\n\n\n2\n33\nxiaobai\n\n\n\n\n\n\n\n\n将id 设置为df的索引, 这样生成的excel 不会在前面用自动生成0 1 2..\n\n\ndf = pd.DataFrame({\"id\": [11, 22, 33], \"name\": [\"xiaobai\", \"xiaohong\", \"xiaohei\"]})\ndf = df.set_index(\"id\")\ndf.to_excel(\"output.xlsx\") # (1)\n\n\n\n\n\n\n点击查看生成的excel\n\n\n\n\n\n\n\n\nid\nname\n\n\n\n\n11\nxiaohei\n\n\n22\nxiaohong\n\n\n33\nxiaobai",
    "crumbs": [
      "pandas",
      "快速入门"
    ]
  },
  {
    "objectID": "docs/programming/python/pandas/quick-start.html#创建excel",
    "href": "docs/programming/python/pandas/quick-start.html#创建excel",
    "title": "python pandas",
    "section": "",
    "text": "import pandas as pd\nfile = \"output.xlsx\"\n\n# 简单创建一个xlsx文件\ndf = pd.DataFrame()\n# 保存到目录下,内容是空的\ndf.to_excel(\"output.xlsx\")\n\n\n\n\n会在最左边一列显示0 1 2,是dataFrame的索引\n\n\nimport pandas as pd\ndf = pd.DataFrame({\"id\": [11, 22, 33], \"name\": [\"xiaobai\", \"xiaohong\", \"xiaohei\"]})\ndf.to_excel(\"output.xlsx\")\n\n\n\n\n\n\n点击查看生成的excel\n\n\n\n\n\n\n\n\n\nid\nname\n\n\n\n\n0\n11\nxiaohei\n\n\n1\n22\nxiaohong\n\n\n2\n33\nxiaobai\n\n\n\n\n\n\n\n\n将id 设置为df的索引, 这样生成的excel 不会在前面用自动生成0 1 2..\n\n\ndf = pd.DataFrame({\"id\": [11, 22, 33], \"name\": [\"xiaobai\", \"xiaohong\", \"xiaohei\"]})\ndf = df.set_index(\"id\")\ndf.to_excel(\"output.xlsx\") # (1)\n\n\n\n\n\n\n点击查看生成的excel\n\n\n\n\n\n\n\n\nid\nname\n\n\n\n\n11\nxiaohei\n\n\n22\nxiaohong\n\n\n33\nxiaobai",
    "crumbs": [
      "pandas",
      "快速入门"
    ]
  },
  {
    "objectID": "docs/programming/python/pandas/quick-start.html#读取excel",
    "href": "docs/programming/python/pandas/quick-start.html#读取excel",
    "title": "python pandas",
    "section": "2 读取excel",
    "text": "2 读取excel\n\ninput.xlsx简单读取指定索引列指定第几行开始?设置无表头读自定义表头名\n\n\n\n\n\nid\nname\n\n\n\n\n11\nxiaohei\n\n\n22\nxiaohong\n\n\n33\nxiaobai\n\n\n44\nxiaohuang\n\n\n55\nxiaolan\n\n\n66\nxiaozi\n\n\n\n\n\n\nimport pandas as pd\nfile = \"input.xlsx\"\nuser = pd.read_excel(file)\n# 打印几行几列\n# (6, 2): 6行2列的意思,注意不包含列名那一行\nprint(user.shape)\nprint(user.columns) # 打印列名(表头)\nprint(user.head())  #默认打印5行\nprint(user.head(5)) # 读5行\n\n\n\n\n\n\n点击查看执行结果\n\n\n\n\n\n输出的结果: 加上列名那一行,一共6行, 第一列是索引列\n    id       name\n0  11    xiaobai\n1  22   xiaohong\n2  33    xiaohei\n3  44  xiaohuang\n4  55    xiaolan\n\n\n\n\n\n\n\nimport pandas as pd\nfile = \"input.xlsx\"\n# 直接指定哪列是index, 这样获取的数据就不会有自动生成的那个索引列\nuser = pd.read_excel(file, index_col=\"id\")\nprint(user.head())\n\n\n\n\n\n\n点击查看执行结果\n\n\n\n\n\nid       name\n11    xiaobai\n22   xiaohong\n33    xiaohei\n44  xiaohuang\n55    xiaolan\n\n\n\n\n\n\n\nimport pandas as pd\nfile = \"input.xlsx\"\n# 如果 表格前面的行是空的, 会自动跳过的\n# 如果 是脏数据, 就需要指定了\n# 从excel的第二行开始读 (这个时候第二行作为列名行)\nuser = pd.read_excel(file, header=1)\nprint(user.columns) # 这个时候的列名是 上面读取的第一行\n\n\n\n\n\n\n点击查看执行结果\n\n\n\n\n\nIndex([11, 'xiaobai'], dtype='object')\n\n\n\n\n\n\n\nimport pandas as pd\nfile = \"input.xlsx\"\n# 没有header的情况,就是我们没有给表格的表头指定是什么字段\n# 没有列名, 全是数据, 那么我们就要\nuser = pd.read_excel(file, header=None)\nprint(user.columns) # 默认会给表头指定为 0,1,2..\n\n\n\n\n\n\n点击查看执行结果\n\n\n\n\n\nInt64Index([0, 1], dtype='int64')\n\n\n\n\n\n\n\nuser = pd.read_excel(file)\nuser.columns = [\"user_id\", \"user_name\"]\n# inplace=True 表示直接修改, 否则你需要 user=user.set_index(\"user_id\")\nuser.set_index(\"user_id\",inplace=True) # 这样就不会输出 默认的索引列, 用user_id作为索引了.\nuser.to_excel(\"output5.xlsx\")\n\n\n\n\n\n\n点击查看生成的excel\n\n\n\n\n\n\n\n\nuser_id\nuser_name\n\n\n\n\n11\nxiaohei\n\n\n22\nxiaohong\n\n\n33\nxiaobai\n\n\n44\nxiaohuang\n\n\n55\nxiaolan\n\n\n66\nxiaozi",
    "crumbs": [
      "pandas",
      "快速入门"
    ]
  },
  {
    "objectID": "docs/programming/python/pandas/quick-start.html#统计",
    "href": "docs/programming/python/pandas/quick-start.html#统计",
    "title": "python pandas",
    "section": "3 统计",
    "text": "3 统计",
    "crumbs": [
      "pandas",
      "快速入门"
    ]
  },
  {
    "objectID": "docs/programming/python/pandas/quick-start.html#排序",
    "href": "docs/programming/python/pandas/quick-start.html#排序",
    "title": "python pandas",
    "section": "4 排序",
    "text": "4 排序",
    "crumbs": [
      "pandas",
      "快速入门"
    ]
  },
  {
    "objectID": "docs/programming/python/pandas/quick-start.html#数据筛选",
    "href": "docs/programming/python/pandas/quick-start.html#数据筛选",
    "title": "python pandas",
    "section": "5 数据筛选",
    "text": "5 数据筛选",
    "crumbs": [
      "pandas",
      "快速入门"
    ]
  },
  {
    "objectID": "docs/programming/css/quick-start.html",
    "href": "docs/programming/css/quick-start.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "css教程"
  },
  {
    "objectID": "docs/programming/css/quick-start.html#hr",
    "href": "docs/programming/css/quick-start.html#hr",
    "title": "斯巴拉稀",
    "section": "",
    "text": "css教程"
  },
  {
    "objectID": "docs/programming/rust/advanced/01.mem.html",
    "href": "docs/programming/rust/advanced/01.mem.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "Important\n\n\n\n会合并到基础篇",
    "crumbs": [
      "并发与异步",
      "内存"
    ]
  },
  {
    "objectID": "docs/programming/rust/advanced/01.mem.html#类型",
    "href": "docs/programming/rust/advanced/01.mem.html#类型",
    "title": "斯巴拉稀",
    "section": "1 类型",
    "text": "1 类型\n\n\n\n\n\n\n\n以1个字节1个字节的方式来读写原本4个字节类型的内存空间\n\n\n\n\n\nfn main() {\n    // 10 00000100 00000011 00000001\n    let mut a = 33817345i32;\n    struct FourI8 {\n        first: i8,\n        second: i8,\n        third: i8,\n        fourth: i8,\n    }\n    // 将变量a的地址 转换为一个指针 ,指针类型是i32,这个就是a原来的内存读取方式\n    // 然后再将这个指针 进行类型转换, 转换为 结构体的方式来读取 a 所在的那块内存\n    let b = &mut a as *mut i32 as *mut FourI8;\n    unsafe {\n        println!(\n            \"{} {} {} {}\",\n            (*b).first,\n            (*b).second,\n            (*b).third,\n            (*b).fourth\n        );\n        (*b).first = 2;\n        // 10 00000100 00000011 00000010\n        println!(\"{:b}\", a);\n    }\n}",
    "crumbs": [
      "并发与异步",
      "内存"
    ]
  },
  {
    "objectID": "docs/programming/rust/advanced/01.mem.html#内存对齐",
    "href": "docs/programming/rust/advanced/01.mem.html#内存对齐",
    "title": "斯巴拉稀",
    "section": "2 内存对齐",
    "text": "2 内存对齐\n\n代码可能的对齐方式一可能的对齐方式二实际测试结果\n\n\nstruct A {\n    a: u8,\n    b: u32,\n    c: u16,\n}\n\n\n// 这种对齐 12个字节\nstruct A {\n    a: u8,\n    _pad1: [u8; 3], // to align `b`\n    b: u32,\n    c: u16,\n    _pad2: [u8; 2], // to make overall size multiple of 4\n}\n\n\n// 这种对齐 8个字节\nstruct A {\n    b: u32,\n    c: u16,\n    a: u8,\n    _pad: u8,\n}\n\n\nuse std::mem;\n\nstruct A {\n    a: u8,\n    b: u32,\n    c: u16,\n}\n\nfn main() {\n    let x = A { a: 1, b: 2, c: 3 };\n    println!(\"{}\", mem::size_of_val(&x)); // 8\n    // 0x0x7ff7bf6930be-0x0x7ff7bf6930b8-0x0x7ff7bf6930bc\n    // 也就是说实际优化成\n    struct A {\n        b: u32,\n        c: u16,\n        a: u8,\n    }\n    println!(\"0x{:p}-0x{:p}-0x{:p}\", &x.a, &x.b, &x.c);\n}",
    "crumbs": [
      "并发与异步",
      "内存"
    ]
  },
  {
    "objectID": "docs/programming/rust/advanced/01.mem.html#box",
    "href": "docs/programming/rust/advanced/01.mem.html#box",
    "title": "斯巴拉稀",
    "section": "3 Box",
    "text": "3 Box\nfn main() {\n    // 5 是在 堆上分配的, 栈上的变量b 指向了它\n    let b = Box::new(5);\n    let a = 11i64;\n    let c = Box::new(&a);\n    println!(\"b的值 = {:p}\", b);\n    println!(\"c的地址 : {:p}\", &c);\n    println!(\"a的地址 : {:p}\", &a);\n    println!(\"c的值: {:p}\", c);\n    let d = &c as *const Box&lt;&i64&gt; as *const u64;\n    unsafe {\n        // c的值是个地址,指向堆上的内存\n        println!(\"c的值: 0x{:x}\", *d);\n        let dd = *d as *const u64;\n        // c的值是地址,该地址所在内存 存的是 a的地址\n        println!(\"0x{:x}\", *dd);\n    }\n}",
    "crumbs": [
      "并发与异步",
      "内存"
    ]
  },
  {
    "objectID": "docs/programming/rust/advanced/01.mem.html#vectnt",
    "href": "docs/programming/rust/advanced/01.mem.html#vectnt",
    "title": "斯巴拉稀",
    "section": "4 Vec,[T;N],&[T]",
    "text": "4 Vec,[T;N],&[T]\nfn main() {\n    let mut vec: Vec&lt;i32&gt; = vec![1, 2, 3, 4];\n    let arr = [1, 2, 3, 4];\n    vec.push(5);\n    let (ptr, len, cap) = (vec.as_ptr(), vec.len(), vec.capacity());\n    println!(\"Vec 的指针: {:?}\", ptr);\n    println!(\"Vec 的长度: {}\", len);\n    println!(\"Vec 的容量: {}\", cap);\n    // 等价于 let slice_vec:&[i32]=&v;\n    // let slice_vec = &v[..];\n    // [T] 本身表示动态大小, &[T] 切片后,确定了长度\n    let slice_vec = &vec as &[i32];\n\n    // 等价于 let slice_arr:&[i32]=&arr;\n    // let slice_arr = &arr[..];\n    let slice_arr = &arr as &[i32];\n    println!(\n        \"vec的ptr:{:p}-slice_vec的ptr:{:p}-{}\",\n        vec.as_ptr(),\n        slice_vec.as_ptr(),\n        slice_vec.len()\n    );\n    println!(\n        \"arr地址:{:p}-slice_arr的ptr:{:p}-{}\",\n        &arr,\n        slice_arr.as_ptr(),\n        slice_arr.len()\n    );\n\n    struct SliceStruct {\n        a: usize,\n        b: usize,\n    }\n\n    unsafe {\n        let b = &slice_vec as *const &[i32] as *const SliceStruct;\n        // a: cap, b:ptr,c:len\n        println!(\"0x{:x}-0x{:x}\", (*b).a, (*b).b);\n    }\n    struct VecStruct {\n        a: usize,\n        b: usize,\n        c: usize,\n    }\n\n    unsafe {\n        let b = &vec as *const Vec&lt;i32&gt; as *const VecStruct;\n        // a: cap, b:ptr,c:len\n        println!(\"0x{:x}-0x{:x}-0x{:x}\", (*b).a, (*b).b, (*b).c);\n    }\n}",
    "crumbs": [
      "并发与异步",
      "内存"
    ]
  },
  {
    "objectID": "docs/programming/rust/advanced/01.mem.html#stringstr",
    "href": "docs/programming/rust/advanced/01.mem.html#stringstr",
    "title": "斯巴拉稀",
    "section": "5 String,&str",
    "text": "5 String,&str\nfn main() {\n    let a = \"hello\";\n    let b = \"world\".to_string();\n    println!(\"{:p}-{:p}\", &a, a.as_ptr());\n    println!(\"{:p}-{:p}-{}-{}\", &b, b.as_ptr(), b.capacity(), b.len());\n    unsafe {\n        let c = a.as_ptr() as *const u8;\n        println!(\"{:p}\", c);\n        let mut d;\n        for i in 0..10 {\n            // 一个字节一个字节的打印\n            d = c.add(i);\n            // h-e-l-l-o-w-o-r-l-d-\n            print!(\"{}-\", *d as char);\n        }\n        println!(\"\")\n    }\n\n    let e = &b[1..];\n    println!(\"{:p}-{:p}\", &e, e.as_ptr());\n\n    struct StringStruct {\n        a: usize, // cap\n        b: usize, // ptr\n        c: usize, // len\n    }\n    let mut s = \"hello\".to_string();\n    s.push_str(\"x\");\n    // 6-10\n    println!(\"{}-{}\", s.len(), s.capacity());\n    let b = &s as *const String as *const StringStruct;\n    unsafe {\n        // 0xa-0x7f8fbb705f90-0x6\n        println!(\"0x{:x}-0x{:x}-0x{:x}\", (*b).a, (*b).b, (*b).c);\n    }\n}",
    "crumbs": [
      "并发与异步",
      "内存"
    ]
  },
  {
    "objectID": "docs/programming/rust/advanced/01.mem.html#static",
    "href": "docs/programming/rust/advanced/01.mem.html#static",
    "title": "斯巴拉稀",
    "section": "6 &’static",
    "text": "6 &’static\n1fn foo() -&gt; &'static [u8] {\n    &[1, 2, 3]\n}\nfn main(){\n    let b = 1;\n    println!(\"b: {:p}\", &b);\n\n    let a = foo();\n    // a: 0x10fa97aa0\n    println!(\"a: {:p}\", a); // 只读内存区\n    let c = Box::new(2i64);\n    println!(\"c: {:p}\", c.as_ref());\n    let d = &c as *const Box&lt;i64&gt; as *const u64;\n    unsafe {\n        // c的值是个地址,指向堆上的内存\n        println!(\"c指向堆上的地址: 0x{:x}\", *d);\n    }\n    let s = \"abc\";\n    //  s: 0x10fa97aa3 ,  a的 [1,2,3] 占用了3个字节 刚好\n    println!(\" s: {:p}\", s.as_ptr()); // 只读内存区\n}\n\n1\n\na.当看到这个可以编译通过时,我就猜测是在编译期直接在只读内存区写入数据,这和字符串字面量实际是一样的  b.当 foo()改成返回 &[b'a', b'b', b'c'], 你会发现 变量s 关联的只读区和 foo()关联的只读区 一样,直接复用了",
    "crumbs": [
      "并发与异步",
      "内存"
    ]
  },
  {
    "objectID": "docs/programming/rust/advanced/01.mem.html#todo",
    "href": "docs/programming/rust/advanced/01.mem.html#todo",
    "title": "斯巴拉稀",
    "section": "7 TODO",
    "text": "7 TODO",
    "crumbs": [
      "并发与异步",
      "内存"
    ]
  },
  {
    "objectID": "docs/programming/rust/web/test2.html",
    "href": "docs/programming/rust/web/test2.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "web test2 ## tt ff"
  },
  {
    "objectID": "docs/programming/rust/web/test2.html#tttt",
    "href": "docs/programming/rust/web/test2.html#tttt",
    "title": "斯巴拉稀",
    "section": "",
    "text": "web test2 ## tt ff"
  },
  {
    "objectID": "docs/programming/rust/web/actix-web/index.html#footnotes",
    "href": "docs/programming/rust/web/actix-web/index.html#footnotes",
    "title": "斯巴拉稀",
    "section": "Footnotes",
    "text": "Footnotes\n\n\ngithubhttps://actix.rs/docs/↩︎"
  },
  {
    "objectID": "docs/programming/rust/async/concurrency.html",
    "href": "docs/programming/rust/async/concurrency.html",
    "title": "rust 并发",
    "section": "",
    "text": "Caution\n\n\n\n老笔记 ,待整理…",
    "crumbs": [
      "并发与异步",
      "并发(todo)"
    ]
  },
  {
    "objectID": "docs/programming/rust/async/concurrency.html#实现模型",
    "href": "docs/programming/rust/async/concurrency.html#实现模型",
    "title": "rust 并发",
    "section": "1 实现模型",
    "text": "1 实现模型\nrust 标准库就提供1:1 模型的实现, 第三方crate 有m:n模型的实现",
    "crumbs": [
      "并发与异步",
      "并发(todo)"
    ]
  },
  {
    "objectID": "docs/programming/rust/async/concurrency.html#使用线程",
    "href": "docs/programming/rust/async/concurrency.html#使用线程",
    "title": "rust 并发",
    "section": "2 使用线程",
    "text": "2 使用线程\nuse std::thread;\nuse std::time::Duration;\n\nfn main() {\n\n    thread::spawn(|| {\n        for i in 1..10 {\n            println!(\"hi number {} from the spawned thread!\", i);\n            thread::sleep(Duration::from_millis(1));\n        }\n    });\n\n    for i in 1..5 {\n        println!(\"hi number {} from the main thread!\", i);\n        thread::sleep(Duration::from_millis(1));\n    }\n}\n线程没有完全执行完,就退出了\n等待线程完成\nuse std::thread;\nuse std::time::Duration;\n\nfn main() {\n    //thread::spawn 的返回类型是 JoinHandle,它有值的所有权\n    let handle = thread::spawn(|| {\n        for i in 1..10 {\n            println!(\"hi number {} from the spawned thread!\", i);\n            thread::sleep(Duration::from_millis(1));\n        }\n    });\n\n    for i in 1..5 {\n        println!(\"hi number {} from the main thread!\", i);\n        thread::sleep(Duration::from_millis(1));\n    }\n    // 等待其他线程执行完成\n    handle.join().unwrap();\n}",
    "crumbs": [
      "并发与异步",
      "并发(todo)"
    ]
  },
  {
    "objectID": "docs/programming/rust/async/concurrency.html#move-闭包",
    "href": "docs/programming/rust/async/concurrency.html#move-闭包",
    "title": "rust 并发",
    "section": "3 move 闭包",
    "text": "3 move 闭包\n报错\nuse std::thread;\n\nfn main() {\n    let v = vec![1, 2, 3];\n    // 闭包使用外部数据,是一种借用\n    // rust无法确定 子线程什么时候结束, 而线程使用的借用数据可能被其他线程修改(比如主线程),这样就有问题了\n    let handle = thread::spawn(|| {\n        println!(\"Here's a vector: {:?}\", v);\n    });\n\n    handle.join().unwrap();\n}\n使用move\nuse std::thread;\n\nfn main() {\n    let v = vec![1, 2, 3];\n    // v的所有权被move到闭包中\n    let handle = thread::spawn(move || {\n        println!(\"Here's a vector: {:?}\", v);\n    });\n    // println!(\"{:?}\", v);  // 提示v 已经被move了, 无法借用\n    handle.join().unwrap();\n}",
    "crumbs": [
      "并发与异步",
      "并发(todo)"
    ]
  },
  {
    "objectID": "docs/programming/rust/async/concurrency.html#channel-使用消息传递",
    "href": "docs/programming/rust/async/concurrency.html#channel-使用消息传递",
    "title": "rust 并发",
    "section": "4 channel 使用消息传递",
    "text": "4 channel 使用消息传递\n类似go的channel, 线程之间通过发送消息来通信\nmpsc : multiple producer, single consumer\nuse std::sync::mpsc;\nuse std::thread;\n\nfn main() {\n    //tx 发送端, rx 接收端\n    let (tx, rx) = mpsc::channel();\n\n    thread::spawn(move || {\n        let val = String::from(\"hi\");\n        // send() 返回    Result&lt;T, E&gt;\n        tx.send(val).unwrap();\n    });\n    // recv 会堵塞, 直到channel 有数据发送过来\n    // 成功返回 Result&lt;T,E&gt; 发送端关闭,会返回错误\n    let received = rx.recv().unwrap();\n    println!(\"Got: {}\", received);\n}\n使用for in来接收数据\nuse std::sync::mpsc;\nuse std::thread;\nuse std::time::Duration;\n\nfn main() {\n    let (tx, rx) = mpsc::channel();\n\n    thread::spawn(move || {\n        let vals = vec![\n            String::from(\"hi\"),\n            String::from(\"from\"),\n            String::from(\"the\"),\n            String::from(\"thread\"),\n        ];\n\n        for val in vals {\n            tx.send(val).unwrap();\n            thread::sleep(Duration::from_secs(1));\n        }\n    });\n\n    for received in rx {\n        println!(\"Got: {}\", received);\n    }\n}\n多个生产者\nuse std::sync::mpsc;\nuse std::thread;\nuse std::time::Duration;\n\nfn main() {\n    // --snip--\n\n    let (tx, rx) = mpsc::channel();\n\n    let tx1 = tx.clone();\n    thread::spawn(move || {\n        let vals = vec![\n            String::from(\"hi\"),\n            String::from(\"from\"),\n            String::from(\"the\"),\n            String::from(\"thread\"),\n        ];\n\n        for val in vals {\n            tx1.send(val).unwrap();\n            thread::sleep(Duration::from_secs(1));\n        }\n    });\n\n    thread::spawn(move || {\n        let vals = vec![\n            String::from(\"more\"),\n            String::from(\"messages\"),\n            String::from(\"for\"),\n            String::from(\"you\"),\n        ];\n\n        for val in vals {\n            tx.send(val).unwrap();\n            thread::sleep(Duration::from_secs(1));\n        }\n    });\n\n    for received in rx {\n        println!(\"Got: {}\", received);\n    }\n}",
    "crumbs": [
      "并发与异步",
      "并发(todo)"
    ]
  },
  {
    "objectID": "docs/programming/rust/async/concurrency.html#共享状态的并发",
    "href": "docs/programming/rust/async/concurrency.html#共享状态的并发",
    "title": "rust 并发",
    "section": "5 共享状态的并发",
    "text": "5 共享状态的并发\nShared-State Concurrency\n多所有权, 多个线程同时访问一块内存\n\n5.1 Mutex\nuse std::sync::Mutex;\n\nfn main() {\n    // 返回Mutex&lt;T&gt;  也是智能指针\n    let m = Mutex::new(5);\n\n    {\n        // 通过.lock() 获取锁, 如果获取不到,就会阻塞当前线程\n        // 返回值是 MutexGuard 类型,它实现了 Deref trait 和Drop trait\n        let mut num = m.lock().unwrap();\n        *num = 6;\n        // 报错, 锁还没释放, 下面的代码不能执行\n        // let mut num2 = m.lock().unwrap();\n    }\n    // 这里 m 已经释放锁(drop 操作), 下面的代码可以执行\n    let mut num2 = m.lock().unwrap();\n\n    println!(\"m = {:?}\", m);\n}\n\n\n5.2 Rc? 多个线程send\n报错了, rc 是不能在线程间安全发送,因为没有实现 Send trait\nuse std::rc::Rc;\nuse std::sync::Mutex;\nuse std::thread;\n\nfn main() {\n    let counter = Rc::new(Mutex::new(0));\n    let mut handles = vec![];\n\n    for _ in 0..10 {\n        let counter = Rc::clone(&counter);\n        let handle = thread::spawn(move || {\n            let mut num = counter.lock().unwrap();\n\n            *num += 1;\n        });\n        handles.push(handle);\n    }\n\n    for handle in handles {\n        handle.join().unwrap();\n    }\n\n    println!(\"Result: {}\", *counter.lock().unwrap());\n}\n\n\n5.3 Arc\nArc= atomic rc\nuse std::sync::{Arc, Mutex};\nuse std::thread;\n\nfn main() {\n    let counter = Arc::new(Mutex::new(0));\n    let mut handles = vec![];\n\n    for _ in 0..10 {\n        let counter = Arc::clone(&counter);\n        let handle = thread::spawn(move || {\n            let mut num = counter.lock().unwrap();\n\n            *num += 1;\n        });\n        handles.push(handle);\n    }\n\n    for handle in handles {\n        handle.join().unwrap();\n    }\n\n    println!(\"Result: {}\", *counter.lock().unwrap());\n}",
    "crumbs": [
      "并发与异步",
      "并发(todo)"
    ]
  },
  {
    "objectID": "docs/programming/rust/async/concurrency.html#send-sync-trait",
    "href": "docs/programming/rust/async/concurrency.html#send-sync-trait",
    "title": "rust 并发",
    "section": "6 Send Sync trait",
    "text": "6 Send Sync trait\n\nSend\n\n实现Send trait的类型, 就可以线程间转移所有权\n几乎所有类型都实现了Send, 但是Rc 没有实现,它只能用于单线程\n由Send 成员组成的类型 也是Send\n\nSync\n\n实现Sync trait的类型,可以安全的被多线程引用\nT 是 Sync, 那么 &T 就是 Send\n基础类型都实现了 Sync, 完全由Sync组成的类型 也是Sync\nRc,RefCell, Cell不是 Sync, Mutex是Sync\n\n\n手动实现Send和Sync 是很难做到安全的",
    "crumbs": [
      "并发与异步",
      "并发(todo)"
    ]
  },
  {
    "objectID": "docs/programming/rust/async/coroutine.html",
    "href": "docs/programming/rust/async/coroutine.html",
    "title": "rust coroutine",
    "section": "",
    "text": "需切换到nightly版本\n\nrustup override set nightly\n\n#![feature(coroutines, coroutine_trait, stmt_expr_attributes)]\n\nuse std::ops::{Coroutine, CoroutineState};\nuse std::pin::Pin;\n\nfn main() {\n    let mut coroutine = #[coroutine] || {\n        yield 1;\n        return \"foo\"\n    };\n\n    match Pin::new(&mut coroutine).resume(()) {\n        CoroutineState::Yielded(1) =&gt; {println!(\"11\");}\n        _ =&gt; panic!(\"unexpected value from resume\"),\n    }\n    match Pin::new(&mut coroutine).resume(()) {\n        CoroutineState::Complete(\"foo\") =&gt; {println!(\"foo\");}\n        _ =&gt; panic!(\"unexpected value from resume\"),\n    }\n}\n\n\n\n Back to top",
    "crumbs": [
      "并发与异步",
      "coroutine(todo)"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/enum.html",
    "href": "docs/programming/rust/basic/enum.html",
    "title": "rust 枚举 enum",
    "section": "",
    "text": "Important\n\n\n\n\n看枚举之前,先看看union\nunion是一种允许在相同的内存位置存储多种类型的数据结构\n因此该类型大小等于内存占用最大的那个成员的内存大小\nunion类型的主要功能是和c语言进行交互\n\n\n\nunion MyUnion {\n    j: i32,\n    i: i8,\n}\n\nfn main() {\n    // 00000001 00000100  &lt;== 整个union 是这样的数据 4个字节\n    let mut my_union = MyUnion { j: 260 };\n    // 把它当作i32整型来使用, 需要 unsafe 块，因为这可能涉及内存重新解释\n    println!(\"j value: {}\", unsafe { my_union.j });\n    // 我们直接打印 i 看看,发现 是260 低位的一个字节的值\n    println!(\"i value: {}\", unsafe { my_union.i });\n    // 注意：在访问了union的一个字段后，访问其他字段之前,最好先进行“重置”或明确知道内存布局\n    // 否则可能会读取到无效的、未初始化的或者非预期的数据\n    my_union.i = 3;\n    println!(\"j value: {}\", unsafe { my_union.j }); // 259\n}",
    "crumbs": [
      "基础篇",
      "枚举"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/enum.html#union",
    "href": "docs/programming/rust/basic/enum.html#union",
    "title": "rust 枚举 enum",
    "section": "",
    "text": "Important\n\n\n\n\n看枚举之前,先看看union\nunion是一种允许在相同的内存位置存储多种类型的数据结构\n因此该类型大小等于内存占用最大的那个成员的内存大小\nunion类型的主要功能是和c语言进行交互\n\n\n\nunion MyUnion {\n    j: i32,\n    i: i8,\n}\n\nfn main() {\n    // 00000001 00000100  &lt;== 整个union 是这样的数据 4个字节\n    let mut my_union = MyUnion { j: 260 };\n    // 把它当作i32整型来使用, 需要 unsafe 块，因为这可能涉及内存重新解释\n    println!(\"j value: {}\", unsafe { my_union.j });\n    // 我们直接打印 i 看看,发现 是260 低位的一个字节的值\n    println!(\"i value: {}\", unsafe { my_union.i });\n    // 注意：在访问了union的一个字段后，访问其他字段之前,最好先进行“重置”或明确知道内存布局\n    // 否则可能会读取到无效的、未初始化的或者非预期的数据\n    my_union.i = 3;\n    println!(\"j value: {}\", unsafe { my_union.j }); // 259\n}",
    "crumbs": [
      "基础篇",
      "枚举"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/enum.html#enum",
    "href": "docs/programming/rust/basic/enum.html#enum",
    "title": "rust 枚举 enum",
    "section": "2 enum",
    "text": "2 enum\n枚举是这样一种类型,允许你通过列举可能的成员(variants:变体)来定义一个类型\n\n2.1 内存布局\n\n\n\n\n\n\n\n例子1,运行看看, 然后取消注释b257再运行\n\n\n\n\n\nenum Cat {\n    b1,\n    b2,\n    b3,\n    b4,\n    b5,\n    b6,\n    b7,\n    b8,\n    b9,\n    b10,\n    b11,\n    b12,\n    b13,\n    b14,\n    b15,\n    b16,\n    b17,\n    b18,\n    b19,\n    b20,\n    b21,\n    b22,\n    b23,\n    b24,\n    b25,\n    b26,\n    b27,\n    b28,\n    b29,\n    b30,\n    b31,\n    b32,\n    b33,\n    b34,\n    b35,\n    b36,\n    b37,\n    b38,\n    b39,\n    b40,\n    b41,\n    b42,\n    b43,\n    b44,\n    b45,\n    b46,\n    b47,\n    b48,\n    b49,\n    b50,\n    b51,\n    b52,\n    b53,\n    b54,\n    b55,\n    b56,\n    b57,\n    b58,\n    b59,\n    b60,\n    b61,\n    b62,\n    b63,\n    b64,\n    b65,\n    b66,\n    b67,\n    b68,\n    b69,\n    b70,\n    b71,\n    b72,\n    b73,\n    b74,\n    b75,\n    b76,\n    b77,\n    b78,\n    b79,\n    b80,\n    b81,\n    b82,\n    b83,\n    b84,\n    b85,\n    b86,\n    b87,\n    b88,\n    b89,\n    b90,\n    b91,\n    b92,\n    b93,\n    b94,\n    b95,\n    b96,\n    b97,\n    b98,\n    b99,\n    b100,\n    b101,\n    b102,\n    b103,\n    b104,\n    b105,\n    b106,\n    b107,\n    b108,\n    b109,\n    b110,\n    b111,\n    b112,\n    b113,\n    b114,\n    b115,\n    b116,\n    b117,\n    b118,\n    b119,\n    b120,\n    b121,\n    b122,\n    b123,\n    b124,\n    b125,\n    b126,\n    b127,\n    b128,\n    b129,\n    b130,\n    b131,\n    b132,\n    b133,\n    b134,\n    b135,\n    b136,\n    b137,\n    b138,\n    b139,\n    b140,\n    b141,\n    b142,\n    b143,\n    b144,\n    b145,\n    b146,\n    b147,\n    b148,\n    b149,\n    b150,\n    b151,\n    b152,\n    b153,\n    b154,\n    b155,\n    b156,\n    b157,\n    b158,\n    b159,\n    b160,\n    b161,\n    b162,\n    b163,\n    b164,\n    b165,\n    b166,\n    b167,\n    b168,\n    b169,\n    b170,\n    b171,\n    b172,\n    b173,\n    b174,\n    b175,\n    b176,\n    b177,\n    b178,\n    b179,\n    b180,\n    b181,\n    b182,\n    b183,\n    b184,\n    b185,\n    b186,\n    b187,\n    b188,\n    b189,\n    b190,\n    b191,\n    b192,\n    b193,\n    b194,\n    b195,\n    b196,\n    b197,\n    b198,\n    b199,\n    b200,\n    b201,\n    b202,\n    b203,\n    b204,\n    b205,\n    b206,\n    b207,\n    b208,\n    b209,\n    b210,\n    b211,\n    b212,\n    b213,\n    b214,\n    b215,\n    b216,\n    b217,\n    b218,\n    b219,\n    b220,\n    b221,\n    b222,\n    b223,\n    b224,\n    b225,\n    b226,\n    b227,\n    b228,\n    b229,\n    b230,\n    b231,\n    b232,\n    b233,\n    b234,\n    b235,\n    b236,\n    b237,\n    b238,\n    b239,\n    b240,\n    b241,\n    b242,\n    b243,\n    b244,\n    b245,\n    b246,\n    b247,\n    b248,\n    b249,\n    b250,\n    b251,\n    b252,\n    b253,\n    b254,\n    b255,\n    b256,\n    // b257,\n}\nfn main() {\n    let x = Cat::b1;\n    // 一个字节一共可以有256种可能,刚好可以保存上面任何一个变体,值就能区分\n    println!(\"{}\", std::mem::size_of::&lt;Cat&gt;());\n}\n\n\n\n\n\n\n\n\n\n例子2\n\n\n\n\n\n\ncode内存结构图\n\n\nenum Cat {\n    Tiger(i32), //tag =0\n    Lion(i8),  // tag =1\n    Dog(i16), // tag =2\n}\n\nuse std::mem;\nfn main() {\n    let lion = Cat::Lion(66);\n    println!(\"lion : {}\", mem::size_of_val(&lion)); // 8\n    unsafe {\n        let d = &lion as *const Cat as *const u64;\n        //0x4201 --&gt; 0x42=66 这个是data 0x01=1 这个是tag\n        //实际: 第一个字节存tag, 第二个字节存携带的数据 (因为这里Lion携带的数据是i8用一个字节就行了)\n        println!(\"0x{:x}\", *d);\n    }\n    let dog = Cat::Dog(66);\n    println!(\"Dog : {}\", mem::size_of_val(&dog));  // 8\n    unsafe {\n        let d = &dog as *const Cat as *const u64;\n        //0x420002 --&gt; 0x42=66 这个是data 0x0002 这个是tag\n        //Dog 携带的数据是i16  是2个字节, 所以这里tag和携带的数据各占用两个字节\n        println!(\"0x{:x}\", *d);\n    }\n\n    let tiger = Cat::Tiger(66);\n    println!(\"Tiger : {}\", mem::size_of_val(&tiger)); // 8\n    unsafe {\n        let d = &tiger as *const Cat as *const u64;\n        //0x4200000000 --&gt; 0x42=66 , 0x00 这个是tag\n        println!(\"0x{:x}\", *d);\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n例子3: 我们来看看枚举中变体携带String的情况\n\n\n\n\n\n\ncode内存结构图\n\n\nenum Message {\n    Quit,                    // 不需要占用内存空间, 0\n    Move { x: i32, y: i32 }, // 8bytes\n    Write(String),           // 24\n    ChangeColor(i32, i32, i32), // 12\n    // Read(String),\n}\nstruct enumStringStruct {\n    a: u64,\n    b: u64,\n    c: u64,\n    // d: u64,\n}\n\nfn main() {\n    let mut s = \"hello\".to_string();\n    println!(\"{}-{}\", s.len(), s.capacity());\n    s.push_str(\"x\");\n    println!(\"{}-{}\", s.len(), s.capacity());\n    println!(\"{:p}\", s.as_ptr()); //0x7f8144705f90\n    let m = Message::Write(s);\n    println!(\"{}\", mem::size_of_val(&m)); // 24\n    let b = &m as *const Message as *const enumStringStruct;\n    unsafe {\n        // 发现没有 这个 携带String的没有tag信息, 无tag信息来表示这个是携带String的变体\n        // 0xa-0x7f8144705f90-0x6\n        println!(\"Write: 0x{:x}-0x{:x}-0x{:x}\", (*b).a, (*b).b, (*b).c);\n    }\n    // 取消注释掉下面的代码, 和上面定义的枚举Message中的Read(String) 变体 ,再看看,会发现有各自的tag信息, 总体的内存占用变为32个字节了\n    //---\n    // let mut s = \"hello\".to_string();\n    // s.push_str(\"x\");\n    // println!(\"{:p}\", s.as_ptr()); \n    // let m = Message::Read(s);\n    // println!(\"{}\", mem::size_of_val(&m)); // 24\n    // let b = &m as *const Message as *const enumStringStruct;\n    // unsafe {\n    //     println!(\n    //         \"Read: 0x{:x}-0x{:x}-0x{:x}\",\n    //         (*b).a,\n    //         (*b).b,\n    //         (*b).c,\n    //         (*b).d\n    //     );\n    // }\n    //---\n    let m = Message::Move { x: 11, y: 22 };\n    println!(\"{}\", mem::size_of_val(&m)); // 24\n    let b = &m as *const Message as *const enumStringStruct;\n    unsafe {\n        //                tag    y       x\n        // 0x8000000000000001-0x160000000b-0x0\n        println!(\"Move: 0x{:x}-0x{:x}-0x{:x}\", (*b).a, (*b).b, (*b).c);\n    }\n\n    let m = Message::ChangeColor(6, 7, 8);\n    println!(\"{}\", mem::size_of_val(&m)); // 24\n    let b = &m as *const Message as *const enumStringStruct;\n    unsafe {\n        //                tag   7       6   8\n        // 0x8000000000000003-0x700000006-0x8\n        println!(\"ChangeColor: 0x{:x}-0x{:x}-0x{:x}\", (*b).a, (*b).b, (*b).c);\n    }\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n例子4: 只有一个成员且不携带数据的枚举\n\n\n\n\n\n\n\n不需要tag来区分哪个变体,所以不需要空间来存储tag\n\nfn main() {\n    enum MyEnum {\n        Cat,\n    }\n    let a = MyEnum::Cat;\n    println!(\"{}\", mem::size_of_val(&a));//0\n}\n\n\n\n\n\n\n\n\n\n\nImportant\n\n\n\n\n根据实际情况, 我们看到, 在上面的例子中 携带String的 枚举变体实际上没有存储tag信息,其他变体存了tag,且在高位估计是为了区分Write变体存的cap而增加了一个0x80 (注意: 这只是这个例子的推测)\n如果将上面的例子中的 Read(String) 取消注释, 这样就有2个携带String的变体了,这个时候怎么区分了,可以试试看, 结果是该枚举的大小变成了32字节了,需要新的内存空间来区分它们\n实际源码根据不同情况是如何优化的,我没去看, 但是通过上面的例子,我们大概了解了一些情况,我觉得ok\n\n\n\n\n\n2.2 简单例子\nenum IpAddrKind {\n    V4,\n    V6,\n}\n\nstruct IpAddr {\n    kind: IpAddrKind,\n    address: String,\n}\n\nfn main() {\n    // 下面2个的类型都是 IpAddrKind\n    // 他们的值,只能是枚举定义里的成员的其中一个\n    let four = IpAddrKind::V4;\n    let six = IpAddrKind::V6;\n    // 任何一个传给函数的参数类型是 IpAddrKind ,是ok的\n    route(IpAddrKind::V4);\n    route(IpAddrKind::V6);\n\n    let home = IpAddr {\n        kind: IpAddrKind::V4,\n        address: String::from(\"127.0.0.1\"),\n    };\n\n    let loopback = IpAddr {\n        kind: IpAddrKind::V6,\n        address: String::from(\"::1\"),\n    };\n}\n\nfn route(ip_kind: IpAddrKind) {}\n\n\n2.3 携带数据\n上面的例子中, 我们可能会问, 枚举的成员本身要是能携带数据岂不是更好?\nenum IpAddr {\n    // 可以设置携带不同类型的数据\n    // 就好像一个构造方法一样了\n    V4(u8, u8, u8, u8),\n    V6(String),\n}\nenum Message {\n    Quit,\n    // 像一个结构体一样\n    Move { x: i32, y: i32 },\n    Write(String),\n    ChangeColor(i32, i32, i32),\n}\n\nfn main() {\n    // 就好像调用了构造方法,返回类型 IpAddr的一个实例\n    let home = IpAddr::V4(127, 0, 0, 1);\n\n    let loopback = IpAddr::V6(String::from(\"::1\"));\n\n    let m = Message::Move { x: 22, y: 11 };\n}\n上面的message 的成员就好像 不同的 struct\nstruct QuitMessage; // unit struct\nstruct MoveMessage {\n    x: i32,\n    y: i32,\n}\nstruct WriteMessage(String); // tuple struct\nstruct ChangeColorMessage(i32, i32, i32); // tuple struct\n\n\n2.4 实现方法\n可以像 struct 一样 设置方法\nenum Message {\n    Quit,\n    // 像一个结构体一样\n    Move { x: i32, y: i32 },\n    Write(String),\n    ChangeColor(i32, i32, i32),\n    // hello(),\n}\nimpl Message {\n    // 接收一个 `&self` 参数，表示它是一个实例方法\n    fn call(&self) {\n        // method body would be defined here\n    }\n    // 如果 Message的成员里有个成员名字和这个一样\n    // 那么 Message::hello()  会被认为是 成员,类型是Message\n    fn hello() {\n        println!(\"hello\");\n    }\n}\n\nfn main() {\n    let m = Message::Write(String::from(\"hello\"));\n    m.call();\n    Message::hello();\n}\n\n\n2.5 变体成员是函数?\n\n\n\n\n\n\nCaution\n\n\n\n\n通过下面的测试我们发现: 带() 这种变体可以当成函数类型\n\n\n\n\n\nMessage::Write 实现了 Fn trait\n\n#[derive(Debug)]\nenum Message {\n    Write(i32),\n}\nfn apply&lt;F, T&gt;(f: F, v: T)\nwhere\n    F: Fn(T) -&gt; Message,\n{\n    f(v);\n}\nfn main() {\n    let a = Message::Write;\n    let f = a(2); // 本身这样看,就挺像函数的\n    println!(\"{:?}\", f);\n    apply(a, 3); // 没报错, 说明a 实现了Fn trait\n}\n\nfn main() {\n    let wr = Message::Write(11);\n    print_type_of(&wr); // 类型是 Message\n    let a = [1, 2, 3];\n    // 我们知道map 接收一个闭包\n    let mut f = a.iter().map(Some);\n    // Some 当成函数, 而Some 的参数算 (T) 捕获的是&x\n    // Some(&x) 返回值Option::Some(&x)\n    if let Some(Option::Some(&y)) = f.next() {\n        println!(\"{}\", y);\n    }\n\n    #[derive(Debug)]\n    enum Message {\n        Write(i32),\n    }\n    let a = [1, 2, 3];\n    let mut f = a.into_iter().map(Message::Write);\n    if let Some(Message::Write(x)) = f.next() {\n        println!(\"{}\", x);\n    }\n    let a = [1, 2, 3];\n    // Message::Write 相当于函数, 参数是i32, 看Message定义里的 Write(i32)\n    // into_iter().map 里面传递参数是 Self, 所以 这里闭包使用的参数 也是i32, 返回值是Message::Write(i32)\n    // collect() 的返回值是 Vec&lt;Message&gt;\n    let f: Vec&lt;Message&gt; = a.into_iter().map(Message::Write).collect();\n    println!(\"{:?}\", f);\n}\n\n\n2.6 类C枚举\n// An attribute to hide warnings for unused code.\n#![allow(dead_code)]\n\n// 从0开始自增\nenum Number {\n    Zero,\n    One,\n    Two,\n}\n// 从3 开始自增\nenum Number2 {\n    Zero = 3,\n    One,\n    Two,\n}\n\n// 明确指定值\nenum Color {\n    Red = 0xff0000,\n    Green = 0x00ff00,\n    Blue = 0x0000ff,\n}\n\nfn main() {\n    // `enums` 使用 as 进行转换, 获取数据.\n    println!(\"zero is {}\", Number::Zero as i32);\n    println!(\"one is {}\", Number::One as i32);\n    println!(\"number2 one is {}\", Number2::One as i32); //4\n    println!(\"number2 two is {}\", Number2::Two as i32); //5\n\n    println!(\"roses are #{:06x}\", Color::Red as i32);\n    println!(\"violets are #{:06x}\", Color::Blue as i32);\n}\n\n\n2.7 use\n#![allow(dead_code)]\nenum Status {\n    Rich,\n    Poor,\n}\n\nfn main() {\n    // 使用use ,这样使用的时候,不用 写前面的 Status\n    // 可以这样, use crate::Status::*;\n    use crate::Status::{Poor, Rich};\n    // 等价于 `Status::Poor`.\n    let status = Poor;\n}\n\n\n2.8 Option 枚举\n// 在rust 中用 Option&lt;T&gt; 枚举来表示要么是一个T类型的值, 要么就是None (表示没有任何值)\nenum Option&lt;T&gt; {\n    None,\n    // T 泛型, 这里说明Some这个成员可以携带任何数据\n    Some(T),\n}\n\nand_thenmap\n\n\n\n\n\n\n\n\nTip\n\n\n\n\nOption 枚举类型的方法, 如果调用者(Option类型) 值为None, 则返回 None; 否则使用包装的值调用 f,并返回结果\n\n\n\n\n\n源码\n\npub fn and_then&lt;U, F&gt;(self, f: F) -&gt; Option&lt;U&gt;\n    where\n        F: FnOnce(T) -&gt; Option&lt;U&gt;,\n    {\n        match self {\n\n            Some(x) =&gt; f(x),\n            None =&gt; None,\n        }\n    }\n\n\n\n测试例子\n\nfn main() {\n    // and_then 接收的f , 必须是返回 Option的闭包\n    let a = \"abc\".parse::&lt;i32&gt;().ok().and_then(|x| Some(x));\n    println!(\"{:?}\", a);\n}\n\n\n\n\n\n源码\n\npub fn map&lt;U, F&gt;(self, f: F) -&gt; Option&lt;U&gt;\nwhere\n    F: FnOnce(T) -&gt; U,\n{\n    match self {\n        // 相比较and_then, f 不用返回Option\n        // 这里就用Some 包起来.\n        Some(x) =&gt; Some(f(x)),\n        None =&gt; None,\n    }\n}\n\n\n\n例子\n\nfn main() {\n    let s1 = Some(String::from(\"Hello, World!\"));\n    let len = s1.map(|s| s.len());\n    println!(\"{:?}\", len)\n}\n\n\n\n\n\n\n2.9 Result 枚举\npub enum Result&lt;T, E&gt; {\n    Ok(T),\n    Err(E),\n}\n\nand_then\n\n\n\n\n源码\n\npub fn and_then&lt;U, F: FnOnce(T) -&gt; Result&lt;U, E&gt;&gt;(self, op: F) -&gt; Result&lt;U, E&gt; {\n    match self {\n        Ok(t) =&gt; op(t),\n        Err(e) =&gt; Err(e),\n    }\n}\n\n\n\n测试例子\n\nuse std::fs::File;\nuse std::io::{self, Read};\n\nfn open_file(path: &str) -&gt; Result&lt;File, io::Error&gt; {\n    File::open(path)\n}\nfn main() {\n    let file_path = \"example.txt\";\n    let file = open_file(file_path).and_then(|mut f| {\n        let mut buffer = String::new();\n        f.read_to_string(&mut buffer)?;\n        Ok(buffer)\n    });\n\n    match file {\n        Ok(content) =&gt; println!(\"File content: {}\", content),\n        Err(e) =&gt; println!(\"Failed to read file: {}\", e),\n    }\n}",
    "crumbs": [
      "基础篇",
      "枚举"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/ptr.html",
    "href": "docs/programming/rust/basic/ptr.html",
    "title": "rust 智能指针",
    "section": "",
    "text": "指针: 指向一块内存地址的变量,变量的值是内存地址\n智能指针\n\nRust 的智能指针是一类数据结构，它们对传统指针的功能进行了扩展\n它们通常包含元数据（例如，引用计数）以管理内存和对象的生命周期\nRust 标准库中定义了几种智能指针，如 Box&lt;T&gt;, Rc&lt;T&gt;, Arc&lt;T&gt;, Ref, RefMut, Cell, RefCell 等\n智能指针的主要目的是提供对内存安全、并发安全以及数据共享和所有权转移的更精细的控制\n\n\n\n智能指针通常使用struct来实现,实现了Deref和Drop trait\n\nDeref trait 允许智能指针像引用一样使用, 例如解引用\nDrop trait 智能指针在离开作用域时执行的代码",
    "crumbs": [
      "基础篇",
      "智能指针"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/ptr.html#相关概念",
    "href": "docs/programming/rust/basic/ptr.html#相关概念",
    "title": "rust 智能指针",
    "section": "",
    "text": "指针: 指向一块内存地址的变量,变量的值是内存地址\n智能指针\n\nRust 的智能指针是一类数据结构，它们对传统指针的功能进行了扩展\n它们通常包含元数据（例如，引用计数）以管理内存和对象的生命周期\nRust 标准库中定义了几种智能指针，如 Box&lt;T&gt;, Rc&lt;T&gt;, Arc&lt;T&gt;, Ref, RefMut, Cell, RefCell 等\n智能指针的主要目的是提供对内存安全、并发安全以及数据共享和所有权转移的更精细的控制\n\n\n\n智能指针通常使用struct来实现,实现了Deref和Drop trait\n\nDeref trait 允许智能指针像引用一样使用, 例如解引用\nDrop trait 智能指针在离开作用域时执行的代码",
    "crumbs": [
      "基础篇",
      "智能指针"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/ptr.html#box",
    "href": "docs/programming/rust/basic/ptr.html#box",
    "title": "rust 智能指针",
    "section": "2 Box",
    "text": "2 Box\nBox&lt;T&gt; 是一个智能指针,它允许在堆上存储数据,在栈上存放指向它的指针,并确保在离开作用域时正确清理堆上的数据\n\n2.1 基本使用\nfn main() {\n    // 5 是在 堆上分配的, 栈上的变量b 指向了 它\n    let b = Box::new(5);\n    println!(\"b = {}\", b);\n}\n我们运行一下这个,看看报错的信息\n// 这里的定义本身就报错了, 因为这个 枚举类型的大小无法确定\nenum List {\n    Cons(i32, List),\n    Nil,\n}\n\nuse crate::List::{Cons, Nil};\n\nfn main() {\n    let list = Cons(1, Cons(2, Cons(3, Nil)));\n}\n提示使用Box ,这样 cons(i32, Box&lt;List&gt;) 大小就确定了.\nhelp: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to break the cycle\n  |\n2 |     Cons(i32, Box&lt;List&gt;),\n修改后\nenum List {\n    Cons(i32, Box&lt;List&gt;),\n    Nil,\n}\n\nuse crate::List::{Cons, Nil};\n\nfn main() {\n    let list = Cons(1, Box::new(Cons(2, Box::new(Cons(3, Box::new(Nil))))));\n}\n\n\n\n\n\n\nCaution\n\n\n\n\n执行下面代码我们可以推测出, Box::new([1i32; 16])会先在栈上创建数组[1i32; 16],然后再将它复制到堆上.\n原因是数组 [1;16] 是个表达式,是需要先计算它的大小的,需要在栈上计算和存储\n\n\n\nfn main() {\n    let a = 11;\n    let b = Box::new([1i32; 16]);\n    let c = 5;\n    println!(\"{:p}\", &a);\n    println!(\"{:p}\", &b);\n    println!(\"{:p}\", &c);\n}\n\n\n2.2 获取裸指针\n\n\n获取Box的裸指针\n\nfn main() {\n    let f;\n    {\n        let b = Box::new(5);\n        println!(\"{:p}\", b); // 堆上的5的地址\n        println!(\"{:p}\", &b); // 栈上b变量的地址\n        // 将 b 转换为 *mut T 可变裸指针\n        // c 的类型是 这里是 *mut i32\n        // b 被move 掉了,但是这个c指向了 b指向的内存,且c没有这块内存的所有权\n        let c = Box::into_raw(b);\n        println!(\"{:p}\", c); // 堆上5的地址\n        unsafe {\n            println!(\"{}\", *c);\n            *c = 23;\n            f = &*c;\n            // Box::from_raw 重新获取所有权,这样离开作用域后, 堆上的数据5被回收了\n            let s = Box::from_raw(c);\n        }\n    }\n    println!(\"f=={}\", *f);  // 指向的数据已经不确定了,是不对的\n}\n\nfn main() {\n    let d;\n    {\n        let mut b = Box::new(5);\n        println!(\"{:p}\", b); // 堆上的5的地址\n        // 第二种方式来获取 裸指针\n        // unsafe 那里对 *d 做修改, 就是需要对d 所指向的数据修改\n        // 那么就是 对 *b 做修改, 则需要 对 *b 做 &mut 处理\n        d = &mut *b as *const i32 as *mut i32;\n        unsafe {\n            println!(\"{}\", *d);\n        }\n    } // b drop 了, 指向的堆内存 释放了\n\n    println!(\"{:p}\", d);\n    // println!(\"{}\", b);\n    unsafe {\n        // 数据不对了\n        println!(\"{}\", *d);\n    }\n}",
    "crumbs": [
      "基础篇",
      "智能指针"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/ptr.html#deref-trait",
    "href": "docs/programming/rust/basic/ptr.html#deref-trait",
    "title": "rust 智能指针",
    "section": "3 deref trait",
    "text": "3 deref trait\n\n3.1 Box\nfn main() {\n    let x = 5;\n    let y = &x;\n\n    assert_eq!(5, x);\n    assert_eq!(5, *y);// *y 解引用 得到 x\n}\n因为Box 实现了Deref trait,所以可以对Box&lt;T&gt;进行解引用操作是可以的\nfn main() {\n    let x = 5;  // 栈上的5\n    let y = Box::new(x); // 将5复制到堆上\n\n    assert_eq!(5, x);\n    assert_eq!(5, *y);\n}\n\n\n3.2 隐式解引用转化(Deref coercion)\n\n\n\n\n\n\nTip\n\n\n\n当把某个类型T(实现了Deref trait)的引用传递给一个函数或方法时,与函数或方法定义的参数类型不一样时,会自动进行式解引用转化,转化为经过 deref 操作后返回的那个引用\n可变引用的情况需要实现 DerefMut trait\n\n下面三种情况会发生自动转化\n\nFrom &T to &U when T: Deref&lt;Target=U&gt;\nFrom &mut T to &mut U when T: DerefMut&lt;Target=U&gt;\nFrom &mut T to &U when T: Deref&lt;Target=U&gt;\n\n\n\n\nstruct MyBox&lt;T&gt;(T);\n\nimpl&lt;T&gt; MyBox&lt;T&gt; {\n    fn new(x: T) -&gt; MyBox&lt;T&gt; {\n        MyBox(x)\n    }\n}\nuse std::ops::Deref;\n\nimpl&lt;T&gt; Deref for MyBox&lt;T&gt; {\n    type Target = T;\n    // 实现 Deref trait 的这个deref 方法的返回值,就是我们 * 操作的真正目标\n    // 因为返回的是引用, 所以 * 操作 ok的\n    fn deref(&self) -&gt; &Self::Target {\n        &self.0\n    }\n}\nfn hello(name: &str) {\n    println!(\"Hello, {name}!\");\n}\n\nfn main() {\n    let m = MyBox::new(String::from(\"Rust\"));\n    // &m: MyBox&lt;String&gt; deref 转化为 &String\n    // String 也实现了 Deref trait ,&String deref返回的是 &str\n    // 这些过程在编译时就完成了, 所以不会有额外的开销\n    hello(&m);\n    // 等价于\n    hello(&(*m)[..])\n}\n\n\n3.3 自定义智能指针\nstruct MyBox&lt;T&gt;(T, T);\n\nimpl&lt;T&gt; MyBox&lt;T&gt; {\n    fn new(x: T, y: T) -&gt; MyBox&lt;T&gt; {\n        MyBox(x, y)\n    }\n}\nuse std::ops::Deref;\n\nimpl&lt;T&gt; Deref for MyBox&lt;T&gt; {\n    type Target = T;\n    // 实现 Deref trait 的这个deref 方法的返回值,就是我们 * 操作的真正目标\n    // 因为返回的是引用, 所以 * 操作 ok的\n    fn deref(&self) -&gt; &Self::Target {\n        &self.1\n    }\n}\n\nfn main() {\n    let x = 5;\n    let y = MyBox::new(x, 12);\n    // 如果没有实现 Deref trait, 那么 * 操作就会报错\n    println!(\"{}\", *y); // 12\n    // 显然 上面实现的 deref(&self)方法是 类型MyBox的方法,\n    // 所以可以 y.deref() 获取\n    println!(\"{}\", *(y.deref())); // 12\n}",
    "crumbs": [
      "基础篇",
      "智能指针"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/ptr.html#drop-trait",
    "href": "docs/programming/rust/basic/ptr.html#drop-trait",
    "title": "rust 智能指针",
    "section": "4 drop trait",
    "text": "4 drop trait\n\n相当于析构函数\n通过实现 Drop trait, 可以自定义值离开作用域时发生的事情(比如文件资源的释放).\n任何类型都可以实现这个 Drop trait\n\ndrop 一个 实现了copy的类型, 不会执行任何操作\n\n\nstruct CustomSmartPointer {\n    data: String,\n}\n// Drop 在预导入模块里, 所以不需要use\nimpl Drop for CustomSmartPointer {\n    // 参数是可变借用 &mut self\n    fn drop(&mut self) {\n        println!(\"Dropping CustomSmartPointer with data `{}`!\", self.data);\n    }\n}\n\nfn main() {\n    let a = CustomSmartPointer {\n        data: String::from(\"hello stuff\"),\n    };\n    // 无法显示的调用 drop 方法\n    // a.drop()\n    // 可以使用  std::mem::drop(a); 来提前调用\n    // drop(a);  这样就行了, 因为drop 是预导入模块里的\n    {\n        let c = CustomSmartPointer {\n            data: String::from(\"my stuff\"),\n        };\n    }// c 最先执行drop, 所以先打印 my stuff\n    let d = CustomSmartPointer {\n        data: String::from(\"other stuff\"),\n    };\n    println!(\"CustomSmartPointers created.\");\n}",
    "crumbs": [
      "基础篇",
      "智能指针"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/ptr.html#rct-引用计数智能指针",
    "href": "docs/programming/rust/basic/ptr.html#rct-引用计数智能指针",
    "title": "rust 智能指针",
    "section": "5 Rc<T> 引用计数智能指针",
    "text": "5 Rc&lt;T&gt; 引用计数智能指针\n\nRc = reference counting\nRc&lt;T&gt; 允许同一个数据有多个所有者\n当最后是0个引用,那么该值就会被清理\n员工下班了,谁离开了是不能随便就熄灯关门,是等只有最后一个人走了,才能熄灯关门,这种需求的时候我们就可以用这个 Rc&lt;T&gt; 类型\n通过不可变引用来共享数据,只读\n\nenum List {\n    Cons(i32, Box&lt;List&gt;),\n    Nil,\n}\n\nuse crate::List::{Cons, Nil};\n\nfn main() {\n    let a = Cons(5, Box::new(Cons(10, Box::new(Nil))));\n    let b = Cons(3, Box::new(a));\n    let c = Cons(4, Box::new(a)); // 报错了, a 被move了\n}\n使用 Rc&lt;T&gt; 就可以解决这个问题\nenum List {\n    Cons(i32, Rc&lt;List&gt;),\n    Nil,\n}\n\nuse crate::List::{Cons, Nil};\nuse std::rc::Rc;\n\nfn main() {\n    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));\n    println!(\"count after creating a = {}\", Rc::strong_count(&a)); //1\n    // Rc::clone() 只会使 引用计数+1, 不会进行深度 copy\n    // a.clone()  会进行深度copy\n    let b = Cons(3, Rc::clone(&a)); // a 的引用计数+1\n    println!(\"count after creating b = {}\", Rc::strong_count(&a)); //2\n     {\n        let d = Cons(4, Rc::clone(&a));\n        println!(\"count after creating d = {}\", Rc::strong_count(&a)); // 3\n    } // 这里d离开作用域,drop操作, 所以a的引用计数-1, 变为2\n    let c = Cons(4, Rc::clone(&a)); // a 的引用计数+1\n    println!(\"count after creating c = {}\", Rc::strong_count(&a)); // 3\n}",
    "crumbs": [
      "基础篇",
      "智能指针"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/ptr.html#refcellt",
    "href": "docs/programming/rust/basic/ptr.html#refcellt",
    "title": "rust 智能指针",
    "section": "6 RefCell<T>",
    "text": "6 RefCell&lt;T&gt;\n\n单线程内部使用\n数据所有者只有一个\n运行时检查\n\n报错了,因为你不能可变借用一个不可变的值\nfn main() {\n    let x = 5;\n    let y = &mut x;\n}\n有这样的需求, 我们希望该值对外部是不可变的, 对于它内部可以有方法来修改它的值.\nRefCell 就是能够可变借用一个原本不可变的值\nuse std::cell::RefCell;\n\nfn main() {\n    let shared_map = RefCell::new(vec![1, 2, 3]);\n    // 创建1个可变引用\n    let mut first_ref = shared_map.borrow_mut();\n    // 不允许多个可变借用同时存在\n    // let mut second_ref = shared_map.borrow_mut();\n\n    // 修改通过不可变引用获取的数据\n    first_ref.push(4);\n    println!(\"{:?}\", shared_map);\n}\nuse std::cell::RefCell;\n\nfn main() {\n    let c = RefCell::new(5);\n    // 多个不可变借用\n    let borrowed_five = c.borrow();\n    let borrowed_five2 = c.borrow();\n}\n\n每次 调用 .borrow() 方法, 不可变借用计数+1, 其返回值离开作用域,不可变计数-1\n每次调用 .borrow_mut() 方法, 可变借用计数+1,其返回值离开作用域,可变计数-1\n根据上面2点来检查借用规则, 只允许一个可变借用,或多个不可变借用",
    "crumbs": [
      "基础篇",
      "智能指针"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/ptr.html#rc-refcell-结合使用",
    "href": "docs/programming/rust/basic/ptr.html#rc-refcell-结合使用",
    "title": "rust 智能指针",
    "section": "7 Rc RefCell 结合使用",
    "text": "7 Rc RefCell 结合使用\n#[derive(Debug)]\nenum List {\n    Cons(Rc&lt;RefCell&lt;i32&gt;&gt;, Rc&lt;List&gt;),\n    Nil,\n}\n\nuse crate::List::{Cons, Nil};\nuse std::cell::RefCell;\nuse std::rc::Rc;\n\nfn main() {\n    let value = Rc::new(RefCell::new(5));\n\n    let a = Rc::new(Cons(Rc::clone(&value), Rc::new(Nil)));\n\n    let b = Cons(Rc::new(RefCell::new(3)), Rc::clone(&a));\n    let c = Cons(Rc::new(RefCell::new(4)), Rc::clone(&a));\n\n    *value.borrow_mut() += 10;\n\n    println!(\"a after = {:?}\", a);\n    println!(\"b after = {:?}\", b);\n    println!(\"c after = {:?}\", c);\n}",
    "crumbs": [
      "基础篇",
      "智能指针"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/ptr.html#引用循环",
    "href": "docs/programming/rust/basic/ptr.html#引用循环",
    "title": "rust 智能指针",
    "section": "8 引用循环",
    "text": "8 引用循环\n\n8.1 Rc\nuse crate::List::{Cons, Nil};\nuse std::cell::RefCell;\nuse std::rc::Rc;\n\n#[derive(Debug)]\nenum List {\n    Cons(i32, RefCell&lt;Rc&lt;List&gt;&gt;),\n    Nil,\n}\n\nimpl List {\n    fn tail(&self) -&gt; Option&lt;&RefCell&lt;Rc&lt;List&gt;&gt;&gt; {\n        // self: &Self\n        match self {\n            Cons(_, item) =&gt; Some(item),\n            Nil =&gt; None,\n        }\n    }\n}\n\nfn main() {\n    let a = Rc::new(Cons(5, RefCell::new(Rc::new(Nil))));\n\n    println!(\"a initial rc count = {}\", Rc::strong_count(&a)); // 1\n    println!(\"a next item = {:?}\", a.tail());\n    // b的下一个元素是a\n    let b = Rc::new(Cons(10, RefCell::new(Rc::clone(&a))));\n\n    println!(\"a rc count after b creation = {}\", Rc::strong_count(&a)); //2\n    println!(\"b initial rc count = {}\", Rc::strong_count(&b)); //1\n    println!(\"b next item = {:?}\", b.tail());\n\n    if let Some(link) = a.tail() {\n        // a的下一个元素是b, a和b 之间循环引用了.\n        *link.borrow_mut() = Rc::clone(&b); // b +1\n    }\n\n    println!(\"b rc count after changing a = {}\", Rc::strong_count(&b)); //2\n    println!(\"a rc count after changing a = {}\", Rc::strong_count(&a)); //2\n\n    // 栈溢出了, 因为打印 a.tail() ,就是要打印b, 而要完全打印b,就需要打印a的值,因为b的\"下一个元素\"是a\n    // println!(\"a next item = {:?}\", a.tail());\n} // 离开作用域, b 做引用计数-1操作,那么还有1个, 接着a离开作用域 引用计数-1,也是还剩1个. 这样2个都没被释放\n\n\n8.2 Weak\n\n强引用\n\nRc.clone 后rc的引用计数(strong_count)会+1, 实例只有在 strong_count=0,才会被释放\n\n弱引用\n\nRc::downgrade 会创建值的弱引用(weak_count+1),返回类型是 Weak\nweak_count不为0,不会影响值的释放\nstrong_ount为0, 弱引用会自动断开\n使用Weak前,需要确保它指向的值依然存在\n\n\nuse std::cell::RefCell;\nuse std::rc::{Rc, Weak};\n\n#[derive(Debug)]\nstruct Node {\n    value: i32,\n    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,\n    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,\n}\nfn main() {\n    let leaf = Rc::new(Node {\n        value: 3,\n        parent: RefCell::new(Weak::new()),\n        children: RefCell::new(vec![]),\n    });\n    println!(\n        \"leaf strong = {}, weak = {}\",\n        Rc::strong_count(&leaf),\n        Rc::weak_count(&leaf),\n    );\n    // upgrade: 从 Weak&lt;T&gt; 获取一个 Rc&lt;T&gt;\n    println!(\"leaf parent = {:?}\", leaf.parent.borrow().upgrade());\n\n    let branch = Rc::new(Node {\n        value: 5,\n        parent: RefCell::new(Weak::new()),\n        children: RefCell::new(vec![Rc::clone(&leaf)]),\n    });\n    *leaf.parent.borrow_mut() = Rc::downgrade(&branch);\n    println!(\n        \"branch strong = {}, weak = {}\",\n        Rc::strong_count(&branch),\n        Rc::weak_count(&branch),\n    );\n\n    println!(\n        \"leaf strong = {}, weak = {}\",\n        Rc::strong_count(&leaf), //2\n        Rc::weak_count(&leaf),\n    );\n\n    println!(\"leaf parent = {:?}\", leaf.parent.borrow().upgrade());\n    println!(\n        \"leaf strong = {}, weak = {}\",\n        Rc::strong_count(&leaf),\n        Rc::weak_count(&leaf),\n    );\n}",
    "crumbs": [
      "基础篇",
      "智能指针"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/expression.html",
    "href": "docs/programming/rust/basic/expression.html",
    "title": "rust 语句和表达式",
    "section": "",
    "text": "知识点回顾\n\n\n\n() 既是一种类型:单元类型, 也是一个值",
    "crumbs": [
      "基础篇",
      "语句和表达式"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/expression.html#概念",
    "href": "docs/programming/rust/basic/expression.html#概念",
    "title": "rust 语句和表达式",
    "section": "",
    "text": "知识点回顾\n\n\n\n() 既是一种类型:单元类型, 也是一个值",
    "crumbs": [
      "基础篇",
      "语句和表达式"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/expression.html#代码块表达式",
    "href": "docs/programming/rust/basic/expression.html#代码块表达式",
    "title": "rust 语句和表达式",
    "section": "2 {} 代码块表达式",
    "text": "2 {} 代码块表达式\n\n\n{}代码块表达式的值\n\nfn main() {\n    // {} 代码块 是有值的, 如果最后一个表达式后面有分号，那么整个代码块的值是 ()\n    // 所以我们可以将它赋值给变量, 注意最后 }后的分号 是表明这一整个是一个语句\n    // 可以说这个时候, {} 将语句变成了表达式,它的返回值是()\n    let a = {\n        let tmp = 2;\n    };\n    println!(\"a的值: {:?}\", a); // ()\n    let a = {\n        let tmp = 2;\n        5\n    };\n    println!(\"a的值: {:?}\", a); // 5\n}\n\n\n\n函数体\n\n// 函数的函数体 {} 这个就可以理解为 {}表达式\n// 所以现在可以理解能这些写\nfn test() -&gt; i32 {\n    let b = 2;\n    println!(\"{}\", b);\n    b\n}\n\n\n\n单独的{} 不带分号的情况\n\nfn test() -&gt; i32 {\n    {\n        let a = 1;\n        // 如果写了什么作为返回值, 就只能写 ()\n        // 当然我们不可能写类似这样的代码\n        // 因为这个{} 没有接收者\n        ()\n    }  //注意这里没有 ; \n    let b = 2;\n    b\n}\n\n\n\n单独的{}; 带分号的情况\n\nfn test() -&gt; i32 {\n    {\n        let a = 1;\n        \"aa\"  // 可以返回任何类型的值\n    };  // 当你加了 ; 后, 这{}; 是一个语句,\n        // 你可以理解为 将{} 表达式的值赋值给一个临时变量,\n        // 所以{} 里面可以返回任何值\n\n    let b = 2;\n    b\n}\nfn main(){}",
    "crumbs": [
      "基础篇",
      "语句和表达式"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/expression.html#赋值表达式",
    "href": "docs/programming/rust/basic/expression.html#赋值表达式",
    "title": "rust 语句和表达式",
    "section": "3 赋值表达式",
    "text": "3 赋值表达式\n\n\n赋值表达式的值\n\nfn main(){\n    let y;\n    // 赋值表达式 y=2, 我们知道表达式是有值的, 它的返回值是()\n    // let b = (y = 2); (y=2) 的括号可以省略,所以如下写法\n    let b = y = 2;\n    println!(\"y的值: {}\", y); // 2\n    println!(\"b的值: {:?}\", b); // ()\n    // 直接报错, 右边是个语句,没有返回值\n    // let a=(let z=2;);\n}\n\n\n\nif中使用赋值表达式\n\nfn main(){\n    let z;\n    // z=3 的返回值是() , 而 我们需要是的 bool类型\n    // 所以报错了.\n    if z = 3 {\n        println!(\"hello\");\n    }\n}",
    "crumbs": [
      "基础篇",
      "语句和表达式"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/expression.html#if-else-表达式",
    "href": "docs/programming/rust/basic/expression.html#if-else-表达式",
    "title": "rust 语句和表达式",
    "section": "4 if else 表达式",
    "text": "4 if else 表达式\n\n\n\n\n\n\nNote\n\n\n\n\n当成三元运算, 实际上这种方式更加的易于理解,可读性好\n三元运算,本身需要重新学习,时间一长,可能忘记了逻辑, 而if else天生就不会忘记\n这也是有些语言为什么不设计三元表达式的原因\n\n\n\nfn main() {\n    let x = 1;\n    let is_one = if x == 1 { true } else { false };\n    println!(\"{}\", is_one);\n}",
    "crumbs": [
      "基础篇",
      "语句和表达式"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/struct.html",
    "href": "docs/programming/rust/basic/struct.html",
    "title": "rust 结构体",
    "section": "",
    "text": "C struct\n\n#[derive(Debug)]\nstruct User {\n    active: bool,\n    username: String,\n    email: String,\n    sign_in_count: u64,\n}\n\nfn main() {\n    let mut u = build_user(\"username123\".to_string(), \"someone@example.com\".to_string());\n\n    println!(\"{}\", u.email);\n    u.active = false;\n    println!(\"{}\", u);\n\n    let u1 = build_user(\"u1@hotmail\".to_string(), \"u1\".to_string());\n    let u2 = User {\n        email: String::from(\"u2@hotmail\"),\n        // 作为 base struct 必须放在最后, 否则是报错的\n        // base struct 会使用剩余没设置值的字段\n        // 所以注意这里u1 的 name被move 进来了.\n        ..u1\n    };\n    println!(\"{:?}\", u2);\n    println!(\"{:#?}\", u2); // 更加直观的打印\n\n    // 因为u1.name 被move 了,所以会报错\n    // println!(\"{:?}\", u1); \n    println!(\"{:?}\", u1.email); // email 还是可以打印的.\n\n}\nfn build_user(email: String, username: String) -&gt; User {\n    User { // 每个字段都必须设置值, 否则报错\n        active: true,\n        username, //  如果和结构体的字段同名, 可以直接这样简化写法\n        email,    //  \n        sign_in_count: 1,\n    }\n}\n\n\n\n\n\n\n\n\n\nTip\n\n\n\n\ntuple struct\n只有字段的类型,没有name\n\n\n\n// 虽然元素类型一样, 但是2个结构体是不同的类型\nstruct Color(i32, i32, i32);\nstruct Point(i32, i32, i32);\n\nfn main() {\n    let black = Color(0, 0, 0);\n    let origin = Point(0, 0, 0);\n    // 同元祖访问\n    println!(\"{}\", black.0);\n}\n\n\n\nunit struct, 没有字段的结构体\n\nstruct AlwaysEqual;\n\nfn main() {\n    // 实例化了\n    let subject = AlwaysEqual;\n}",
    "crumbs": [
      "基础篇",
      "结构体"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/struct.html#三种形式",
    "href": "docs/programming/rust/basic/struct.html#三种形式",
    "title": "rust 结构体",
    "section": "",
    "text": "C struct\n\n#[derive(Debug)]\nstruct User {\n    active: bool,\n    username: String,\n    email: String,\n    sign_in_count: u64,\n}\n\nfn main() {\n    let mut u = build_user(\"username123\".to_string(), \"someone@example.com\".to_string());\n\n    println!(\"{}\", u.email);\n    u.active = false;\n    println!(\"{}\", u);\n\n    let u1 = build_user(\"u1@hotmail\".to_string(), \"u1\".to_string());\n    let u2 = User {\n        email: String::from(\"u2@hotmail\"),\n        // 作为 base struct 必须放在最后, 否则是报错的\n        // base struct 会使用剩余没设置值的字段\n        // 所以注意这里u1 的 name被move 进来了.\n        ..u1\n    };\n    println!(\"{:?}\", u2);\n    println!(\"{:#?}\", u2); // 更加直观的打印\n\n    // 因为u1.name 被move 了,所以会报错\n    // println!(\"{:?}\", u1); \n    println!(\"{:?}\", u1.email); // email 还是可以打印的.\n\n}\nfn build_user(email: String, username: String) -&gt; User {\n    User { // 每个字段都必须设置值, 否则报错\n        active: true,\n        username, //  如果和结构体的字段同名, 可以直接这样简化写法\n        email,    //  \n        sign_in_count: 1,\n    }\n}\n\n\n\n\n\n\n\n\n\nTip\n\n\n\n\ntuple struct\n只有字段的类型,没有name\n\n\n\n// 虽然元素类型一样, 但是2个结构体是不同的类型\nstruct Color(i32, i32, i32);\nstruct Point(i32, i32, i32);\n\nfn main() {\n    let black = Color(0, 0, 0);\n    let origin = Point(0, 0, 0);\n    // 同元祖访问\n    println!(\"{}\", black.0);\n}\n\n\n\nunit struct, 没有字段的结构体\n\nstruct AlwaysEqual;\n\nfn main() {\n    // 实例化了\n    let subject = AlwaysEqual;\n}",
    "crumbs": [
      "基础篇",
      "结构体"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/struct.html#方法和关联函数",
    "href": "docs/programming/rust/basic/struct.html#方法和关联函数",
    "title": "rust 结构体",
    "section": "2 方法和关联函数",
    "text": "2 方法和关联函数\n#[derive(Debug)]\nstruct Rectangle {\n    width: u32,\n    height: u32,\n}\n// impl 块里的所有东西都和 Rectangle 类型产生关联\nimpl Rectangle {\n    // 第一个参数是 &self 是 self: &Self的简写, 是不可变借用\n    // 如果想用 所有权的, 就 用 self 是 self: Self的简写\n    // 如果想用可变借用 就用&mut self 是self: &mut Self 的简写\n    // 调用方法实际上是将调用者作为第一个参数传递给方法\n    fn area_borrows_immutably(&self) -&gt; u32 {\n        println!(\" width... {}\", (*self).width);\n        self.width * self.height\n    }\n\n    fn area_move(self) -&gt; u32 {\n        println!(\" width... {}\", self.width);\n        self.width * self.height\n    }\n    fn area_borrows_mutably(&mut self) -&gt; u32 {\n        println!(\" width... {}\", (*self).width);\n        self.width * self.height\n    }\n\n    fn change_width(&mut self, width: u32) {\n        self.width = width;\n    }\n\n    // 关联函数\n    // 例子: 正方形 ,这里没有用到 &self 作为第一个参数\n    fn square(size: u32) -&gt; Self {\n        Self {\n            width: size,\n            height: size,\n        }\n    }\n    // rust没有专门的构造函数,需要自己定义,我们一般用new 这个方法名,\n    pub fn new(width: u32, height: u32) -&gt; Self {\n        Rectangle {\n            width,\n            height,\n        }\n    }\n}\n\nfn main() {\n    let rect1 = Rectangle {\n        width: 30,\n        height: 50,\n    };\n    println!(\"{}\", rect1.area_borrows_immutably());  // &lt;1&gt;\n    println!(\"{:?}\", rect1);\n    println!(\"{}\", rect1.area_move());\n    // 报错, move掉了, 说明 我们的结构体是move 属性的,\n    // println!(\"{:?}\", rect1);\n    let mut rect1 = Rectangle {\n        width: 30,\n        height: 50,\n    };\n    println!(\"{}\", rect1.area_borrows_mutably());\n\n    let mut rect2 = Rectangle {\n        width: 30,\n        height: 50,\n    };\n    // 调用的时候根据方法的第一个参数类型,会自动转为 比如 可变借用\n    rect2.change_width(35);\n    println!(\"{}\", rect2.area_borrows_immutably());\n\n    // 这样的方式调用\n    let r = &mut rect2;\n    Rectangle::change_width(r, 40);\n    println!(\"{}\", r.height);\n    println!(\"{}\", rect2.area_borrows_immutably());\n\n    // 使用 :: 来调用\n    let sq = Rectangle::square(3);\n    println!(\"{}\", sq.area_borrows_immutably());\n}\n\nrect1.area_borrows_immutably()这个其实只是语法糖, 实际上是Rectangle::area_borrows_immutably(&rect1)",
    "crumbs": [
      "基础篇",
      "结构体"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/collection.html",
    "href": "docs/programming/rust/basic/collection.html",
    "title": "rust 集合",
    "section": "",
    "text": "Tip\n\n\n\n\n只能存储相同类型的数据\n在内存中连续存放\n容量可以在执行过程中动态扩大和缩放\n\n既然是动态的,那么它必定是要在堆上分配的.\n\n\n\n\n\n\nfn main() {\n    // 第一种方式,存放的类型是i32,\n    // 也可以不指定是什么类型的(去掉Vec&lt;i32&gt;),push 后 就推断出什么类型了\n    let mut v: Vec&lt;i32&gt; = Vec::new();\n    // 添加\n    v.push(5);\n    v.push(6);\n    // 第二种定义方式\n    // 宏等价于调用 Vec::new 创建一个新的空 vector，然后向其中添加元素\n    let mut y=vec![1,2,3,4,5];\n    // 第三种 通过迭代器创建\n    let v: Vec&lt;i32&gt; = (0..5).collect();\n    println!(\"{:?}\", v);\n    // 第四中 设置 capacity\n    let mut v = Vec::with_capacity(5);\n    v.push(1);\n    println!(\"{}-{}\", v.capacity(), v.len());\n\n    // 插入和删除\n    let mut v = vec![10, 20, 30, 40, 50];\n    // 在索引为 3的地方插入 35\n    v.insert(3, 35);\n    assert_eq!(v, [10, 20, 30, 35, 40, 50]);\n    // 移除索引为 1的元素\n    v.remove(1);\n    assert_eq!(v, [10, 30, 35, 40, 50])\n}\n\n\n\n#[test]\nfn test() {\n    let v = vec![1, 2, 3, 4, 5];\n\n    let third: &i32 = &v[2];\n    println!(\"The third element is {third}\");\n\n    // get的返回类型是  Option\n    let third: Option&lt;&i32&gt; = v.get(2);\n    match third {\n        Some(third) =&gt; println!(\"The third element is {third}\"),\n        None =&gt; println!(\"There is no third element.\"),\n    }\n}\n越界,报错\n#[test]\nfn test() {\n    let v = vec![1, 2, 3, 4, 5];\n    // 会直接panic: index out of bounds\n    let does_not_exist = &v[100];\n    // 这个不会报错\n    let does_not_exist = v.get(100);\n}\n\n\n\nenum SpreadsheetCell {\n    Int(i32),\n    Float(f64),\n    Text(String),\n}\nfn main() {\n    let row = vec![\n        SpreadsheetCell::Int(3),\n        SpreadsheetCell::Text(String::from(\"blue\")),\n        SpreadsheetCell::Float(10.12),\n    ];\n}\n\n\n\n#[test]\nfn test() {\n    let v = vec![100, 32, 57];\n    // 不可变借用 遍历\n    for i in &v {\n        println!(\"{i}\");\n    }\n\n    let mut v2 = vec![100, 32, 57];\n    // 可变借用,然后修改元素\n    for i in &mut v2 {\n        *i += 50;\n    }\n    println!(\"{:?}\", v2)\n}",
    "crumbs": [
      "基础篇",
      "集合"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/collection.html#vector",
    "href": "docs/programming/rust/basic/collection.html#vector",
    "title": "rust 集合",
    "section": "",
    "text": "Tip\n\n\n\n\n只能存储相同类型的数据\n在内存中连续存放\n容量可以在执行过程中动态扩大和缩放\n\n既然是动态的,那么它必定是要在堆上分配的.\n\n\n\n\n\n\nfn main() {\n    // 第一种方式,存放的类型是i32,\n    // 也可以不指定是什么类型的(去掉Vec&lt;i32&gt;),push 后 就推断出什么类型了\n    let mut v: Vec&lt;i32&gt; = Vec::new();\n    // 添加\n    v.push(5);\n    v.push(6);\n    // 第二种定义方式\n    // 宏等价于调用 Vec::new 创建一个新的空 vector，然后向其中添加元素\n    let mut y=vec![1,2,3,4,5];\n    // 第三种 通过迭代器创建\n    let v: Vec&lt;i32&gt; = (0..5).collect();\n    println!(\"{:?}\", v);\n    // 第四中 设置 capacity\n    let mut v = Vec::with_capacity(5);\n    v.push(1);\n    println!(\"{}-{}\", v.capacity(), v.len());\n\n    // 插入和删除\n    let mut v = vec![10, 20, 30, 40, 50];\n    // 在索引为 3的地方插入 35\n    v.insert(3, 35);\n    assert_eq!(v, [10, 20, 30, 35, 40, 50]);\n    // 移除索引为 1的元素\n    v.remove(1);\n    assert_eq!(v, [10, 30, 35, 40, 50])\n}\n\n\n\n#[test]\nfn test() {\n    let v = vec![1, 2, 3, 4, 5];\n\n    let third: &i32 = &v[2];\n    println!(\"The third element is {third}\");\n\n    // get的返回类型是  Option\n    let third: Option&lt;&i32&gt; = v.get(2);\n    match third {\n        Some(third) =&gt; println!(\"The third element is {third}\"),\n        None =&gt; println!(\"There is no third element.\"),\n    }\n}\n越界,报错\n#[test]\nfn test() {\n    let v = vec![1, 2, 3, 4, 5];\n    // 会直接panic: index out of bounds\n    let does_not_exist = &v[100];\n    // 这个不会报错\n    let does_not_exist = v.get(100);\n}\n\n\n\nenum SpreadsheetCell {\n    Int(i32),\n    Float(f64),\n    Text(String),\n}\nfn main() {\n    let row = vec![\n        SpreadsheetCell::Int(3),\n        SpreadsheetCell::Text(String::from(\"blue\")),\n        SpreadsheetCell::Float(10.12),\n    ];\n}\n\n\n\n#[test]\nfn test() {\n    let v = vec![100, 32, 57];\n    // 不可变借用 遍历\n    for i in &v {\n        println!(\"{i}\");\n    }\n\n    let mut v2 = vec![100, 32, 57];\n    // 可变借用,然后修改元素\n    for i in &mut v2 {\n        *i += 50;\n    }\n    println!(\"{:?}\", v2)\n}",
    "crumbs": [
      "基础篇",
      "集合"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/collection.html#hashmap",
    "href": "docs/programming/rust/basic/collection.html#hashmap",
    "title": "rust 集合",
    "section": "2 hashmap",
    "text": "2 hashmap\nuse std::collections::HashMap;\nfn main() {\n    // 如果仅仅只有这个语句, 则会报错,因为编译器无法知道数据类型,就无法分配内存了\n    // let mut s = HashMap::new();\n    // 这样就不会了\n    let mut scores: HashMap&lt;String, i32&gt; = HashMap::new();\n    // 插入元素\n    scores.insert(String::from(\"Blue\"), 10);\n    scores.insert(String::from(\"Yellow\"), 50);\n\n    // 读取\n    let team_name = String::from(\"Blue2\");\n    // get() 返回 类型是Option&lt;&V&gt;,没有的话就是 返回 None\n    // copied() 将 返回的Option&lt;&i32&gt; 变成 Option&lt;i32&gt;\n    // unwrap_or(0)  表示如果该key ,则返回一个 0\n    let score = scores.get(&team_name).copied().unwrap_or(2);\n    println!(\"{}\", score);\n\n    // 遍历\n    for (key, value) in &scores {\n        println!(\"{key}: {value}\");\n    }\n\n    // 更新元素, 还是用insert 会覆盖\n    scores.insert(String::from(\"Blue\"), 12);\n\n    // key Yellow 不存在,才添加\n    // 返回一个value的可变借用\n    scores.entry(String::from(\"Yellow\")).or_insert(50);\n\n    let text = \"hello world wonderful world\";\n    let mut map = HashMap::new();\n    for word in text.split_whitespace() {\n        // 第一次 word  key 不存在的时候, 插入 0, 返回value的可变借用\n        // 下面的操作才会是  *count +=1\n        // 第二次来, 存在, 返回旧 value 的可变借用 ,后面 还是 *count +=1\n        let count = map.entry(word).or_insert(0);\n        *count += 1;\n    }\n\n    println!(\"{:?}\", map);\n    println!(\"{:#?}\",map); // 格式化打印\n}\n所有权\nuse std::collections::HashMap;\nfn main() {\n    let field_name = String::from(\"Favorite color\");\n    let field_value = String::from(\"Blue\");\n\n    let mut map = HashMap::new();\n    map.insert(field_name, field_value);\n    //  field_name, field_value  已经被move 了. 报错了. 看值的类型\n    // println!(\"{}-{}\", field_name, field_value);\n}",
    "crumbs": [
      "基础篇",
      "集合"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/collection.html#字符串",
    "href": "docs/programming/rust/basic/collection.html#字符串",
    "title": "rust 集合",
    "section": "3 字符串",
    "text": "3 字符串\n\n\n\n\n\n\n\n\nImportant\n\n\n\nrust中字符串默认编码是utf-8,是变长的, 字母ab这些是一个字节, 中文3个字节\n\n\n字符串相关的几种定义\n\n\n3.1 str\nfn main(){\n    let a = \"abc\";\n    let b = \"hello\";\n}\n\n我们可以得到这个a和b的类型是 &str,在没有学习切片前,仅从这个类型名称看,我们可以推断 &str 是一个指向字符串字面量的指针.\n既然是 &这个操作, 那么*a 指向的类型似乎就是str了,a和b指向的str类型占用的空间不同,这样说来str类型的长度是可变的.\n所以我们无法在代码中直接使用str类型, 因为编译期间需要确定变量的大小.\n那么不难推断出&str这种引用可变长度类型的类型, 除了有指针指向str外, 还必须有一个信息来存储你引用的长度.\n\n\n\n3.2 &str\n字符串切片: 只是对一块内存空间的借用,无所有权\nuse std::mem;\nfn main() {\n    // 字符切片 &str , abc 这个是 字符串字面量\n    let x = \"abc\";\n    println!(\n        \"x指向的字符串实际地址:{:p}--长度:{}--占用字节数: {}\",\n        x.as_ptr(),\n        x.len(),\n        mem::size_of_val(&x)\n    );\n    let y: &'static str = \"abc\";\n    println!(\n        \"y指向的字符串实际地址:{:p}--长度:{}--占用字节数: {}\",\n        y.as_ptr(),\n        y.len(),\n        mem::size_of_val(&y)\n    );\n    // 字符串 String\n    let z = String::from(x);\n    println!(\"z指向的字符串的地址:{:p}\", z.as_ptr());\n    let s = String::from(\"hello world\");\n    // 字符串切片\n    let s2 = &s[0..4]; // s2 内容是 \"hell\"\n    println!(\"String s:{:p}\", s.as_ptr());\n    println!(\"&str s2:{:p}\", s2.as_ptr());\n    println!(\"{s}-{s2}\");\n}\n看看是否能修改\nfn main() {\n    // 会直接提示不需要mut\n    let mut a = \"abc\";\n    // let mut a = \"abc\".to_string();\n    let b = a.as_ptr() as *mut i8;\n    unsafe {\n        println!(\"11\");\n        *b = 98; // 修改字符串内容\n        println!(\"22\"); // 上一步无法成功执行,但是没报错, 这里不会执行打印\n    }\n    println!(\"x{}\", a);\n}\nfn main() {\n    // 不会转义, 原样输出\n    let a = r\"\\a\\b\";\n    println!(\"{}\", a);\n    println!(\n        r#\"hello\nworld \\n ('\"')\n\"#\n    )\n}\n\n\n3.3 String\n字符串:有这块内存空间的所有权\n是一种集合类型,所以前面集合类型的操作也适用\n\n\n\n\n\n\nImportant\n\n\n\n函数参数用 &str, 结构体成员图方便的话,可以直接用 String\n\n\n\n3.3.1 基础操作\nuse std::mem;\nfn main() {\n    let s1 = \"hello\".to_string();\n    // 空字符串\n    let s2 = String::new();\n    let s3 = \" world\".to_string();\n    // + 法 , 第二个变量 要是 字符串的借用\n    let c = s1 + &s3; //s1 被move 了\n    println!(\"{}\", c);\n\n    // format! 宏 来拼接字符串, 类似 println! ,只不过返回结果,不打印\n    let s1 = String::from(\"tic\");\n    let s2 = String::from(\"tac\");\n    let s3 = String::from(\"toe\");\n    // let s = s1 + \"-\" + &s2 + \"-\" + &s3;\n    let s = format!(\"{s1}-{s2}-{s3}\");\n    println!(\"{}-{}-{}\", s1, s2, s3); // 都可用\n\n    let mut x = String::from(\"abc\");\n    println!(\"{:p}\", &x);\n    println!(\"{}\", mem::size_of_val(&x));\n    x.push_str(\"我们\");\n    println!(\"{}\", x);\n    println!(\"{}\", mem::size_of_val(&x));\n    println!(\"{:?}-{}-{}\", x.as_ptr(), x.len(), x.capacity());\n    x.pop();\n    println!(\"{:?}-{}-{}\", x.as_ptr(), x.len(), x.capacity());\n    x.push('x');\n    println!(\"{:?}-{}-{}\", x.as_ptr(), x.len(), x.capacity());\n    // cap 这个显示的值和 内部实际预留空间,应该是不同, 参考go的设计\n    x.push_str(\"hello world python golang rust c++ c# java php\");\n    println!(\"{:?}-{}-{}\", x.as_ptr(), x.len(), x.capacity());\n}\n\n\n3.3.2 切片\nfn main() {\n    let s = String::from(\"hello\");\n    // [start_index..end_index]\n    let slice1 = &s[0..2];\n    let slice2 = &s[..2]; // 同上\n    println!(\"{}-{}\", slice1, slice2);\n\n    let len = s.len();\n\n    let slice3 = &s[3..len];\n    let slice4 = &s[3..]; //同上\n    println!(\"{}-{}\", slice3, slice4);\n\n    let slice5 = &s[0..len];\n    let slice6 = &s[..]; // 同上\n    println!(\"{}-{}\", slice5, slice6);\n}\n\n\n通过可变借用的切片,对原String进行修改\n\nfn main() {\n    let mut a = \"abc\".to_string();\n    let b = &mut a[..];\n    // 我们无法通过b对原a String进行添加字符的操作\n    // 因为我们只是可变借用了原String的一部分\n    b.make_ascii_uppercase(); // 将 a 的内容转换为大写\n    println!(\"{}\", a);\n}\n\n\n\n3.3.3 索引操作?\nString 类型无法进行 索引操作\nfn main() {\n    let s1 = String::from(\"hello\");\n    let h = s1[0]; // 报错\n}\n\n\n使用这种方式来\n\nfn main() {\n    let s1 = String::from(\"he我ll们o\");\n    // 这种查找 复杂度 O(n) , 每个\"字\" 占用空间不同, 需要先解析出一个个\"字\"\n    let h = s1.chars().nth(0);\n    let i = s1.chars().nth(2);\n    println!(\"{:?}\", h); // Some('h')\n    println!(\"{:?}\", i); // Some('我')\n}\n\n\n\n3.3.4 三种方式读取\nString 类型是对 Vec[u8]的一种包装\nfn main() {\n    let s1 = String::from(\"नमस्ते\");\n    println!(\"{}\", s1.len());\n    // 1. 以字节(byte) 的形式\n    for b in s1.bytes() {\n        println!(\"{b}\");\n    }\n    // 2. 以unicode 标量值(scalar values)的形式\n\n    // 打印了 每一个字(或字母)\n    for c in \"hello我们\".chars() {\n        println!(\"{}\", c);\n    }\n    // 但是 这个好像不对了,\n    // .chars()  用unicode 编码的方式来读取,按理说应该能读取到想要的字才对\n    // 毕竟 unicode 编码了全世界的字符(每个字符都有对应的unicode编码)\n    // 原因是 梵文中的某些字符可能由多个Unicode标量值组成，这些标量值在视觉上被视为一个整体\n    // 所以 这里只打印了 \"真正字符\"的一部分\n    for c in s1.chars() {\n        println!(\"{}\", c);\n    }\n    println!(\"=============\");\n    // 3. 获取真正更接近 字母的 字形簇 (grapheme clusters)\n    // 需要添加 第三方crate: cargo add unicode_segmentation\n    use unicode_segmentation::UnicodeSegmentation;\n    for grapheme in s1.graphemes(true) {\n        println!(\"{}\", grapheme);\n    }\n}\n\n\n\n3.4 单字节字符字面量\n\n\n\n\n\n\nTip\n\n\n\n\n这个实际是单字节数组\nchar 是 字符字面量, 一个字符是4个字节\n\n\n\nuse std::any::type_name;\n\nfn print_type_of&lt;T&gt;(_: &T) {\n    println!(\"{}\", type_name::&lt;T&gt;());\n}\nfn main() {\n    let a = b\"hello\";\n    // &[u8; 5]  结果发现是 [u8;5] 这种数组的引用\n    print_type_of(&a);\n    let b = a as &[u8]; // 转切片\n}\n\n\n3.5 通过切片计算实际指向的字符串占用的字节大小\nfn main() {\n    let s1 = String::from(\"hello我们\");\n    // 方法1：使用 std::mem::size_of_val()\n    println!(\n        \"s1 实际指向的字符串内容占用的内存大小: {} 字节\",\n        // s1.as_str()  &String 转为 &str 字符串切片\n        std::mem::size_of_val(s1.as_str()) //11  hello=5个字节, 我们=6个字节\n    );\n    // s1 字符串变量 占用空间大小 24\n    println!(\"字符串变量s1占用内存大小: {}\", std::mem::size_of_val(&s1));\n    let a = [1, 2, 3];\n    let b = &a; // b 数组 的指针, 就是 8个字节\n    println!(\"数组指针的大小(b的大小): {}\", std::mem::size_of_val(&b));\n    let c = b as &[i32]; // 数组指针转换为 切片\n    println!(\"数组切片占用空间(c的大小): {}\", std::mem::size_of_val(&c)); // 16 胖指针 ,没毛病\n    println!(\n        \"切片指向的内容(这里刚好是整个数组内容)实际占用的空间: {}\",\n        std::mem::size_of_val(c)\n    ); // 12 ,3个i32 =12\n    let d = &a[1..2];\n    // size_of_val(指针) =&gt; 计算指针指向的 内容占用内存大小\n    // &[T]或 &str 这种 切片, 指向的是 不定长的类型 [T] 或 str,所以是计算他们占用的空间\n    println!(\"切片指向的内容占用的空间: {}\", std::mem::size_of_val(d)); // 8 ,2个i32\n}",
    "crumbs": [
      "基础篇",
      "集合"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/iterator.html",
    "href": "docs/programming/rust/basic/iterator.html",
    "title": "rust 迭代器iterator",
    "section": "",
    "text": "什么是迭代器?\n\n\n\n\n迭代器是一个可以帮助你逐个访问集合（比如数组、列表或者其他数据结构）中元素的“指针”或者“工具”.\n获取一个集合的迭代器后,你就拥有了可以逐个访问它的元素的能力\n\n\n\n\n\n\n\n\n\n怎么设计?\n\n\n\n\n只要给一个类型实现了能够逐个获取元素的能力, 它可以说就实现了迭代器\ntrait 作为有可以共享代码的机制非常合适\n设计这样一个trait\n\n里面有一个需要实现的方法next(),功能就是上面提到的逐个获取元素的能力\n再设置一些默认的方法, 他们调用了next方法,做对应的功能处理,功能就共享给了所有实现该trait的类型\n\n只要类型实现了该next方法就可以了\n\n\n\n所有迭代器都实现了 iterator trait\n\n\nIterator trait 在标准库中的定义\n\npub trait Iterator {\n    type Item;\n\n    fn next(&mut self) -&gt; Option&lt;Self::Item&gt;;\n\n    // 其他方法都有默认实现\n}",
    "crumbs": [
      "基础篇",
      "迭代器"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/iterator.html#原理",
    "href": "docs/programming/rust/basic/iterator.html#原理",
    "title": "rust 迭代器iterator",
    "section": "",
    "text": "什么是迭代器?\n\n\n\n\n迭代器是一个可以帮助你逐个访问集合（比如数组、列表或者其他数据结构）中元素的“指针”或者“工具”.\n获取一个集合的迭代器后,你就拥有了可以逐个访问它的元素的能力\n\n\n\n\n\n\n\n\n\n怎么设计?\n\n\n\n\n只要给一个类型实现了能够逐个获取元素的能力, 它可以说就实现了迭代器\ntrait 作为有可以共享代码的机制非常合适\n设计这样一个trait\n\n里面有一个需要实现的方法next(),功能就是上面提到的逐个获取元素的能力\n再设置一些默认的方法, 他们调用了next方法,做对应的功能处理,功能就共享给了所有实现该trait的类型\n\n只要类型实现了该next方法就可以了\n\n\n\n所有迭代器都实现了 iterator trait\n\n\nIterator trait 在标准库中的定义\n\npub trait Iterator {\n    type Item;\n\n    fn next(&mut self) -&gt; Option&lt;Self::Item&gt;;\n\n    // 其他方法都有默认实现\n}",
    "crumbs": [
      "基础篇",
      "迭代器"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/iterator.html#获取迭代器",
    "href": "docs/programming/rust/basic/iterator.html#获取迭代器",
    "title": "rust 迭代器iterator",
    "section": "2 获取迭代器",
    "text": "2 获取迭代器\nlet v1 = vec![1, 2, 3];\n// 仅仅定义而没有使用它, 这样不会有任何的消耗\n// 看ide的提示信息\nv1.iter();\nlet v1_iter = v1.iter();\n\n对原数据的不可变借用对原数据的可变借用对原数据获取了所有权\n\n\nfn main() {\n    let v1 = vec![1, 2, 3];\n\n    // v1_iter 本身取得的是 v1元素的不可变借用\n    let v1_iter = v1.iter();\n\n    // 这个mut 表示 该迭代器是可变的.\n    let mut v1_iter = v1.iter();\n    if let Some(b) = v1_iter.next() {\n        println!(\"{}\", b); // 1\n    }\n    // 结果是: Iter([2, 3]), 这下能理解为啥上面需要 mut v1_iter\n    // 因为 next 方法会消耗 迭代器, 迭代器改变了\n    println!(\"{:?}\", v1_iter);\n    // 继续调用next ,继续消耗迭代器\n    v1_iter.next();\n    v1_iter.next();\n    if let None = v1_iter.next() {\n        println!(\"没有元素后再调用next 返回None\");\n    }\n    //结果是 Iter([])\n    println!(\"{:?}\", v1_iter);\n    v1_iter.next(); // 不会报错\n    println!(\"{:?}\", v1_iter);\n\n    let v1 = vec![1, 2, 3];\n    let v1_iter = v1.iter();\n    // for循环 会取得v1_iter的所有权\n    // 底层是调用了 next() 方法\n    for val in v1_iter {\n        println!(\"{}\", val);\n        //  v1_iter 已经被move了, 报错\n        println!(\"{:?}\", v1_iter);\n    }\n}\n\n\nfn main() {\n    let mut v1 = vec![1, 2, 3];\n    // 取得v1的可变借用的迭代器\n    let v1_iter = v1.iter_mut();\n    println!(\"{:?}\", v1_iter);\n    let v11 = v1_iter.map(|x| {\n        *x = *x + 1; // 修改v1元素的值,每个元素+1\n        *x + 1\n    });\n    println!(\"{:?}\", v11.collect::&lt;Vec&lt;_&gt;&gt;()); //  [3, 4, 5]\n    println!(\"{:?}\", v1); //[2, 3, 4]\n\n}\n\n\nfn main() {\n    let v1 = vec![1, 2, 3];\n    // v1.into_iter 看into_iter源码 impl&lt;T, A: Allocator&gt; IntoIterator for Vec&lt;T, A&gt;\n    // 我们平常都写Vec&lt;i32&gt; 这种, 第二个参数一般省略,A表示使用默认的用于存储向量元素的分配器\n    // 所以实际是调用 Vec::&lt;i32&gt;::into_iter(v1)\n    // 而 v1 是 move 型的类型\n    let v1_iter = v1.into_iter();\n    // println!(\"{:?}\", v1);  // 报错了, 提示已经被move\n    println!(\"{:?}\", v1_iter2); // IntoIter([1, 2, 3])\n}",
    "crumbs": [
      "基础篇",
      "迭代器"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/iterator.html#使用适配器",
    "href": "docs/programming/rust/basic/iterator.html#使用适配器",
    "title": "rust 迭代器iterator",
    "section": "3 使用适配器",
    "text": "3 使用适配器\n\n\n\n\n\n\n什么是适配器?\n\n\n\n\n通过将原有数据进行转换调整以达到符合我们需求的一种”设备”\nrust上来讲就是迭代器iterator trait上定义的一些方法,用于对迭代器中可处理的数据进行操作\n\n\n\n\n3.1 适配器的类别\n\n\n\n\n\n\nTip\n\n\n\n\n消耗型适配器: 前面章节中我们使用的 next() 就是消耗型\n迭代器适配器: 它不会消耗迭代器,相反它是产生一个新的迭代器\n\n\n\n\n\n迭代器适配器\n\nfn main() {\n    let v1 = vec![1, 2, 3];\n    let v1_iter = v1.iter();\n    // Iterator::map(self, f), 源码第一个参数是Self\n    // 所以实际是 Iterator::map(v1_iter,|x|*x+1)\n    // 迭代器是结构体, 是move类型\n    let v1_new_iter = v1_iter.map(|x| *x + 1);\n    //报错了. v1_iter 已经被move了,被 获取了所有权\n    println!(\"{:?}\", v1_iter);\n}\n\n\n\n消耗型适配器collect\n\nfn main() {\n    let  v1 = vec![1, 2, 3];\n    let v1_iter = v1.iter();\n    let v1_new_iter = v1_iter.map(|x| *x + 1);\n    // let data = v1_new_iter.collect::&lt;Vec&lt;_&gt;&gt;();\n    let data: Vec&lt;_&gt; = v1_new_iter.collect();\n    // 报错, collect 会消耗迭代器然后创建一个 vector 来保存数据\n    // 提示被move了\n    println!(\"{:?}\", v1_new_iter);\n    println!(\"{:?}\", data);\n\n\n\n3.2 常用适配器\n\n3.2.1 sum\nfn main() {\n    let v1 = vec![1, 2, 3];\n\n    let v1_iter = v1.iter();\n    let total: i32 = v1_iter.sum();\n    println!(\"{total}\");\n    // 调用sum 会获取v1_iter的所有权,所以报错了,提示move掉了\n    // println!(\"{:?}\", v1_iter);\n}\n\n\n3.2.2 zip\nfn main() {\n    let a = [1, 2, 3];\n    let b = ['a', 'b', 'c'];\n    // [(1, 'a'), (2, 'b'), (3, 'c')]\n    let r=a.iter().zip(b.iter()).collect::&lt;Vec&lt;_&gt;&gt;();\n    println!(\"{:?}\", r);\n}\n\n\n3.2.3 map\n\n源码定义.iter()下map里使用的闭包参数类型.into_iter()下.iter_mut()下\n\n\nfn map&lt;B, F&gt;(self, f: F) -&gt; Map&lt;Self, F&gt;\n    where\n        Self: Sized,\n        F: FnMut(Self::Item) -&gt; B,\n    {\n        Map::new(self, f)\n    }\n\n\nuse std::any::type_name;\n\nfn print_type_of&lt;T&gt;(_: &T) {\n    println!(\"{}\", type_name::&lt;T&gt;());\n}\nfn main() {\n    let v1 = vec![1, 2, 3];\n    for i in &v1 {\n        print_type_of(&i); // i 的类型是 &i32\n        println!(\"{}\", *i);\n    }\n    let mut v1_iter = v1.iter();\n    if let Some(b) = v1_iter.next() {\n        print_type_of(&b); // &i32\n    }\n    println!(\"{:?}\", v1);\n    let v1_iter = v1.iter();\n    // map 里闭包捕获的 v1的元素 是 &i32 类型\n    // 然后我们再看map的源码\n    // Iterator::map(self, FnMut(Self::Item) -&gt; B),\n    // 所以首先 v1_iter被move 了,失效了\n    // v1_iter.next() 得到的每个 元素 是 &i32,\n    // FnMut(Self::Item) -&gt; B 闭包参数是 Self.Item 就是迭代器逐个解析出的每个元素 &i32\n    // 所以传递给闭包 |x| *x + 1 的参数x\n    // 知道了x 是&i32, 所以我们才写 *x+1\n    // Vec&lt;_&gt; _ 表示Vec 元素类型不清楚\n    let f: Vec&lt;_&gt; = v1_iter.map(|x| *x + 1).collect();\n    println!(\"{:?}\", f); // [2, 3, 4]\n\n    let a = vec![(1, 11), (2, 22), (3, 33)];\n    let b: Vec&lt;_&gt; = a.iter().map(|&(x, y)| x + 1).collect();\n    println!(\"{:?}\", b);\n}\n\n\nfn main() {\n    let v1 = vec![1, 2, 3];\n    for i in v1 {\n        print_type_of(&i); // i的类型是 i32\n    }\n    let v1 = vec![1, 2, 3];\n    let mut v1_iter = v1.into_iter();\n    if let Some(b) = v1_iter.next() {\n        print_type_of(&b); // i32\n    }\n    let v1 = vec![1, 2, 3];\n    let v1_iter = v1.into_iter();\n    let f: Vec&lt;_&gt; = v1_iter.map(|x| x + 1).collect();\n    println!(\"{:?}\", f);\n}\n\n\nuse std::any::type_name;\n\nfn print_type_of&lt;T&gt;(_: &T) {\n    println!(\"{}\", type_name::&lt;T&gt;());\n}\nfn main() {\n    let mut v1 = vec![1, 2, 3];\n    for i in &mut v1 {\n        print_type_of(&i); // i 的类型是 &mut i32\n        println!(\"{}\", *i);\n    }\n    let mut v1_iter = v1.iter_mut();\n    if let Some(b) = v1_iter.next() {\n        print_type_of(&b); // &mut i32\n    }\n    println!(\"{:?}\", v1);\n    let v1_iter = v1.iter_mut();\n    let f: Vec&lt;_&gt; = v1_iter\n        .map(|x| {\n            *x = *x + 1; // 可变借用 ,所以可以修改\n            *x + 1\n        })\n        .collect();\n    println!(\"{:?}\", f);\n    println!(\"{:?}\", v1);\n}\n\n\n\n\n\n3.2.4 filter\n\n源码定义.iter()下filter里使用的闭包参数类型.into_iter()下\n\n\n#[inline]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_do_not_const_check]\nfn filter&lt;P&gt;(self, predicate: P) -&gt; Filter&lt;Self, P&gt;\nwhere\n    Self: Sized,\n    P: FnMut(&Self::Item) -&gt; bool,\n{\n    Filter::new(self, predicate)\n}\n\n\nfn main() {\n    let v1: Vec&lt;i32&gt; = vec![1, 2, 3, 4, 5];\n    let v1_iter = v1.iter();\n    let two = 2;\n    // filter 将符合条件的返回 (true的情况)\n    // v1_iter 元素是 &i32,\n    // filter源码 定义的闭包类型是 FnMut(&Self::Item) -&gt; bool\n    // 取的 &Self::Item -&gt; & &i32, 所以 闭包里的x 的类型是 &&i32\n    let v_filtered: Vec&lt;_&gt; = v1_iter.filter(|x| **x &gt;= two).collect();\n    println!(\"{:?}\", v_filtered);\n}\n\n\nfn main() {\n    let v1: Vec&lt;i32&gt; = vec![1, 2, 3, 4, 5];\n    let v1_iter = v1.into_iter();\n    let two = 2;\n    let v_filtered: Vec&lt;_&gt; = v1_iter.filter(|x| *x &gt;= two).collect();\n    println!(\"{:?}\", v_filtered);\n}\n\n\n\n\n\n3.2.5 any\nfn main() {\n    let v1 = vec![1, 2, 3];\n    // any 如果有一个满足条件就返回true\n    println!(\"2 in v1: {}\", v1.iter().any(|x| *x == 2));\n}\n\n\n3.2.6 find\n\n源码定义使用\n\n\nfn find&lt;P&gt;(&mut self, mut predicate: P) -&gt; Option&lt;Self::Item&gt;\nwhere\n    Self: Sized,\n    P: FnMut(&Self::Item) -&gt; bool,\n{\n    while let Some(x) = self.next() {\n        if predicate(&x) {\n            return Some(x);\n        }\n    }\n    None\n}\n\n\nfn main() {\n    let v1 = vec![1, 2, 3];\n    let mut iter = v1.iter();\n    println!(\"Find 2 in v1: {:?}\", iter.find(|&&x| x == 2));\n}\nfn main() {\n    let v1 = vec![1, 2, 3];\n    let mut iter = v1.into_iter();\n    println!(\"Find 2 in v1: {:?}\", iter.find(|&x| x == 2));\n}\n\n\n\n\n\n3.2.7 position\nfn main() {\n    let v1 = vec![1, 2, 6];\n    // 符合条件的 索引 返回, 第一个元素 符合 *2=2\n    let index = v1.iter().position(|&x| x * 2 == 2);\n    println!(\"{:?}\", index)  // Some(0) 第一个元素\n}\n\n\n3.2.8 enumerate\nfn main(){\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    // 产生一个新的迭代器, 每个元素是一个元组 (元素索引,元素)\n    for (index, value) in vowels.iter().enumerate() {\n        println!(\"{}: {}\", index, value);\n    }\n}",
    "crumbs": [
      "基础篇",
      "迭代器"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/iterator.html#为自定义类型实现迭代器",
    "href": "docs/programming/rust/basic/iterator.html#为自定义类型实现迭代器",
    "title": "rust 迭代器iterator",
    "section": "4 为自定义类型实现迭代器",
    "text": "4 为自定义类型实现迭代器\n随便写一个非常简单的例子\nuse std::iter::Iterator;\nuse std::result;\n\n// 定义一个自定义类型 `Counter`\nstruct Counter {\n    start: u32,\n    end: u32,\n}\n\n// 不可变借用迭代器\nstruct CounterIter&lt;'a&gt; {\n    counter: &'a Counter,\n    curr: u32,\n}\n\n// 可变借用迭代器\nstruct CounterIterMut&lt;'a&gt; {\n    counter: &'a mut Counter,\n    curr: u32,\n}\n\n// 实现不可变借用迭代器\nimpl&lt;'a&gt; Iterator for CounterIter&lt;'a&gt; {\n    type Item = u32;\n\n    fn next(&mut self) -&gt; Option&lt;Self::Item&gt; {\n        self.curr += 1;\n\n        if self.curr - 1 + self.counter.start &lt;= self.counter.end {\n            Some(self.curr - 1 + self.counter.start)\n        } else {\n            None\n        }\n    }\n}\n\n// 实现可变借用迭代器\nimpl&lt;'a&gt; Iterator for CounterIterMut&lt;'a&gt; {\n    type Item = u32;\n\n    fn next(&mut self) -&gt; Option&lt;Self::Item&gt; {\n        self.curr += 1;\n        if self.curr - 1 + self.counter.start &lt;= self.counter.end {\n            Some(self.curr - 1 + self.counter.start)\n        } else {\n            None\n        }\n    }\n}\n\n// 为 `Counter` 类型增加方法以获取不同类型的迭代器\nimpl Counter {\n    // 获取不可变借用迭代器\n    fn iter(&self) -&gt; CounterIter {\n        CounterIter {\n            counter: self,\n            curr: 0,\n        }\n    }\n\n    // 获取可变借用迭代器\n    fn iter_mut(&mut self) -&gt; CounterIterMut {\n        CounterIterMut {\n            counter: self,\n            curr: 0,\n        }\n    }\n\n    // 获取所有权\n    fn into_iter(self) -&gt; Self {\n        self\n    }\n    fn new(start: u32, end: u32) -&gt; Self {\n        Counter { start, end }\n    }\n}\n// 为 `Counter` 实现 `Iterator` trait\nimpl Iterator for Counter {\n    // 定义迭代器返回的类型\n    type Item = u32;\n\n    // 实现 `next` 方法\n    fn next(&mut self) -&gt; Option&lt;Self::Item&gt; {\n        // 检查计数器是否超过某个阈值\n        if self.start &lt;= self.end {\n            self.start += 1;\n            Some(self.start - 1)\n        } else {\n            None\n        }\n    }\n}\nfn main() {\n    let counter = Counter::new(1, 4);\n\n    // 使用不可变借用迭代器\n    let mut iter = counter.iter();\n    println!(\"Immutable borrow iterator:\");\n    while let Some(number) = iter.next() {\n        println!(\"{}\", number);\n    }\n\n    let mut counter = Counter::new(2, 6);\n\n    // 使用可变借用迭代器\n    let mut iter_mut = counter.iter_mut();\n    println!(\"\\nMutable borrow iterator:\");\n    while let Some(number) = iter_mut.next() {\n        println!(\"{}\", number);\n    }\n\n    // 使用获取所有权的迭代器\n    println!(\"\\nOwned iterator:\");\n    for number in counter.into_iter() {\n        println!(\"{}\", number);\n    }\n}",
    "crumbs": [
      "基础篇",
      "迭代器"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/error.html",
    "href": "docs/programming/rust/basic/error.html",
    "title": "rust 错误",
    "section": "",
    "text": "越界\nfn main() {\n    let v = vec![1, 2, 3];\n\n    v[99];\n}\n\n\n\n\npanic!()\n\nfn main() {\n    panic!(\"crash and burn\"); // 后面的不会执行\n    println!(\"1\");\n}\n\nfn not_yet_implemented() {\n    // 标记尚未实现的功能。\n    // 当执行到这个宏时，程序会 panic,并显示一条消息\n    unimplemented!();\n}\nfn feature_not_ready_yet() {\n    // 用于标记代码中的“待办事项”\n    // 即开发者知道这部分代码需要在未来完成\n    todo!(\"Implement this feature\");\n}\nfn unreachable() {\n    // 表明某个代码路径实际上不应该被执行到\n    // 如果执行到这个宏，程序会触发一个 panic\n    unreachable!();\n}\n\nfn main() {\n    let x = 5;\n    assert!(x &lt; 10); // 如果 x &gt;= 10，则会 panic\n    let a = 5;\n    let b = 6;\n    assert_eq!(a, b); // 如果 a != b，则会 panic\n    assert_ne!(a, b); // 如果 a == b，则会 panic\n}",
    "crumbs": [
      "基础篇",
      "错误处理"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/error.html#unrecoverable-errors",
    "href": "docs/programming/rust/basic/error.html#unrecoverable-errors",
    "title": "rust 错误",
    "section": "",
    "text": "越界\nfn main() {\n    let v = vec![1, 2, 3];\n\n    v[99];\n}\n\n\n\n\npanic!()\n\nfn main() {\n    panic!(\"crash and burn\"); // 后面的不会执行\n    println!(\"1\");\n}\n\nfn not_yet_implemented() {\n    // 标记尚未实现的功能。\n    // 当执行到这个宏时，程序会 panic,并显示一条消息\n    unimplemented!();\n}\nfn feature_not_ready_yet() {\n    // 用于标记代码中的“待办事项”\n    // 即开发者知道这部分代码需要在未来完成\n    todo!(\"Implement this feature\");\n}\nfn unreachable() {\n    // 表明某个代码路径实际上不应该被执行到\n    // 如果执行到这个宏，程序会触发一个 panic\n    unreachable!();\n}\n\nfn main() {\n    let x = 5;\n    assert!(x &lt; 10); // 如果 x &gt;= 10，则会 panic\n    let a = 5;\n    let b = 6;\n    assert_eq!(a, b); // 如果 a != b，则会 panic\n    assert_ne!(a, b); // 如果 a == b，则会 panic\n}",
    "crumbs": [
      "基础篇",
      "错误处理"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/error.html#recoverable-errors",
    "href": "docs/programming/rust/basic/error.html#recoverable-errors",
    "title": "rust 错误",
    "section": "2 Recoverable Errors",
    "text": "2 Recoverable Errors\nenum Result&lt;T, E&gt; {\n    Ok(T),\n    Err(E),\n}\n\n2.1 match\nuse std::fs::File;\n\nfn main() {\n    let greeting_file_result = File::open(\"hello.txt\");\n\n    let greeting_file = match greeting_file_result {\n        Ok(file) =&gt; file, // 返回给 greeting_file\n        Err(error) =&gt; {\n            // 直接panic\n            panic!(\"Problem opening the file: {:?}\", error);\n        }\n    };\n}\nuse std::fs::File;\nuse std::io::ErrorKind;\n\nfn main() {\n    let greeting_file_result = File::open(\"hello.txt\");\n\n    let greeting_file = match greeting_file_result {\n        Ok(file) =&gt; file,\n        Err(error) =&gt; match error.kind() {\n            // 匹配不同的错误\n            ErrorKind::NotFound =&gt; match File::create(\"hello.txt\") {\n                Ok(fc) =&gt; fc,\n                Err(e) =&gt; panic!(\"Problem creating the file: {:?}\", e),\n            },\n            other_error =&gt; {\n                panic!(\"Problem opening the file: {:?}\", other_error);\n            }\n        },\n    };\n}\n\n\n2.2 unwrap_or_else\n使用 Result&lt;T, E&gt; 的方法 unwrap_or_else\nuse std::fs::File;\nuse std::io::ErrorKind;\n\nfn main() {\n    let greeting_file = File::open(\"hello.txt\").unwrap_or_else(|error| {\n        if error.kind() == ErrorKind::NotFound {\n            File::create(\"hello.txt\").unwrap_or_else(|error| {\n                panic!(\"Problem creating the file: {:?}\", error);\n            })\n        } else {\n            panic!(\"Problem opening the file: {:?}\", error);\n        }\n    });\n}\n\n\n2.3 unwrap\nuse std::fs::File;\n\nfn main() {\n    // unwrap 方法会返回一个 Result 枚举，\n    // 如果 Result 枚举是 Ok 类型，则 unwrap 会返回 Ok 中的值，\n    // 如果 Result 枚举是 Err 类型，则 unwrap 会panic Err 中的错误信息, 程序退出\n    let greeting_file = File::open(\"hello.txt\").unwrap();\n}\n\n\n2.4 expect\n相比unwrap 就是能定义输出的错误信息\nuse std::fs::File;\n\nfn main() {\n    let greeting_file = File::open(\"hello.txt\")\n        .expect(\"hello.txt 文件不存在 \");\n}\n\n\n2.5 ?\nuse std::fs::File;\nuse std::io::{self, Read};\nfn main() {\n    read_username_from_file().unwrap();\n}\nfn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {\n    let username_file_result = File::open(\"hello.txt\");\n    // 错误的情况, 返回 result&lt;String,Error&gt;\n    let mut username_file = match username_file_result {\n        Ok(file) =&gt; file,\n        // return 会退出函数, 返回Err(e) 给read_username_from_file\n        Err(e) =&gt; return Err(e),\n    };\n\n    let mut username = String::new();\n    // 不管结果如何, 都返回 ,让给调用者处理\n    match username_file.read_to_string(&mut username) {\n        Ok(_) =&gt; Ok(username),\n        Err(e) =&gt; Err(e),\n    }   // 注意这里是没有 ; 的, 因为要返回 result&lt;T,E&gt;\n}\n上面的写法, 你会发现, 有同样类似的逻辑, 就是将结果result 给调用者自己处理, 使用? 简化代码\nuse std::fs::File;\nuse std::io::{self, Read};\nfn main() {\n    read_username_from_file().unwrap();\n}\nfn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {\n    // \\? 放在 Result 类型的返回值上\n    // 如果返回值是 Ok,那么Ok包含的value 会被返回, 程序继续执行\n    // 如果返回值是 Err, 则 当前函数执行完毕, return Err ,Err作为函数的返回值\n    let mut username_file = File::open(\"hello.txt\")?;\n    let mut username = String::new();\n    let s = username_file.read_to_string(&mut username)?;\n    println!(\"s:=={}\", s); // 读取的字节书\n    Ok(username)\n}\n更简洁\nuse std::fs::File;\nuse std::io::{self, Read};\n\nfn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {\n    let mut username = String::new();\n\n    File::open(\"hello.txt\")?.read_to_string(&mut username)?;\n\n    Ok(username)\n}\n当然 标准库 提供了 上面的需求的更好的方法, 知道就行, 这不是我们讨论的点.\nuse std::fs;\nuse std::io;\n\nfn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {\n    fs::read_to_string(\"hello.txt\")\n}\n\n\n\n\n\n\nCaution\n\n\n\n\n? 只能被用在 函数里\n只能用在 Result, Option, 或者其他 实现了 FromResidual的 类型上\n\n\n\n下面代码报错了\nuse std::fs::File;\n\nfn main() {\n    let greeting_file = File::open(\"hello.txt\")?;\n}",
    "crumbs": [
      "基础篇",
      "错误处理"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/error.html#开源错误处理库",
    "href": "docs/programming/rust/basic/error.html#开源错误处理库",
    "title": "rust 错误",
    "section": "3 开源错误处理库",
    "text": "3 开源错误处理库\n\n3.1 anyhow1\n\n3.1.1 源码分析\n\n\n3.1.2 使用\nuse std::fs;\n\nuse anyhow::Result as anyRes;\nfn main() {\n}\n\n// 使用anyhow 我们可以不关心具体的错误\nfn get_file_info()(file_path: &str) -&gt; anyRes&lt;String&gt; {\n    // ? 表示 正确返回Ok() 里的值, 如有错误,则直接return Err(e),函数 退出\n    let info = fs::read_to_string(file_path)?;\n    // 正常的情况, 需要用Ok包起来 变成 Result 返回\n    Ok(info)\n}\n\n\n\n3.2 thiserror2",
    "crumbs": [
      "基础篇",
      "错误处理"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/error.html#footnotes",
    "href": "docs/programming/rust/basic/error.html#footnotes",
    "title": "rust 错误",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nanyhow, doc↩︎\nthiserror↩︎",
    "crumbs": [
      "基础篇",
      "错误处理"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/crate-mod.html#crate1",
    "href": "docs/programming/rust/basic/crate-mod.html#crate1",
    "title": "rust 模块",
    "section": "1 crate1",
    "text": "1 crate1\nRust 程序由 crate组成. 每个 crate 都是既完整又内聚的单元,包括单个库(library)或可执行程序的所有源代码,以及任何相关的测试、示例、工具、配置和其他杂项\ncrate root 是源代码文件,编译器会从这里开始组成你的crate的根module\ncargo new hello\ncd hello\ntree\n.\n├── Cargo.toml\n└── src\n    ├   # 这个是 binary crate 的crate root\n    ├   # 这个 binary crate 的名字与package相同, hello\n    └── main.rs\n# 我们手动创建一个library crate\n# 这个 library crate 的名字也是与package相同,hello\ntouch src/lib.rs # 这个文件默认就是 library crate 的crate root\nCargo.toml 没有指定上面2个文件名是 crate root ,因为这个是一种默认约定, 就像go里的main.go, cargo 会把crate root 文件给 rustc来构建",
    "crumbs": [
      "基础篇",
      "crate与模块"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/crate-mod.html#module",
    "href": "docs/programming/rust/basic/crate-mod.html#module",
    "title": "rust 模块",
    "section": "2 module",
    "text": "2 module\n模块是组织代码的一种方式,它允许你将代码分割到不同的文件中,并让每个文件只包含相关的代码. 模块可以嵌套,并且可以被任意数量的模块使用\nmod front_of_house {\n    mod hosting {\n        fn add_to_waitlist() {}\n        fn seat_at_table() {}\n    }\n    mod serving {\n        fn take_order() {}\n        fn serve_order() {}\n        fn take_payment() {}\n    }\n}\n前面我们说到 src/main.rs and src/lib.rs 之所以被称为 crate root, 这是因为 main.rs或lib.rs 文件的内容形成了一个名字叫做 crate的模块,位于module tree的root位置\n上面代码的 module tree\ncrate #(根部,名字为crate的模块)\n └── front_of_house # (名字为front_of_house的模块)\n     ├── hosting #(名字为hosting的模块)\n     │   ├── add_to_waitlist\n     │   └── seat_at_table\n     └── serving #(名字为serving的模块)\n         ├── take_order\n         ├── serve_order\n         └── take_payment\n就像目录一样, 这样我们是不是就可以像目录一样的访问方式去找到我们的模块",
    "crumbs": [
      "基础篇",
      "crate与模块"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/crate-mod.html#pathpub",
    "href": "docs/programming/rust/basic/crate-mod.html#pathpub",
    "title": "rust 模块",
    "section": "3 path,pub",
    "text": "3 path,pub\n\n\n\n\n\n\n关于pub的总结\n\n\n\n\n没有设置pub 相当于 设置pub(self)\npub(xxxx) 表示被约束的东西只能被xxxx及其子模块访问\n单独的pub 表示能被外部访问\n\n\n\n.\n├── Cargo.toml\n└── src\n    ├── lib.rs\n    └── main.rs\n\n\nsrc/lib.rs\n\n// 没有pub 的模块, 表示只能被当前模块及其后代模块访问\n// 对front_of_house 来说 ,当前模块是 crate\nmod front_of_house {\n    // 如果没有pub, 表示 hosting模块是私有的, 只能被当前模块及其后代模块访问\n    // 对hosting 来说 ,当前模块是front_of_house \n    // 该mod 如果要让外部访问, 需要 + pub\n    pub mod hosting {\n        // 方法同理\n        pub fn add_to_waitlist() {}\n    }\n}\n\npub fn eat_at_restaurant() {\n    // 绝对路径调用, 这个lib.rs 文件隐含着 形成的 名为 crate的模块\n    // 同理如果你在 main.rs 中 使用crate:: 表示main.rs 文件里找模块\n    // 因为 front_of_house 和 eat_at_restaurant 在同一个crate中,\n    // 注意 eat_at_restaurant 是方法,不是模块, 所以它是在 根模块 crate 中\n    // 好比 linux的目录 / 中, 而 front_of_house 是模块, 就好比 /front_of_house 目录\n    // 所以可以直接使用 crate:: 来,不需要 pub front_of_house\n    crate::front_of_house::hosting::add_to_waitlist();\n\n    // 相对路径\n    // 好比在目录 / 中访问 front_of_house/hosting/add_to_waitlist\n    front_of_house::hosting::add_to_waitlist();\n\n    let mut meal = back_of_house::Breakfast::summer(\"Rye\");\n    meal.toast = String::from(\"Wheat\");\n    println!(\"I'd like {} toast please\", meal.toast);\n\n    //  seasonal_fruit 是私有的, 无法访问\n    // meal.seasonal_fruit = String::from(\"blueberries\");\n}\n\nfn deliver_order() {}\n\nmod back_of_house {\n    fn fix_incorrect_order() {\n        cook_order();\n        // super 父模块 ,得到根模块 crate\n        // 子模块访问父模块的方法, 方法不需要pub\n        super::deliver_order();\n        // 绝对路径\n        crate::deliver_order();\n    }\n\n    fn cook_order() {\n        // 父模块访问子模块 fridge里的方法, 方法需要pub\n        fridge::get_item();\n    }\n    // 没有pub 的模块, 只对被当前模块及其后代模块访问\n    // 对fridge 来说 ,当前模块是 back_of_house\n    mod fridge {\n        pub fn get_item() {}\n        // 没有pub的, 表示只能被当前模块, 这里就是 fridge 访问\n        fn get_item2(){}\n        fn get_item3(){\n            self::get_item2();\n        }\n    }\n\n    // 结构体的 权限\n    pub struct Breakfast {\n        pub toast: String, // pub\n        seasonal_fruit: String, //私有\n    }\n\n    impl Breakfast {\n        pub fn summer(toast: &str) -&gt; Breakfast {\n            Breakfast {\n                toast: String::from(toast),\n                seasonal_fruit: String::from(\"peaches\"),\n            }\n        }\n    }\n    // 枚举的权限, 只要 pub enum ,成员变体就全是pub了\n    pub enum Appetizer {\n        Soup,\n        Salad,\n    }\n}\n\npub(crate) pub(self) pub(super)\n\n.\n├── Cargo.toml\n└── src\n    ├── lib.rs\n    └── main.rs\n\nCargo.tomllib.rsmain.rs\n\n\n[package]\nname = \"world\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n\npub mod back {\n    pub fn hello() {\n        println!(\"hello\");\n    }\n}\npub mod back2 {\n    // 表示给只能被crate 模块及其子模块访问\n    pub(crate) fn world2() {\n        println!(\"world2\");\n    }\n    pub fn world22() {\n        println!(\"world22\");\n    }\n    // pub(self) 表示只能被当前模块以及子模块访问\n    // 这和不带 pub(self) 是一样的.\n    // 等同于 fn world222()\n    pub(self) fn world222() {\n        println!(\"world222\");\n    }\n    pub mod back2_son {\n        // pub(super) 表示该back2_son_1方法只能被父模块\n        // 也就是back2及其子模块访问\n        pub(super) fn back2_son_1() {\n            println!(\"back2_son_1\");\n        }\n        pub fn back2_son_2() {\n            println!(\"back2_son_2\");\n        }\n        // in 只能设置父模块或祖先模块\n        pub(in crate::back2) fn back2_son_3() {\n            println!(\"back2_son_3\");\n        }\n    }\n    mod back2_son2 {\n\n        fn say() {\n            super::back2_son::back2_son_1();\n            super::back2_son::back2_son_2();\n        }\n    }\n}\n// 表示给crate 模块及其子模块使用\n// 在main.rs 里是无法使用的.\npub(crate) mod back3 {\n    pub fn world3() {\n        println!(\"world3\");\n        crate::back2::back2_son::back2_son_2();\n        // crate::back2::back2_son::back2_son_1(); 不可访问\n    }\n}\n\n\nuse world::back;\nuse world::back2;\n// use world::back3; 不可访问\nfn main() {\n    back::hello();\n    // back2::world2(); 不可访问\n    back2::world22();\n    // back2::world222(); 不可访问\n}",
    "crumbs": [
      "基础篇",
      "crate与模块"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/crate-mod.html#use",
    "href": "docs/programming/rust/basic/crate-mod.html#use",
    "title": "rust 模块",
    "section": "4 use",
    "text": "4 use\n\n\n\n\n\n\nTip\n\n\n\nuse 语句将路径引入到当前作用域,从而允许你使用路径中指定的名称\n\n\n\n4.1 mod\nmod front_of_house {\n    pub mod hosting {\n        pub fn add_to_waitlist() {}\n        pub struct Dog {}\n    }\n}\n// 将hosting 引入当前作用域, 这样 就能直接使用 这个hosting模块\n// 相当于在 crate 根模块中 定义了 hosting 模块\n1use crate::front_of_house::hosting;\n// 使用相对路径, as 别名\nuse front_of_house::hosting as hosting2;\n// 引入函数一般是引入到父级模块\n// 可以use 引入具体的函数,但是一般我们不这样弄,\n// 因为 最后是让你自己知道使用的函数是引入的模块里的还是你自己这里定义的\nuse front_of_house::hosting::add_to_waitlist as waitlist;\n// 如果是引入 struct enum 等其他不是函数的东西 ,一般就use 到 具体的struct,enum.\nuse front_of_house::hosting::Dog;\n\n// 外部代码 默认是不能访问, use 还需要 加上pub\n// pub use 表示导出, 这样外部代码就能 导入到它的作用域\npub use front_of_house::hosting as pub_hosting;\n\npub fn eat_at_restaurant() {\n    hosting::add_to_waitlist();\n    hosting2::add_to_waitlist();\n    waitlist();\n    let a = Dog {};\n}\n\nmod back_of_house {\n    use crate::front_of_house::hosting;\n\n    fn take() {\n        // 当前这个 back_of_house 模块下想直接使用, 还是得 use 引入\n        // add_to_waitlist 还是必须pub\n        hosting::add_to_waitlist();\n        // 使用super 来\n        super::hosting::add_to_waitlist();\n    }\n}\n\n1\n\n将hosting 引入当前作用域, 这样 就能直接使用 这个hosting模块 相当于在 crate 根模块中 定义了 hosting 模块\n\n\n\n\n4.2 外部package\n\n\n\n\n\n\n使用外部package\n\n\n\n\nCargo.toml 添加要依赖的包\n代码中使用 use 将包引入到自己的作用域\n虽然std标准库也是外部包,但是已经被内置,所以不需要Cargo.toml 中添加\n\n\n\n添加包\ncargo add rand\n查看一下Cargo.toml\n[package]\nname = \"hello\"\nversion = \"0.1.0\"\nedition = \"2021\"\n[dependencies]\nrand = \"0.8.5\"\nuse rand::Rng;  // 引入添加的外部包\nuse std::collections::HashMap; // 引入标准库\nfn main() {}\n\n\n4.3 本地package\n\n\n\n\n\n\nTip\n\n\n\nmain.rs 变为本地 package的使用者. The module tree should be defined in src/lib.rs. Then, any public items can be used in the binary crate by starting paths with the name of the package. The binary crate becomes a user of the library crate just like a completely external crate would use the library crate\n\n\n\n.\n├── Cargo.toml\n└── src\n    ├── lib.rs\n    └── main.rs\n\nCargo.tomllib.rsmain.rs\n\n\n[package]\nname = \"world\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n\npub mod back {\n    pub fn hello() {\n        println!(\"hello\");\n    }\n}\n\n\nuse world::back;\nfn main() {\n    back::hello();\n}\n\n\n\n\n\n\n4.4 use 其他语法\nuse std::cmp::Ordering;\nuse std::io;\n使用{} 来简写\nuse std::{cmp::Ordering, io};\nuse std::io;\nuse std::io::Write;\n// 使用 self, 等价于上面2个\nuse std::io::{self, Write};\n使用*\nuse std::collections::*;\n\n\n4.5 prelude\n\n\n\n\n\n\nTip\n\n\n\n标准库中有一些非常常用的东西,我们可能每一个rs文件都要去use相关的, 所以rust编译期自动的为每一个crate插入一句use std::prelude::*;",
    "crumbs": [
      "基础篇",
      "crate与模块"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/crate-mod.html#module-拆分",
    "href": "docs/programming/rust/basic/crate-mod.html#module-拆分",
    "title": "rust 模块",
    "section": "5 module 拆分",
    "text": "5 module 拆分\n\n\nsrc/main.rs\n\n// mod 后 就可以直接在 main() 里使用 front_of_house::hosting::add_to_waitlist()\n// 这样 显式mod 后, 才会将 该mod 的代码进行编译\n1mod front_of_house;\n\n// 上面mod 后, 我们才能用 use 的方式\nuse crate::front_of_house::hosting;\n\npub fn eat_at_restaurant() {\n    hosting::add_to_waitlist();\n}\n\nfn main() {\n    front_of_house::hosting::add_to_waitlist();\n    hosting::add_to_waitlist();\n}\n\n\n1\n\n如果我们在定义mod 时, 模块名后面跟着 ; 号, 那么rust 必须能从src目录下找到(否则报错) 1. 与模块同名的文件,里面的内容就是这个模块的定义  2. 或者与模块同名的文件夹(文件夹里需要一个mod.rs文件,它的内容就是模块的定义)\n\n\n\n模块同名的文件模块同名的文件夹\n\n\n\n\nsrc/front_of_house.rs\n\npub mod hosting {\n    pub fn add_to_waitlist() {\n        println!(\"hello\");\n    }\n}\n\n\n\n\n\nsrc/front_of_house/mod.rs\n\npub mod hosting {\n    pub fn add_to_waitlist() {\n        println!(\"hello\");\n    }\n}\n\n\n\n\n理解为将该文件包含到main.rs中,相当于如下代码\n\n\nsrc/main.rs\n\nmod front_of_house {\n    pub mod hosting {\n        pub fn add_to_waitlist() {\n            println!(\"hello\");\n        }\n    }\n}\n\nuse crate::front_of_house::hosting;\n\npub fn eat_at_restaurant() {\n    hosting::add_to_waitlist();\n}\nfn main() {\n    front_of_house::hosting::add_to_waitlist();\n    hosting::add_to_waitlist();\n}\n\n我们继续将front_of_house模块里的hosting模块进行拆分\n\n模块同名的文件的情况模块同名的文件夹的情况\n\n\n\n\nsrc/front_of_house.rs\n\npub mod hosting;\n\ncd src\nmkdir -p front_of_house\n我们需要在 front_of_house 目录下创建hosting.rs 文件\n\n\nsrc/front_of_house/hosting.rs\n\npub fn add_to_waitlist() {\n    println!(\"hello\");\n}\n\n\n\n\n\nsrc/front_of_house/mod.rs\n\npub mod hosting;\n\ncd src\nmkdir -p front_of_house/hosting\n\n\nsrc/front_of_house/hosting/mod.rs\n\npub fn add_to_waitlist() {\n    println!(\"hello\");\n}",
    "crumbs": [
      "基础篇",
      "crate与模块"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/crate-mod.html#footnotes",
    "href": "docs/programming/rust/basic/crate-mod.html#footnotes",
    "title": "rust 模块",
    "section": "Footnotes",
    "text": "Footnotes\n\n\ncrates github crates.io↩︎",
    "crumbs": [
      "基础篇",
      "crate与模块"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/pattern-match.html",
    "href": "docs/programming/rust/basic/pattern-match.html",
    "title": "rust 模式匹配 pattern match",
    "section": "",
    "text": "Important\n\n\n\n\n模式匹配是一种编程语言特性, 允许你将值(简单的值或者复杂的数据结构)与预定义的模式进行比较,并在匹配成功时执行相应的代码(变量绑定或其他操作)\n结合下图, 然后后面的实际例子, 体会一下\n就我个人印象, 了解下模式匹配的定义(没错,就是定义) 是很有好处的, 之前就直接开干,概念没有特别去思考, 有些东西会有些模糊",
    "crumbs": [
      "基础篇",
      "模式匹配"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/pattern-match.html#概念逻辑",
    "href": "docs/programming/rust/basic/pattern-match.html#概念逻辑",
    "title": "rust 模式匹配 pattern match",
    "section": "",
    "text": "Important\n\n\n\n\n模式匹配是一种编程语言特性, 允许你将值(简单的值或者复杂的数据结构)与预定义的模式进行比较,并在匹配成功时执行相应的代码(变量绑定或其他操作)\n结合下图, 然后后面的实际例子, 体会一下\n就我个人印象, 了解下模式匹配的定义(没错,就是定义) 是很有好处的, 之前就直接开干,概念没有特别去思考, 有些东西会有些模糊",
    "crumbs": [
      "基础篇",
      "模式匹配"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/pattern-match.html#let",
    "href": "docs/programming/rust/basic/pattern-match.html#let",
    "title": "rust 模式匹配 pattern match",
    "section": "2 let",
    "text": "2 let\nlet PATTERN = EXPRESSION;\nfn main() {\n    // 这种变量申明初始化, 其实就是模式匹配\n    // x 就是pattern , 然后1 就是 x 要与之匹配的值\n    // 这个就属于 irrefutable 类型的模式, 因为x 能匹配上任何东西, 必定匹配上的.\n    let x = 1;\n\n    // (b,c) 是模式, 右边的(1,2) 是值, 结构上能够匹配上\n    // 所以 将 1 绑定到变量b, 将 2 绑定到变量c\n    let (b, c) = (1, 2);\n    println!(\"{}-{}\", b, c);\n    // 忽略第一个元素 , 这里 _ 就是图一里提到的占位符模式\n    let (_, y) = (1, 2);\n    println!(\"y: {}\", y);\n\n    struct Person {\n        name: String,\n        age: i32,\n    }\n    let p1 = Person {\n        name: \"zhang fei\".to_string(),\n        age: 22,\n    };\n    // 同理\n    let Person { name: n, age: m } = p1;\n    println!(\"{} : {}\", n, m);\n\n    let p2 = Person {\n        name: \"liu bei\".to_string(),\n        age: 32,\n    };\n    // 名字与字段名一样的情况,可以省略\n    let Person { name, age } = p2;\n    println!(\"{} : {}\", name, age);\n    let p3 = Person {\n        name: \"guan yu\".to_string(),\n        age: 13,\n    };\n    // 可以使用.. 省略\n    let Person { name,.. } = p3;\n    println!(\"{}\",name);\n}\n\n\n支持& 这种匹配\n\nfn print_coordinates(&(x, y): &(i32, i32)) {\n    println!(\"Current location: ({}, {})\", x, y);\n}\n\nfn main() {\n    let point = (3, 5);\n    // 函数传递参数 相当于 let 形参=传递的实参\n    // let &(x, y)= &(3,5)\n    print_coordinates(&point);\n\n    // 理解了 这也是模式匹配, 下面这个就不觉得奇怪了\n    let &a = &11;\n    println!(\"{}\", a);\n}",
    "crumbs": [
      "基础篇",
      "模式匹配"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/pattern-match.html#match",
    "href": "docs/programming/rust/basic/pattern-match.html#match",
    "title": "rust 模式匹配 pattern match",
    "section": "3 match",
    "text": "3 match\nmatch VALUE {\n    PATTERN =&gt; EXPRESSION,\n    PATTERN =&gt; EXPRESSION,\n    PATTERN =&gt; EXPRESSION,\n}\n\n3.1 枚举\n模式是枚举\nfn main() {\n    let x = Some(5);\n    // 这里的 x 是值\n    match x {\n        // Some(value) 是模式\n        Some(value) =&gt; {\n            // 匹配成功后,执行相应代码\n            // Some(value)=Some(5) 这里也绑定了 变量, value=5\n            println!(\"Got a value: {}\", value)\n        }\n        // None 是模式\n        None =&gt; println!(\"No value\"),\n    }\n}\nenum Coin {\n    Penny,\n    Nickel,\n    Dime(String),\n    Quarter,\n}\n\nfn main() {\n    let c = Coin::Penny;\n    let d = Coin::Dime(\"hello\".to_string());\n    // 这里 let r=  就是前面我们提到 irrefutable 类型的模式\n    // 然后右边本身也含着一个 模式匹配\n    let r = match d {\n        Coin::Penny =&gt; {\n            println!(\"Lucky penny!\");\n            1\n        }\n        Coin::Nickel =&gt; 5,\n        Coin::Dime(s) =&gt; {\n            println!(\"{}\", s); // 可以在这边获取枚举成员携带的数据\n            10 //返回值\n        }\n        // 必须把所有成员匹配都写上,否则报错, 去看 Pattern Syntax\n        Coin::Quarter =&gt; 25,\n    };\n    println!(\"{}\", r);\n}\n\n\n3.2 字面量\nfn main(){\n    let x = 1;\n\n    match x {\n        // 这里的数字1  就是模式, 是字面量的模式\n        1 =&gt; println!(\"一\"),\n        2 =&gt; println!(\"二\"),\n        // 虽然这个也匹配, 但是只会执行前面第一个匹配的分支\n        1 =&gt; println!(\"1\"),\n        3 =&gt; println!(\"三\"),\n        4 =&gt; println!(\"四\"),\n        5 =&gt; println!(\"五\"),\n        // _ 是占位符模式\n        _ =&gt; println!(\"其他数字\"),\n    }\n    match x{\n        2=&gt;println!(\"二\"),\n        // 可以随便一个变量名来表示其他数据\n        other=&gt;println!(\"其他数字: {}\",other),\n    }\n}\n\n\n3.3 结构体\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nfn main() {\n    let p = Point { x: 10, y: 0 };\n\n    match p {\n        Point { x, y: 0 } =&gt; println!(\"y=0 才能匹配上 {}\", x),\n        Point { x, y: 0..=2 } =&gt; println!(\"y&gt;=0 &lt;=2 是才匹配上 {}\", x),\n        Point { x: 0, y } =&gt; println!(\"x=0 才能匹配上 {}\", y),\n        Point { x, y } =&gt; println!(\"都能匹配上 ({}, {})\", x, y),\n    }\n}",
    "crumbs": [
      "基础篇",
      "模式匹配"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/pattern-match.html#if-let",
    "href": "docs/programming/rust/basic/pattern-match.html#if-let",
    "title": "rust 模式匹配 pattern match",
    "section": "4 if let",
    "text": "4 if let\n相当于 使用 match ,然后只匹配一个成员,然后执行代码块, 更加简洁\n\n使用if .. else注意\n\n\nfn main() {\n    // Some 这个是Option&lt;t&gt; 枚举里的成员, 因为 默认 use了,所以可以直接拿来用\n    let config_max = Some(3u8);\n    match config_max {\n        Some(max) =&gt; println!(\"The maximum is configured to be {}\", max),\n        _ =&gt; (),\n    }\n    let config_max = Some(3u8);\n    // 相当于上面的 match, 但是我们这里不用写 另外 _ 的分支\n    // 模式匹配上,绑定值到变量max, 然后执行 {} 里的代码, 匹配不上 就继续后面的代码\n    // 和if 判断 很像\n    if let Some(max) = config_max {\n        println!(\"The maximum is configured to be {}\", max);\n    }\n}\n\n\nfn main() {\n    let n = 1;\n    // 1=n , 1 是字面量 模式(pattern)\n    // n 是值, 这里匹配上了\n    if let 1 = n {\n        println!(\"{}\", 1);\n    } else {  // 也能 else if {} else{}\n        println!(\"{}\", 2);\n    }\n    // 类似我们之前if 条件语句那边\n    let r = if let 1 = n { 11 } else { 22 };\n    println!(\"{}\", r);\n}\n\n\nfn main() {\n    // 之前 这种 let x =1  很显然也可以 使用 if\n    // 只是这样写, 会提示你 这个肯定会匹配上, 不需要写 if 这种\n    if let x = 1 {\n        println!(\"hello\")\n    }\n    //错误, 提示在这个作用域中找不到x\n    // println!(\"{}\", x);\n}",
    "crumbs": [
      "基础篇",
      "模式匹配"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/pattern-match.html#while-let",
    "href": "docs/programming/rust/basic/pattern-match.html#while-let",
    "title": "rust 模式匹配 pattern match",
    "section": "5 while let",
    "text": "5 while let\nfn main() {\n    let mut optional = Some(0);\n\n    // let Some(i)=optional 匹配上, 就进入{}\n    // 1. 第一次 匹配上 i=0\n    while let Some(i) = optional {\n        if i &gt; 9 {\n            println!(\"Greater than 9, quit!\");\n            optional = None;\n        } else {\n            // 2. 到这里, ... 到 i=9 最后一次在这里,然后 i&gt;9,走上面的分支\n            println!(\"`i` is `{:?}`. Try again.\", i);\n            optional = Some(i + 1);\n        }\n    }\n}",
    "crumbs": [
      "基础篇",
      "模式匹配"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/pattern-match.html#let-ref",
    "href": "docs/programming/rust/basic/pattern-match.html#let-ref",
    "title": "rust 模式匹配 pattern match",
    "section": "6 let ref",
    "text": "6 let ref\nref 是模式的一部分, 而 & 是借用运算符,是表达式的一部分\n\n简单变量中使用结构体使用枚举中使用ref mut 可变借用\n\n\nfn main() {\n    let ref_c2 = &1;\n    // 等价上面,  如果是ref mut 就是可变借用了\n    let ref ref_c1 = 1;\n    println!(\"{}-{}\", *ref_c1, *ref_c2);\n}\n\n\n\n\n看一下这个例子, 报错了\n\nstruct Person {\n    name: String,\n    age: i32,\n}\nfn main() {\n    let p1 = Person {\n        name: \"zhang fei\".to_string(),\n        age: 22,\n    };\n    let Person { name, age } = p1;\n    println!(\"{} : {}\", name, age);\n    // 我们发现这里会报错,提示 p1.name 已经被move给前面的 name了\n    // 因为相当于变量赋值,name 是 move 类别\n    println!(\"{}-{}\", p1.age, p1.name);\n}\n\n\n\n我们使用ref 借用name就行\n\nstruct Person {\n    name: String,\n    age: i32,\n}\nfn main() {\n    let p1 = Person {\n        name: \"zhang fei\".to_string(),\n        age: 22,\n    };\n    let Person { ref name, age } = p1;\n    println!(\"{} : {}\", name, age);\n    let Person {\n        // 这里的name 是字段, n 才是我们要的值, 所以别弄错, ref是修饰n\n        name: ref n,\n        age: m,\n    } = p1;\n    println!(\"{} : {}\", n, m);\n}\n\n\n\n\n\n报错: 枚举中发生move\n\nfn main() {\n    let x: Option&lt;String&gt; = Some(\"hello\".to_string());\n    match x {\n        // 注意是在这里 发生了 move\n        // Some(e)=x, e 获取了x 里部分数据的所有权.\n        Some(e) =&gt; println!(\"{}\", e),\n        _ =&gt; println!(\"other\"),\n    }\n    // x中的数据被转移所有权了,所以这里报错了\n    println!(\"{:?}\", x);\n}\n\n\n\n添加ref\n\nfn main() {\n    let x: Option&lt;String&gt; = Some(\"hello\".to_string());\n    match x {\n        // 加上ref ,表示这里e 是 借用了 x里面的数据\n        // x 数据是完整的, 后面就不会报错了.\n        Some(ref e) =&gt; println!(\"hello{}\", e),\n        _ =&gt; println!(\"other\"),\n    }\n\n    println!(\"{:?}\", x);\n}\n\n\n\n使用match &x\n\nfn main() {\n    let x: Option&lt;String&gt; = Some(\"hello\".to_string());\n    // match &x\n    match &x {\n        // 编译器自动将e弄成 &String ,对 x 内 字符串的借用了\n        // 如果是 match &mut x 同理\n        Some(e) =&gt; println!(\"hello{}\", *e),\n        _ =&gt; println!(\"other\"),\n    }\n\n    println!(\"{:?}\", x);\n}\n\n\n\nstruct Person {\n    name: String,\n    age: i32,\n}\nfn main() {\n    let mut p1 = Person {\n        name: \"zhang fei\".to_string(),\n        age: 22,\n    };\n    let Person { ref mut name, age } = p1;\n    println!(\"{} : {}\", name, age);\n    name.push_str(\" hello\");\n    println!(\"{}\", p1.name);\n}",
    "crumbs": [
      "基础篇",
      "模式匹配"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/pattern-match.html#let-mut",
    "href": "docs/programming/rust/basic/pattern-match.html#let-mut",
    "title": "rust 模式匹配 pattern match",
    "section": "7 let mut",
    "text": "7 let mut\n\n\n\n\n\n\nCaution\n\n\n\n没错, 我们平常使用的let mut x=1 类似这种语句, mut 是模式匹配中模式的一部分\n\n\nstruct Person {\n    name: String,\n    age: i32,\n}\nfn main() {\n    let mut x=2;\n    let (mut a, mut b) = (1, 2);\n    a = 33;\n    println!(\"{}\", a);\n    struct Person {\n        name: String,\n        age: i32,\n    }\n    let p1 = Person {\n        name: \"zhang fei\".to_string(),\n        age: 22,\n    };\n    let Person { name, age } = p1;\n    println!(\"{} : {}\", name, age);\n    // name.push_str(\"string\"); 报错,因为name 不可变\n    let p1 = Person {\n        name: \"zhang fei\".to_string(),\n        age: 22,\n    };\n    let Person { mut name, age } = p1;\n    name.push_str(\"string\"); // ok\n}",
    "crumbs": [
      "基础篇",
      "模式匹配"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/pattern-match.html#pattern-syntax",
    "href": "docs/programming/rust/basic/pattern-match.html#pattern-syntax",
    "title": "rust 模式匹配 pattern match",
    "section": "8 Pattern Syntax",
    "text": "8 Pattern Syntax\n\n8.1 .. 剩余\nstruct Point {\n    x: i32,\n    y: i32,\n    z: i32,\n}\nfn main() {\n    let (a, ..) = (1, 2, 3, 4, 5);\n    println!(\"{}\", a); // 1\n    let (b, .., c) = (1, 2, 3, 4, 5);\n    println!(\"{}-{}\", b, c); // 1-5\n\n    // 结构体 不能 将.. 放中间\n    let Point { x: x1, .. } = Point {\n        x: 11,\n        y: 22,\n        z: 33,\n    };\n    println!(\"{}\", x1); // 1\n}\n\n\n8.2 _ 忽略绑定\nfn main() {\n    let (_, x, _) = (1, 2, 3);\n    println!(\"{}\", x);\n\n    let y = Some(String::from(\"hello\"));\n    // - 没有绑定, 所以没有move,后面的y打印不会报错\n    if let Some(_) = y {\n        println!(\"ss\");\n    };\n    println!(\"{:?}\", y);\n}\n\n\n8.3 _ 剩余部分\n成员不用全部写上的方式\nenum Coin {\n    Penny,\n    Nickel,\n    Dime(String),\n    Quarter,\n}\n\nfn main() {\n    let d = Coin::Dime(\"hello\".to_string());\n    let r = match d {\n        Coin::Penny =&gt; {\n            println!(\"Lucky penny!\");\n            1\n        }\n        // 用other 表示其他情况\n        other =&gt; 666,\n    };\n    println!(\"{}\", r);\n}\n使用_来表示不匹配的情况,这里的和枚举显然不一样,在枚举里如果要写,是肯定能匹配上的,这里是完全可能匹配不上,所以用 _ 来区分 前面用的other.\n其实都用 _ 就行\nfn main() {\n    let d = 3;\n    let r = match d {\n        1 =&gt; 11,\n        2 =&gt; 22,\n        _ =&gt; 888,\n    };\n    println!(\"{}\", r);\n}\n\n\n8.4 | 和 if\nfn main() {\n    let x = 4;\n    let y = true;\n\n    match x {\n        // 或者等4或5,或6 并且 y为真才行, y是外部定义的那个y\n        4 | 5 | 6 if y =&gt; println!(\"yes\"),\n        7 | 8 =&gt; println!(\"7-8\"),\n        _ =&gt; println!(\"no\"),\n    }\n}\nfn main() {\n    let x = Some(5);\n    let y = 5;\n\n    match x {\n        Some(50) =&gt; println!(\"50\"),\n        // ==y 的y 是外部 定义的 y =5\n        // Some(y) 的y 与外部无关\n        Some(y) if y == y =&gt; {\n            println!(\"Matched, n = {}\", y)\n        }\n        _ =&gt; println!(\"Default case, x = {:?}\", x),\n    }\n}\n\n\n8.5 ..= 范围\n&gt;=xx &lt;=yy\nfn main() {\n    let x = 5i32;\n\n    match x {\n        1..=5 =&gt; println!(\"&gt;=1 &lt;=5\"),\n        _ =&gt; println!(\"something else\"),\n    }\n    println!(\"i32最小值{}\", i32::MIN);\n    match x {\n        i32::MIN..=2_i32 =&gt; println!(\"&lt;=2\"),\n        3 =&gt; println!(\"=3\"),\n        4 =&gt; println!(\"=4\"),\n        5_i32..=i32::MAX =&gt; println!(\"&gt;=5\"),\n    };\n}\n\n\n8.6 @ 绑定\nenum Student {\n    primary { age: i32 },\n    junior { age: i32 },\n}\nfn main() {\n    let s = Student::primary { age: 3 };\n\n    match s {\n        Student::primary { age: primary_age } if primary_age &gt;= 7 && primary_age &lt;= 11 =&gt; {\n            println!(\"Hello\")\n        }\n        // 相当于上面 primary_age &gt;= 3 && primary_age &lt;= 6\n        // @前面是绑定的变量 \n        Student::primary {\n            // 这里就表示当你符合 &gt;=3 &lt;=6 ,绑定匹配到的age到primary_age 这个变量\n            age: primary_age @ 3..=6,\n        } =&gt; println!(\"是 &gt;=3 &lt;=6 岁的小学生: {}\", primary_age),\n        Student::junior { age: 10..=12 } =&gt; {\n            println!(\"10-12 岁的初中生\")\n        }\n        Student::junior { age } =&gt; println!(\"Found: {}\", age),\n        _ =&gt; (),\n    }\n\n    let a=Some(42);\n    match a {\n        // 得到 `Some` 可变类型，如果它的值（绑定到 `n` 上）等于 42，则匹配。\n        Some(n @ 42) =&gt; println!(\"The Answer: {}!\", n),\n        // 匹配任意其他数字。\n        Some(n)      =&gt; println!(\"Not interesting... {}\", n),\n        // 匹配任意其他值（`None` 可变类型）。\n        _            =&gt; (),\n    }\n}\nfn main() {\n    let x = 11;\n    match x {\n        // | 多个情况 绑定\n        e @ 11 | e @ 1..=3 =&gt; println!(\"{}\", e),\n        _ =&gt; println!(\"other\"),\n    }\n}",
    "crumbs": [
      "基础篇",
      "模式匹配"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/pattern-match.html#non_exhaustive",
    "href": "docs/programming/rust/basic/pattern-match.html#non_exhaustive",
    "title": "rust 模式匹配 pattern match",
    "section": "9 non_exhaustive",
    "text": "9 non_exhaustive\n\n\n\n\n\n\nCaution\n\n\n\n\n当你使用上游开发人员创建的一个enum, 然后你写了全部分支, OK.\n突然有一天, 上游人员给这个enum 添加了一个变体成员, 这个时候因为你的模式匹配enum中没有写_ 这种,导致现在没有写完全部分支,错误发生了\nnon_exhaustive就是为了防止这种情况的发生而设计的\n\n\n\n\n.\n├── Cargo.toml # package : world\n└── src\n    ├── lib.rs \n    ├── main.rs\n\nlib.rsmain.rs\n\n\npub mod enum_ex {\n    // 这个属性, 表示 其他人 match时 必须使用 _ 来整完剩余分支\n    #[non_exhaustive]\n    pub enum Coin {\n        Penny,\n        Nickel,\n        Dime(String),\n        Quarter,\n    }\n}\n\n\nuse world::enum_ex::Coin;\n\nfn main() {\n    let c = Coin::Penny;\n    let d = Coin::Dime(\"hello\".to_string());\n    let r = match d {\n        Coin::Penny =&gt; {\n            println!(\"Lucky penny!\");\n            1\n        }\n        Coin::Nickel =&gt; 5,\n        Coin::Dime(s) =&gt; {\n            println!(\"{}\", s);\n            10\n        }\n        Coin::Quarter =&gt; 25,\n        // 必须 使用 _, 否则报错,编译不过的\n        _ ==&gt; 0,\n    };\n    println!(\"{}\", r);\n}",
    "crumbs": [
      "基础篇",
      "模式匹配"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/cargo.html",
    "href": "docs/programming/rust/basic/cargo.html",
    "title": "rust cargo",
    "section": "",
    "text": "打开本地离线cargo文档\n\nrustup doc --cargo\n\n\n\n发布的配置信息, 是预定义好的,可自定义\n\ncargo build\n    Finished dev [unoptimized + debuginfo] target(s) in 0.0s\ncargo build --release\n    Finished release [optimized] target(s) in 0.0s\n我们运行2个命令看看, 看到 dev 和 release, 实际就是使用了不同的默认配置 dev默认的一些配置\n[profile.dev]\nopt-level = 0\ndebug = true\nsplit-debuginfo = '...'  # Platform-specific.\nstrip = \"none\"\ndebug-assertions = true\noverflow-checks = true\nlto = false\npanic = 'unwind'\nincremental = true\ncodegen-units = 256\nrpath = false\n我们可以通过修改Cargo.toml来覆盖一些默认配置\n[package]\nname = \"world\"\nversion = \"0.1.0\"\nedition = \"2021\"\n[dependencies]\nrand = \"0.8.5\"\n[profile.dev] # dev 配置\nopt-level = 1\n[profile.release] # release 配置\nopt-level = 3\n修改完后, 我们再次编译可以看到 optimized\ncargo build\n    Finished dev [optimized + debuginfo] target(s) in 3.14s\ndependencies的三种方式\n[dependencies]\nclap = \"2.27.1\" # from crates.io\nrand = { git = \"https://github.com/rust-lang-nursery/rand\" } # from online repo\nbar = { path = \"../bar\" } # from a path in the local filesystem\n\n\n\n\n\n\n\n\n\nCaution\n\n\n\n待完善\n\n\n~/.cargo/config.toml影响该用户的所有 Rust 项目\n安装 sccache2 编译加速\ncargo install sccache\n\n\n~/.cargo/config.toml\n\n[source.crates-io]\nreplace-with = 'ustc'\n\n[source.ustc]\nregistry = \"sparse+https://mirrors.ustc.edu.cn/crates.io-index/\"\n\n[alias]     # command aliases\nb = \"build\"\nc = \"check\"\nt = \"test\"\nr = \"run\"\nrr = \"run --release\"\n[build]\n# 这样设置可以将所有的rust编译后的可执行文件放到一块去,哪天清理时比较方便\n1target-dir = \"/Users/xxxx/.rust-target\"\n# 使用 sccache 进行编译加速\nrustc-wrapper = \"/Users/xxxx/.cargo/bin/sccache\"\n\n\n1\n\n路径自行配置, 使用绝对路径",
    "crumbs": [
      "基础篇",
      "cargo"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/cargo.html#配置文件",
    "href": "docs/programming/rust/basic/cargo.html#配置文件",
    "title": "rust cargo",
    "section": "",
    "text": "打开本地离线cargo文档\n\nrustup doc --cargo\n\n\n\n发布的配置信息, 是预定义好的,可自定义\n\ncargo build\n    Finished dev [unoptimized + debuginfo] target(s) in 0.0s\ncargo build --release\n    Finished release [optimized] target(s) in 0.0s\n我们运行2个命令看看, 看到 dev 和 release, 实际就是使用了不同的默认配置 dev默认的一些配置\n[profile.dev]\nopt-level = 0\ndebug = true\nsplit-debuginfo = '...'  # Platform-specific.\nstrip = \"none\"\ndebug-assertions = true\noverflow-checks = true\nlto = false\npanic = 'unwind'\nincremental = true\ncodegen-units = 256\nrpath = false\n我们可以通过修改Cargo.toml来覆盖一些默认配置\n[package]\nname = \"world\"\nversion = \"0.1.0\"\nedition = \"2021\"\n[dependencies]\nrand = \"0.8.5\"\n[profile.dev] # dev 配置\nopt-level = 1\n[profile.release] # release 配置\nopt-level = 3\n修改完后, 我们再次编译可以看到 optimized\ncargo build\n    Finished dev [optimized + debuginfo] target(s) in 3.14s\ndependencies的三种方式\n[dependencies]\nclap = \"2.27.1\" # from crates.io\nrand = { git = \"https://github.com/rust-lang-nursery/rand\" } # from online repo\nbar = { path = \"../bar\" } # from a path in the local filesystem\n\n\n\n\n\n\n\n\n\nCaution\n\n\n\n待完善\n\n\n~/.cargo/config.toml影响该用户的所有 Rust 项目\n安装 sccache2 编译加速\ncargo install sccache\n\n\n~/.cargo/config.toml\n\n[source.crates-io]\nreplace-with = 'ustc'\n\n[source.ustc]\nregistry = \"sparse+https://mirrors.ustc.edu.cn/crates.io-index/\"\n\n[alias]     # command aliases\nb = \"build\"\nc = \"check\"\nt = \"test\"\nr = \"run\"\nrr = \"run --release\"\n[build]\n# 这样设置可以将所有的rust编译后的可执行文件放到一块去,哪天清理时比较方便\n1target-dir = \"/Users/xxxx/.rust-target\"\n# 使用 sccache 进行编译加速\nrustc-wrapper = \"/Users/xxxx/.cargo/bin/sccache\"\n\n\n1\n\n路径自行配置, 使用绝对路径",
    "crumbs": [
      "基础篇",
      "cargo"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/cargo.html#常用命令",
    "href": "docs/programming/rust/basic/cargo.html#常用命令",
    "title": "rust cargo",
    "section": "2 常用命令",
    "text": "2 常用命令\n# 查看所有cargo 命令\ncargo --list\n# 添加 一个依赖项 (外部crate)\n# 会在 Cargo.toml [dependencies] 下写入依赖的crate名以及它的版本\ncargo add csv\n# 工作空间下, 多package 的情况下,需要指定 package\ncargo add csv --package test_csv\n# --features derive 表示启用了serde 的derive 这个特性\n# 启用后你可以在你的代码中使用 serde 宏来为你的数据结构自动生成序列化和反序列化的实现\ncargo add serde --features derive",
    "crumbs": [
      "基础篇",
      "cargo"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/cargo.html#文档",
    "href": "docs/programming/rust/basic/cargo.html#文档",
    "title": "rust cargo",
    "section": "3 文档",
    "text": "3 文档\n\n3.1 注释\n生成HTML文档,显示如何使用API\n我们 在src/lib.rs中添加一些文档注释\n\n\nsrc/lib.rs\n\n1//! # My Crate\n//!\n//! `my_crate` is a collection of utilities to make performing certain\n//! calculations more convenient.\n\n/// Adds one to the number given.\n///\n2/// # Examples\n///\n/// ```\n3/// let arg = 5;\n/// let answer = my_crate::add_one(arg);\n///\n/// assert_eq!(6, answer);\n/// ```\npub fn add_one(x: i32) -&gt; i32 {\n    x + 1\n}\n\n\n1\n\n描述 我们要发布的 整个crate, 使用 //!\n\n2\n\n使用 ///,可以用markdown 语法  Example 是一个常见的我们要去写的区域,后面写上示例Panics: 描述可能发生panic的场景 Errors: 如何函数返回Result,描述可能的错误种类,以及导致错误的条件Safty: 如果函数处于unsafe调用, 那么就描述使用unsafe的原因和使用的前提\n\n3\n\n使用cargo test 会测试这里的代码, 注意 需要将 示例代码里使用的 my_crate改成 Cargo.toml中 [package] 的 name\n\n\n# --open 会直接打开 生成的 html\ncargo doc --open\n# 会测试 文档注释中的代码\ncargo test\n   Doc-tests ....\n\n\n3.2 pub use\n\nsrc/lib.rssrc/main.rs\n\n\n//! # Art\n//!\n//! A library for modeling artistic concepts.\n\n// --加上这些--\n1pub use self::kinds::PrimaryColor;\npub use self::kinds::SecondaryColor;\npub use self::utils::mix;\n//  -----\n\npub mod kinds {\n    /// The primary colors according to the RYB color model.\n    pub enum PrimaryColor {\n        Red,\n        Yellow,\n        Blue,\n    }\n\n    /// The secondary colors according to the RYB color model.\n    pub enum SecondaryColor {\n        Orange,\n        Green,\n        Purple,\n    }\n}\n\npub mod utils {\n    use crate::kinds::*;\n\n    /// Combines two primary colors in equal amounts to create\n    /// a secondary color.\n    pub fn mix(c1: PrimaryColor, c2: PrimaryColor) -&gt; SecondaryColor {\n        SecondaryColor::Orange\n    }\n}\n\n1\n\n这样生成的文档方便用户查看,不需要点击多次才能看到\n\n\n\n\n// use art::kinds::PrimaryColor;\n// use art::utils::mix;\n\n// 在lib.rs 添加 pub use 后, 这里可以这样了,生成的文档也方便用户使用\nuse art::mix;\nuse art::PrimaryColor;\n\nfn main() {\n    let red = PrimaryColor::Red;\n    let yellow = PrimaryColor::Yellow;\n    mix(red, yellow);\n}\n\n\n\ncargo doc --open # 查看一下",
    "crumbs": [
      "基础篇",
      "cargo"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/cargo.html#发布crate到crate.io",
    "href": "docs/programming/rust/basic/cargo.html#发布crate到crate.io",
    "title": "rust cargo",
    "section": "4 发布crate到crate.io",
    "text": "4 发布crate到crate.io\n\n4.1 登录crate.io获取token\n登录crate.io后,进入settings页面, 生成一个token\n# 该命令会将token 存储在 ~/.cargo/credentials\ncargo login abcdefghijklmnopqrstuvwxyz012345\n\n\n4.2 修改Cargo.toml\n[package]\n1name = \"guessing_game\"\nversion = \"0.1.0\"\nedition = \"2021\"\n2description = \"该描述会显示在crate.io的搜索结果里\"\n3license = \"MIT OR Apache-2.0\"\n[dependencies]\n\n1\n\n名字在crate.io中必须是独一无二的\n\n2\n\n必填项\n\n3\n\n必填项,许可标识值可在spdx上查找\n\n\n\n\n4.3 发布\ncargo publish\n发布已存在crate的新版本, 需要修改 toml文件中的 version3, 再执行cargo publish 即可\n\n\n4.4 cargo yank 撤回\n\n首先 crate.io 是不能让你删除已经发布的版本的,因为如果已经有人用了怎么办\n但是可以让你撤回,它的意思是, 防止新的用户使用这个可能不太好的版本,cargo add xxxx 后不会使用到这个撤回的版本, 如果是已经使用了这个版本的人(Cargo.lock里指定了版本了), 还是可以下载使用的\n\ncargo yank --vers 1.0.1\n    Updating crates.io index\n        Yank guessing_game@1.0.1\n# 取消 yank\ncargo yank --vers 1.0.1 --undo\n    Updating crates.io index\n      Unyank guessing_game@1.0.1",
    "crumbs": [
      "基础篇",
      "cargo"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/cargo.html#工作空间-workspace",
    "href": "docs/programming/rust/basic/cargo.html#工作空间-workspace",
    "title": "rust cargo",
    "section": "5 工作空间 workspace",
    "text": "5 工作空间 workspace\n\n5.1 创建\nmkdir add\ncd add\ntouch Cargo.toml\n\n\nCargo.toml\n\n[workspace]\n\nmembers = [\n1    \"adder\",\n]\n2resolver = \"2\"\n\n\n1\n\n这样一个member就是一个package, 我们可以这样在一个工作空间中创建多个package, 之前比如测试代码时我们可能会cargo new xxx 一个新的项目来进行测试,现在可以这样处理.  实际操作时,这里空着或者members=整个都不写就行,后面使用cargo new xxx 会自动在这里添加\n\n2\n\nresolver4\n\n\n\n\n添加 一个binary package\n\ncargo new adder\ncargo build\ntree -L 2\n    .\n    ├── Cargo.lock\n    ├── Cargo.toml\n    ├── adder\n    │   ├── Cargo.toml\n    │   └── src\n    └── target # 存放所有members 编译后的东西\n        ├── CACHEDIR.TAG\n        └── debug\ncd adder\n# 我们没有看到在这个adder目录下生成target目录\n# 还是会在 外层的 target 目录下生成\ncargo build\n\n\n\n添加一个 lib package\n\n# 该命令会在 Cargo.toml的 members 里自动添加\ncargo new add_one --lib\ntree -L 2\n    ├── Cargo.lock\n    ├── Cargo.toml\n    ├── add_one\n    │   ├── Cargo.toml\n    │   └── src\n    │       └── lib.rs\n    ├── adder\n    │   ├── Cargo.toml\n    │   └── src\n    │       └── main.rs\n    └── target\n\n\n\n在add_one/src/lib.rs添加一个方法\n\npub fn add_one(x: i32) -&gt; i32 {\n    x + 1\n}\n\n现在我们要在adder 中依赖add_one这个package,需要在adder/Cargo.toml中添加\n\n\nadder/Cargo.toml\n\n[package]\nname = \"adder\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[dependencies]\nadd_one = { path = \"../add_one\" }\n\n\n\nadder/src/main.rs\n\nuse add_one;\n\nfn main() {\n    let num = 10;\n    println!(\"Hello, world! {num} plus one is {}!\", add_one::add_one(num));\n}\n\n\n\n运行指定 binary crate\n\ncargo run  -p adder\n\n\n\n5.2 使用外部crate\nadder/Cargo.toml[dependencies]中添加rand = \"0.8.1\",然后在add_one/Cargo.toml[dependencies]中添加rand = \"0.8.5\"后, cargo build 只会在外层Cargo.lock中生成一个rand版本.这样工作空间中的crate 都会使用同一个版本的rand\n\n\n5.3 测试\n# 在add目录下\n# 会test 工作空间中所有的package\ncargo test\n# 指定\ncargo test -p adder",
    "crumbs": [
      "基础篇",
      "cargo"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/cargo.html#一个package多个binary",
    "href": "docs/programming/rust/basic/cargo.html#一个package多个binary",
    "title": "rust cargo",
    "section": "6 一个package多个binary",
    "text": "6 一个package多个binary\n├── Cargo.lock\n├── Cargo.toml\n├── src\n│   ├── main.rs  # 含有main()\n│   ├── bin # 必须用这个目录名\n│   │   └── hello.rs # 同样含有main()\n\n\n运行另外一个可执行 binary hello.rs\n\ncargo run --bin=hello # = 指定文件名(去掉 .后缀)\n# 可以不用=\ncargo run --bin hello",
    "crumbs": [
      "基础篇",
      "cargo"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/cargo.html#安装二进制包",
    "href": "docs/programming/rust/basic/cargo.html#安装二进制包",
    "title": "rust cargo",
    "section": "7 安装二进制包",
    "text": "7 安装二进制包\n只能安装具有 binary target的 package (有binary crate)\n# 会安装到 $HOME/.cargo/bin 目录\ncargo install ripgrep",
    "crumbs": [
      "基础篇",
      "cargo"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/cargo.html#自定义命令扩展",
    "href": "docs/programming/rust/basic/cargo.html#自定义命令扩展",
    "title": "rust cargo",
    "section": "8 自定义命令扩展",
    "text": "8 自定义命令扩展\n在系统中你可以直接运行的一个命令 名字是cargo-xxxx,那么你就可以运行cargo xxxx 这样来替代运行它, cargo --list 可以查看到.\n我们在安装rust后, 可以在~/.cargo/bin 看到一些可执行文件, cargo-fmt 就是其中的一个, 我们可以发现有cargo fmt这个命令,就像cargo 的内置命令一样",
    "crumbs": [
      "基础篇",
      "cargo"
    ]
  },
  {
    "objectID": "docs/programming/rust/basic/cargo.html#footnotes",
    "href": "docs/programming/rust/basic/cargo.html#footnotes",
    "title": "rust cargo",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nconfig.toml↩︎\nsccache↩︎\nhttp://semver.org/↩︎\nresolver-versions↩︎",
    "crumbs": [
      "基础篇",
      "cargo"
    ]
  },
  {
    "objectID": "docs/programming/rust/pkg/utils.html",
    "href": "docs/programming/rust/pkg/utils.html",
    "title": "rust 实用库",
    "section": "",
    "text": "cargo add csv\nuse anyhow::Result;\nuse std::fs::{self, File};\nfn main() -&gt; Result&lt;()&gt; {\n    // 如果你是在 工作空间根目录下 执行 cargo run,\n    // 则这个csv文件需要相对于 工作空间根目录\n    let file = File::open(\"a.csv\")?;\n    let mut csv = csv::Reader::from_reader(file);\n    // let headers = csv.headers()?.clone();\n    // println!(\"{:?}\", headers);\n    for result in csv.records() {\n        let record = result?;\n        //  let json_val = headers.iter().zip(record.iter()).collect::&lt;Value&gt;();\n        println!(\"{:?}\", record);\n        println!(\"{:?}\", record.get(0));\n    }\n    Ok(())\n}",
    "crumbs": [
      "库",
      "常用库"
    ]
  },
  {
    "objectID": "docs/programming/rust/pkg/utils.html#csv",
    "href": "docs/programming/rust/pkg/utils.html#csv",
    "title": "rust 实用库",
    "section": "",
    "text": "cargo add csv\nuse anyhow::Result;\nuse std::fs::{self, File};\nfn main() -&gt; Result&lt;()&gt; {\n    // 如果你是在 工作空间根目录下 执行 cargo run,\n    // 则这个csv文件需要相对于 工作空间根目录\n    let file = File::open(\"a.csv\")?;\n    let mut csv = csv::Reader::from_reader(file);\n    // let headers = csv.headers()?.clone();\n    // println!(\"{:?}\", headers);\n    for result in csv.records() {\n        let record = result?;\n        //  let json_val = headers.iter().zip(record.iter()).collect::&lt;Value&gt;();\n        println!(\"{:?}\", record);\n        println!(\"{:?}\", record.get(0));\n    }\n    Ok(())\n}",
    "crumbs": [
      "库",
      "常用库"
    ]
  },
  {
    "objectID": "docs/programming/rust/pkg/utils.html#serde1",
    "href": "docs/programming/rust/pkg/utils.html#serde1",
    "title": "rust 实用库",
    "section": "2 serde1",
    "text": "2 serde1\ncargo add serde --features derive\nuse std::error::Error;\n\n#[derive(Debug, serde::Deserialize)]\nstruct Record {\n    city: String,\n    region: u8,\n    country: String,\n}\n\n/* a.csv\ntokyo,3,japan\nbeijing,1,china\n*/\nfn read_csv() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {\n    let file = std::fs::File::open(\"a.csv\")?;\n    let mut rdr = csv::ReaderBuilder::new()\n        .has_headers(false) // 如果都是数据的情况, 设置没有 header\n        .from_reader(file);\n    for result in rdr.deserialize() {\n        // Notice that we need to provide a type hint for automatic\n        // deserialization.\n        let record: Record = result?;\n        println!(\"{}-{}\", record.city, record.country);\n    }\n    Ok(())\n}\n\n/*  a-with-header.csv\ncity,region,country\ntokyo,3,japan\nbeijing,1,china\n */\nfn read_csv_with_header() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {\n    let file = std::fs::File::open(\"a-with-header.csv\")?;\n    let mut rdr = csv::ReaderBuilder::new()\n        .has_headers(true) // 如果是有header的情况, 设置true\n        .from_reader(file);\n    for result in rdr.deserialize() {\n        let record: Record = result?;\n        println!(\"{}-{}\", record.city, record.country);\n    }\n    Ok(())\n}\n\nfn main() {\n    if let Err(err) = read_csv() {\n        println!(\"error running read_csv_with_header: {}\", err);\n    }\n    if let Err(err) = read_csv_with_header() {\n        println!(\"error running read_csv_with_header: {}\", err);\n    }\n}\n\ncargo add serde_json\nuse serde::{Deserialize, Serialize};\n\n// 使用 serde 的 derive 宏来为结构体自动实现序列化和反序列化\n#[derive(Serialize, Deserialize, Debug)]\nstruct Person {\n    // rename可以设置json 格式的时候, 显示的名字\n    #[serde(rename = \"user_name\")]\n    name: String,\n    age: u8,\n    phones: Vec&lt;String&gt;,\n}\n\nfn main() {\n    // 创建一个 Person 实例\n    let person = Person {\n        name: \"John Doe\".to_string(),\n        age: 30,\n        phones: vec![\"+44 1234567\".to_string(), \"+44 2345678\".to_string()],\n    };\n\n    // 将 Person 实例序列化为 JSON 字符串\n    let serialized = serde_json::to_string(&person).unwrap();\n    println!(\"Serialized:\\n{}\", serialized);\n\n    // 将 JSON 字符串反序列化为 Person 实例\n    let deserialized: Person = serde_json::from_str(&serialized).unwrap();\n    println!(\"Deserialized:\\n{:?}\", deserialized);\n}",
    "crumbs": [
      "库",
      "常用库"
    ]
  },
  {
    "objectID": "docs/programming/rust/pkg/utils.html#time",
    "href": "docs/programming/rust/pkg/utils.html#time",
    "title": "rust 实用库",
    "section": "3 time",
    "text": "3 time\n\n3.1 标准库里的time\nfn main() {\n    use std::time::{Duration, SystemTime, UNIX_EPOCH};\n    let now = SystemTime::now();\n\n    println!(\"{:?}\", now);\n    let now = SystemTime::now();\n    // UNIX_EPOCH: 1970/1/1\n    match now.duration_since(UNIX_EPOCH) {\n        Ok(elapsed) =&gt; {\n            println!(\"从 UNIX EPOCH 现在过去了 {} 秒\", elapsed.as_secs());\n        }\n        Err(e) =&gt; {\n            println!(\"SystemTime 在 UNIX EPOCH 之前: {:?}\", e);\n        }\n    }\n\n    use std::thread;\n\n    println!(\"程序开始\");\n    // 休眠2s\n    thread::sleep(Duration::from_secs(2));\n    println!(\"程序结束\");\n    let duration = now.elapsed();\n    println!(\"从获取now开始 到现在操作耗时: {:?}\", duration);\n    let now2 = now.checked_add(Duration::from_secs(3));\n    println!(\"{:?}\", now2);\n}",
    "crumbs": [
      "库",
      "常用库"
    ]
  },
  {
    "objectID": "docs/programming/rust/pkg/utils.html#rand-随机数",
    "href": "docs/programming/rust/pkg/utils.html#rand-随机数",
    "title": "rust 实用库",
    "section": "4 rand 随机数",
    "text": "4 rand 随机数\n\n\n添加库\n\ncargo add rand\n\n\n生成随机数指定范围生成使用其他分布类型指定字符为自定义类型生成随机值\n\n\nextern crate rand; // 为了能在博客上能运行,这里需要加这句\nuse rand::Rng;\nfn main() {\n    let mut rng = rand::thread_rng();\n    // 整数类型 生成的范围是 其类型范围内分布\n    let n1: u8 = rng.gen();\n    let n2: u16 = rng.gen();\n    println!(\"Random u8: {}\", n1);\n    println!(\"Random u16: {}\", n2);\n    println!(\"Random u32: {}\", rng.gen::&lt;u32&gt;());\n    println!(\"Random i32: {}\", rng.gen::&lt;i32&gt;());\n    // [0-1) 0到1区间(不包含1) 的浮点数\n    println!(\"Random float: {}\", rng.gen::&lt;f64&gt;());\n}\n\n\nextern crate rand;\nuse rand::Rng;\n\nfn main() {\n    let mut rng = rand::thread_rng();\n    println!(\"Integer: {}\", rng.gen_range(0..10));\n    println!(\"Float: {}\", rng.gen_range(0.0..10.0));\n\n    // 如果在相同范围内重复生成数字时, 下述代码性能可能会更好\n    use rand::distributions::{Distribution, Uniform};\n    let mut rng = rand::thread_rng();\n    let die = Uniform::from(1..7);\n\n    loop {\n        let throw = die.sample(&mut rng);\n        println!(\"Roll the die: {}\", throw);\n        if throw == 6 {\n            break;\n        }\n    }\n}\n\n\n\n\n\n\n\n\nCaution\n\n\n\n\n默认情况下, 随机数在 rand crate 中是均匀分布. rand_distr crate 提供其它的分布类型(比如正态分布)\n关于这个分布类型, 自己网上了解, 这里简单说下\n根据正态分布的68-95-99.7规则, 对于一个均值为μ、标准差为σ的正态分布, 以下是一些概率分布的近似情况:\n\n大约68% 的数据值会落在均值的一个标准差范围内, 即在区间 [μ - σ, μ + σ] 内\n大约95% 的数据值会落在均值的两个标准差范围内, 即在区间 [μ - 2σ, μ + 2σ] 内\n大约99.7% 的数据值会落在均值的三个标准差范围内, 即在区间 [μ - 3σ, μ + 3σ] 内\n\n在均值是0.0, 标准差是1.0 的正态分布 生成的随机数, 具体的分布情况:\n\n大约68%的数据值会落在 [-1.0, 1.0] 的区间内\n大约95%的数据值会落在 [-2.0, 2.0] 的区间内\n大约99.7%的数据值会落在 [-3.0, 3.0] 的区间内\n我在下面的代码中测试了该分布情况,确实如此\n\n\n\n\n\n\n添加rand_distr库\n\ncargo add rand_distr\n\n\n\n多执行几次看看\n\nextern crate rand;\nextern crate rand_distr;\nuse rand::thread_rng;\nuse rand_distr::{Distribution, Normal};\n\nfn main() {\n    let (mut v1, mut v2, mut v3) = (0, 0, 0);\n    let mut rng = thread_rng();\n    // 均值是0.0, 标准差是1.0\n    let normal = Normal::new(0.0, 1.0).unwrap();\n    for _ in 0..100 {\n        // 循环100次\n        // 调用sample方法，使用rng生成一个符合正态分布的随机数，并将其绑定到变量v上\n        let v = normal.sample(&mut rng);\n        // println!(\"{} \", v);\n        if v &gt;= -1.0 && v &lt;= 1.0 {\n            v1 += 1;\n        }\n        if v &gt;= -2.0 && v &lt;= 2.0 {\n            v2 += 1;\n        }\n        if v &gt;= -3.0 && v &lt;= 3.0 {\n            v3 += 1;\n        }\n    }\n    println!(\"{}\", v1);\n    println!(\"{}\", v2);\n    println!(\"{}\", v3);\n}\n\n\n\nextern crate rand;\nuse rand::{thread_rng, Rng};\nuse rand::distributions::Alphanumeric;\n\nfn main() {\n    let rand_string: String = thread_rng()\n        .sample_iter(&Alphanumeric) // A-Z，a-z，0-9\n        .take(10)  // 10位长度\n        .map(char::from)\n        .collect();\n\n    println!(\"{}\", rand_string);\n\n    // 自定义字符\n    const CHARSET: &[u8] = b\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\\n                            abcdefghijklmnopqrstuvwxyz\\\n                            0123456789)(*&^%$#@!~\";\n    const PASSWORD_LEN: usize = 10;\n    let mut rng = rand::thread_rng();\n\n    let password: String = (0..PASSWORD_LEN)\n        .map(|_| {\n            let idx = rng.gen_range(0..CHARSET.len());\n            CHARSET[idx] as char\n        })\n        .collect();\n\n    println!(\"{}\", password);\n}\n\n\nextern crate rand;\nuse rand::distributions::{Distribution, Standard};\nuse rand::Rng;\n\n#[derive(Debug)]\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nimpl Distribution&lt;Point&gt; for Standard {\n    fn sample&lt;R: Rng + ?Sized&gt;(&self, rng: &mut R) -&gt; Point {\n        let (rand_x, rand_y) = rng.gen();\n        Point {\n            x: rand_x,\n            y: rand_y,\n        }\n    }\n}\n\nfn main() {\n    let mut rng = rand::thread_rng();\n    // 元组\n    let rand_tuple = rng.gen::&lt;(i32, bool, f64)&gt;();\n    // 需要为Standard实现 Distribution&lt;Point&gt; 这个trait 才可以这样\n    let rand_point: Point = rng.gen();\n    println!(\"Random tuple: {:?}\", rand_tuple);\n    println!(\"Random Point: {:?}\", rand_point);\n}",
    "crumbs": [
      "库",
      "常用库"
    ]
  },
  {
    "objectID": "docs/programming/rust/pkg/utils.html#footnotes",
    "href": "docs/programming/rust/pkg/utils.html#footnotes",
    "title": "rust 实用库",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nhttps://serde.rs/  serde github↩︎",
    "crumbs": [
      "库",
      "常用库"
    ]
  },
  {
    "objectID": "docs/ai/editor.html#编辑器",
    "href": "docs/ai/editor.html#编辑器",
    "title": "斯巴拉稀",
    "section": "2 编辑器",
    "text": "2 编辑器\n\n2.1 cursor1"
  },
  {
    "objectID": "docs/ai/editor.html#footnotes",
    "href": "docs/ai/editor.html#footnotes",
    "title": "斯巴拉稀",
    "section": "Footnotes",
    "text": "Footnotes\n\n\ngithub  https://www.cursor.com/↩︎"
  },
  {
    "objectID": "docs/ai/index.html",
    "href": "docs/ai/index.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "deepseek https://chat.deepseek.com/sign_in kimi SenseNova 5 万知AI\n\n\n\n Back to top"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Welcome",
    "section": "",
    "text": "Welcome\n\n\n\n\n\n\nhello world\n\n\n\n离真正的好博客还差一个筋斗云 !!!\n会慢慢优化, 大量笔记整理中…\n\n\n\n\n\n\n\n Back to top"
  }
]
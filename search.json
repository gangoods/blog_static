[
  {
    "objectID": "docs/rust/advanced/01.mem.html",
    "href": "docs/rust/advanced/01.mem.html",
    "title": "斯巴拉稀",
    "section": "",
    "text": "以1个字节1个字节的方式来读写原本4个字节类型的内存空间\n\n\n\n\n\nfn main() {\n    // 10 00000100 00000011 00000001\n    let mut a = 33817345i32;\n    struct FourI8 {\n        first: i8,\n        second: i8,\n        third: i8,\n        fourth: i8,\n    }\n    let b = &mut a as *mut i32 as *mut FourI8;\n    unsafe {\n        println!(\n            \"{} {} {} {}\",\n            (*b).first,\n            (*b).second,\n            (*b).third,\n            (*b).fourth\n        );\n        (*b).first = 2;\n        // 10 00000100 00000011 00000010\n        println!(\"{:b}\", a);\n    }\n}",
    "crumbs": [
      "进阶",
      "内存"
    ]
  },
  {
    "objectID": "docs/rust/advanced/01.mem.html#类型",
    "href": "docs/rust/advanced/01.mem.html#类型",
    "title": "斯巴拉稀",
    "section": "",
    "text": "以1个字节1个字节的方式来读写原本4个字节类型的内存空间\n\n\n\n\n\nfn main() {\n    // 10 00000100 00000011 00000001\n    let mut a = 33817345i32;\n    struct FourI8 {\n        first: i8,\n        second: i8,\n        third: i8,\n        fourth: i8,\n    }\n    let b = &mut a as *mut i32 as *mut FourI8;\n    unsafe {\n        println!(\n            \"{} {} {} {}\",\n            (*b).first,\n            (*b).second,\n            (*b).third,\n            (*b).fourth\n        );\n        (*b).first = 2;\n        // 10 00000100 00000011 00000010\n        println!(\"{:b}\", a);\n    }\n}",
    "crumbs": [
      "进阶",
      "内存"
    ]
  },
  {
    "objectID": "docs/rust/advanced/01.mem.html#内存对齐",
    "href": "docs/rust/advanced/01.mem.html#内存对齐",
    "title": "斯巴拉稀",
    "section": "内存对齐",
    "text": "内存对齐\n\n代码可能的对齐方式一可能的对齐方式二实际测试结果\n\n\nstruct A {\n    a: u8,\n    b: u32,\n    c: u16,\n}\n\n\n// 这种对齐 12个字节\nstruct A {\n    a: u8,\n    _pad1: [u8; 3], // to align `b`\n    b: u32,\n    c: u16,\n    _pad2: [u8; 2], // to make overall size multiple of 4\n}\n\n\n// 这种对齐 8个字节\nstruct A {\n    b: u32,\n    c: u16,\n    a: u8,\n    _pad: u8,\n}\n\n\nuse std::mem;\n\nstruct A {\n    a: u8,\n    b: u32,\n    c: u16,\n}\n\nfn main() {\n    let x = A { a: 1, b: 2, c: 3 };\n    println!(\"{}\", mem::size_of_val(&x)); // 8\n    // 0x0x7ff7bf6930be-0x0x7ff7bf6930b8-0x0x7ff7bf6930bc\n    // 也就是说实际优化成\n    struct A {\n        b: u32,\n        c: u16,\n        a: u8,\n    }\n    println!(\"0x{:p}-0x{:p}-0x{:p}\", &x.a, &x.b, &x.c);\n}",
    "crumbs": [
      "进阶",
      "内存"
    ]
  },
  {
    "objectID": "docs/rust/advanced/01.mem.html#union",
    "href": "docs/rust/advanced/01.mem.html#union",
    "title": "斯巴拉稀",
    "section": "union",
    "text": "union\n\nunion是一种允许在相同的内存位置存储多种类型的数据结构\n因此该类型大小等于内存占用最大的那个成员的内存大小\n\nunion MyUnion {\n    j: i32,\n    i: i8,\n}\n\nfn main() {\n    let mut my_union = MyUnion { j: 260 };\n    // 把它当作i32整型来使用, 需要 unsafe 块，因为这可能涉及内存重新解释\n    // 和前面类型章节中,我们一个字节一个字节的方式去重新读原本4个字节类型的内存空间一个道理\n    println!(\"j value: {}\", unsafe { my_union.j });\n    // 我们直接打印 i 看看,发现 是260 低位的一个字节的值\n    println!(\"i value: {}\", unsafe { my_union.i });\n    // 注意：在访问了union的一个字段后，访问其他字段之前,最好先进行“重置”或明确知道内存布局\n    // 否则可能会读取到无效的、未初始化的或者非预期的数据\n    my_union.i = 3;\n    println!(\"j value: {}\", unsafe { my_union.j }); // 259\n}",
    "crumbs": [
      "进阶",
      "内存"
    ]
  },
  {
    "objectID": "docs/rust/advanced/01.mem.html#enum",
    "href": "docs/rust/advanced/01.mem.html#enum",
    "title": "斯巴拉稀",
    "section": "enum",
    "text": "enum\n\n\n\n\n\n\n\n例子1,运行看看, 然后取消注释b257再运行\n\n\n\n\n\nenum Cat {\n    b1,\n    b2,\n    b3,\n    b4,\n    b5,\n    b6,\n    b7,\n    b8,\n    b9,\n    b10,\n    b11,\n    b12,\n    b13,\n    b14,\n    b15,\n    b16,\n    b17,\n    b18,\n    b19,\n    b20,\n    b21,\n    b22,\n    b23,\n    b24,\n    b25,\n    b26,\n    b27,\n    b28,\n    b29,\n    b30,\n    b31,\n    b32,\n    b33,\n    b34,\n    b35,\n    b36,\n    b37,\n    b38,\n    b39,\n    b40,\n    b41,\n    b42,\n    b43,\n    b44,\n    b45,\n    b46,\n    b47,\n    b48,\n    b49,\n    b50,\n    b51,\n    b52,\n    b53,\n    b54,\n    b55,\n    b56,\n    b57,\n    b58,\n    b59,\n    b60,\n    b61,\n    b62,\n    b63,\n    b64,\n    b65,\n    b66,\n    b67,\n    b68,\n    b69,\n    b70,\n    b71,\n    b72,\n    b73,\n    b74,\n    b75,\n    b76,\n    b77,\n    b78,\n    b79,\n    b80,\n    b81,\n    b82,\n    b83,\n    b84,\n    b85,\n    b86,\n    b87,\n    b88,\n    b89,\n    b90,\n    b91,\n    b92,\n    b93,\n    b94,\n    b95,\n    b96,\n    b97,\n    b98,\n    b99,\n    b100,\n    b101,\n    b102,\n    b103,\n    b104,\n    b105,\n    b106,\n    b107,\n    b108,\n    b109,\n    b110,\n    b111,\n    b112,\n    b113,\n    b114,\n    b115,\n    b116,\n    b117,\n    b118,\n    b119,\n    b120,\n    b121,\n    b122,\n    b123,\n    b124,\n    b125,\n    b126,\n    b127,\n    b128,\n    b129,\n    b130,\n    b131,\n    b132,\n    b133,\n    b134,\n    b135,\n    b136,\n    b137,\n    b138,\n    b139,\n    b140,\n    b141,\n    b142,\n    b143,\n    b144,\n    b145,\n    b146,\n    b147,\n    b148,\n    b149,\n    b150,\n    b151,\n    b152,\n    b153,\n    b154,\n    b155,\n    b156,\n    b157,\n    b158,\n    b159,\n    b160,\n    b161,\n    b162,\n    b163,\n    b164,\n    b165,\n    b166,\n    b167,\n    b168,\n    b169,\n    b170,\n    b171,\n    b172,\n    b173,\n    b174,\n    b175,\n    b176,\n    b177,\n    b178,\n    b179,\n    b180,\n    b181,\n    b182,\n    b183,\n    b184,\n    b185,\n    b186,\n    b187,\n    b188,\n    b189,\n    b190,\n    b191,\n    b192,\n    b193,\n    b194,\n    b195,\n    b196,\n    b197,\n    b198,\n    b199,\n    b200,\n    b201,\n    b202,\n    b203,\n    b204,\n    b205,\n    b206,\n    b207,\n    b208,\n    b209,\n    b210,\n    b211,\n    b212,\n    b213,\n    b214,\n    b215,\n    b216,\n    b217,\n    b218,\n    b219,\n    b220,\n    b221,\n    b222,\n    b223,\n    b224,\n    b225,\n    b226,\n    b227,\n    b228,\n    b229,\n    b230,\n    b231,\n    b232,\n    b233,\n    b234,\n    b235,\n    b236,\n    b237,\n    b238,\n    b239,\n    b240,\n    b241,\n    b242,\n    b243,\n    b244,\n    b245,\n    b246,\n    b247,\n    b248,\n    b249,\n    b250,\n    b251,\n    b252,\n    b253,\n    b254,\n    b255,\n    b256,\n    // b257,\n}\nfn main() {\n    let x = Cat::b1;\n    println!(\"{}\", mem::size_of::&lt;Cat&gt;());\n}\n\n\n\n\n\n\n\n\n\n例子2\n\n\n\n\n\n\ncode内存结构图\n\n\nenum Cat {\n    Tiger(i32), //tag =0\n    Lion(i8),  // tag =1\n    Dog(i16), // tag =2\n}\n\nuse std::mem;\nfn main() {\n    let lion = Cat::Lion(66);\n    println!(\"lion : {}\", mem::size_of_val(&lion)); // 8\n    unsafe {\n        let d = &lion as *const Cat as *const u64;\n        //0x4201 --&gt; 0x42=66 这个是data 0x01=1 这个是tag\n        //实际: 第一个字节存tag, 第二个字节存携带的数据 (因为这里Lion携带的数据是i8用一个字节就行了)\n        println!(\"0x{:x}\", *d);\n    }\n    let dog = Cat::Dog(66);\n    println!(\"Dog : {}\", mem::size_of_val(&dog));  // 8\n    unsafe {\n        let d = &dog as *const Cat as *const u64;\n        //0x420002 --&gt; 0x42=66 这个是data 0x0002 这个是tag\n        //Dog 携带的数据是i16  是2个字节, 所以这里tag和携带的数据各占用两个字节\n        println!(\"0x{:x}\", *d);\n    }\n\n    let tiger = Cat::Tiger(66);\n    println!(\"Tiger : {}\", mem::size_of_val(&tiger)); // 8\n    unsafe {\n        let d = &tiger as *const Cat as *const u64;\n        //0x4200000000 --&gt; 0x42=66 , 0x00 这个是tag\n        println!(\"0x{:x}\", *d);\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n例子3: 我们来看看枚举中变体携带String的情况\n\n\n\n\n\n\ncode内存结构图\n\n\nenum Message {\n    Quit,                    // 不需要占用内存空间, 0\n    Move { x: i32, y: i32 }, // 8bytes\n    Write(String),           // 24\n    ChangeColor(i32, i32, i32), // 12\n    // Read(String),\n}\nstruct enumStringStruct {\n    a: u64,\n    b: u64,\n    c: u64,\n    // d: u64,\n}\n\nfn main() {\n    let mut s = \"hello\".to_string();\n    println!(\"{}-{}\", s.len(), s.capacity());\n    s.push_str(\"x\");\n    println!(\"{}-{}\", s.len(), s.capacity());\n    println!(\"{:p}\", s.as_ptr()); //0x7f8144705f90\n    let m = Message::Write(s);\n    println!(\"{}\", mem::size_of_val(&m)); // 24\n    let b = &m as *const Message as *const enumStringStruct;\n    unsafe {\n        // 发现没有 这个 携带String的没有tag信息, 无tag信息来表示这个是携带String的变体\n        // 0xa-0x7f8144705f90-0x6\n        println!(\"Write: 0x{:x}-0x{:x}-0x{:x}\", (*b).a, (*b).b, (*b).c);\n    }\n    // 取消注释掉下面的代码, 和上面定义的枚举Message中的Read(String) 变体 ,再看看,会发现有各自的tag信息, 总体的内存占用变为32个字节了\n    //---\n    // let mut s = \"hello\".to_string();\n    // s.push_str(\"x\");\n    // println!(\"{:p}\", s.as_ptr()); \n    // let m = Message::Read(s);\n    // println!(\"{}\", mem::size_of_val(&m)); // 24\n    // let b = &m as *const Message as *const enumStringStruct;\n    // unsafe {\n    //     println!(\n    //         \"Read: 0x{:x}-0x{:x}-0x{:x}\",\n    //         (*b).a,\n    //         (*b).b,\n    //         (*b).c,\n    //         (*b).d\n    //     );\n    // }\n    //---\n    let m = Message::Move { x: 11, y: 22 };\n    println!(\"{}\", mem::size_of_val(&m)); // 24\n    let b = &m as *const Message as *const enumStringStruct;\n    unsafe {\n        //                tag    y       x\n        // 0x8000000000000001-0x160000000b-0x0\n        println!(\"Move: 0x{:x}-0x{:x}-0x{:x}\", (*b).a, (*b).b, (*b).c);\n    }\n\n    let m = Message::ChangeColor(6, 7, 8);\n    println!(\"{}\", mem::size_of_val(&m)); // 24\n    let b = &m as *const Message as *const enumStringStruct;\n    unsafe {\n        //                tag   7       6   8\n        // 0x8000000000000003-0x700000006-0x8\n        println!(\"ChangeColor: 0x{:x}-0x{:x}-0x{:x}\", (*b).a, (*b).b, (*b).c);\n    }\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n例子4: 只有一个成员且不携带数据的枚举\n\n\n\n\n\n\n\n不需要tag来区分哪个变体,所以不需要空间来存储tag\n\nfn main() {\n    enum MyEnum {\n        Cat,\n    }\n    let a = MyEnum::Cat;\n    println!(\"{}\", mem::size_of_val(&a));//0\n}\n\n\n\n\n\n\n\n\n\n\nImportant\n\n\n\n\n根据实际情况, 我们看到, 在上面的例子中 携带String的 枚举变体实际上没有存储tag信息,其他变体存了tag,且在高位估计是为了区分Write变体存的cap而增加了一个0x80 (注意: 这只是这个例子的推测)\n如果将上面的例子中的 Read(String) 取消注释, 这样就有2个携带String的变体了,这个时候怎么区分了,可以试试看, 结果是该枚举的大小变成了32字节了,需要新的内存空间来区分它们\n实际源码根据不同情况是如何优化的,我没去看, 但是通过上面的例子,我们大概了解了一些情况,我觉得ok",
    "crumbs": [
      "进阶",
      "内存"
    ]
  },
  {
    "objectID": "docs/rust/advanced/01.mem.html#box",
    "href": "docs/rust/advanced/01.mem.html#box",
    "title": "斯巴拉稀",
    "section": "Box",
    "text": "Box\nfn main() {\n    // 5 是在 堆上分配的, 栈上的变量b 指向了它\n    let b = Box::new(5);\n    let a = 11i64;\n    let c = Box::new(&a);\n    println!(\"b的值 = {:p}\", b);\n    println!(\"c的地址 : {:p}\", &c);\n    println!(\"a的地址 : {:p}\", &a);\n    println!(\"c的值: {:p}\", c);\n    let d = &c as *const Box&lt;&i64&gt; as *const u64;\n    unsafe {\n        // c的值是个地址,指向堆上的内存\n        println!(\"c的值: 0x{:x}\", *d);\n        let dd = *d as *const u64;\n        // c的值是地址,该地址所在内存 存的是 a的地址\n        println!(\"0x{:x}\", *dd);\n    }\n}",
    "crumbs": [
      "进阶",
      "内存"
    ]
  },
  {
    "objectID": "docs/rust/advanced/01.mem.html#vectnt",
    "href": "docs/rust/advanced/01.mem.html#vectnt",
    "title": "斯巴拉稀",
    "section": "Vec,[T;N],&[T]",
    "text": "Vec,[T;N],&[T]\nfn main() {\n    let mut vec: Vec&lt;i32&gt; = vec![1, 2, 3, 4];\n    let arr = [1, 2, 3, 4];\n    vec.push(5);\n    let (ptr, len, cap) = (vec.as_ptr(), vec.len(), vec.capacity());\n    println!(\"Vec 的指针: {:?}\", ptr);\n    println!(\"Vec 的长度: {}\", len);\n    println!(\"Vec 的容量: {}\", cap);\n    // 等价于 let slice_v:&[i32]=&v;\n    // let slice_v = &v[..];\n    let slice_vec = &vec as &[i32];\n\n    // 等价于 let slice_arr:&[i32]=&arr;\n    // let slice_arr = &arr[..];\n    let slice_arr = &arr as &[i32];\n    println!(\n        \"vec的ptr:{:p}-slice_vec的ptr:{:p}-{}\",\n        vec.as_ptr(),\n        slice_vec.as_ptr(),\n        slice_vec.len()\n    );\n    println!(\n        \"arr地址:{:p}-slice_arr的ptr:{:p}-{}\",\n        &arr,\n        slice_arr.as_ptr(),\n        slice_arr.len()\n    );\n\n    struct SliceStruct {\n        a: usize,\n        b: usize,\n    }\n\n    unsafe {\n        let b = &slice_vec as *const &[i32] as *const SliceStruct;\n        // a: cap, b:ptr,c:len\n        println!(\"0x{:x}-0x{:x}\", (*b).a, (*b).b);\n    }\n    struct VecStruct {\n        a: usize,\n        b: usize,\n        c: usize,\n    }\n\n    unsafe {\n        let b = &vec as *const Vec&lt;i32&gt; as *const VecStruct;\n        // a: cap, b:ptr,c:len\n        println!(\"0x{:x}-0x{:x}-0x{:x}\", (*b).a, (*b).b, (*b).c);\n    }\n}",
    "crumbs": [
      "进阶",
      "内存"
    ]
  },
  {
    "objectID": "docs/rust/advanced/01.mem.html#stringstr",
    "href": "docs/rust/advanced/01.mem.html#stringstr",
    "title": "斯巴拉稀",
    "section": "String,&str",
    "text": "String,&str\nfn main() {\n    let a = \"hello\";\n    let b = \"world\".to_string();\n    println!(\"{:p}-{:p}\", &a, a.as_ptr());\n    println!(\"{:p}-{:p}-{}-{}\", &b, b.as_ptr(), b.capacity(), b.len());\n    unsafe {\n        let c = a.as_ptr() as *const u8;\n        println!(\"{:p}\", c);\n        let mut d;\n        for i in 0..10 {\n            // 一个字节一个字节的打印\n            d = c.add(i);\n            // h-e-l-l-o-w-o-r-l-d-\n            print!(\"{}-\", *d as char);\n        }\n        println!(\"\")\n    }\n\n    let e = &b[1..];\n    println!(\"{:p}-{:p}\", &e, e.as_ptr());\n\n    struct StringStruct {\n        a: usize, // cap\n        b: usize, // ptr\n        c: usize, // len\n    }\n    let mut s = \"hello\".to_string();\n    s.push_str(\"x\");\n    // 6-10\n    println!(\"{}-{}\", s.len(), s.capacity());\n    let b = &s as *const String as *const StringStruct;\n    unsafe {\n        // 0xa-0x7f8fbb705f90-0x6\n        println!(\"0x{:x}-0x{:x}-0x{:x}\", (*b).a, (*b).b, (*b).c);\n    }\n}",
    "crumbs": [
      "进阶",
      "内存"
    ]
  },
  {
    "objectID": "docs/rust/advanced/01.mem.html#todo",
    "href": "docs/rust/advanced/01.mem.html#todo",
    "title": "斯巴拉稀",
    "section": "TODO",
    "text": "TODO",
    "crumbs": [
      "进阶",
      "内存"
    ]
  }
]